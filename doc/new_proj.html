<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title>Starting new C++ project</title>
</head>

<body>
<h1>Starting new C++ project</h1>

<ul>
  <li> <a href="#ref_Checkout">
    Retrieve NCBI C++ source tree from CVS</a>
  <li> <a href="#ref_Structure">
    CVS tree structure of NCBI C++ projects</a>
  <li> <a href="#ref_Create">
    Creating a CVS directory for a new C++ project</a>
  <li> <a href="#ref_Makefile">
    Project makefiles and sub-projects</a>
  <ul>
    <li> <a href="#ref_MakeMeta">
    <i>Meta-makefiles</i> (to provide multiple and/or recursive builds)</a>
    <li> <a href="#ref_MakeProj">
    Project makefiles (to build a particular library or application)</a>
    <ul>
      <li> <a href="#ref_MakeProjMk">
        <i><b>Configured</b></i> tools and flags for the whole build tree</a>
      <li> <a href="#ref_MakeProjLib">
        Customized makefile to build a  library</a>
      <li> <a href="#ref_MakeProjApp">
        Customized makefile to build an application</a>
      <li> <a href="#ref_MakeProjTarget">
        Standard build targets(<b>all, clean, purge</b>)
        in the customized makefiles</a>
    </ul>
  </ul>
  <li> <a href="mkfiles.html">
    A real-life example of the NCBI C++ makefile hierarchy
   (project <i><b>corelib/</b></i>)</a>
</ul>

<p>
<br>
<a name="ref_Checkout"></a>
<h2>Retrieve NCBI C++ source tree from CVS</h2>

<p>
To checkout the whole NCBI C++ source tree from CVS to you local
directory(e.g. <b><i>foo/c++/</i></b>) use:
<pre>
cd foo
cvs checkout -d c++ internal/c++
</pre>

For the detailed info on CVS see
<a href="http://www.cs.utah.edu/csinfo/texinfo/cvs/cvs_toc.html">
  CVS online manual</a> or run commands <i>"man cvs"</i> or <i>"cvs -H"</i> on
your workstation.


<p>
<br>
<a name="ref_Structure"></a>
<h2>CVS tree structure of NCBI C++ projects</h2>

<p>
(For the overall NCBI C++ CVS tree structure see in
<a href="config.html#ref_Source">NCBI C++ source code repository</a>.)

<p>
The standard CVS location for NCBI C++/STL projects is
<i><b>$CVSROOT/internal/c++/</b></i>. Public header files
(<i>*.hpp, *.inl</i>) of all projects are located below
the <i><b>$CVSROOT/internal/c++/include/</b></i> directory.
<i><b>$CVSROOT/internal/c++/src/</b></i> directory has just the same
hierarchy of subdirectories as <i><b>.../include/</b></i>, and its
very top level contains:

<ul>
  <li> Templates of generic makefiles (<b><i>Makefile.*.in</i></b>):
    <ul>
      <li> <b><i>Makefile.in</i></b> -- makefile to perform a recursive
        build in all project subdirectories
      <li> <b><i>Makefile.meta.in</i></b> -- to be included to all makefiles
        that provide both local and recursive builds
      <li> <b><i>Makefile.lib.in</i></b> -- to be included to all makefiles
        that perform a "standard" library build
      <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serve as a template for the
        project <i>customized makefiles</i> (<b><i>Makefile.*.lib[.in]</i></b>) that perform
        a "standard" library build
      <li> <b><i>Makefile.app.in</i></b> -- to be included to all makefiles
        that perform a "standard" application build
      <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serve as a template for the
        project <i>customized makefiles</i> (<b><i>Makefile.*.app[.in]</i></b>) that perform
        a "standard" application build
    </ul>

  <p>
    <li> Tree of project directories, each contains:
      <ul>
        <li> <b><i>*.cpp, *.hpp, *.inl</i></b> --
          project's source files and private headers
        <li> <b><i>Makefile.in</i></b> --
          a <a href="#ref_MakeMeta"><i>meta-makefile</i></a>
          to specify which local projects (described in <i>Makefile.*.in</i>)
          and sub-projects(located in the project subdirectories) must be built
        <li> <b><i>Makefile.*.lib[.in], Makefile.*.app[.in]</i></b> --
          <i>customized makefiles</i> to build a library or an application
        <li> <b><i>Makefile.*[.in]</i></b> -- "free style" makefiles
        <li> sub-project directories (if any)
      </ul>
</ul>


<br>
<a name="ref_Create"></a>
<h2>Creating source and include CVS dirs for a new C++ project</h2>

<p>
To create your new project(e.g. "bar_proj") directories in the
NCBI C++ CVS tree (assuming that the whole NCBI C++ has been
<a href="#ref_Checkout">checked out</a>
to directory <b><i>foo/c++/</i></b>):<pre>
cd foo/c++/include && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
cd foo/c++/src     && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
</pre>

Now you can <a href="new_mod.html">add</a> and edit your project C++
files in there.

<p>
NOTE: remember to add this new project directory to <i>$(SUB_PROJ)</i>
list of the upper level <a href="#ref_MakeMeta"><i>meta-makefile</i></a>
configurable template
(e.g., for this particular case, to <b><i>foo/c++/src/Makefile.in</i></b>).


<p>
<br>
<a name="ref_Makefile"></a>
<h2>Project makefiles and sub-projects</h2>

<a name="ref_MakeMeta"></a>
<h4>Meta-makefiles (to provide multiple and/or recursive builds)</h4>

All projects from the NCBI C++ hierarchy are tied together by a
set of <i>meta-makefiles</i> which present in all project source directories
and provide a uniform and easy way to perform both local and recursive
builds. 

A typical <i>meta-makefile</i> template(e.g. <i><b>Makefile.in</b></i> in your
<b><i>foo/c++/src/bar_proj/</i></b> dir) looks like that:
<pre>
USR_PROJ = bar_u1 bar_u2 ...  # Makefile.bar_u1,     Makefile.bar_u1     ...
LIB_PROJ = bar_l1 bar_l2 ...  # Makefile.bar_l1.lib, Makefile.bar_l1.lib ...
APP_PROJ = bar_a1 bar_l2 ...  # Makefile.bar_a1.app, Makefile.bar_a1.app ...
SUB_PROJ = app sub_proj1 sub_proj2

srcdir = @srcdir@
include @builddir@/Makefile.meta
</pre>

The mandatory <i>"srcdir = @srcdir@ ; include @builddir@/Makefile.meta"</i>
provides build rules for the following standard targets:
<ul>
  <li> <a href="#ref_MakeProjTarget"><b>all</b></a>:
    <ul>
		<li> run <i>"make  -f {Makefile.*} all"</i> for the makefiles with
		  the suffixes enlisted in macro <b>USR_PROJ</b>: <pre>
make -f Makefile.bar_u1 all
make -f Makefile.bar_u2 all
...... </pre>
		<li> build library(ies) using attributes defined in the
		  <i>customized makefiles</i> <b>Makefile.*.lib</b> with the suffixes
        enlisted in macro <b>LIB_PROJ</b>
		  <li> build application(s) using attributes defined in the
		  <i>customized makefiles</i> <b>Makefile.*.app</b> with the suffixes
        enlisted in macro <b>APP_PROJ</b>
    </ul>
  <li> <a href="#ref_MakeProjTarget"><b>all_r</b></a> --
	 first do target <b>all</b>, then run <i>"make  all_r"</i>
	 in all subdirectories enlisted in <i>$(SUB_PROJ)</i>: <pre>
cd bar_test       &&  make -f Makefile all_r
cd bar_sub_proj1  &&  make -f Makefile all_r
...... </pre>
  <li> <a href="#ref_MakeProjTarget"><b>clean, clean_r</b></a> --
	 run just the same makefiles but with targets <b>clean</b> and <b>clean_r</b>
    (rather than <b>all</b> and <b>all_r</b>), respectively
  <p>
  <li> <a href="#ref_MakeProjTarget"><b>purge, purge_r</b></a> --
	 .....with targets <b>purge</b> and <b>purge_r</b>, respectively
</ul>


<p>
<br>
<a name="ref_MakeProj"></a>
<h4>Project makefiles (to build a particular library or application)</h4>

Just like <b><i>Makefile.meta.in</i></b> configurable template is used to ease
and standatize the writing of
<a href="#ref_MakeMeta"><i>meta-makefiles</i></a>, so there are templates
to help in the creation of "regular" project makefiles to build
a library or an application. These auxiliary template makefiles
are <b><i>Makefile.mk.in</i></b>, <b><i>Makefile.lib.in</i></b>,
<b><i>Makefile.app.in</i></b>, <b><i>Makefile.lib.tmpl.in</i></b> and
<b><i>Makefile.app.tmpl.in</i></b>. The <b><i>configure</i></b>'d versions of
them get put to the very top of a <i>build tree</i>.


<p>
<br>
<a name="ref_MakeProjMk"></a>
<h4><i><b>Configured</b> tools and flags for the whole build tree</i></h4>

Usually, <b><i>Makefile.mk</i></b> must be included to the makefiles
that build libraries and applications -- as it defines a set of
makefile macros to be used in the
<a href="config.html#ref_StdBuildRules">standard</a> project build process:
<ul>
  <li> <a href="config.html#ref_TableToolsAndFlags">
       compiler, linker, and other tools</a>
  <li> <a href="config.html#ref_TableToolsAndFlags">
       flags</a> for compiler, linker, and other tools
  <li> info on the local
       <a href="config.html#ref_TableLocalization1">
       system and third-party packages</a>
  <li> path to the input (<b>top_srcdir, includedir</b>) and
  output (<b>libdir, bindir</b>, etc.) directories
  <li> path to the current <i>build</i> and <i>source</i> directories
  (<b>builddir</b> and <b>srcdir</b>, respectively)
  <li> command shell (<b>SHELL</b>) to use by the makefiles, and
  suffixes (<b>.SUFFIXES:</b>), etc.
</ul>



<p>
<br>
<a name="ref_MakeProjLib"></a>
<h4><i>Customized makefile to build a library</i></h4>

Here is an example of a <i>customized makefile</i> to build
library <i><b>libxmylib.a</b></i> from two source files,
<i><b>xmy_src1.cpp</b></i> and <i><b>xmy_src2.c</b></i>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI C Toolkit.<pre>
File Makefile.xmylib.lib:

LIB      = xmylib
OBJ      = xmy_src1 xmy_src2
CFLAGS   = $(ORIG_CFLAGS)   -abc -DFOOBAR_NOT_CPLUSPLUS
CXXFLAGS = $(ORIG_CXXFLAGS) -xyz
CPPFLAGS = $(ORIG_CPPFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)</pre>

<ul>
  <li> Compile <i><b>xmy_src1.cpp</b></i> using C++ compiler <b>CXX</b> with
       flags <b>CXXFLAGS CPPFLAGS</b> (which are the
       original C++ and preprocessor flags, <b>ORIG_*FLAGS</b>,
       plus some additional flags specified by user)
  <li> Compile <i><b>xmy_src2.c</b></i> using C compiler <b>CC</b> with
       flags <b>CFLAGS CPPFLAGS</b> (which are the
       original C and preprocessor flags, <b>ORIG_*FLAGS</b>,
       plus some additional flags specified by user)
  <li> Using <b>AR</b> and <b>RANLIB</b>, compose
       library <i><b>libxmylib.a</b></i> from the resultant object files
  <li> Copy the library to top-level <b><i>lib/</i></b> directory of
       the <i>build tree</i> (for later use by other projects)
</ul>

This <i>customized makefile</i> should be referenced as <i><b>xmylib</b></i> in the
<b>LIB_PROJ</b> macro of relevant
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>. Note also, that the
<a href="#ref_MakeProjMk"><i>Makefile.mk</i></a> will be
implicitely included to resolve all
<a href="config.html#ref_TableToolsAndFlags">tools, flags</a>, and
<a href="config.html#ref_TableLocalization1">
system and third-party package related</a> macros.


<p>
<br>
<a name="ref_MakeProjApp"></a>
<h4><i>Customized makefile to build an application</i></h4>

Here is an example of a <i>customized makefile</i> to build
application <i><b>my_exe</b></i> from three source files,
<i><b>my_main.cpp</b></i>, <i><b>my_src1.cpp</b></i>,
and <i><b>my_src2.c</b></i>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI SSS DB packages,
and the target executable uses NCBI C++ libraries
<a href="#ref_MakeProjLib"><i><b>libxmylib.a</b></i></a> and
<i><b>libxncbi.a</b></i>, plus
NCBI SSS DB, SYBASE, and system network libraries.<pre>
File Makefile.my_exe.app:

APP      = my_exe
OBJ      = my_main my_src1 my_src2
LIB      = xmylib xncbi
CPPFLAGS = $(ORIG_CPPFLAGS) $(NCBI_SSSDB_INCLUDE)
LIBS     = $(NCBI_SSSDB_LIBS) $(SYBASE_LIBS) $(NETWORK_LIBS) $(ORIG_LIBS)</pre>

<ul>
  <li> Compile <i><b>my_main.cpp</b></i> and <i><b>my_src1.cpp</b></i>
    using C++ compiler <b>CXX</b> with flags <b>CPPFLAGS</b>
    (<a href="#ref_Note1">*</a>)
  <li> Compile <i><b>my_src2.c</b></i> using C compiler <b>CC</b> with
    flags <b>CPPFLAGS</b>
    (<a href="#ref_Note1">*</a>)
  <li> Using <b>CXX</b> as a linker, build an executable
    <i><b>my_exe</b></i> from object files
    <b><i>my_main.o, my_src1.o, my_src2.o</i></b>, NCBI C++ Toolkit libraries
    <a href="#ref_MakeProjLib"><i><b>libxmylib.a</b></i></a> and
    <i><b>libxncbi.a</b></i>, and NCBI SSS DB, SYBASE,
    and system network libraries
    (<a href="#ref_Note1">*</a>)
  <li> Copy the library to top-level <b><i>lib/</i></b> directory of
    the <i>build tree</i> (for later use by other projects)
</ul>

<a name="ref_Note1"></a>
<i><b>(*)</b></i>
as we did not redefine <b>CFLAGS</b>, <b>CXXFLAGS</b>, <b>LDFLAGS</b>,
so their default values <b>ORIG_*FLAGS</b> (obtained during the <i>build
tree</i> <a href="config.html#ref_Configure">configuration</a>) will be
<a href="config.html#ref_StdBuildRules">used</a>.

<p>
This <i>customized makefile</i> should be referenced as <i><b>my_exe</b></i> in the
<b>APP_PROJ</b> macro of relevant
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>. Note also, that the
<a href="#ref_MakeProjMk"><i>Makefile.mk</i></a> will be
implicitely included to resolve all
<a href="config.html#ref_TableToolsAndFlags">tools, flags</a>, and
<a href="config.html#ref_TableLocalization1">
system and third-party package related</a> macros.


<p>
<br>
<a name="ref_MakeProjTarget"></a>
<h2>Standard build targets(<b>all, clean, purge</b>)
    in the <i>customized makefiles</i></h2>

<ul>
  <li> <b>all</b> -- compile object modules specified in the
  <i>"$(OBJ)"</i> macro, and use them to build library <i>"$(LIB)"</i> or
  application <i>"$(APP)"</i>;  then copy the resultant lib/app to the
  <b>libdir/ bindir</b> directory, respectively
  <li> <b>clean</b> -- remove all object modules and lib/app
  that have been built by <b>all</b>
  <li> <b>purge</b> -- do <b>clean</b>, and then remove the copy
  of lib/app from the <b>libdir/ bindir</b> directory
</ul>

Naturally, the <i>customized makefiles</i> will not make a difference between
recursive(<b>all_r, clean_r, purge_r</b>) and non-recursive(<b>all, clean, purge</b>)
targets -- because the recursion and multiple build is
entirely up to the <a href="#ref_MakeMeta"><i>meta-makefiles</i></a>.


<br></br>
<hr>
<table border=0 width="100%" cellspacing=0>
  <tr>
    <td><address><a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td>
<!-- <td align=center><i>$Revision$</i></td> -->
    <td align=right>($Date$)</td></tr>
</table>
  </body>
</html>
