<!-- $Id$ -->
<!--#set var="TITLE" value="NCBI C++ Toolkit:  New Projects" -->
<!--#set var="HEADING" value="Starting New Projects" -->
<!--#set var="DOCROOT" value="." -->
<!--#include virtual="./ssi/header.shtml" -->

<p></p>
<a name="ref_Checkout"></a>
The following assumes that you have all of the necessary Toolkit components.
If you need to obtain part or all of the Toolkit's source tree, consult the
<a href="download.html#ref_FTP">FTP instructions</a> or <a href="cvs.html">CVS checkout
procedures</a>.   Please visit the <a href="get_started.html"><i>Getting Started</i></a> page for a broad
overview of the NCBI C++ Toolkit and its use.


<ul>

  <li> <a href="#ref_ProjectStructure">
    New Projects:  Location and File Structure</a>
  <li> <a href="#ref_Structure">
    Projects and the Toolkit's CVS Tree Structure</a>
  <li> <a href="#ref_Create">
    Creating a CVS directory for a new C++ project</a>
  <li><a href="#ref_NewModule">
    Starting New Modules</a>
  <li> <a href="#ref_MakeMeta">
    Meta-makefiles (allow for multiple and/or recursive builds)</a>
  <li> <a href="#ref_MakeProj">
    Project makefiles</a>
    <ul>
      <li> <a href="#ref_MakeProjLib">
        Customized makefile to build a library</a>
      <li> <a href="#ref_MakeProjApp">
        Customized makefile to build an application</a>
      <li> <a href="#ref_MakeProjUsr">
        User-defined makefile to build... whatever</a>
    </ul>
  <li> <a href="#ref_Outside">
    New Project (lib, application) Development Aids</a>
    <ul>
      <li> <a href="#ref_OutsideImport">
           <b><tt>import_project.sh</tt></b> -- prepare a new project that lives in an NCBI C++ subtree
           </a>
      <li> <a href="#ref_OutsideCreate">
           <b><tt>new_project.sh</tt></b> -- prepare a new project that only links to the NCBI C++ tree
           </a>
      <li> <a href="#ref_OutsideHello">
           <b><tt>hello.sh</tt></b> -- a simple demo CGI application HELLO
           </a>
    </ul>
  <li> <a href="mkfiles.html">
    A real-life example of the NCBI C++ makefile hierarchy
   (project <tt><b>corelib/</b></tt>)</a>
</ul>

<hr>

<p></p>
<a name="ref_ProjectStructure"></a>
<h2> New Projects:  Location and File Structure </h2>
Before creating the new project, you must decide if you need to work within a C++ source tree
(or subtree) or merely need to link with the Toolkit libraries and work in a separate directory.
The later case is simpler and allows you to work independently in a private directory, but
it is not an option if the Toolkit source, headers, or <i>Makefiles</i> are to be directly
used or altered during the new project's development.

<ul>
    <li><a href="programming_manual/inside_tree.html">Work in the Full Toolkit Source Tree</a></li>
    <li><a href="programming_manual/sub_tree.html">Work in a Toolkit Subtree</a></li>
    <li><a href="programming_manual/outside_tree.html">Work in a Separate Directory</a></li>
</ul>

<p></p>
<p>
Regardless of where you build your new project, it must adopt and maintain
a particular structure.  Specifically,
each project's <a href="lxr/source/src/"><i>source tree</i></a> relative to $NCBI<tt>/c++</tt>
should contain:
<ul>
    <li> <b><i>include/*.hpp</i></b> --  project's public headers
    <li> <b><i>src/*.{cpp, hpp}</i></b> --  project's source files and private headers
    <li> <b><i>src/Makefile.in</i></b> -- a <a href="#ref_MakeMeta"><i>meta-makefile</i></a>
          template to specify which local projects (described in <i>Makefile.*.in</i>)
          and sub-projects (located in the project subdirectories) must be built
    <li> <b><i>src/Makefile.&lt;project_name&gt;.{lib, app}[.in]</i></b> -- one or more <i>customized makefiles</i> to build a library or an application
    <li> <b><i>src/Makefile.*[.in]</i></b> -- "free style" makefiles (if any)
    <li> sub-project directories (if any)
</ul>

<hr>

<p>
<br>
<a name="ref_Structure"></a>
<h2>Projects and the Toolkit's CVS Tree Structure</h2>

<font size=-1>
(For the overall NCBI C++ CVS tree structure see
<a href="config.html#ref_Source">the configuration page</a>; see the
<a href="download.html">download page</a> for source acquisition information
and <a href="cvs.html">CVS details</a>.)
</font>

<p>
Even if you work outside of the C++ tree, it is necessary to understand
how the Toolkit uses <i>makefiles</i>, <i>meta-makefiles</i>, and <i>makefile templates</i>,
and the CVS tree structure.

<p>
The standard CVS location for NCBI C++/STL projects is
<i><b>$CVSROOT/internal/c++/</b></i>. Public header files
(<i>*.hpp, *.inl</i>) of all projects are located below
the <i><b>$CVSROOT/internal/c++/include/</b></i> directory.
<i><b>$CVSROOT/internal/c++/src/</b></i> directory has just the same
hierarchy of subdirectories as <i><b>.../include/</b></i>, and its
very top level contains:

<ul>
  <li> Templates of generic makefiles (<b><i>Makefile.*.in</i></b>):
    <ul>
      <li> <b><i>Makefile.in</i></b> -- makefile to perform a recursive
        build in all project subdirectories
      <li> <b><i>Makefile.meta.in</i></b> -- included by all makefiles
        that provide both local and recursive builds
      <li> <b><i>Makefile.lib.in</i></b> -- included by all makefiles
        that perform a "standard" library build, when building only
        static libraries.
      <li> <b><i>Makefile.dll.in</i></b> -- included by all makefiles
        that perform a "standard" library build, when building only
        shared libraries.
      <li> <b><i>Makefile.both.in</i></b> -- included by all makefiles
        that perform a "standard" library build, when building both
        static and shared libraries.
      <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serves as a template
        for the project <i>customized makefiles</i>
        (<b><i>Makefile.*.lib[.in]</i></b>) that perform a "standard"
        library build
      <li> <b><i>Makefile.app.in</i></b> -- included by all makefiles
        that perform a "standard" application build
      <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serves as a template
        for the project <i>customized makefiles</i>
        (<b><i>Makefile.*.app[.in]</i></b>) that perform a "standard"
        application build
	  <li> <b><i>Makefile.rules.in,
        Makefile.rules_with_autodep.in</i></b> -- instructions for
        building object files; included by most other makefiles
	  <li> <b><i>Makefile.mk.in</i></b> -- included by all makefiles;
        sets a lot of configuration variables
    </ul>

  <p>
  <li> The contents of each project are detailed <a href="#ref_ProjectStructure">above</a>.
      If your project is to become part of the Toolkit tree, you need to ensure that
      all <i>makefiles</i> and <i>Makefile*.in</i> templates are available so the
      master <i>makefiles</i> can properly
      configure and build it (see "<a href="#ref_MakeMeta">Meta-Makefiles</a>" and "<a href="#ref_MakeProj">Project Makefiles"</a> below).
      You will also need to <a href="#ref_Create">prepare CVS directories</a>
      to hold the new source and header files.</li>

</ul>

<p>

<hr>

<br>
<a name="ref_Create"></a>
<h2>Creating source and include CVS dirs for a new C++ project</h2>

<p>
To create your new project (<i>e.g.</i>, "bar_proj") directories in the
NCBI C++ CVS tree to directory <b><i>foo/c++/</i></b>):

<font size="-1">
<pre>
    cd foo/c++/include && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
    cd foo/c++/src     && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
</pre>
</font>

Now you can <a href="new_mod.html">add</a> and edit your project C++
files in there.

<p>
NOTE: remember to add this new project directory to the <i>$(SUB_PROJ)</i>
list of the upper level <a href="#ref_MakeMeta"><i>meta-makefile</i></a>
configurable template (<i>e.g.</i>, for this particular case, to
<b><i>foo/c++/src/Makefile.in</i></b>).
<p>

<hr>

<p>
<br>
<a name="ref_NewModule"></a>
<h2> Starting New Modules </h2>

<p></p>
Projects consist of modules, which are most often a pair of source (*.cpp)
and header (*.hpp) files.  To help create new modules, template source &amp; header files
may be used, or you may modify the sample code generated by the script
<a href="scripts_usage.html#ref_New_ProjectUsage"><tt>new_project.sh</tt></a>.
See the <a href="new_mod.html">new modules page</a> for details.
<p>

<hr>

<p>
<br>
<a name="ref_MakeMeta"></a>
<h3>Meta-makefiles (to provide multiple and/or recursive builds)</h3>

All projects from the NCBI C++ hierarchy are tied together by a set of
<i>meta-makefiles</i> which are present in all project source
directories and provide a uniform and easy way to perform both local
and recursive builds.  See more detail on the <a href="makefiles.html">Working with Makefiles</a> page.

A typical <i>meta-makefile</i> template(e.g. <i><b>Makefile.in</b></i> in your
<b><i>foo/c++/src/bar_proj/</i></b> dir) looks like that:
<pre>
    # Makefile.bar_u1, Makefile.bar_u2 ...
    USR_PROJ = bar_u1 bar_u2 ...
    # Makefile.bar_l1.lib, Makefile.bar_l2.lib ...
    LIB_PROJ = bar_l1 bar_l2 ...
    # Makefile.bar_a1.app, Makefile.bar_a2.app ...
    APP_PROJ = bar_a1 bar_l2 ...
    SUB_PROJ = app sub_proj1 sub_proj2
    srcdir = @srcdir@
    include @builddir@/Makefile.meta
</pre>

This template separately specifies instructions for user, library and application
projects, along with a set of three sub-projects that can be made.
The mandatory final two lines <i>"srcdir = @srcdir@ ; include @builddir@/Makefile.meta"</i>
define the <a href="makefiles.html#ref_MakefilesTargets">standard build targets</a>.
<p>

<hr>

<p>
<br>
<a name="ref_Makefile"></a>
<a name="ref_MakeProj"></a>
<h3>Project makefiles</h3>

Just like the configurable template <tt>Makefile.meta.in</tt> is
used to ease and standardize the writing of <a
href="#ref_MakeMeta"><i>meta-makefiles</i></a>, so there are templates
to help in the creation of "regular" project makefiles to build a
library or an application. These auxiliary template makefiles are
described on the "<a href="makefiles.html#ref_MakefilesHier">Working with Makefiles</a>" page
and listed <a href="#ref_Structure">above</a>.  The
<tt>configure</tt>'d versions of these templates get put at the very top of
a <i>build tree</i>.
<p>

In addition to the <i>meta-makefile</i> that must be defined for each project,
a <i>customized makefile</i> <tt>Makefile.<i>&lt;project_name&gt;</i>.[app|lib]</tt>
must also be provided.  The following three sections give
examples of <i>customized makefiles</i> for a <a href="#ref_MakeProjLib">library</a> and an
<a href="#ref_MakeProjApp">application</a>, along
with a case where a <a href="#ref_MakeProjUsr">user-defined</a> <i>makefile</i> is required.
<p>

You have great latitude in specifying optional packages, features and projects in
<i>makefiles</i>.  The macro <tt>REQUIRES</tt> in the examples is one way to
allows you access them.  See the "<i>Working with Makefiles</i>"
page for a <a href="makefiles.html#ref_Packages">complete list</a>; the configuration
page gives the corresponding <a href="config.html#ref_ProhibitPackage">configure options</a>.


<p>
<br>
<a name="ref_MakeProjLib"></a>
<h3><i>Example 1:</i> Customized makefile to build a library</h3>

<dl>
    <dt>
    <dd>
Here is an example of a <i>customized makefile</i> to build
library <i><b>libxmylib.a</b></i> from two source files
<i><b>xmy_src1.cpp</b></i> and <i><b>xmy_src2.c</b></i>, and one
pre-compiled object file <i><b>some_obj1.o</b></i>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI C Toolkit.

<font size="-1">
        <pre>
    File Makefile.xmylib.lib:

    LIB      = xmylib
    SRC      = xmy_src1 xmy_src2
    OBJ      = some_obj1
    REQUIRES = xrequirement
    CFLAGS   = $(ORIG_CFLAGS)   -abc -DFOOBAR_NOT_CPLUSPLUS
    CXXFLAGS = $(FAST_CXXFLAGS) -xyz
    cppFLAGS = $(ORIG_cppFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)
</pre>
</font>

<ul>
  <li> Skip building this library if <tt>xrequirement</tt>
       (<a href="makefiles.html#ref_Packages">an optional package or project</a>)
       is disabled or unavailable
  <li> Compile <i><b>xmy_src1.cpp</b></i> using the C++ compiler
       <b>$(CXX)</b> with the flags <b>$(FAST_CXXFLAGS)  -xyz $(cppFLAGS)</b>,
       which are the C++ flags for faster code, some additional flags
       specified by the user, and original preprocessor flags
  <li> Compile <i><b>xmy_src2.c</b></i> using the C compiler <b>CC</b>
       with the flags <b>$(CFLAGS) -abc -DFOOBAR_NOT_CPLUSPLUS $(cppFLAGS)</b>,
       which are the original C flags, some additional flags
       specified by the user, and original preprocessor flags
  <li> Using <b>$(AR)</b> and <b>$(RANLIB)</b> [<b>$(LINK_DLL)</b> if
       building a shared library], compose the
       library <i><b>libxmylib.a</b></i> [<i><b>libxmylib.so</b></i>]
       from the resultant object files, plus the pre-compiled object file
       <i><b>some_obj1.o</b></i>.
  <li> Copy <i><b>libxmylib.*</b></i> to the
       top-level <b><i>lib/</i></b> directory of the
       <i>build tree</i> (for the later use by other projects)
</ul>

This <i>customized makefile</i> should be referred to as
<i><b>xmylib</b></i> in the <b>LIB_PROJ</b> macro of the relevant
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>. As usual,
<a href="makefiles.html#ref_MakeProjMk"><i>Makefile.mk</i></a> will be
implicitly included.

<p>
This <i>customized makefile</i> can be used to build both <i>static</i>
and <a href="config.html#ref_DLL"><i>dynamic (DLL)</i></a> versions of
the library. <br>
To encourage its build as a <i>DLL</i> on the capable
platforms, you can explicitly specify:
<pre>    LIB_OR_DLL = dll</pre>
or
<pre>    LIB_OR_DLL = both</pre>
Conversely, if you want the library be always built as <i>static</i>, specify:
<pre>    LIB_OR_DLL = lib</pre>
</dl>


<p>
<br>
<a name="ref_MakeProjApp"></a>
<h3><i>Example 2:</i> Customized makefile to build an application</h3>

<dl>
    <dt>
    <dd>
Here is an example of a <i>customized makefile</i> to build the
application <i><b>my_exe</b></i> from three source files,
<i><b>my_main.cpp</b></i>, <i><b>my_src1.cpp</b></i>,
and <i><b>my_src2.c</b></i>.
To make the example even more realistic, we assume that the said
source files include headers from the NCBI SSS DB packages,
and the target executable uses the NCBI C++ libraries
<a href="#ref_MakeProjLib"><i><b>libxmylib.*</b></i></a> and
<i><b>libxncbi.*</b></i>, plus
NCBI SSS DB, SYBASE, and system network libraries.  We assume further
that the user would prefer to link statically against libxmylib if
building the toolkit as both shared and static libraries
(<i><b>configure --with-dll --with-static ...</b></i>), but is fine
with a shared libxncbi.
<font size="-1">
        <pre>
    File Makefile.my_exe.app:

    APP      = my_exe
    SRC      = my_main my_src1 my_src2
    OBJ      = some_obj
    LIB      = xmylib$(STATIC) xncbi
    REQUIRES = xrequirement
    cppFLAGS = $(ORIG_cppFLAGS) $(NCBI_SSSDB_INCLUDE)
    LIBS     = $(NCBI_SSSDB_LIBS) $(SYBASE_LIBS) $(NETWORK_LIBS) $(ORIG_LIBS)
</pre>
</font>

<ul>
  <li> Skip building this library if xrequirement
       (<a href="makefiles.html#ref_Packages">an optional package or project</a>)
       is disabled or unavailable
  <li> Compile <i><b>my_main.cpp</b></i> and <i><b>my_src1.cpp</b></i>
    using the C++ compiler <b>$(CXX)</b> with the flags <b>$(cppFLAGS)</b>
    (<a href="#ref_Note1">*</a>)
  <li> Compile <i><b>my_src2.c</b></i> using the C compiler
    <b>$(CC)</b> with the flags <b>$(cppFLAGS)</b>
    (<a href="#ref_Note1">*</a>)
  <li> Using <b>$(CXX)</b> as a linker, build an executable
    <i><b>my_exe</b></i> from the object files
    <b><i>my_main.o, my_src1.o, my_src2.o</i></b>, the precompiled
    object file <b><i>some_obj.o</i></b>, NCBI C++ Toolkit libraries
    <a href="#ref_MakeProjLib"><i><b>libxmylib.a</b></i></a> and
    <i><b>libxncbi.*</b></i>, and NCBI SSS DB, SYBASE, and system
    network libraries (<a href="#ref_Note1">*</a>)
  <li> Copy the application to the top-level <b><i>bin/</i></b> directory of
    the <i>build tree</i> (for later use by other projects)
</ul>
<p>

<a name="ref_Note1"></a>
<i><b>(*)</b></i>
Since we did not redefine <b>CFLAGS</b>, <b>CXXFLAGS</b>, or <b>LDFLAGS</b>,
their default values <b>ORIG_*FLAGS</b> (obtained during the <i>build
tree</i> <a href="config.html#ref_Configure">configuration</a>) will be
<a href="config.html#ref_StdBuildRules">used</a>.

<p>
This <i>customized makefile</i> should be referred to as
<i><b>my_exe</b></i> in the <b>APP_PROJ</b> macro of the relevant
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>. Note also, that the
<a href="makefiles.html#ref_MakeProjMk"><i>Makefile.mk</i></a> will be implicitly
included.
</dl>


<p>
<br>
<a name="ref_MakeProjUsr"></a>
<h3><i>Example 3:</i> User-defined makefile to build... whatever</h3>

<dl>
    <dt>
    <dd>
In some cases, we may need more functionality than the <i>customized
makefiles</i> (designed to build libraries and applications) can provide.

<p>
So, if you have a "regular" non-customized <i>user makefile</i>, and
you want to make from it, then you must enlist this <i>user makefile</i>
in the <b>USR_PROJ</b> macro of the project's
<a href="#ref_MakeMeta"><i>meta-makefile</i></a>.

<p>
Now, during the project build (and before any <i>customized makefiles</i>
are processed), your makefile will be called with one of the
<a href="makefiles.html#ref_MakeProjTarget">standard make targets</a> from the
project's build directory. Additionally, the
<a href="makefiles.html#ref_TablePath"><b>builddir</b></a> and
<a href="makefiles.html#ref_TablePath"><b>srcdir</b></a> macros will be passed
to your makefile (via the <b>make</b> command line).

<p>
In most cases, it is necessary to know your "working environment";
<i>i.e.</i>, tools, flags and paths (those that you use in your
<i>customized makefiles</i>).  This can be easily done by including
<a href="makefiles.html#ref_MakeProjMk"><i>Makefile.mk</i></a> in your makefile.

<p>
Shown below is a real-life example of a <i>user makefile</i>:
<ul>
  <li> build an auxiliary application using the <i>customized makefile</i>
    <i><b>Makefile.hc_gen_obj.app</b></i> (this part is a tricky one...)
  <li> use the resultant application <i><b>$(bindir)/hc_gen_obj</b></i>
    to generate the source and header files <i><b>humchrom_dat.[ch]</b></i>
    from the data file <i><b>humchrom.dat</b></i>
  <li> use the script <i><b>$(top_srcdir)/scripts/if_diff.sh</b></i>
    to replace the previous copies (if any) of humchrom_dat.[ch] with
    the newly generated versions if and only if the new versions are
    different (or there were no old versions).
</ul>

And, of course, it provides build rules for all the
<a href="makefiles.html#ref_MakeProjTarget">standard make targets</a>.

<font size="-1">
<pre>
    File $(top_srcdir)/src/internal/humchrom/Makefile.hc_gen_obj:

    # Build a code generator for hard-coding the chrom data into
    # an obj file
    # Generate header and source "humchrom_dat.[ch]" from data
    # file "humchrom.dat"
    # Deploy the header to the compiler-specific include dir
    # Compile source code
    #################################

    include $(builddir)/Makefile.mk

    BUILD__HC_GEN_OBJ = $(MAKE) -f "$(builddir)/Makefile.app.tmpl" \
    srcdir="$(srcdir)" TMPL="hc_gen_obj" $(MFLAGS)


    all_r: all
    all: build_hc_gen_obj humchrom_dat.dep

    purge_r: purge
    purge:   x_clean
        $(BUILD__HC_GEN_OBJ) purge

    clean_r: clean
    clean:   x_clean
        $(BUILD__HC_GEN_OBJ) clean
    x_clean:
        -rm -f humchrom_dat.h
        -rm -f humchrom_dat.c

    build_hc_gen_obj:
        $(BUILD__HC_GEN_OBJ) all

    humchrom_dat.dep: $(srcdir)/data/humchrom.dat $(bindir)/hc_gen_obj
        -cp -p humchrom_dat.c humchrom_dat.save.c
        $(bindir)/hc_gen_obj -d $(srcdir)/data/humchrom.dat
            -f humchrom_dat
        $(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.h
            $(incdir)/humchrom_dat.h
        -rm humchrom_dat.h
        $(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.c
            humchrom_dat.save.c
        mv humchrom_dat.save.c humchrom_dat.c
        touch humchrom_dat.dep
</pre>
</font>
</dl>

<hr>
<p>
<br>
<a name="ref_Outside"></a>
<h2>New Project (lib, application) Development Aids</h2>

<i><b>NOTE</b></i>:  in NCBI, you can use the scripts located in the pre-built NCBI C++
toolkit directory <b><tt>$NCBI/c++/scripts/.</tt></b>

<p>
<br>
<a name="ref_OutsideImport"></a>
<h3><b><tt>scripts/import_project.sh &lt;cvs_tree_path&gt; [builddir]</tt></b></h3>

<dl>
    <dt>
    <dd>
In many cases, you work on your own project which <b>is a part</b> of the
NCBI C++ tree, and you do not want to check out, update and rebuild
the whole NCBI C++ tree. -- Instead, you just want to use headers and
libraries of the pre-built NCBI C++ Toolkit to build your project.

<p>
The shell script <b><tt>import_project.sh</tt></b> will checkout
your project's source and include directories from CVS, and it will create
a (temporary) makefile based on the project's <i>customized makefile</i>.
This makefile will also contain a reference to the pre-built NCBI C++ toolkit.

<p>
For example (<a href="scripts_usage.html#ref_Import_ProjectUsage">full usage</a>):


<pre>
    <a href="new_project.import.session"><b><tt>import_project.sh hello</tt></b></a>
</pre>


will check out the whole <b>hello</b> demo project from the NCBI C++ tree
(<b><tt>$CVSROOT/internal/c++/src/hello/</tt></b>), and create a
makefile <b><tt>Makefile.hello_app</tt></b> that uses the project's
<i>customized makefile</i> <b><tt>Makefile.hello.app</tt></b>.
Now you can just go to the created working directory
<b><tt>internal/c++/src/hello/</tt></b> and build the demo application
<b>hello.cgi</b> using:
<pre>
    <b>make -f Makefile.hello_app</b>
</pre>
</dl>

<p>
<br>
<a name="ref_OutsideCreate"></a>
<h3><b><tt>scripts/new_project.sh &lt;name&gt; &lt;type&gt; [builddir]</tt></b> </h3>

<dl>
    <dt>
    <dd>
This script will create a startup <i>makefile</i> for a new, from-scratch
project called "<tt>name</tt>" which uses the NCBI C++ Toolkit (and possibly the C Toolkit as
well).  For new libraries, <tt>type=lib</tt> while for new applications <tt>type=app</tt>.

<p></p>
Sample code will be included in the project directory for new applications.  Different samples
are available for <tt>type=app[/basic]</tt> (a command-line argument demo application based
on the <a href="libs.html#ref_SumXNCBI"><tt>corelib</tt></a> library),
<tt>type=app/cgi</tt> (for a <a href="libs.html#ref_SumXCGI">CGI or Fast-CGI</a> application),
<tt>type=app/objmgr</tt> (for an application using the <i>Object Manager</i>) and <tt>type=app/objects</tt>
(for an application using ASN.1 objects).

<p></p>
You will need to slightly edit the resultant <i>makefile</i> to:
<ul>
  <li> specify the name of your library (or application)
  <li> specify the list of source files going to it
  <li> modify some preprocessor, compiler, etc.  flags, if needed
  <li> modify the set of additional libraries to link to it
       (if it's an application), if needed
</ul>

<p>
For example (<a href="scripts_usage.html#ref_New_ProjectUsage">full usage</a>):

<pre>
    <a href="new_project.create.session"><b><tt>new_project.sh foo app/basic</tt></b></a>
</pre>


creates a model <i>makefile</i> <tt>Makefile.foo_app</tt> to build
an application using tools and flags hard-coded in <tt>$NCBI/c++/Debug/build/Makefile.mk</tt>,
and headers from <tt>$NCBI/c++/include/</tt>.  The file <tt>/tmp/foo/foo.cpp</tt> is
also created; you can either replace this with your own <tt>foo.cpp</tt> or modify its sample
code as required.

<p></p>
Now, after specifying the application name, list of source files, etc.,
you can just go to the created working directory <tt>foo/</tt> and build your application using:

<pre>
    make -f Makefile.foo_app
</pre>

<p>
You can easily change the active version of NCBI C++ Toolkit
by manually setting variable <b>$(builddir)</b> in the file
<tt>Makefile.foo_app</tt> to the desired Toolkit path, e.g.,
<tt>builddir = </tt>$(NCBI)/<tt>c++/GCC-Release/build</tt>
</dl>

<p>
<br>
<a name="ref_OutsideHello"></a>
<h3><b><tt>scripts/hello.sh</tt></b> </h3>

<dl>
    <dt>
    <dd>
This script will:
<ul>
  <li> retrieve the demo CGI application project HELLO
  <li> create a standalone makefile to build it
  <li> build HELLO application using this makefile
  <li> run HELLO application
</ul>
It will produce the file <tt>hello.html</tt> containing a model
HTTP response. For more info on the HELLO CGI project see
in section
<i><a href="tools.html">NCBI C++ tools and applications</a> /
<a href="tools/hello/hello.html">HELLO.CGI -- a demo CGI application (NCBI C++)</a></i>.
</dl>

<!--#include virtual="./ssi/navlinks.shtml" -->

<table border=0 width="100%" cellspacing=0>
<script>
<!--
print_author('cpp-core', 'Denis Vakatov', '$Date$', 'ncbi.nlm.nih.gov');
print_author('cpp-core', 'Chris Lanczycki');
// -->
</script>
</table>

<!--#include virtual="./ssi/footer.shtml" -->
