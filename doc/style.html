<!--#set var="TITLE" value="Naming conventions, Indentation and Bracing" -->
<!--#set var="DOCROOT" value="." -->
<!--#include virtual="./ssi/header.shtml" -->

<h1>Naming conventions, Indentation and Bracing</h1>

<cite>
"In My Egotistical Opinion, most people's C programs should be indented
 six feet downward and covered with dirt."
</cite> -- Blair P. Houghton

<p>Nevertheless, here goes:

<ul>
    <li> <a href="#ref_Naming">Naming conventions</a>
    <ul>
        <li> <a href="#ref_NamingTypes">Type Names</a>
        <li> <a href="#ref_NamingCPP">Preprocessor Define/Macro</a>
        <li> <a href="#ref_NamingFuncArg">Function arguments</a>
        <li> <a href="#ref_NamingConst">Constants</a>
        <li> <a href="#ref_NamingCVar">Class and structure member variables</a>
        <li> <a href="#ref_NamingCFunc">Class member functions</a>
        <li> <a href="#ref_NamingStatic">Module static functions and data</a>
        <li> <a href="#ref_NamingGlobal">
                  Global ("extern") functions and data</a>
     </ul>
     <li> <a href="#ref_Prefix">Name prefixing and/or the use of namespaces</a>
     <li> <a href="#ref_Scope">Use of the NCBI name scope</a>
     <li> <a href="#ref_Indent">Code indentation and bracing</a>
     <li> <a href="#ref_Class">Class declaration</a>
     <li> <a href="#ref_FunctionDecl">Function declaration</a>
     <li> <a href="#ref_FunctionDef">Function definition</a>
     <li> <a href="#ref_Whitespace">Use of whitespace</a>
</ul>


<br>

<a name="ref_Naming"></a>
<h2> Naming conventions </h2>

<table border=1 cellspacing=0>

  <tr height=40><th>Synopsis</th><th>Example</th></tr>

  <a name="ref_NamingTypes"></a>
  <tr><th colspan=2 align=left height=40>
      &nbsp;&nbsp;&nbsp;Type Names</th></tr>
  <tr><td><i><b>C</b>ClassTypeName</i></td><td><span class="ncbi_ccode">
      class CMyClass { ..... };</span></td></tr>
  <tr><td><i><b>I</b>InterfaceName</i><!--NCBI_MARK--></td><td><span class="ncbi_ccode">
      class IMyInterface { ..... };</span></td></tr>
  <tr><td><i><b>S</b>StructTypeName</i><!--NCBI_MARK--></td><td><span class="ncbi_ccode">
      struct SMyStruct { ..... };</span></td></tr>
  <tr><td><i><b>U</b>UnionTypeName</i><!--NCBI_MARK--></td><td><span class="ncbi_ccode">
      union UMyUnion { ..... };</span></td></tr>
  <tr><td><i><b>E</b>EnumTypeName</i><!--NCBI_MARK--></td><td><span class="ncbi_ccode">
      enum EMyEnum { ..... };</span></td></tr>
  <tr><td><i><b>F</b>FunctionTypeName</i><!--NCBI_MARK--></td><td><span class="ncbi_ccode">
      typedef int (*FMyFunc)(void);</span></td></tr>
  <tr><td><i><b>P</b>PredicateName</i><!--NCBI_MARK--></td><td><span class="ncbi_ccode">
      struct PMyPred { bool operator() (..... , .....); };</span></td></tr>
  <tr><td><i><b>T</b>AuxiliaryTypedef <a href="#ref_AuxType">(see also)</a></i><!--NCBI_MARK--></td>
     <td><span class="ncbi_ccode">typedef map&lt;int,string&gt; TMapIntStr;</span></td></tr>
  <tr><td><i><b>T</b>Iterator<b>_I</b></i><!--NCBI_MARK--></td>
      <td><span class="ncbi_ccode">typedef list&lt;int&gt;::iterator TList_I;</span></td></tr>
  <tr><td><i><b>T</b>ConstIterator<b>_CI</b></i><!--NCBI_MARK--></td>
      <td><span class="ncbi_ccode">typedef set&lt;string&gt;::const_iterator TSet_CI;</span></td></tr>
  <tr><td><i><b>N</b>Namespace <a href="#ref_Prefix">(see also)</a></i><!--NCBI_MARK--></td><td>
      <span class="ncbi_ccode">namespace NMyNamespace { ..... } </span></td></tr>

  <a name="ref_NamingCPP"></a>
  <tr><th colspan=2 align=left height=40>
      &nbsp;&nbsp;&nbsp;Preprocessor Define/Macro</th></tr>
  <tr><td><i>MACRO_NAME</i></td><td><span class="ncbi_ccode">#define MY_DEFINE 12345</span></td></tr>
  <tr><td><i>macro_arg_name</i></td><td><span class="ncbi_ccode">#define MY_MACRO(x, y) (((x) + 1) < (y))</span></td></tr>

  <a name="ref_NamingFuncArg"></a>
  <tr><th colspan=2 align=left height=40>
      &nbsp;&nbsp;&nbsp;Function arguments and local variables</th></tr>
  <tr><td><i>func_local_name</i></td><td><span class="ncbi_ccode">void MyFunc(int foo_bar, CMyClass& some_class) <br>
{ <br>
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;foo_size; <br>
&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;bar_offset;
</span></td></tr>

  <a name="ref_NamingConst"></a>
  <tr><th colspan=2 align=left height=40>
      &nbsp;&nbsp;&nbsp;Constants</th></tr>
  <tr><td><i><b>k</b>ConstantName</i><!--NCBI_MARK--></td><td>
      <span class="ncbi_ccode">const int kMyConst = 123;</span></td></tr>
  <tr><td><i><b>e</b>EnumConstantName</i><!--NCBI_MARK--></td>
      <td><span class="ncbi_ccode">enum EMyEnum { <br>
          &nbsp;&nbsp;&nbsp;&nbsp; eMyEnum_1 = 11, <br>
          &nbsp;&nbsp;&nbsp;&nbsp; eMyEnum_2 = 22, <br>
          &nbsp;&nbsp;&nbsp;&nbsp; eMyEnum_3 = 33 <br>
          };</span></td></tr>

  <tr><td><i><b>f</b>FlagConstantName</i><!--NCBI_MARK--></td>
      <td><span class="ncbi_ccode">enum EMyFlags { <br>
          &nbsp;&nbsp;&nbsp;&nbsp; fMyFlag_1 = 0x1, <br>
          &nbsp;&nbsp;&nbsp;&nbsp; fMyFlag_2 = 0x2 <br>
          }; <br>
          typedef int TMyFlags;  // holds a binary OR of "EMyFlags"
          </tt><!--NCBI_MARK--></td></tr>

  <a name="ref_NamingCVar"></a>
  <tr><th colspan=2 align=left height=40>
      &nbsp;&nbsp;&nbsp;Class and structure member variables</th></tr>
  <tr><td><i><b>m_</b>ClassMemberName</i><!--NCBI_MARK--></td><td><span class="ncbi_ccode">
      class C { short m_MyClassData; };</span></td></tr>
  <tr><td><i><b>m_</b>StructFieldName</i><!--NCBI_MARK--></td><td><span class="ncbi_ccode">
      struct S { int my_struct_field; };</span></td></tr>
  <tr><td><i><b>sm_</b>ClassStaticMemberName</i><!--NCBI_MARK--></td><td><span class="ncbi_ccode">
      class C { static double sm_MyClassStaticData; };</span></td></tr>

  <a name="ref_NamingCFunc"></a>
  <tr><th colspan=2 align=left height=40>
      &nbsp;&nbsp;&nbsp;Class member functions</th></tr>
  <tr><td><i>Func</i></td><td><span class="ncbi_ccode">bool MyFunc(void);</span></td></tr>
  
  <a name="ref_NamingStatic"></a>
  <tr><th colspan=2 align=left>
      &nbsp;&nbsp;&nbsp;Module static functions and data</th></tr>
  <tr><td><i><b>s_</b>StaticFunc</b></td><td><span class="ncbi_ccode">
      static char s_MyStaticFunc(void);</span></td></tr>
  <tr><td><i><b>s_</b>StaticVar</b></td><td><span class="ncbi_ccode">
      static int s_MyStaticVar;</span></td></tr>

  <a name="ref_NamingGlobal"></a>
  <tr><th colspan=2 align=left height=40>
      &nbsp;&nbsp;&nbsp;Global (<i>"extern"</i><!--NCBI_MARK-->) functions and data
      </th></tr>
  <tr><td><i>GlobalFunc</i></td><td><span class="ncbi_ccode">double MyGlobalFunc(void);</span></td></tr>
  <tr><td><i><b>g_</b>GlobalVar</i><!--NCBI_MARK--></td><td><span class="ncbi_ccode">short g_MyGlobalVar;</span></td></tr>

</table>

<a name="ref_AuxType"></a>

<p>
(*) The auxiliary typedefs(like <span class="ncbi_type"><b>T</b>AuxiliaryTypedef</span>) are usually
used for an ad-hoc type mappings(especially when using templates) and
not when a real type definition takes place.


<br><br><br>

<a name="ref_Prefix"></a>
<h2>Name prefixing and/or the use of namespaces</h2>

In addition to the above naming conventions that highlights the
nature and/or the scope of things, one should also consider the use
of prefixes (or namespaces) in order to:
<ul>
    <li> avoid name conflicts
    <li> indicate the package which the thing belongs to
</ul>
E.g. it will always be a good idea to name your new base
class (for some package "<span class="ncbi_proj">Fo"</span>") "<span class="ncbi_class">C<b>Foo</b>Object</span>" rather
than just "<span class="ncbi_class">CObject</span>". -- And the same is true for all other
things from this package, so name the constants "<span class="ncbi_var">k<b>Foo</b>Someconst</span>",
types "<span class="ncbi_type">T<b>Foo</b>Sometype</span>", etc.

<p>
It is decided that we usually do not use C++ namespaces (other than
the NCBI-wide namespace "<span class="ncbi_ccode">ncbi::</span>") in NCBI.

<p>
One can emulate a sort of namespace by putting the things into a
structure or class scope, like
"<span class="ncbi_ccode">struct N<b>Foo</b>Globals { .....;  void SomeFunc(int); ... };</span>".
Then just use an explicit prefix when referencing these things, e.g. call
<span class="ncbi_funk">"N<b>Foo</b>Globals::SomeFunc(5)"</span>.
This approach can be useful to group and prefix a set of global functions.
As for classes, etc. it is still better to use simple prefixes
(as described above) instead.


<br><br><br>

<a name="ref_Scope"></a>
<h2>Use of the NCBI name scope</h2>

<span class="ncbi_code">&lt;ncbistl.hpp&gt;</span>

<p>
All NCBI-made API must be put into the single namespace.
For this reason, there are two preprocessor macros,
<span class="ncbi_macro">BEGIN_NCBI_SCOPE</span> and <span class="ncbi_macro">END_NCBI_SCOPE</span>,
that must embrace <em>all</em> NCBI C++ API code -- both declarations
and definitions (see <a href="new_mod.html">examples </a>).
Inside these "brackets", all <span class="ncbi_ccode">"std::"</span> and <span class="ncbi_ccode">"ncbi::"</span> scope prefixes
can(and must!) be omitted. Safely.

<p>
For the code that does not define new API but merely <em>uses</em>
NCBI C++ API, there is a macro <span class="ncbi_macro">USING_NCBI_SCOPE</span>
(semicolon-terminated) that makes all "std"- and
"ncbi"-related types and protos be visible by default,
without the explicit scope specification
(<span class="ncbi_ccode">"std::"</span> and <span class="ncbi_ccode">"ncbi::"</span> prefixes, respectively).

<p>
Use macro <span class="ncbi_macro">NCBI_USING_NAMESPACE_STD</span> (semicolon-terminated)
if you want make visible only "std"-related code, without the "ncbi"-related one.


<br><br><br>

<a name="ref_Indent"></a>
<h2>Code indentation and bracing </h2>

<em>4-space indentation only</em>!
Tabulation symbol <em>must not</em> be used for indentation.

<p>Try not to cross the "standard page boundary" of <em>80</em> symbols.

<p>In <span class="ncbi_keyword">if, for, while, do, switch, case</span>, etc. and
type definition statements:

<pre class="ncbi_code">
if (...) {
    .....;
} else if (...) {
    .....;
} else {
    .....;
}

for (...;  ...;  ...) {
    .....;
}

while (...) {
    .....;
}

do {
    .....;
} while (...);

switch (...) {
case ...: {
    .....;
    break;
}
} // switch

struct|union|enum <[S|U|E]TypeName> {
    .....;
};

class <CTypeName>
{
    .....;
};

try {
    .....;
}
catch (exception& e) {
    .....;
}
    </pre>



<a name="ref_Class"></a>
<h2>Class declaration</h2>

<pre class="ncbi_code">
class CFooClass
{
public:
    // Constructors and Destructor (they are usually public)
    CFooClass(bool init_bool = true);
    CFooClass(int  init_int);
    ~CFooClass(void);

    // Members and Methods
    float PublicFunc(void);
    // (NOTE:  the use of public data members is
    //         strictly discouraged!)
    int   m_PublicData;

protected:
    double m_ProtectedData;
    static int ProtectedFunc(char ch);

private:
    int    m_PrivateData;
    double PrivateFunc(int some_int = 123);

    // Friends
    friend bool  SomeFriendFunc(void);
    friend class CSomeFriendClass;
private:
    // Prohibit default initialization and assignment
    // -- e.g. when the member-by-member copying is
    // dangerous.
    // (These two methods are not even implemented.)
    CFooClass(const CFooClass&);
    CFooClass& operator= (const CFooClass&);
};
     </pre>


<a name="ref_FunctionDecl"></a>
<h2>Function declaration</h2>

<pre class="ncbi_code">
// Explain here what MyFunc1() does, and what it returns
int MyFunc1(void);

// Explain here what MyFunc2() does, and what it returns
bool MyFunc2
(double  arg1,      // short description of "arg1"
 string& arg2,      // short description of "arg2"
 long    arg3 = 12  // short description of "arg3"
 );
     </pre>


     <a name="ref_FunctionDef"></a>
    <h2>Function definition</h2>

<pre class="ncbi_code">
bool MyFunc2
(double  arg1,
 string& arg2,
 long    arg3)
{
    .......
    .......
    return true;
}


// For static function, put all comments on what the
// function does and what it returns right here, at
// the point of the function definition
static long s_MyFunc3(void)
{
    .......
    .......
}
</pre>


<a name="ref_Whitespace"></a>
<h2>Use of whitespace</h2>

As the above examples do not make all of our policies on
whitespace clear, here are some explicit guidelines:

<ul>
  <li> When reasonably possible, use spaces to align corresponding
       elements vertically.  (This overrides most of the rules
       below.) 
  <li> Leave one space on either side of most binary operators,
       and two spaces on either side of boolean <span class="ncbi_ccode">&amp;&amp</span>
       and <span class="ncbi_ccode">||</span>.
  <li> Put one space between the names of flow-control keywords
       and macros and their arguments, but no space after the
       names of functions except when necessary for alignment.
  <li> Leave two spaces after the semicolons in
       <span class="ncbi_ccode">for(...;&nbsp;&nbsp;...;&nbsp;&nbsp;...)</span>.
  <li> Leave whitespace around negated conditions so that the
      <span class="ncbi_ccode">!</span> stands out better.
  <li> Leave two blank lines between function definitions.
</ul>

<!--#include virtual="./ssi/navlinks.shtml" -->

<table border=0 width="100%" cellspacing=0>
  <tr>
    <td><address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td>
<!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> -->
    <td align=right><span class="ncbi_cvs_date">$Date$</span></td>
  </tr>
</table>

<!--#include virtual="./ssi/footer.shtml" -->
