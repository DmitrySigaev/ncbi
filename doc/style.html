<!--#set var="TITLE" value="Naming conventions, Indentation and Bracing" -->
<!--#set var="DOCROOT" value="." -->
<!--#include virtual="./ssi/header.shtml" -->

<h1>Naming conventions, Indentation and Bracing</h1>

<i>
"In My Egotistical Opinion, most people's C programs should be indented
 six feet downward and covered with dirt."
</i>
-- Blair P. Houghton

	 <p>
		Nevertheless, here goes:

	 <ul>
		<li> <a href="#ref_Naming">Naming conventions</a>
	 <ul>
		<li> <a href="#ref_NamingTypes">Type Names</a>
		<li> <a href="#ref_NamingCPP">Preprocessor Define/Macro</a>
		<li> <a href="#ref_NamingFuncArg">Function arguments</a>
		<li> <a href="#ref_NamingConst">Constants</a>
		<li> <a href="#ref_NamingCVar">Class member variables</a>
		<li> <a href="#ref_NamingCFunc">Class member functions</a>
		<li> <a href="#ref_NamingStatic">Module static functions and data</a>
		<li> <a href="#ref_NamingGlobal">
				  Global (<i>"extern"</i>) functions and data</a>
	 </ul>
	 <li> <a href="#ref_Prefix">Name prefixing and/or the use of namespaces</a>
	 <li> <a href="#ref_Scope">Use of the NCBI name scope</a>
	 <li> <a href="#ref_Indent">Code indentation and bracing</a>
	 <li> <a href="#ref_Class">Class declaration</a>
	 <li> <a href="#ref_FunctionDecl">Function declaration</a>
	 <li> <a href="#ref_FunctionDef">Function definition</a> </ul>


	 <br><br>

	 <a name="ref_Naming"></a>
     <h2> Naming conventions </h2>

     <table border=1 cellspacing=0>

      <tr><th>Synopsis</th><th>Example</th></tr>

	  <a name="ref_NamingTypes"></a>
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Type Names</th></tr>
      <tr><td><i><b>C</b>ClassTypeName</i></td><td><tt>
				class CMyClass { ..... };</tt></td></tr>
      <tr><td><i><b>I</b>InterfaceName</i></td><td><tt>
				class IMyInterface { ..... };</tt></td></tr>
      <tr><td><i><b>S</b>StructTypeName</i></td><td><tt>
				struct SMyStruct { ..... };</tt></td></tr>
      <tr><td><i><b>U</b>UnionTypeName</i></td><td><tt>
				union UMyUnion { ..... };</tt></td></tr>
      <tr><td><i><b>E</b>EnumTypeName</i></td><td><tt>
				enum EMyEnum { ..... };</tt></td></tr>
      <tr><td><i><b>F</b>FunctionTypeName</i></td><td><tt>
				typedef int (*FMyFunc)(void);</tt></td></tr>
      <tr><td><i><b>P</b>PredicateName</i></td><td><tt>
				struct PMyPred { bool operator() (..... , .....); };</tt></td></tr>
      <tr><td><i><b>T</b>AuxiliaryTypedef <a href="#ref_AuxType">(see also)</a></i></td>
			 <td><tt>typedef map&lt;int,string&gt; TMapIntStr;</tt></td></tr>
      <tr><td><i><b>T</b>Iterator<b>_I</b></i></td>
			 <td><tt>typedef list&lt;int&gt;::iterator TList_I;</tt></td></tr>
      <tr><td><i><b>T</b>ConstIterator<b>_CI</b></i></td>
			 <td><tt>typedef set&lt;string&gt;::const_iterator TSet_CI;</tt></td></tr>
      <tr><td><i><b>N</b>Namespace <a href="#ref_Prefix">(see also)</a></i></td><td><tt>
				namespace NMyNamespace { ..... } </tt></td></tr>

	  <a name="ref_NamingCPP"></a>
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Preprocessor Define/Macro</th></tr>
      <tr><td><i>MACRO_NAME</i></td><td><tt>#define MY_DEFINE 12345</td></tr>
      <tr><td><i>macro_arg_name</i></td><td><tt>#define MY_MACRO(x, y) (((x) + 1) < (y))</td></tr>

	  <a name="ref_NamingFuncArg"></a>
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Function arguments and local variables</th></tr>
      <tr><td><i>func_local_name</i></td><td><tt>void MyFunc(int foo_bar, CMyClass& some_class) <br>
{ <br>
&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;foo_size; <br>
&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;bar_offset;
      </tt></td></tr>

 	  <a name="ref_NamingConst"></a>
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Constants</th></tr>
      <tr><td><i><b>k</b>ConstantName</i></td><td>
				<tt>const int kMyConst = 123;</tt></td></tr>
      <tr><td><i><b>e</b>EnumConstantName</i></td>
			 <td><tt>enum EMyEnum { <br>
				&nbsp;&nbsp;&nbsp;&nbsp; eMyEnum_1 = 11, <br>
				&nbsp;&nbsp;&nbsp;&nbsp; eMyEnum_2 = 22, <br>
				&nbsp;&nbsp;&nbsp;&nbsp; eMyEnum_3 = 33 <br>
				};</tt></td></tr>

      <tr><td><i><b>f</b>FlagConstantName</i></td>
			 <td><tt>enum EMyFlags { <br>
				&nbsp;&nbsp;&nbsp;&nbsp; fMyFlag_1 = 0x1, <br>
				&nbsp;&nbsp;&nbsp;&nbsp; fMyFlag_2 = 0x2 <br>
				}; <br>
				typedef int TMyFlags;  // holds a binary OR of "EMyFlags"
			 </tt></td></tr>

	  <a name="ref_NamingCVar"></a>
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Class member variables</th></tr>
      <tr><td><i><b>m_</b>ClassMemberName</i></td><td><tt>
				class C { short m_MyClassData; }</tt></td></tr>
      <tr><td><i><b>sm_</b>ClassStaticMemberName</i></td><td><tt>
				class C { static double sm_MyClassStaticData; }</tt></td></tr>

	  <a name="ref_NamingCFunc"></a>
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Class member functions</th></tr>
      <tr><td><i>Func</i></td><td><tt>bool MyFunc(void);</tt></td></tr>

	  <a name="ref_NamingStatic"></a>
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Module static functions and data</th></tr>
      <tr><td><i><b>s_</b>StaticFunc</b></td><td><tt>
				static char s_MyStaticFunc(void);</tt></td></tr>
      <tr><td><i><b>s_</b>StaticVar</b></td><td><tt>
				static int s_MyStaticVar;</tt></td></tr>

	   <a name="ref_NamingGlobal"></a>
      <tr><th colspan=2 align=left>
				&nbsp;&nbsp;&nbsp;Global (<i>"extern"</i>) functions and data
			 </th></tr>
      <tr><td><i>GlobalFunc</i></td><td><tt>double MyGlobalFunc(void);</tt></td></tr>
      <tr><td><i><b>g_</b>GlobalVar</i></td><td><tt>short g_MyGlobalVar;</tt></td></tr>

	 </table>

	 <a name="ref_AuxType"></a>

	 <p>
	 (*) The auxiliary typedefs(like <i><b>T</b>AuxiliaryTypedef</i>) are usually
	 used for an ad-hoc type mappings(especially when using templates) and
	 not when a real type definition takes place.


	 <br><br> <br><br>

	 <a name="ref_Prefix"></a>
     <h2>Name prefixing and/or the use of namespaces</h2>

	 In addition to the above naming conventions that highlights the
	 nature and/or the scope of things, one should also consider the use
	 of prefixes (or namespaces) in order to:
	 <ul>
		<li> avoid name conflicts
		<li> indicate the package which the thing belongs to
	 </ul>
	 E.g. it will always be a good idea to name your new base
	 class(for some package <i>"Foo"</i>) <i>"C<b>Foo</b>Object"</i> rather
	 than just <i>"CObject"</i>. -- And the same is true for all other
	 things from this package, so name the constants <i>"k<b>Foo</b>Someconst"</i>,
	 types <i>"T<b>Foo</b>Sometype"</i>, etc.

	 <p>
	 It is decided that we usually do not use C++ namespaces (other than
    the NCBI-wide namespace "ncbi::") in NCBI.
	 <p>
	 One can emulate a sort of namespace by putting the things into a
	 structure or class scope, like
    <i>"struct N<b>Foo</b>Globals { .....;  void SomeFunc(int); ... };"</i>.
	 Then just use an explicit prefix when referencing these things, e.g. call
    <i>"N<b>Foo</b>Globals::SomeFunc(5)"</i>.
	 This approach can be useful to group and prefix a set of global functions.
	 As for classes, etc. it is still better to use simple prefixes
	 (as described above) instead.


	 <br><br><br><br>

	 <a name="ref_Scope"></a>
    <h2>Use of the NCBI name scope</h2>

	 <i>&lt;ncbistl.hpp&gt;</i>

	 <p>
	 All NCBI-made API must be put into the single namespace.
	 For this reason, there are two preprocessor macros,
	 <i>BEGIN_NCBI_SCOPE</i> and <i>END_NCBI_SCOPE</i>,
	 that must embrace <b>all</b> NCBI C++ API code -- both declarations
	 and definitions(see <a href="new_mod.html">examples </a>).
	 Inside these "brackets", all <i>"std::"</i> and <i>"ncbi::"</i> scope prefixes
	 can(and must!) be omitted. Safely.

	 <p>
	 For the code that does not define new API but merely <b>uses</b>
	 NCBI C++ API, there is a macro <i>USING_NCBI_SCOPE</i>
	 (semicolon-terminated) that makes all <b>"std"</b>- and
	 <b>"ncbi"</b>-related types and protos be visible by default,
	 without the explicit scope specification
	 (<i>"std::"</i> and <i>"ncbi::"</i> prefixes, respectively).

	 <p>
	 Use macro <i>NCBI_USING_NAMESPACE_STD</i>(semicolon-terminated)
	 if you want make visible only <b>"std"</b>-related code, without the
	 <b>"ncbi"</b>-related one.


	 <br><br><br><br>

	 <a name="ref_Indent"></a>
    <h2>Code indentation and bracing </h2>

		  <b>4-space indentation only</b>!
		  Tabulation symbol <b>must not</b> be used for indentation.

	 <p>
		Try not to cross the "standard page boundary" of <b>80</b>
		symbols.

	 <p>
		In <i>if, for, while, do, switch, case</i>, etc. and
		type definition statements:
    <pre>
if (...) {
    .....;
}
else if (...) {
    .....;
}
else {
    .....;
}

for|while (...) {
    .....;
}

do {
    .....;
} while (...);

switch (...) {
case ...: {
    .....;
    break;
}
} // switch

struct|union|enum <[S|U|E]TypeName> {
    .....;
};

class <CTypeName>
{
    .....;
};

try {
    .....;
}
catch (exception& e) {
    .....;
}
    </pre>



	 <a name="ref_Class"></a>
    <h2>Class declaration</h2>

	 <pre>
class CFooClass
{
public:
    // Constructors and Destructor (they are usually public)
    CFooClass(bool init_bool = true);
    CFooClass(int  init_int);
    ~CFooClass(void);

    // Members and Methods
    float PublicFunc(void);
    // (NOTE:  the use of public data members is
    //         strictly discouraged!)
    int   m_PublicData;

protected:
    double m_ProtectedData;
    static int ProtectedFunc(char ch);

private:
    int    m_PrivateData;
    double PrivateFunc(int some_int = 123);

    // Friends
    friend bool  SomeFriendFunc(void);
    friend class CSomeFriendClass;
private:
    // Prohibit default initialization and assignment
    // -- e.g. when the member-by-member copying is
    // dangerous.
    // (These two methods are not even implemented.)
    CFooClass(const CFooClass&);
    CFooClass& operator= (const CFooClass&);
};
	 </pre>


	 <a name="ref_FunctionDecl"></a>
    <h2>Function declaration</h2>

	 <pre>
// Explain here what MyFunc1() does, and what it returns
int MyFunc1(void);

// Explain here what MyFunc2() does, and what it returns
bool MyFunc2
(double  arg1,      // short description of "arg1"
 string& arg2,      // short description of "arg2"
 long    arg3 = 12  // short description of "arg3"
 );
	 </pre>


	 <a name="ref_FunctionDef"></a>
    <h2>Function definition</h2>

	 <pre>
bool MyFunc2
(double  arg1,
 string& arg2,
 long    arg3)
{
    .......
    .......
    return true;
}


// For static function, put all comments on what the
// function does and what it returns right here, at
// the point of the function definition
static long s_MyFunc3(void)
{
    .......
    .......
}
	 </pre>



	 <br>

<!--#include virtual="./ssi/navlinks.shtml" -->

<!-- Begin footer content -->

	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
		<tr>
	 </table>

<!--#include virtual="./ssi/footer.shtml" -->
