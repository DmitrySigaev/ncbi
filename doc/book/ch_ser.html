<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Data Serialization (ASN.1, XML) - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_ser" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="js/jig/1.7/js/jig.min.js"></script><script type="text/javascript" src="js/toolkitSymbolSearch.js"></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents ▾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access - SQL, Berkley DB</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_xmlauthor.html">29. XML Authoring using Word</a></li><li class="half_rhythm"><a href="ch_faq.html">30. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">31. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a><ul class="simple-list"><li class="half_rhythm"><a href="release_notes.html">Release Notes (Version 9, May 2012)</a></li><li class="half_rhythm"><a href="release_notes_7-05_2011.html">Release Notes (Version 7, May 2011)</a></li><li class="half_rhythm"><a href="release_notes_06_29_2010.html">Release Notes (June, 2010)</a></li><li class="half_rhythm"><a href="release_notes_05_15_2009.html">Release Notes (May, 2009)</a></li><li class="half_rhythm"><a href="release_notes_12_24_2008.html">Release Notes (December, 2008)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2008.html">Release Notes (March, 2008)</a></li><li class="half_rhythm"><a href="release_notes_08_27_2007.html">Release Notes (August, 2007)</a></li><li class="half_rhythm"><a href="release_notes_03_12_2007.html">Release Notes (March, 2007)</a></li><li class="half_rhythm"><a href="release_notes_08_14_2006.html">Release Notes (August, 2006)</a></li><li class="half_rhythm"><a href="release_notes_04_30_2006.html">Release Notes (April 30, 2006)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2005.html">Release Notes (December 31, 2005)</a></li><li class="half_rhythm"><a href="release_notes_10_03_2005.html">Release Notes (August, 2005)</a></li><li class="half_rhythm"><a href="release_notes_05_05_2005.html">Release Notes (April, 2005)</a></li><li class="half_rhythm"><a href="release_notes_03_09_2005.html">Release Notes (February, 2005)</a></li><li class="half_rhythm"><a href="release_notes_11_22_2004.html">Release Notes (November 22, 2004)</a></li><li class="half_rhythm"><a href="release_notes_10_2_2004.html">Release Notes (October 2, 2004)</a></li><li class="half_rhythm"><a href="release_notes_7_8_2004.html">Release Notes (July 8, 2004)</a></li><li class="half_rhythm"><a href="release_notes_april_16_2004.html">Release Notes (April 16, 2004)</a></li><li class="half_rhythm"><a href="release_notes_12_08_2003.html">Release Notes (December 8, 2003)</a></li><li class="half_rhythm"><a href="release_notes_08_01_2003.html">Release Notes (August 1, 2003)</a></li></ul></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="ch_html.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="ch_datamod.html">Next &gt;</a></div></div><div class="meta_content"><h1><span class="label">13</span><span class="title">Data Serialization (ASN.1, XML)</span></h1><p class="small">Last Update: October 10, 2012.</p></div><div class="body_content"><div class="sec"><h2><span class="title">The SERIAL API [Library <span class="nctnt ncbi-path">xserial</span>:<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/serial">src</a>]</span></h2><p>The overview for this chapter consists of the following topics:</p><ul><li><p>Introduction</p></li><li><p>Chapter Outline</p></li></ul><div class="sec"><h3><span class="title">Introduction</span></h3><p>The Serial library provides a means for loading, accessing, manipulating, and serialization of data in a formatted way. It supports serialization in <a href="http://www.itu.int/ITU-T/studygroups/com17/languages/">ASN.1</a> (text or BER encoding), <a href="http://www.w3.org/XML">XML</a>, and <a href="http://json.org">JSON</a> formats. See also the <a href="ch_app.html#ch_app.datatool">DATATOOL documentation</a> discussion of generating C++ code for serializable objects from the corresponding ASN.1 definition.</p><p>The structure of data is described by some sort of formal language. In our case it can be ASN.1, DTD or XML Schema. Based on such specification, <a href="ch_app.html#ch_app.datatool">DATATOOL</a> application, which is part of NCBI C++ toolkit, generates a collection of data storage classes that can be used to store and serialize data. The design purpose was to make these classes as lightweight as possible, moving all details of serialization into specialized classes - <a href="ch_ser.html#ch_ser.objstream.html_intro">“object streams”</a>. Structure of the data is described with the help of <a href="ch_ser.html#ch_ser.typeinfo.html">“type information”</a>. Data objects contain data and type information only. Any such data storage object can be viewed as a node tree that provides random access to its data. The Serial library provides a means of<a href="ch_ser.html#ch_ser.typeinfo.html_cobjinfo"> traversing</a> this data tree without knowing its structure in advance – using only type information; C++ code generated by DATATOOL makes it possible to access any child node directly.</p><p><a href="ch_ser.html#ch_ser.objstream.html_intro">“Object streams”</a> are intermediaries between data storage objects and input or output stream. They perform encoding or decoding of data according to format specifications. Guided by the type information embedded into data object, on reading they allocate memory when needed, fill in data, and validate that all mandatory data is present; on writing they guarantee that all relevant data is written and that the resulting document is well-formed. All it takes to read or write a top-level data object is one function call – all the details are handled by an object stream.</p><p>Closely related to serialization is the task of converting data from one format into another. One approach could be reading data object completely into memory and then writing it in another format. The only problem is that the size of data can be huge. To simplify this task and to avoid storing data in memory, the serial library provides the <a href="ch_ser.html#ch_ser.objstream.html_objcopy">“object stream copier”</a> class. It reads data by small chunks and writes it immediately after reading. In addition to small memory footprint, it also works much faster.</p><p>Input data can be very large in size; also, reading it completely into memory could not be the goal of processing. Having a large file of data, one might want to investigate information containers only of a particular type. Serial library provides a variety of means for doing this. The list includes <a href="ch_ser.html#ch_ser.objstream.html_readhooks">read</a> and <a href="ch_ser.html#ch_ser.objstream.html_writehooks">write</a> hooks, several types of <a href="ch_ser.html#ch_ser.stream_iterators">stream iterators</a>, and <a href="ch_ser.html#ch_ser.serial_filter">filter templates</a>. It is worth to note that, when using read hooks to read child nodes, one might end up with an invalid top-level data object; or, when using write hooks, one might begin with an invalid object and fill in missing data on the fly – in hooks.</p><p>In essence, “hook” is a callback function that client application provides to serial library. Client application installs the hook, then reads (or writes) data object, and somewhere from the depths of serialization processing, the library calls this hook function at appropriate times, for example, when a data chunk of specified type is about to be read. It is also possible to install <a href="ch_ser.html#ch_ser.stack_path_hooks">context-specific hooks</a>. Such hooks are triggered when serializing a particular object type in a particular structural context; for example, for all objects of class A which are contained in object B.</p></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p></div><ul><li><p><a href="#ch_ser.objstream.html">CObject[IO]Streams</a></p><ul><li><p><a href="#ch_ser.objstream.html_intro">Format Specific Streams: The CObject[IO]Stream classes</a></p></li><li><p><a href="#ch_ser.objstream.html_objistr">The CObjectIStream (*) classes</a></p></li><li><p><a href="#ch_ser.objstream.html_objostr">The CObjectOStream (*) classes</a></p></li><li><p><a href="#ch_ser.objstream.html_objcopy">The CObjectStreamCopier (*) classes</a></p></li><li><p><a href="#ch_ser.objstream.html_cback">Type-specific I/O routines – the hook classes</a></p><ul><li><p><a href="#ch_ser.Hook_Sample">Hook Sample</a></p></li><li><p><a href="#ch_ser.objstream.html_readhooks">Read mode hooks</a></p></li><li><p><a href="#ch_ser.objstream.html_writehooks">Write mode hooks</a></p></li><li><p><a href="#ch_ser.objstream.html_copyhooks">Copy mode hooks</a></p></li><li><p><a href="#ch_ser.Skip_mode_hooks">Skip mode hooks</a></p></li><li><p><a href="#ch_ser.objstream.html_hookguard">The CObjectHookGuard class</a></p></li><li><p><a href="#ch_ser.stack_path_hooks">Stack Path Hooks</a></p></li></ul></li><li><p><a href="#ch_ser.objstream.html_blocks">The ByteBlock and CharBlock classes</a></p></li><li><p><a href="#ch_ser.rpc.html">NCBI C++ Toolkit Network Service (RPC) Clients</a></p><ul><li><p><a href="#ch_ser.data_ser_2_1">Introduction and Use</a></p></li><li><p><a href="#ch_ser.data_ser_2_2">Implementation Details</a></p></li></ul></li><li><p><a href="#ch_ser.serial_verify">Verification of Class Member Initialization</a></p><ul><li><p><a href="#ch_ser.serial_object_api">Initialization Verification in CSerialObject Classes</a></p></li><li><p><a href="#ch_ser.serial_stream_api">Initialization Verification in Object Streams</a></p></li></ul></li><li><p><a href="#ch_ser.simplified_serialization_inte">Simplified serialization interface</a></p></li><li><p><a href="#ch_ser.serial_filter">Finding in input stream objects of a specific type</a></p></li></ul></li><li><p><a href="#ch_ser.iterators.html">The NCBI C++ Toolkit Iterators</a></p><ul><li><p><a href="#ch_ser.iterators.html_generic">STL generic iterators</a></p></li><li><p><a href="#ch_ser.iterators.html_typeIt">CTypeIterator (*) and CTypeConstIterator (*)</a></p></li><li><p><a href="#ch_ser.iterators.html_hier">Class hierarchies, embedded objects, and the NCBI C++ type iterators</a></p></li><li><p><a href="#ch_ser.iterators.html_cobjType">CObjectIterator (*) and CObjectConstIterator (*)</a></p></li><li><p><a href="#ch_ser.iterators.html_stdType">CStdTypeIterator (*) and CStdTypeConstIterator (*)</a></p></li><li><p><a href="#ch_ser.iterators.html_typesIt">CTypesIterator (*)</a></p></li><li><p><a href="#ch_ser.iterators.context_filter">Context Filtering in Type Iterators</a></p></li><li><p><a href="#ch_ser.iterators.html_appendix">Additional Information</a></p></li></ul></li><li><p><a href="#ch_ser.asn.html">Processing Serial Data</a></p><ul><li><p><a href="#ch_ser.asn.html_headersandlibs">Accessing the object header files and serialization libraries</a></p></li><li><p><a href="#ch_ser.asn.html_example1">Reading and writing serial data</a></p></li><li><p><a href="#ch_ser.Reading_and_writing_binary_JSON_d">Reading and writing binary JSON data</a></p></li><li><p><a href="#ch_ser.asn.html_includes">Determining Which Header Files to Include</a></p></li><li><p><a href="#ch_ser.asn.html_linklibs">Determining Which Libraries to Link To</a></p></li></ul></li><li><p><a href="#ch_ser.usrtypeinfo.html">User-defined type information</a></p><ul><li><p><a href="#ch_ser.usrtypeinfo.html_introduction">Introduction</a></p></li><li><p><a href="#ch_ser.usrtypeinfo.html_macros">Installing a GetTypeInfo() function: the BEGIN_/END_ macros</a></p><ul><li><p><a href="#ch_ser.usrtypeinfo.html_class_ref">List of the BEGIN_/END_ macros</a></p></li></ul></li><li><p><a href="#ch_ser.usrtypeinfo.html_addm">Specifying internal structure and class inheritance: the ADD_ macros</a></p></li></ul></li><li><p><a href="#ch_ser.typeinfo.html">Runtime Object Type Information</a></p><ul><li><p><a href="#ch_ser.typeinfo.html_introduction">Introduction</a></p><ul><li><p><a href="#ch_ser.typeinfo.html_ctypeinfo_ref">Type and Object specific info</a></p></li></ul></li><li><p><a href="#ch_ser.typeinfo.html_motivation">Motivation</a></p></li><li><p><a href="#ch_ser.typeinfo.html_cobjinfo">Object Information Classes</a></p></li><li><p><a href="#ch_ser.typeinfo.html_objtype">CObjectTypeInfo (*)</a></p></li><li><p><a href="#ch_ser.typeinfo.html_constobj">CConstObjectInfo (*)</a></p></li><li><p><a href="#ch_ser.typeinfo.html_objinfo">CObjectInfo (*)</a></p></li><li><p><a href="#ch_ser.typeinfo.html_usage">Usage of object type information</a></p></li></ul></li><li><p><a href="#ch_ser.choice.html">Choice objects in the NCBI C++ Toolkit</a></p><ul><li><p><a href="#ch_ser.choice.html_intro">Introduction</a></p></li><li><p><a href="#ch_ser.choice.html_cppchoice">C++ choice objects</a></p></li></ul></li><li><p><a href="#ch_ser.traverse.html">Traversing a Data Structure</a></p><ul><li><p><a href="#ch_ser.traverse.html_locateClass">Locating the Class Definitions</a></p></li><li><p><a href="#ch_ser.traverse.html_accessMember">Accessing and Referencing Data Members</a></p></li><li><p><a href="#ch_ser.traverse.html_example">Traversing a Biostruc</a></p></li><li><p><a href="#ch_ser.traverse.html_iterate">Iterating Over Containers</a></p></li></ul></li><li><p><a href="#ch_ser.SOAP_support">SOAP support</a></p><ul><li><p><a href="#ch_ser.SOAP_message">SOAP message</a></p></li><li><p><a href="#ch_ser.SOAP_client_CSoapHtt">SOAP client - CSoapHttpClient</a></p></li><li><p><a href="#ch_ser.SOAP_server_CSoapSer">SOAP server - CSoapServerApplication</a></p></li><li><p><a href="#ch_ser.Sample_SOAP_server_a">Sample SOAP server and client</a></p><ul><li><p><a href="#ch_ser.Sample_server">Sample server</a></p></li><li><p><a href="#ch_ser.Sample_client">Sample client</a></p></li></ul></li></ul></li><li><p><a href="#ch_ser.ch_ser_test_cases">Test Cases [src/serial/test]</a></p></li></ul></div><div class="sec" id="ch_ser.objstream.html"><h2><span class="title"><span class="nctnt ncbi-class">CObject[IO]Streams</span></span></h2><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_ser.html#ch_ser.objstream.html_intro">Format Specific Streams: The CObject[IO]Stream classes</a></p></li><li><p><a href="ch_ser.html#ch_ser.objstream.html_objistr">The CObjectIStream (*) classes</a></p></li><li><p><a href="ch_ser.html#ch_ser.objstream.html_objostr">The CObjectOStream (*) classes</a></p></li><li><p><a href="ch_ser.html#ch_ser.objstream.html_objcopy">The CObjectStreamCopier (*) classes</a></p></li><li><p><a href="ch_ser.html#ch_ser.objstream.html_cback">Type-specific I/O routines – the hook classes</a></p><ul><li><p><a href="ch_ser.html#ch_ser.Hook_Sample">Hook Sample</a></p></li><li><p><a href="ch_ser.html#ch_ser.objstream.html_readhooks">Read mode hooks</a></p></li><li><p><a href="ch_ser.html#ch_ser.objstream.html_writehooks">Write mode hooks</a></p></li><li><p><a href="ch_ser.html#ch_ser.objstream.html_copyhooks">Copy mode hooks</a></p></li><li><p><a href="ch_ser.html#ch_ser.Skip_mode_hooks">Skip mode hooks</a></p></li></ul></li><li><p><a href="ch_ser.html#ch_ser.objstream.html_hookguard">The CObjectHookGuard class</a></p></li><li><p><a href="ch_ser.html#ch_ser.stack_path_hooks">Stack Path Hooks</a></p></li><li><p><a href="ch_ser.html#ch_ser.objstream.html_blocks">The ByteBlock and CharBlock classes</a></p></li><li><p><a href="ch_ser.html#ch_ser.rpc.html">NCBI C++ Toolkit Network Service Clients</a></p></li><li><p><a href="ch_ser.html#ch_ser.serial_verify">Verification of Class Member Initialization</a></p></li><li><p><a href="ch_ser.html#ch_ser.simplified_serialization_inte">Simplified serialization interface</a></p></li><li><p><a href="ch_ser.html#ch_ser.serial_filter">Finding in input stream objects of a specific type</a></p></li></ul><div class="sec" id="ch_ser.objstream.html_intro"><h3><span class="title">Format Specific Streams: The <span class="nctnt ncbi-class">CObject[IO]Stream</span> classes</span></h3><p>The reading and writing of serialized data objects entails satisfying two independent sets of constraints and specifications: (1) <span class="nctnt ncbi-monospace">format-specific</span> parsing and encoding schemes, and (2) <span class="nctnt ncbi-monospace">object-specific</span> internal structures and rules of composition. The NCBI C++ Toolkit implements serial IO processes by combining a set of <span class="nctnt ncbi-monospace">object stream</span> classes with an independently defined set of <span class="nctnt ncbi-monospace">data object</span> classes. These classes are implemented in the <span class="nctnt ncbi-path">serial</span> and <span class="nctnt ncbi-path">objects</span> directories respectively.</p><p>The base classes for the object stream classes are <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStream.html">CObjectIStream</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStream.html">CObjectOStream</a>. Each of these base classes has derived subclasses which specialize in different formats, including XML, binary ASN.1, and text ASN.1. A simple example program, <span class="nctnt ncbi-path">xml2asn.cpp</span> (see <a href="ch_ser.html#ch_ser.xml2asn_cpp.html">Code Sample 1</a>), described in <a href="ch_ser.html#ch_ser.asn.html_example1">Processing serial data</a>, uses these object stream classes in conjunction with a <span class="nctnt ncbi-class">CBiostruct</span> object to translate a file from XML encoding to ASN.1 formats. In this chapter, we consider in more detail the class definitions for object streams, and how the <a href="ch_ser.html#ch_ser.typeinfo.html_ctypeinfo_ref">type information</a> associated with the data is used to implement serial input and output.</p><div class="box" id="ch_ser.xml2asn_cpp.html"><h4><span class="title">Code Sample 1. xml2asn.cpp</span></h4><pre><span class="nctnt-pre ncbi-code">// File name: xml2asn.cpp<br />// Description: Reads an XML Biostruc file into memory<br />//      and saves it in ASN.1 text and binary formats.<br /><br />#include &lt;corelib/ncbistd.hpp&gt;<br />#include &lt;corelib/ncbiapp.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/objostr.hpp&gt;<br />#include &lt;objects/mmdb1/Biostruc.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br /><br />class CTestAsn : public CNcbiApplication {<br />public:<br />    virtual int Run ();<br />};<br /><br />using namespace objects;<br /><br />int CTestAsn::Run() {<br />    auto_ptr&lt;CObjectIStream&gt;<br />        xml_in(CObjectIStream::Open("1001.xml", eSerial_Xml));<br />    auto_ptr&lt;CObjectOStream&gt;<br />        txt_out(CObjectOStream::Open("1001.asntxt", eSerial_AsnText));<br />    auto_ptr&lt;CObjectOStream&gt;<br />        bin_out(CObjectOStream::Open("1001.asnbin", eSerial_AsnBinary));<br />    CBiostruc bs;<br />    *xml_in &gt;&gt; bs;<br />    *txt_out &lt;&lt; bs;<br />    *bin_out &lt;&lt; bs;<br />    return 0;<br />}<br /><br />int main(int argc, const char* argv[])<br />{<br />    CNcbiOfstream diag("asntrans.log");<br />    SetDiagStream(&amp;diag);<br />    CTestAsn theTestApp;<br />    return theTestApp.AppMain(argc, argv);<br />}</span></pre></div><p>Each object stream specializes in a serial data format and a direction (in/out). It is not until the input and output operators are applied to these streams, in conjunction with a specified serializable object, that the object-specific type information comes into play. For example, if <span class="nctnt ncbi-var">instr</span> is a <span class="nctnt ncbi-class">CObjectIStream</span>, the statement: <span class="nctnt ncbi-code">instr &gt;&gt; myObject</span> invokes a <span class="nctnt ncbi-func">Read()</span> method associated with the input stream, whose sole argument is a <a href="ch_ser.html#ch_ser.typeinfo.html_cobjinfo">CObjectInfo</a> for <span class="nctnt ncbi-var">myObject</span>.</p><p>Similarly, the output operators, when applied to a <span class="nctnt ncbi-class">CObjectOstream</span> in conjunction with a serializable object, will invoke a <span class="nctnt ncbi-func">Write()</span> method on the output stream which accesses the object's type information. The object's type information defines what tag names and value types should be encountered on the stream, while the <span class="nctnt ncbi-class">CObject[IO]Stream</span> subclasses specialize the data serialization format.</p><p>The input and output operators (<span class="nctnt ncbi-code">&lt;&lt;</span> and <span class="nctnt ncbi-code">&gt;&gt;</span>) are declared in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial/serial.hpp">serial/serial.hpp</a> header.</p></div><div class="sec" id="ch_ser.objstream.html_objistr"><h3><span class="title">The <span class="nctnt ncbi-class">CObjectIStream</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStream.html">*</a>) classes</span></h3><p><span class="nctnt ncbi-class">CObjectIStream</span> is a virtual base class for the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStreamXml.html">CObjectIStreamXml</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStreamAsn.html">CObjectIStreamAsn</a>, and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStreamAsnBinary.html">CObjectIStreamAsnBinary</a> classes. As such, it has no public constructors, and its user interface includes the following methods:</p><ul><li><p><span class="nctnt ncbi-func">Open()</span></p></li><li><p><span class="nctnt ncbi-func">Close()</span></p></li><li><p><span class="nctnt ncbi-func">GetDataFormat()</span></p></li><li><p><span class="nctnt ncbi-func">ReadFileHeader()</span></p></li><li><p><span class="nctnt ncbi-func">Read()</span></p></li><li><p><span class="nctnt ncbi-func">ReadObject()</span></p></li><li><p><span class="nctnt ncbi-func">ReadSeparateObject()</span></p></li><li><p><span class="nctnt ncbi-func">Skip()</span></p></li><li><p><span class="nctnt ncbi-func">SkipObject()</span></p></li></ul><p>There are several <span class="nctnt ncbi-func">Open()</span> methods; most of these are static class methods that return a pointer to a newly created <span class="nctnt ncbi-class">CObjectIStream</span>. Typically, these methods are used with an <span class="nctnt ncbi-class">auto_ptr</span>, as in:</p><pre><span class="nctnt-pre ncbi-code">auto_ptr&lt;CObjectIStream&gt; xml_in(CObjectIStream::Open(filename, eSerial_Xml));</span></pre><p>Here, an XML format is specified by the enumerated value <span class="nctnt ncbi-var">eSerial_Xml</span>, defined in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ESerialDataFormat">ESerialDataFormat</a>. Because these methods are static, they can be used to create a new instance of a <span class="nctnt ncbi-class">CObjectIStream</span> subclass, and open it with one statement. In this example, a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStreamXml.html">CObjectIStreamXml</a> is created and opened on the file <span class="nctnt ncbi-var">filename</span>.</p><p>An additional non-static <span class="nctnt ncbi-func">Open()</span> method is provided, which can only be invoked as a member function of a previously instantiated object stream (whose format type is of course, implicit to its class). This method takes a <span class="nctnt ncbi-class">CNcbiIstream</span> and a flag indicating whether or not ownership of the <span class="nctnt ncbi-class">CNcbiIstream</span> should be transferred (so that it can be deleted automatically when the object stream is closed):</p><pre><span class="nctnt-pre ncbi-code">void Open(CNcbiIstream&amp; inStream, EOwnership deleteInStream = eNoOwnership);</span></pre><p>The next three methods have the following definitions. <span class="nctnt ncbi-func">Close()</span> closes the stream. <span class="nctnt ncbi-func">GetDataFormat()</span> returns the enumerated <span class="nctnt ncbi-type">ESerialDataFormat</span> for the stream. <span class="nctnt ncbi-func">ReadFileHeader()</span> reads the first line from the file, and returns it in a string. This might be used for example, in the following context:</p><pre><span class="nctnt-pre ncbi-code">auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(fname, eSerial_AsnText));<br />string type = in.ReadFileHeader();<br />if (type.compare("Seq-entry") == 0) {<br />    CSeq_entry seqent;<br />    in-&gt;Read(ObjectInfo(seqent), eNoFileHeader);<br />    // ...<br />}<br />else if (type.compare("Bioseq-set") == 0) {<br />    CBioseq_set seqset;<br />    in-&gt;Read(ObjectInfo(seqset), eNoFileHeader);<br />    // ...<br />}</span></pre><blockquote id="idp34828128"><p>The <span class="nctnt ncbi-func">ReadFileHeader()</span> method for the base <span class="nctnt ncbi-class">CObjectIStream</span> class returns an empty string. Only those stream classes which specialize in ASN.1 text or XML formats have actual implementations for this method.</p></blockquote><p>Several <span class="nctnt ncbi-func">Read*()</span> methods are provided for usage in different contexts. <span class="nctnt ncbi-func">CObjectIStream::Read()</span> should be used for reading a top-level "root" object from a data file. For convenience, the input operator <span class="nctnt ncbi-code">&gt;&gt;</span>, as described above, indirectly invokes this method on the input stream, using a <a href="ch_ser.html#ch_ser.typeinfo.html_cobjinfo">CObjectTypeInfo</a> object derived from <span class="nctnt ncbi-var">myObject</span>. By default, the <span class="nctnt ncbi-func">Read()</span> method first calls <span class="nctnt ncbi-func">ReadFileHeader()</span>, and then calls <span class="nctnt ncbi-func">ReadObject()</span>. Accordingly, calls to <span class="nctnt ncbi-func">Read()</span> which follow the usage of <span class="nctnt ncbi-func">ReadFileHeader()</span><b>must</b> include the optional <span class="nctnt ncbi-var">eNoFileHeader</span> argument.</p><p>Most data objects also contain embedded objects, and the default behavior of <span class="nctnt ncbi-func">Read()</span> is to load the top-level object, along with all of its contained subobjects into memory. In some cases this may require significant memory allocation, and it may be only the top-level object which is needed by the application. The next two methods, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ReadObject">ReadObject()</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ReadSeparateObject">ReadSeparateObject()</a>, can be used to load subobjects as either persistent data members of the root object or as temporary local objects. In contrast to <span class="nctnt ncbi-func">Read()</span>, these methods assume that there is no file header on the stream.</p><p>As a result of executing <span class="nctnt ncbi-code">ReadObject(member)</span>, the newly created subobject will be instantiated as a member of its parent object. In contrast, <span class="nctnt ncbi-code">ReadSeparateObject(local)</span>, instantiates the subobject in the local temporary variable only, and the corresponding data member in the parent object is set to an appropriate <span class="nctnt ncbi-monospace">null</span> representation for that data type. In this case, an attempt to reference that subobject after exiting the scope where it was created generates an error.</p><p>The <span class="nctnt ncbi-func">Skip()</span> and <span class="nctnt ncbi-func">SkipObject()</span> methods allow entire top-level objects and subobjects to be "skipped". In this case the input is still read from the stream and validated, but no object representation for that data is generated. Instead, the data is stored in a delay buffer associated with the object input stream, where it can be accessed as needed. <span class="nctnt ncbi-func">Skip()</span> should only be applied to top-level objects. As with the <span class="nctnt ncbi-func">Read()</span> method, the optional <span class="nctnt ncbi-type">ENoFileHeader</span> argument can be included if the file header has already been extracted from the data stream. <span class="nctnt ncbi-code">SkipObject(member)</span> may be applied to subobjects of the root object.</p><p>All of the <span class="nctnt ncbi-func">Read</span> and <span class="nctnt ncbi-func">Skip</span> methods are like wrapper functions, which define what activities take place immediately before and after the data is actually read. How and when the data is then loaded into memory is determined by the object itself. Each of the above methods ultimately calls <span class="nctnt ncbi-code">objTypeInfo-&gt;ReadData()</span> or <span class="nctnt ncbi-code">objTypeInfo-&gt;SkipData()</span>, where <span class="nctnt ncbi-var">objTypeInfo</span> is the static type information object associated with the data object. This scheme allows the user to install type-specific read, write, and copy hooks, which are described below. For example, the default behavior of loading all subobjects of the top-level object can be modified by installing appropriate read hooks which use the <span class="nctnt ncbi-func">ReadSeparateObject()</span> and <span class="nctnt ncbi-func">SkipObject()</span> methods where needed.</p></div><div class="sec" id="ch_ser.objstream.html_objostr"><h3><span class="title">The <span class="nctnt ncbi-class">CObjectOStream</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStream.html">*</a>) classes</span></h3><p>The output object stream classes mirror the <span class="nctnt ncbi-class">CObjectIStream</span> classes. The <span class="nctnt ncbi-class">CObjectOStream</span> base class is used to derive the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStreamXml.html">CObjectOStreamXml</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStreamAsn.html">CObjectOStreamAsn</a>, and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStreamAsnBinary.html">CObjectOStreamAsnBinary</a> classes. There are no public constructors, and the user interface includes the following methods:</p><ul><li><p><span class="nctnt ncbi-func">Open()</span></p></li><li><p><span class="nctnt ncbi-func">Close()</span></p></li><li><p><span class="nctnt ncbi-func">GetDataFormat()</span></p></li><li><p><span class="nctnt ncbi-func">WriteFileHeader()</span></p></li><li><p><span class="nctnt ncbi-func">Write()</span></p></li><li><p><span class="nctnt ncbi-func">WriteObject()</span></p></li><li><p><span class="nctnt ncbi-func">WriteSeparateObject()</span></p></li><li><p><span class="nctnt ncbi-func">Flush()</span></p></li><li><p><span class="nctnt ncbi-func">FlushBuffer()</span></p></li></ul><p>Again, there are several <span class="nctnt ncbi-func">Open()</span> methods, which are static class methods that return a pointer to a newly created <span class="nctnt ncbi-class">CObjectOstream</span>:</p><pre><span class="nctnt-pre ncbi-code">static CObjectOStream* Open(ESerialDataFormat format,<br />                            CNcbiOstream &amp;outStream,<br />                            EOwnership deleteOutStream=eNoOwnership,<br />                            TSerial_Format_Flags formatFlags=0)<br /><br />static CObjectOStream* Open(ESerialDataFormat format,<br />                            const string &amp;fileName,<br />                            TSerialOpenFlags openFlags=0,<br />                            TSerial_Format_Flags formatFlags=0)<br /><br />static CObjectOStream* Open(const string &amp;fileName,<br />                            ESerialDataFormat format,<br />                            TSerial_Format_Flags formatFlags=0)</span></pre><p>The <span class="nctnt ncbi-func">Write*()</span> methods correspond to the <span class="nctnt ncbi-func">Read*()</span> methods defined for the input streams. <span class="nctnt ncbi-func">Write()</span> first calls <span class="nctnt ncbi-func">WriteFileHeader()</span>, and then calls <span class="nctnt ncbi-func">WriteObject()</span>. <span class="nctnt ncbi-func">WriteSeparateObject()</span> can be used to write a temporary object (and all of its children) to the output stream. It is also possible to install type-specific <span class="nctnt ncbi-monospace">write</span> hooks. Like the <span class="nctnt ncbi-func">Read()</span> methods, these <span class="nctnt ncbi-func">Write()</span> methods serve as wrapper functions that define what occurs immediately before and after the data is actually written.</p></div><div class="sec" id="ch_ser.objstream.html_objcopy"><h3><span class="title">The <span class="nctnt ncbi-class">CObjectStreamCopier</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectStreamCopier.html">*</a>) classes</span></h3><p>The <span class="nctnt ncbi-class">CObjectStreamCopier</span> class is neither an input nor an output stream class, but a helper class, which allows one to "pass data through" without storing the intermediate objects in memory. Its sole constructor is:</p><pre><span class="nctnt-pre ncbi-code">CObjectStreamCopier(CObjectIStream&amp; in, CObjectOStream&amp; out);</span></pre><p>and its most important method is the <span class="nctnt ncbi-func">Copy(CObjectTypeInfo&amp;)</span> method, which, given an object's description, reads that object from the input stream and writes it to the output stream. The serial formats of both the input and output object streams are implicit, and thus the translation between two different formats is performed automatically.</p><p>In keeping with the <span class="nctnt ncbi-func">Read</span> and <span class="nctnt ncbi-func">Write</span> methods of the <span class="nctnt ncbi-class">CObjectIStream</span> and <span class="nctnt ncbi-class">CObjectOStream</span> classes, the <span class="nctnt ncbi-func">Copy</span> method takes an optional <span class="nctnt ncbi-type">ENoFileHeader</span> argument, to indicate that the file header is not present in the input and should not be generated on the output. The <span class="nctnt ncbi-func">CopyObject()</span> method corresponds to the <span class="nctnt ncbi-func">ReadObject()</span> and <span class="nctnt ncbi-func">WriteObject()</span> methods.</p><p>As an example, consider how the <span class="nctnt ncbi-func">Run()</span> method in <a href="ch_ser.html#ch_ser.xml2asn_cpp.html">xml2asn.cpp</a> might be implemented differently using the <span class="nctnt ncbi-class">CObjectStreamCopier </span>class:</p><pre><span class="nctnt-pre ncbi-code">int CTestAsn::Run() {<br />auto_ptr&lt;CObjectIStream&gt;<br />xml_in(CObjectIStream::Open("1001.xml", eSerial_Xml));<br />auto_ptr&lt;CObjectOStream&gt;<br />txt_out(CObjectOStream::Open("1001.asntxt", eSerial_AsnText));<br />CObjectStreamCopier txt_copier(*xml_in, *txt_out);<br />txt_copier.Copy(CBiostruc::GetTypeInfo());<br />auto_ptr&lt;CObjectOStream&gt;<br />    bin_out(CObjectOStream::Open("1001.asnbin", eSerial_AsnBinary));<br />CObjectStreamCopier bin_copier(*xml_in, *bin_out);<br />bin_copier.Copy(CBiostruc::GetTypeInfo());<br />return 0;<br />}</span></pre><p>It is also possible to install type-specific <span class="nctnt ncbi-func">Copy</span> hooks. Like the <span class="nctnt ncbi-func">Read</span> and <span class="nctnt ncbi-func">Write</span> methods, the <span class="nctnt ncbi-func">Copy</span> methods serve as wrapper functions that define what occurs immediately before and after the data is actually copied.</p></div><div class="sec" id="ch_ser.objstream.html_cback"><h3><span class="title">Type-specific I/O routines – the hook classes</span></h3><p>Much of the functionality needed to read and write serializable objects may be type-specific yet application-driven. Because the specializations may vary with the application, it does not make sense to implement fixed methods, yet we would like to achieve a similar kind of object-specific behavior.</p><p>To address these needs, the C++ Toolkit provides hook mechanisms, whereby the needed functionality can be installed with the object's static class <a href="ch_ser.html#ch_ser.typeinfo.html_ctypeinfo_ref">type information</a> object. Local hooks apply to a selected stream whereas global hooks apply to all streams. <span class="nctnt highlight">Note:</span> global skip hooks are not supported.</p><p>For any given object type, stream, and processing mode (e.g. reading), at most one hook is "active". The active hook for the current processing mode will be called when objects of the given type are encountered in the stream. For example, suppose that local and global hooks have been set for a given object type. Then if a read occurs on the stream for which the local hook was set, the local hook will be called, otherwise the global hook will be called. Designating multiple read/write hooks (both local and global) for a selected object does not generate an error. Older or less specific hooks are simply overridden by the more specific or most recently installed hook.</p><p>Understanding and creating hooks properly relies on three distinct concepts:</p><ul><li><p><b>Structural Context</b> – the criteria for deciding which objects in the stream will be hooked.</p></li><li><p><b>Processing Mode</b> – what is being done when the hook should be called. Hooks will only be called in the corresponding processing mode. For example, if content is being skipped, only skip hooks will be called. If the mode changes to reading, then only read hooks will be called.</p></li><li><p><b>Operation</b> – easily confused with processing mode, the operation is what is done inside the hook, not what is being done when the hook is called.</p></li></ul><p><span class="nctnt highlight">Note:</span> The difference between processing mode and operation can be very confusing. It is natural to think, for example, "I want to read Bioseq id's" without considering how the stream is being processed. The next natural step is to conclude "I want a read hook" - but that could be incorrect. Instead, one should think "I want to <i>read</i> a Bioseq id <i>inside</i> a hook". Only then should the processing mode be chosen, and it may not match the operation performed inside the hook. The processing mode should be chosen based on what should be done with the <i>rest</i> of the stream and whether or not it's necessary to retain the data <i>outside</i> the hook. For example, if you want to read Bioseq id's and don't care about anything else, then you should probably choose the 'skip' processing mode (meaning you would use a skip hook), and <i>within</i> the skip hook you would <i>read</i> the Bioseq id. Or, if you wanted to read entire Bioseq's for later analysis while automatically building a list of Bioseq id's, you would have to use the 'read' processing mode (and therefore a read hook) to save the data for later analysis. Inside the read hook you would use a read operation (to save the data) and at the same time you would have access to the id for building the list of id's.</p><p>There are three main <b>structural contexts</b> in which an object might be encountered in a stream:</p><div class="table" id="ch_ser.T.nc_ContextDescriptionObjectWhen"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Context</th><th align="left" valign="top" rowspan="1" colspan="1">Description</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Object</td><td align="left" valign="top" rowspan="1" colspan="1">When the stream object matches a specified type – for example, the <span class="nctnt ncbi-type">Bioseq</span> type.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Class Member</td><td align="left" valign="top" rowspan="1" colspan="1">When the stream object matches a specified member of a specified <span class="nctnt ncbi-monospace">SEQUENCE</span> type – for example, the <span class="nctnt ncbi-var">id</span> member of the <span class="nctnt ncbi-type">Bioseq</span> type.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Choice Variant</td><td align="left" valign="top" rowspan="1" colspan="1">When the stream object matches a specified variant of a specified <span class="nctnt ncbi-monospace">CHOICE</span> type – for example, the <span class="nctnt ncbi-var">std</span> variant of the <span class="nctnt ncbi-type">Date</span> type.</td></tr></tbody></table></div><p>Complex structural contexts can be created by nesting the main structural contexts. For example, a <a href="ch_ser.html#ch_ser.stack_path_hooks">stack path hook</a> can apply to a specific class member, but only when it is nested inside another specified class member.</p><p>There are four <b>processing modes</b> that can be applied to input/output streams:</p><div class="table" id="ch_ser.T.nc_ModeDescriptionReadWhen_obje"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Mode</th><th align="left" valign="top" rowspan="1" colspan="1">Description</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Read</td><td align="left" valign="top" rowspan="1" colspan="1">When objects are parsed from an input stream and a deserialized instance is retained.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Skip</td><td align="left" valign="top" rowspan="1" colspan="1">When objects are parsed from an input stream but a deserialized instance is not retained</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Copy</td><td align="left" valign="top" rowspan="1" colspan="1">When objects are parsed from an input stream and written directly to an output stream.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Write</td><td align="left" valign="top" rowspan="1" colspan="1">When objects are written to an output stream.</td></tr></tbody></table></div><p>The <b>operation</b> is not restricted to a limited set of choices. It can be any application-specific task, as long as that task is compatible with the processing mode. For example, a skip operation can be performed inside a read hook, provided that the skipped content is optional for the object being read. Similarly, a read operation can be performed inside a skip hook. The operation performed inside a hook must preserve the integrity of the hooked object, and must advance the stream all the way through the hooked object and no farther.</p><p>Hooks can be installed for all combinations of structural context and processing mode. Each combination has a base class that defines a pure virtual method that must be defined in a derived class to implement the hook – e.g. the <span class="nctnt ncbi-class">CReadObjectHook</span> class defines a pure virtual <span class="nctnt ncbi-func">ReadObject()</span> method. The definition of the overriding method in the derived class is often referred to as "the hook".</p><div class="table" id="ch_ser.T.nc_ObjectClass_MemberChoice_Var"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1"></th><th align="left" valign="top" rowspan="1" colspan="1">Object</th><th align="left" valign="top" rowspan="1" colspan="1">Class Member</th><th align="left" valign="top" rowspan="1" colspan="1">Choice Variant</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.objstream.html_readhooks">Read</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Read_Object_Hook_Sample">CReadObjectHook</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Read_Class_Member_Hook_Sample">CReadClassMemberHook</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Read_Choice_Variant_Hook_Sample">CReadChoiceVariantHook</a></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.objstream.html_writehooks">Write</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Write_Object_Hook_Sample">CWriteObjectHook</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Write_Class_Member_Hook_Sample">CWriteClassMemberHook</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Write_Choice_Variant_Hook_Sample">CWriteChoiceVariantHook</a></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.objstream.html_copyhooks">Copy</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Copy_Object_Hook_Sample">CCopyObjectHook</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Copy_Class_Member_Hook_Sample">CCopyClassMemberHook</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Copy_Choice_Variant_Hook_Sample">CCopyChoiceVariantHook</a></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Skip_mode_hooks">Skip</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Skip_Object_Hook_Sample">CSkipObjectHook</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Skip_Class_Member_Hook_Sample">CSkipClassMemberHook</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.Skip_Choice_Variant_Hook_Sample">CSkipChoiceVariantHook</a></td></tr></tbody></table></div><p>In addition, there is a <a href="ch_ser.html#ch_ser.objstream.html_hookguard">hook guard</a> class, which simplifies creating any of the above hooks. There are also <a href="ch_ser.html#ch_ser.stack_path_hooks">stack path hook</a> methods corresponding to each structural context / processing mode combination above, making it easy to create hooks for virtually any conceivable situation.</p><div class="sec" id="ch_ser.Hook_Sample"><h4><span class="title">Hook Sample</span></h4><p>Here is a complete program that illustrates how to create a read hook for class members (other sample programs are available at <a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c%2B%2B/src/sample/app/serial/">http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c%2B%2B/src/sample/app/serial/</a>):</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/general/Date_std.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />// This class implements a read hook for class members.<br />//<br />// A read hook is created by passing a new instance of this class to a<br />// "set hook" method.  Hooks may be created as global or local.  Global hooks<br />// apply to all streams, whereas local hooks are associated with a specific<br />// stream.  Thus, the "set hook" methods for creating class member read hooks<br />// are:<br />//     SetGlobalReadHook()<br />//     SetLocalReadHook()<br />//<br />// This class must override the virtual method ReadClassMember().  See the<br />// comment for the ReadClassMember() method below for more details.<br />//<br />// In principle, multiple instances of this hook class could be used to provide<br />// the same hook processing for more than one entity.  However, it is probably<br />// best to create a separate class for each "thing" you want to hook and<br />// process.<br />//<br />// You should adopt a meaningful naming convention for your hook classes.<br />// In this example, the convention is C&lt;mode&gt;&lt;context&gt;Hook_&lt;object&gt;__&lt;member&gt;<br />// where:   &lt;mode&gt;=(Read|Write|Copy|Skip)<br />//          &lt;context&gt;=(Obj|CM|CV)  --  object, class member, or choice variant<br />// and hyphens in ASN.1 object types are replaced with underscores.<br />//<br />// Note:  Since this is a read hook, ReadClassMember() will only be called when<br />// reading from the stream.  If the stream is being skipped, ReadClassMember()<br />// will not be called.  If you want to use a hook to read a specific type of<br />// class member while skipping everything else, use a skip hook and call<br />// DefaultRead() from within the SkipClassMember() method.<br />//<br />// Note: This example is a read hook, which means that the input stream is<br />// being read when the hook is called.  Hooks for other processing modes<br />// (Write, Skip, and Copy) are similarly created by inheriting from the<br />// respecitive base classes.  It is also a ClassMember hook.  Hooks for<br />// other structural contexts (Object and ChoiceVariant) a similarly derived<br />// from the appropriate base.<br />class CDemoHook : public CReadClassMemberHook<br />{<br />public:<br />    // Implement the hook method.<br />    //<br />    // Once the read hook has been set, ReadClassMember() will be called<br />    // whenever the specified class member is encountered while<br />    // reading a hooked input stream.  Without the hook, the encountered<br />    // class member would have been automatically read.  With the hook, it is<br />    // now the responsibility of the ReadClassMember() method to remove the<br />    // class member from the input stream and process it as desired.  It can<br />    // either read it or skip it to remove it from the stream.  This is<br />    // easily done by calling DefaultRead() or DefaultSkip() from within<br />    // ReadClassMember().  Subsequent processing is up to the application.<br />    virtual void ReadClassMember(CObjectIStream&amp; in,<br />                                 const CObjectInfoMI&amp; passed_info)<br />    {<br />        // Perform any pre-read processing here.<br />        //NcbiCout &lt;&lt; "In ReadClassMember() hook, before reading." &lt;&lt; NcbiEndl;<br /><br />        // You must call DefaultRead() (or perform an equivalent operation)<br />        // if you want the object to be read into memory.  You could also<br />        // call DefaultSkip() if you wanted to skip the hooked object while<br />        // reading everything else.<br />        DefaultRead(in, passed_info);<br /><br />        // Perform any post-read processing here.  Once the object has been<br />        // read, its data can be used for processing. For example, here we dump<br />        // the read object into the standard output.<br />        NcbiCout &lt;&lt; MSerial_AsnText &lt;&lt; passed_info.GetClassObject();<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    // Create some ASN.1 data that can be parsed by this code sample.<br />    char asn[] = "Date-std ::= { year 1998 }";<br /><br />    // Setup an input stream, based on the sample ASN.1.<br />    CNcbiIstrstream iss(asn);<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, iss));<br /><br />    ////////////////////////////////////////////////////<br />    // Create a hook for the 'year' class member of Date-std objects.<br />    // The year class member was aribtrarily chosen to illustrate the<br />    // use of hooks - many other entities would work equally well.<br /><br />    // Get data structures that model the type information for Date-std<br />    // objects and their 'year' class members.<br />    // The type information will be used to recognize and forward 'year'<br />    // class members of Date-std objects found in the stream to the hook.<br />    CObjectTypeInfo typeInfo = CType&lt;CDate_std&gt;();<br />    CObjectTypeInfoMI memberInfo = typeInfo.FindMember("year");<br /><br />    // Set a local hook for Date-std 'year' class members.  This involves<br />    // creating an instance of the hook class and passing that hook to the<br />    // "set hook" method, which registers the hook to be called when a hooked<br />    // type is encountered in the stream.<br />    memberInfo.SetLocalReadHook(*in, new CDemoHook);<br /><br /><br />    // The above three statements could be shortened to:<br />    //CObjectTypeInfo(CType&lt;CDate_std&gt;()).FindMember("year")<br />    //                                   .SetLocalReadHook(*in, new CDemoHook);<br /><br /><br />    // Read from the input stream, storing data in the object.  At this point,<br />    // the hook is in place so simply reading from the input stream will<br />    // cause the hook to be triggered whenever the 'year' class member is<br />    // encountered.<br />    CDate_std my_date;<br />    *in &gt;&gt; my_date;<br /><br />    return 0;<br />}</span></pre></div><div class="sec" id="ch_ser.objstream.html_readhooks"><h4><span class="title">Read mode hooks</span></h4><p>All of the different structural contexts in which an object might be encountered on an input stream can be reduced to three cases:</p><ul><li><p>as a stand-alone object</p></li><li><p>as a data member of a containing object</p></li><li><p>as a variant of a <span class="nctnt ncbi-monospace">choice</span> object</p></li></ul><p>Hooks can be installed for each of the above contexts, depending on the desired level of specificity. Corresponding to these contexts, three abstract base classes provide the foundations for deriving new <span class="nctnt ncbi-monospace">Read</span> hooks:</p><ul><li><p><span class="nctnt ncbi-class">CReadObjectHook</span></p></li><li><p><span class="nctnt ncbi-class">CReadClassMemberHook</span></p></li><li><p><span class="nctnt ncbi-class">CReadChoiceVariantHook</span></p></li></ul><p>Each of these base hook classes exists only to define a pure virtual <span class="nctnt ncbi-func">Read</span> method, which can then be implemented (in a derived subclass) to install the desired type of read hook. If the goal is to apply the new <span class="nctnt ncbi-func">Read</span> method in all contexts, then the new hook should be derived from the <span class="nctnt ncbi-class">CReadObjectHook</span> class, and registered with the object's static type information object. For example, to install a new <span class="nctnt ncbi-class">CReadObjectHook</span> for a <span class="nctnt ncbi-class">CBioseq</span>, one might use:</p><pre><span class="nctnt-pre ncbi-code">CObjectTypeInfo(CBioseq::GetTypeInfo()).<br />    SetLocalReadHook(*in, myReadBioseqHook);</span></pre><p>Another way of installing hooks of any type (read/write/copy, object/member/variant) is provided by <span class="nctnt ncbi-class">CObjectHookGuard</span> class described below.</p><p>Alternatively, if the desired behavior is to trigger the specialized <span class="nctnt ncbi-func">Read</span> method only when the object occurs as a data member of a particular containing class, then the new hook should be derived from the <span class="nctnt ncbi-class">CReadClassMemberHook</span>, and registered with that member's type information object:</p><pre><span class="nctnt-pre ncbi-code">CObjectTypeInfo(CBioseq::GetTypeInfo()).<br />    FindMember("Seq-inst").SetLocalReadHook(*in, myHook);</span></pre><p>Similarly, one can install a read hook that will only be triggered when the object occurs as a choice variant:</p><pre><span class="nctnt-pre ncbi-code">CObjectTypeInfo(CSeq_entry::GetTypeInfo()).<br />    FindVariant("Bioseq").SetLocalReadHook(*in, myReadBioseqHook);</span></pre><p>The new hook classes for these examples should be derived from <span class="nctnt ncbi-class">CReadObjectHook</span>, <span class="nctnt ncbi-class">CReadClassMemberHook</span>, and <span class="nctnt ncbi-class">CReadChoiceVariantHook</span>, respectively. In the first case, all occurrences of <span class="nctnt ncbi-class">CBioseq</span> on any input stream will trigger the new <span class="nctnt ncbi-func">Read</span> method. In contrast, the third case installs this new <span class="nctnt ncbi-func">Read</span> method to be triggered only when the <span class="nctnt ncbi-class">CBioseq</span> occurs as a choice variant in a <span class="nctnt ncbi-class">CSeq_entry</span> object.</p><p>All of the virtual <span class="nctnt ncbi-func">Read</span> methods take two arguments: a <span class="nctnt ncbi-class">CObjectIStream</span> and a reference to a <a href="ch_ser.html#ch_ser.typeinfo.html_objinfo">CObjectInfo</a>. For example, the <span class="nctnt ncbi-class">CReadObjectHook</span> class declares the <span class="nctnt ncbi-func">ReadObject()</span> method as:</p><pre><span class="nctnt-pre ncbi-code">virtual void ReadObject(CObjectIStream&amp; in,<br />                        const CObjectInfo&amp; object) = 0;</span></pre><p>The <span class="nctnt ncbi-func">ReadClassMember</span> and <span class="nctnt ncbi-func">ReadChoiceVariant</span> hooks differ from the <span class="nctnt ncbi-func">ReadObject</span> hook class, in that the second argument to the virtual <span class="nctnt ncbi-func">Read</span> method is an iterator, pointing to the object type information for a sequence member or choice variant respectively.</p><p>In summary, to install a read hook for an object type:</p><p>derive a new class from the appropriate hook class:</p><ul><li><p>if the hook should be called regardless of the structural context in which the target object occurs, use the <span class="nctnt ncbi-class">CReadObjectHook</span> class.</p></li><li><p>if the target object occurs as a sequence member, use the <span class="nctnt ncbi-class">CReadClassMemberHook</span> class.</p></li><li><p>if the target object occurs as a choice variant, use the <span class="nctnt ncbi-class">CReadChoiceVariant Hook</span> class.</p></li></ul><p>implement the virtual <span class="nctnt ncbi-func">Read</span> method for the new class.</p><p>install the hook, using the <span class="nctnt ncbi-func">SetLocalReadHook()</span> method defined in</p><ul><li><p><span class="nctnt ncbi-class">CObjectTypeInfo</span> for a <span class="nctnt ncbi-class">CReadObjectHook</span></p></li><li><p><span class="nctnt ncbi-class">CMemberInfo</span> for a <span class="nctnt ncbi-class">CReadClassMemberHook</span></p></li><li><p><span class="nctnt ncbi-class">CVariantInfo</span> for a <span class="nctnt ncbi-class">CReadChoiceVariantHook</span></p></li></ul><p>or use <span class="nctnt ncbi-class">CObjectHookGuard</span> class to install any of these hooks.</p><p>In many cases you will need to read the hooked object and do some special processing, or to skip the entire object. To simplify object reading or skipping all base hook classes have <span class="nctnt ncbi-func">DefaultRead()</span> and <span class="nctnt ncbi-func">DefaultSkip()</span> methods taking the same arguments as the user provided ReadXXXX() methods. Thus, to read a bioseq object from a hook:</p><pre><span class="nctnt-pre ncbi-code">void CMyReadObjectHook::ReadObject(CObjectIStream&amp; in,<br />                                   const CObjectInfo&amp; object)<br />{<br />    DefaultRead(in, object);<br />    // Do some user-defined processing of the bioseq<br />}</span></pre><p>Note that from a choice variant hook you can not skip stream data -- this could leave the choice object in an uninitialized state. For this reason the CReadChoiceVariantHook class has no DefaultSkip() method.</p><div class="sec" id="ch_ser.Read_Object_Hook_Sample"><h5><span class="title">Read Object Hook Sample</span></h5><p>A read object hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/general/Date_std.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook : public CReadObjectHook<br />{<br />public:<br />    virtual void ReadObject(CObjectIStream&amp; strm,<br />                            const CObjectInfo&amp; passed_info)<br />    {<br />        DefaultRead(strm, passed_info);<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    char asn[] = "Date-std ::= { year 1998 }";<br />    CNcbiIstrstream iss(asn);<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, iss));<br /><br />    CObjectTypeInfo(CType&lt;CDate_std&gt;()).SetLocalReadHook(*in, new CDemoHook());<br /><br />    CDate_std my_date;<br />    *in &gt;&gt; my_date;<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCReadObjectHook.html">class documentation</a> for more information.</p></div><div class="sec" id="ch_ser.Read_Class_Member_Hook_Sample"><h5><span class="title">Read Class Member Hook Sample</span></h5><p>A read class member hook can be created very much like other hooks. For an example, see the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>.</p><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCReadClassMemberHook.html">class documentation</a> for more information.</p></div><div class="sec" id="ch_ser.Read_Choice_Variant_Hook_Sample"><h5><span class="title">Read Choice Variant Hook Sample</span></h5><p>A read choice variant hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/general/Date.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook : public CReadChoiceVariantHook<br />{<br />public:<br />    virtual void ReadChoiceVariant(CObjectIStream&amp; strm,<br />                                   const CObjectInfoCV&amp; passed_info)<br />    {<br />        DefaultRead(strm, passed_info);<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    char asn[] = "Date ::= str \"late-spring\"";<br />    CNcbiIstrstream iss(asn);<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, iss));<br /><br />    CObjectTypeInfo(CType&lt;CDate&gt;()).FindVariant("str")<br />                                   .SetLocalReadHook(*in, new CDemoHook);<br /><br />    CDate my_date;<br />    *in &gt;&gt; my_date;<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCReadChoiceVariantHook.html">class documentation</a> for more information.</p></div></div><div class="sec" id="ch_ser.objstream.html_writehooks"><h4><span class="title">Write mode hooks</span></h4><p>The <span class="nctnt ncbi-monospace">Write</span> hook classes parallel the <span class="nctnt ncbi-monospace">Read</span> hook classes, and again, we have three base classes:</p><ul><li><p><span class="nctnt ncbi-class">CWriteObjectHook</span></p></li><li><p><span class="nctnt ncbi-class">CWriteClassMemberHook</span></p></li><li><p><span class="nctnt ncbi-class">CWriteChoiceVariantHook</span></p></li></ul><p>These classes define the pure virtual methods:</p><pre><span class="nctnt-pre ncbi-code">CWriteObjectHook::WriteObject(CObjectOStream&amp;,<br />    const CConstObjectInfo&amp; object) = 0;<br /><br />CWriteClassMemberHook::WriteClassMember(CObjectOStream&amp;,<br />    const CConstObjectInfoMI&amp; member) = 0;<br /><br />CWriteChoiceVariantHook::WriteChoiceVariant(CObjectOStream&amp;,<br />    const CConstObjectInfoCV&amp; variant) = 0;</span></pre><p>Like the read hooks, your derived write hooks can be installed by invoking the <span class="nctnt ncbi-func">SetLocalWriteObjectHook()</span> methods for the appropriate type information objects. Corresponding to the examples for read hooks then, we would have:</p><pre><span class="nctnt-pre ncbi-code">CObjectTypeInfo(CBioseq::GetTypeInfo()).<br />    SetLocalWriteHook(*in, myWriteBioseqHook);<br /><br />CObjectTypeInfo(CBioseq::GetTypeInfo()).<br />    FindMember("Seq-inst").SetLocalWriteHook(*in, myWriteSeqinstHook);<br /><br />CObjectTypeInfo(CSeq_entry::GetTypeInfo()).<br />    FindVariant("Bioseq").SetLocalWriteHook(*in, myWriteBioseqHook);</span></pre><p><span class="nctnt ncbi-class">CObjectHookGuard</span> class provides is a simple way to install write hooks.</p><div class="sec" id="ch_ser.Write_Object_Hook_Sample"><h5><span class="title">Write Object Hook Sample</span></h5><p>A write object hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/biblio/Cit_art.hpp&gt;<br />#include &lt;serial/objectio.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/objostr.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook : public CWriteObjectHook<br />{<br />public:<br />    virtual void WriteObject(CObjectOStream&amp; out,<br />                             const CConstObjectInfo&amp; passed_info)<br />    {<br />        DefaultWrite(out, passed_info);<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, "if"));<br />    auto_ptr&lt;CObjectOStream&gt; out(CObjectOStream::Open(eSerial_AsnText, "of"));<br /><br />    CObjectTypeInfo(CType&lt;CCit_art&gt;()).SetLocalWriteHook(*out, new CDemoHook);<br /><br />    CCit_art article;<br />    *in &gt;&gt; article;<br />    *out &lt;&lt; article;<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCWriteObjectHook.html">class documentation</a> for more information.</p></div><div class="sec" id="ch_ser.Write_Class_Member_Hook_Sample"><h5><span class="title">Write Class Member Hook Sample</span></h5><p>A write class member hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/biblio/Auth_list.hpp&gt;<br />#include &lt;objects/biblio/Cit_art.hpp&gt;<br />#include &lt;serial/objectio.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/objostr.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook: public CWriteClassMemberHook<br />{<br />public:<br />    virtual void WriteClassMember(CObjectOStream&amp; out,<br />                                  const CConstObjectInfoMI&amp; passed_info)<br />    {<br />        DefaultWrite(out, passed_info);<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, "if"));<br />    auto_ptr&lt;CObjectOStream&gt; out(CObjectOStream::Open(eSerial_AsnText, "of"));<br /><br />    CObjectTypeInfo(CType&lt;CAuth_list&gt;())<br />        .FindMember("names")<br />        .SetLocalWriteHook(*out, new CDemoHook);<br /><br />    CCit_art article;<br />    *in &gt;&gt; article;<br />    *out &lt;&lt; article;<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCWriteClassMemberHook.html">class documentation</a> for more information.</p></div><div class="sec" id="ch_ser.Write_Choice_Variant_Hook_Sample"><h5><span class="title">Write Choice Variant Hook Sample</span></h5><p>A write choice variant hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/biblio/Auth_list.hpp&gt;<br />#include &lt;objects/biblio/Cit_art.hpp&gt;<br />#include &lt;serial/objectio.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/objostr.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook : public CWriteChoiceVariantHook<br />{<br />public:<br />    virtual void WriteChoiceVariant(CObjectOStream&amp; out,<br />                                    const CConstObjectInfoCV&amp; passed_info)<br />    {<br />        DefaultWrite(out, passed_info);<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, "if"));<br />    auto_ptr&lt;CObjectOStream&gt; out(CObjectOStream::Open(eSerial_AsnText, "of"));<br /><br />    (*CObjectTypeInfo(CType&lt;CAuth_list&gt;()).FindMember("names"))<br />        .GetPointedType()<br />        .FindVariant("std")<br />        .SetLocalWriteHook(*out, new CDemoHook);<br /><br />    CCit_art article;<br />    *in &gt;&gt; article;<br />    *out &lt;&lt; article;<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCWriteChoiceVariantHook.html">class documentation</a> for more information.</p></div></div><div class="sec" id="ch_ser.objstream.html_copyhooks"><h4><span class="title">Copy mode hooks</span></h4><p>As with the <span class="nctnt ncbi-monospace">Read</span> and <span class="nctnt ncbi-monospace">Write</span> hook classes, there are three base classes which define the following <span class="nctnt ncbi-monospace">Copy</span> methods:</p><pre><span class="nctnt-pre ncbi-code">CCopyObjectHook::CopyObject(CObjectStreamCopier&amp; copier,<br />    const CObjectTypeInfo&amp; object) = 0;<br /><br />CCopyClassMemberHook::CopyClassMember(CObjectStreamCopier&amp; copier,<br />    const CObjectTypeInfoMI&amp; member) = 0;<br /><br />CCopyChoiceVariantHook::CopyChoiceVariant(CObjectStreamCopier&amp; copier,<br />    const CObjectTypeInfoCV&amp; variant) = 0;</span></pre><p>Newly derived copy hooks can be installed by invoking the <span class="nctnt ncbi-func">SetLocalCopyObjectHook()</span> method for the appropriate type information object. The other way of installing hooks is described below in the <span class="nctnt ncbi-class">CObjectHookGuard</span> section.</p><p>To do default copying of an object in the overloaded hook method each of the base copy hook classes has a <span class="nctnt ncbi-func">DefaultCopy()</span> method.</p><div class="sec" id="ch_ser.Copy_Object_Hook_Sample"><h5><span class="title">Copy Object Hook Sample</span></h5><p>A copy object hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/biblio/Cit_art.hpp&gt;<br />#include &lt;serial/objcopy.hpp&gt;<br />#include &lt;serial/objectio.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/objostr.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook : public CCopyObjectHook<br />{<br />public:<br />    virtual void CopyObject(CObjectStreamCopier&amp; copier,<br />                            const CObjectTypeInfo&amp; passed_info)<br />    {<br />        DefaultCopy(copier, passed_info);<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, "if"));<br />    auto_ptr&lt;CObjectOStream&gt; out(CObjectOStream::Open(eSerial_AsnText, "of"));<br />    CObjectStreamCopier copier(*in, *out);<br /><br />    CObjectTypeInfo(CType&lt;CCit_art&gt;())<br />        .SetLocalCopyHook(copier, new CDemoHook());<br /><br />    copier.Copy(CType&lt;CCit_art&gt;());<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCCopyObjectHook.html">class documentation</a> for more information.</p></div><div class="sec" id="ch_ser.Copy_Class_Member_Hook_Sample"><h5><span class="title">Copy Class Member Hook Sample</span></h5><p>A copy class member hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/seq/Bioseq.hpp&gt;<br />#include &lt;objects/seqset/Seq_entry.hpp&gt;<br />#include &lt;serial/objcopy.hpp&gt;<br />#include &lt;serial/objectio.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/objostr.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook : public CCopyClassMemberHook<br />{<br />public:<br />    virtual void CopyClassMember(CObjectStreamCopier&amp; copier,<br />                                 const CObjectTypeInfoMI&amp; passed_info)<br />    {<br />        DefaultCopy(copier, passed_info);<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, "if"));<br />    auto_ptr&lt;CObjectOStream&gt; out(CObjectOStream::Open(eSerial_AsnText, "of"));<br />    CObjectStreamCopier copier(*in, *out);<br /><br />    CObjectTypeInfo(CType&lt;CBioseq&gt;())<br />        .FindMember("annot")<br />        .SetLocalCopyHook(copier, new CDemoHook());<br /><br />    copier.Copy(CType&lt;CBioseq&gt;());<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCCopyClassMemberHook.html">class documentation</a> for more information.</p></div><div class="sec" id="ch_ser.Copy_Choice_Variant_Hook_Sample"><h5><span class="title">Copy Choice Variant Hook Sample</span></h5><p>A copy choice variant hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/biblio/Auth_list.hpp&gt;<br />#include &lt;objects/biblio/Cit_art.hpp&gt;<br />#include &lt;serial/objcopy.hpp&gt;<br />#include &lt;serial/objectio.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/objostr.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook : public CCopyChoiceVariantHook<br />{<br />public:<br />    virtual void CopyChoiceVariant(CObjectStreamCopier&amp; copier,<br />                                   const CObjectTypeInfoCV&amp; passed_info)<br />    {<br />        DefaultCopy(copier, passed_info);<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, "if"));<br />    auto_ptr&lt;CObjectOStream&gt; out(CObjectOStream::Open(eSerial_AsnText, "of"));<br />    CObjectStreamCopier copier(*in, *out);<br /><br />    (*CObjectTypeInfo(CType&lt;CAuth_list&gt;()).FindMember("names"))<br />        .GetPointedType()<br />        .FindVariant("std")<br />        .SetLocalCopyHook(copier, new CDemoHook);<br /><br />    copier.Copy(CType&lt;CCit_art&gt;());<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCCopyChoiceVariantHook.html">class documentation</a> for more information.</p></div></div><div class="sec" id="ch_ser.Skip_mode_hooks"><h4><span class="title">Skip mode hooks</span></h4><p>As with the <span class="nctnt ncbi-monospace">Read</span> and <span class="nctnt ncbi-monospace">Write</span> hook classes, there are three base classes which define the following <span class="nctnt ncbi-monospace">Skip</span> methods:</p><pre><span class="nctnt-pre ncbi-code">CSkipObjectHook::SkipObject(CObjectIStream&amp; in,<br />    const CObjectTypeInfo&amp; object) = 0;<br /><br />CSkipClassMemberHook::SkipClassMember(CObjectIStream&amp; in,<br />    const CObjectTypeInfoMI&amp; member) = 0;<br /><br />CSkipChoiceVariantHook::SkipChoiceVariant(CObjectIStream&amp; in,<br />    const CObjectTypeInfoCV&amp; variant) = 0;</span></pre><p>Newly derived skip hooks can be installed by invoking the <span class="nctnt ncbi-func">SetLocalSkipObjectHook()</span> method for the appropriate type information object. The other way of installing hooks is described below in the <span class="nctnt ncbi-class">CObjectHookGuard</span> section.</p><p>The <span class="nctnt ncbi-class">CSkipObjectHook</span> class has a <span class="nctnt ncbi-func">DefaultSkip()</span> method, like the base classes for the other processing modes, but for historical reasons <span class="nctnt ncbi-func">DefaultSkip()</span> methods were not defined for the <span class="nctnt ncbi-class">CSkipClassMemberHook</span> and <span class="nctnt ncbi-class">CSkipChoiceVaraintHook</span> classes. Nevertheless, achieving the same result is easily accomplished – for example:</p><pre><span class="nctnt-pre ncbi-code">class CMySkipClassMemberHook : public CSkipClassMemberHook<br />{<br />public:<br />    virtual void SkipClassMember(CObjectIStream&amp; in,<br />                                 const CObjectTypeInfoMI&amp; member)<br />    {<br />        in.SkipObject(*member);<br />    }<br />};</span></pre><div class="sec" id="ch_ser.Skip_Object_Hook_Sample"><h5><span class="title">Skip Object Hook Sample</span></h5><p>A skip object hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/biblio/Cit_art.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook : public CSkipObjectHook<br />{<br />public:<br />    virtual void SkipObject(CObjectIStream&amp; in,<br />                            const CObjectTypeInfo&amp; passed_info)<br />    {<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, "if"));<br /><br />    CObjectTypeInfo(CType&lt;CCit_art&gt;()).SetLocalSkipHook(*in, new CDemoHook);<br /><br />    in-&gt;Skip(CType&lt;CCit_art&gt;());<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSkipObjectHook.html">class documentation</a> for more information.</p></div><div class="sec" id="ch_ser.Skip_Class_Member_Hook_Sample"><h5><span class="title">Skip Class Member Hook Sample</span></h5><p>A skip class member hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/biblio/Auth_list.hpp&gt;<br />#include &lt;objects/biblio/Cit_art.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook : public CSkipClassMemberHook<br />{<br />public:<br />    virtual void SkipClassMember(CObjectIStream&amp; in,<br />                                 const CObjectTypeInfoMI&amp; passed_info)<br />    {<br />        in.SkipObject(*passed_info);<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, "if"));<br /><br />    CObjectTypeInfo(CType&lt;CAuth_list&gt;())<br />        .FindMember("names")<br />        .SetLocalSkipHook(*in, new CDemoHook);<br /><br />    in-&gt;Skip(CType&lt;CCit_art&gt;());<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSkipClassMemberHook.html">class documentation</a> for more information.</p></div><div class="sec" id="ch_ser.Skip_Choice_Variant_Hook_Sample"><h5><span class="title">Skip Choice Variant Hook Sample</span></h5><p>A skip choice variant hook can be created very much like other hooks. For example, the executable lines in the <a href="ch_ser.html#ch_ser.Hook_Sample">hook sample</a>, can be replaced with:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;objects/biblio/Imprint.hpp&gt;<br />#include &lt;objects/general/Date.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />USING_SCOPE(ncbi::objects);<br /><br />class CDemoHook : public CSkipChoiceVariantHook<br />{<br />public:<br />    virtual void SkipChoiceVariant(CObjectIStream&amp; in,<br />                                   const CObjectTypeInfoCV&amp; passed_info)<br />    {<br />        in.SkipObject(*passed_info);<br />    }<br />};<br /><br />int main(int argc, char** argv)<br />{<br />    char asn[] = "Imprint ::= { date std { year 2010 } }";<br />    CNcbiIstrstream iss(asn);<br />    auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, iss));<br /><br />    CObjectTypeInfo(CType&lt;CDate&gt;()).FindVariant("std")<br />                                   .SetLocalSkipHook(*in, new CDemoHook());<br /><br />    in-&gt;Skip(CType&lt;CImprint&gt;());<br /><br />    return 0;<br />}</span></pre><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSkipChoiceVariantHook.html">class documentation</a> for more information.</p></div></div><div class="sec" id="ch_ser.objstream.html_hookguard"><h4><span class="title">The <span class="nctnt ncbi-class">CObjectHookGuard</span> class</span></h4><p>To simplify hooks usage <span class="nctnt ncbi-class">CObjectHookGuard</span> class may be used. It's a template class: the template parameter is the class to be hooked (in case of member or choice variant hooks it's the parent class of the member).</p><p>The CObjectHookGuard class has several constructors for installing different hook types. The last argument to all constructors is a stream pointer. By default the pointer is NULL and the hook is intalled as a global one. To make the hook stream-local pass the stream to the guard constructor.</p><ul><li><p>Object read/write hooks:<br /><span class="nctnt ncbi-code">CObjectHookGuard(CReadObjectHook&amp; hook,</span><br /><span class="nctnt ncbi-code">                 CObjectIStream* in = 0);</span><br /><span class="nctnt ncbi-code">CObjectHookGuard(CWriteObjectHook&amp; hook,</span><br /><span class="nctnt ncbi-code">                 CObjectOStream* out = 0);</span></p></li><li><p>Class member read/write hooks:<br /><span class="nctnt ncbi-code">CObjectHookGuard(string id,</span><br /><span class="nctnt ncbi-code">                 CReadClassMemberHook&amp; hook,</span><br /><span class="nctnt ncbi-code">                 CObjectIStream* in = 0);</span><br /><span class="nctnt ncbi-code">CObjectHookGuard(string id,</span><br /><span class="nctnt ncbi-code">                 CWriteClassMemberHook&amp; hook,</span><br /><span class="nctnt ncbi-code">                 CObjectOStream* out = 0);</span></p></li></ul><p>The string "id" argument is the name of the member in ASN.1 specification for generated classes.</p><ul><li><p>Choice variant read/write hooks:<br /><span class="nctnt ncbi-code">CObjectHookGuard(string id,</span><br /><span class="nctnt ncbi-code">                 CReadChoiceVariantHook&amp; hook,</span><br /><span class="nctnt ncbi-code">                 CObjectIStream* in = 0);</span><br /><span class="nctnt ncbi-code">CObjectHookGuard(string id,</span><br /><span class="nctnt ncbi-code">                 CWriteChoiceVariantHook&amp; hook,</span><br /><span class="nctnt ncbi-code">                 CObjectOStream* out = 0);</span></p></li></ul><p>The string "id" argument is the name of the variant in ASN.1 specification for generated classes.</p><p>The guard's destructor will uninstall the hook. Since all hook classes are derived from CObject and stored as CRef&lt;&gt;-s, the hooks are destroyed automatically when uninstalled. For this reason it's recommended to create hook objects on heap.</p></div><div class="sec" id="ch_ser.stack_path_hooks"><h4><span class="title">Stack Path Hooks</span></h4><p>When an object is serialized or deserialized, a string called the stack path is created internally to track the structural context of the current location. The stack path starts with the type name of the top-level data object. While each sub-object is processed, a '<span class="nctnt ncbi-monospace">.</span>' and the sub-object name are "pushed on the stack".</p><p>An example of a possible stack path string is:</p><pre><span class="nctnt-pre ncbi-monospace">Seq-entry.set.seq-set.seq.annot.data.ftable.data.pub.pub.article</span></pre><p>Hooks based on the stack path can be created if you need to specify a more complex structural context for when a hook should be called. More complex, that is, than the "object", "class member", and "choice variant" contexts discussed in earlier sections. For example, "I want to hook the reading of objects named 'title' when and only when they are contained by objects named 'book', not all occurrences of 'title' objects", or, "I want to hook the reading of all sequence members named 'title' in all objects, not only in a specific one". The serial library makes it possible to set hooks for such structural contexts by passing a stack path mask to various "SetHook" methods. When the stack path string for the object being processed matches the stack path mask, the hook will be called.</p><p>The general form of the stack path mask is:</p><pre><span class="nctnt-pre ncbi-monospace">TypeName.Member1.Member2.HookedMember</span></pre><p>More formally:</p><pre><span class="nctnt-pre ncbi-code">StackPathMask ::= (TypeName | Wildcard) ('.' (MemberName | Wildcard))+</span></pre><p>Here <span class="nctnt ncbi-monospace">TypeName</span> and <span class="nctnt ncbi-monospace">MemberName</span> are strings; '<span class="nctnt ncbi-monospace">.</span>' separates path elements; and <span class="nctnt ncbi-monospace">Wildcard</span> is defined as:</p><pre><span class="nctnt-pre ncbi-code">Wildcard ::= ('?' | '*')</span></pre><p>The question mark means "match exactly one path element with any name", while the asterisk means "match one or more path elements with any names".</p><p>An example of a possible stack path mask is:</p><pre><span class="nctnt-pre ncbi-monospace">*.article.*.authors</span></pre><p><span class="nctnt highlight">Note:</span> The first element of the stack path mask must be either a wildcard or the type of the top-level object in the stream. Type names are not permitted anywhere but the first element, which makes stack path masks like "<span class="nctnt ncbi-monospace">*.Cit-book.*.date</span>" invalid (ASN.1 type names begin with uppercase while member names begin with lowercase).</p><p>As with regular serialization hooks, it is possible to install a path hook for a specific object:</p><pre><span class="nctnt-pre ncbi-code">CObjectTypeInfo(CBioseq::GetTypeInfo()).<br />    SetPathReadHook(in, path, myReadBioseqHook);</span></pre><p>a member of a sequence object:</p><pre><span class="nctnt-pre ncbi-code">CObjectTypeInfo(CBioseq::GetTypeInfo()).FindMember("inst").<br />    SetPathReadHook(in, path, myReadSeqinstHook);</span></pre><p>or a variant of a choice object:</p><pre><span class="nctnt-pre ncbi-code">CObjectTypeInfo(CSeq_entry::GetTypeInfo()).FindVariant("seq").<br />    SetPathReadHook(in, path, myReadBioseqHook);</span></pre><p>Here <span class="nctnt ncbi-var">in</span> is a pointer to an input object stream. If it is equal to zero, the hook will be installed globally, otherwise - for that particular stream.</p><p>In addition, it is possible to install path hooks directly in object streams without specifying an ASN.1 type. For example, to install a read hook on all string objects named <span class="nctnt ncbi-var">last-name</span>, one could use either this:</p><pre><span class="nctnt-pre ncbi-code">CObjectTypeInfo(CStdTypeInfo&lt;string&gt;::GetTypeInfo()).<br />    SetPathReadHook(in,"*.last-name",myObjHook);</span></pre><p>or this:</p><pre><span class="nctnt-pre ncbi-code">in-&gt;SetPathReadObjectHook("*.last-name", myObjHook);</span></pre><p>Setting path hooks directly in streams also makes it possible to differentiate between <span class="nctnt ncbi-var">last-name</span> being a sequence member and choice variant. So, for example:</p><pre><span class="nctnt-pre ncbi-code">in-&gt;SetPathReadMemberHook("*.last-name", myMemHook);</span></pre><p>will hook sequence members and not choice variants, while:</p><pre><span class="nctnt-pre ncbi-code">in-&gt;SetPathReadVariantHook("*.last-name", myVarHook);</span></pre><p>will hook choice variants and not sequence members.</p><p>Stack path hooks can be removed by passing <span class="nctnt ncbi-macro">NULL</span> instead of a hook pointer to the various "SetHook" methods.</p></div></div><div class="sec" id="ch_ser.stream_iterators"><h3><span class="title">Stream Iterators</span></h3><p>When working with a stream, it is sometimes convenient to be able to read or write data elements directly, bypassing the standard data storage mechanism. For example, when reading a large container object, the purpose could be to process its elements. It is possible to read everything at once, but this could require a lot of memory to store the data in. An alternative approach, which greatly reduces the amount of required memory, could be to read elements one by one, process them as they arrive, and then discard. Or, when writing a container, one could construct it in memory only partially, and then add missing elements 'on the fly' - where appropriate. To make it possible, the SERIAL library introduces <span class="nctnt ncbi-monospace">stream iterators</span>. Needless to say, the most convenient way of using this mechanism is in read/write hooks.</p><p>SERIAL library defines the following stream iterator classes: <span class="nctnt ncbi-class">CIStreamClassMemberIterator</span> and <span class="nctnt ncbi-class">CIStreamContainerIterator</span> for input streams, and <span class="nctnt ncbi-class">COStreamClassMember</span> and <span class="nctnt ncbi-class">COStreamContainer</span> for output ones.</p><p>Reading a container could look like this:</p><pre><span class="nctnt-pre ncbi-code">for ( CIStreamContainerIterator i(in, containerType); i; ++i ) {<br />      CElementClass element;<br />      i &gt;&gt; element;<br />}</span></pre><p>Writing - like this:</p><pre><span class="nctnt-pre ncbi-code">set&lt;CElementClass&gt; container;  // your container<br />............<br />COStreamContainer osc(out, containerType);<br />for (set&lt;CElementClass&gt;::const_iterator i = container.begin();<br />     i != container.end(); ++i ) {<br />    const CElementClass&amp; element = *i;</span><br />    <span class="nctnt-pre ncbi-code">osc &lt;&lt; element;<br />}</span></pre><p>For more examples of using stream iterators please refer to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/asn2asn/asn2asn.cpp">asn2asn</a> sample application.</p></div><div class="sec" id="ch_ser.objstream.html_blocks"><h3><span class="title">The <span class="nctnt ncbi-class">ByteBlock</span> and <span class="nctnt ncbi-class">CharBlock</span> classes</span></h3><p><span class="nctnt ncbi-class">CObject[IO]Stream::ByteBlock</span> class may be used for non-standard processing of an OCTET STRING data, e.g. from a read/write hooks. The <span class="nctnt ncbi-class">CObject[IO]Stream::CharBlock</span> class has almost the same functionality, but may be used for VisibleString data processing.</p><p>An example of using ByteBlock or CharBlock classes is generating data on-the-fly in a write hook. To use block classes:</p><p>Initialize the block variable with an i/o stream and, in case of output stream, the length of the block.</p><p>Use Read()/Write() functions to process block data</p><p>Close the block with the End() function</p><p>Below is an example of using <span class="nctnt ncbi-class">CObjectOStream::ByteBlock</span> in an object write hook for non-standard data processing. Note, that ByteBlock and CharBlock classes read/write data only. You should also provide some code for writing class' and members' tags.</p><p>Since OCTET STRING and VisibleString in the NCBI C++ Toolkit are implemented as <span class="nctnt ncbi-class">vector&lt;char&gt;</span> and <span class="nctnt ncbi-class">string</span> classes, which have no serailization type info, you can not install a read or write hook for these classes. The example also demonstrates how to process members of these types using the containing class hook. Another example of using CharBlock with write hooks can be found in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/serial/test/test_serial.cpp">test_serial.cpp</a> application.</p><pre><span class="nctnt-pre ncbi-code">void CWriteMyObjectHook::WriteObject(CObjectOStream&amp; out,<br />                                     const CConstObjectInfo&amp; object)<br />{<br />    const CMyObject&amp; obj = *reinterpret_cast&lt;const CMyObject*&gt;<br />        (object.GetObjectPtr());<br />    if ( NothingToProcess(obj) ) {<br />        // No special processing - use default write method<br />        DefaultWrite(out, object);<br />        return;<br />    }<br />    // Write object open tag<br />    out.BeginClass(object.GetClassTypeInfo());<br />    // Iterate object members<br />    for (CConstObjectInfo::CMemberIterator member =<br />        object.BeginMembers(); member; ++member) {<br />        if ( NeedProcessing(member) ) {<br />            // Write the special member manually<br />            out.BeginClassMember(member.GetMemberInfo()-&gt;GetId());<br />            // Start byte block, specify output stream and block size<br />            size_t length = GetRealDataLength(member);<br />            CObjectOStream::ByteBlock bb(out, length);<br />            // Processing and output<br />            for (int i = 0; i &lt; length; ) {<br />                char* buf;<br />                int buf_size;<br />                // Assuming ProcessData() generates the data from "member",<br />                // starting from position "i" and stores the data to "buf"<br />                ProcessData(member, i, &amp;buf_size, &amp;buf);<br />                i += buf_size;<br />                bb.Write(buf, buf_size);<br />            }<br />        }<br />        // Close the byte block<br />        bb.End();<br />        // Close the member<br />        out.EndClassMember();<br />    }<br />    else {<br />        // Default writer for members without special processing<br />        if ( member.IsSet() )<br />            out.WriteClassMember(member);<br />    }<br />    // Close the object<br />    out.EndClass();<br />}</span></pre></div><div class="sec" id="ch_ser.rpc.html"><h3><span class="title">NCBI C++ Toolkit Network Service (RPC) Clients</span></h3><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_ser.html#ch_ser.data_ser_2_1">Introduction and Use</a></p></li><li><p><a href="ch_ser.html#ch_ser.data_ser_2_2">Implementation Details</a></p></li></ul><div class="sec" id="ch_ser.data_ser_2_1"><h4><span class="title">Introduction and Use</span></h4><p>The C++ Toolkit now contains <a href="ch_app.html#ch_app.datatool">datatool</a>-generated classes for certain ASN.1-based network services: at the time of this writing, <span class="nctnt ncbi-monospace">Entrez2</span>, <span class="nctnt ncbi-monospace">ID1</span>, and <span class="nctnt ncbi-monospace">MedArch</span>. (There is also an independently written class for the <span class="nctnt ncbi-monospace">Taxon1</span> service, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CTaxon1&amp;d=C">CTaxon1</a>, which this page does not discuss further.) All of these classes, declared in headers named <span class="nctnt ncbi-path">objects/.../client(_).hpp</span>, inherit certain useful properties from the base template <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CRPCClient&amp;d=C">CRPCClient&lt;&gt;</a>:</p><ul><li><p>They normally defer connection until the first actual query, and disconnect automatically when destroyed, but let users request either action explicitly.</p></li><li><p>They are designed to be thread-safe (but, at least for now, maintain only a single connection per instance, so forming pools may be appropriate).</p></li></ul><p>The usual interface to these classes is through a family of methods named <span class="nctnt ncbi-func">AskXxx</span>, each of which takes a request of an appropriate type and an optional pointer to an object that will receive the full reply and returns the corresponding reply choice. For example, <span class="nctnt ncbi-func">CEntrez2Client::AskEval_boolean</span> takes a request of type <span class="nctnt ncbi-type">const CEntrez2_eval_boolean&amp;</span> and an optional pointer of type <span class="nctnt ncbi-type">CEntrez2_reply*</span>, and returns a reply of type <span class="nctnt ncbi-type">CRef&lt;CEntrez2_boolean_reply&gt;</span>. All of these methods automatically detect server-reported errors or unexpected reply choices, and throw appropriate exceptions when they occur. There are also lower-level methods simply named <span class="nctnt ncbi-func">Ask</span>, which may come in handy if you do not know what kind of query you will need to make.</p><p>In addition to these standard methods, there are certain class-specific methods: <span class="nctnt ncbi-class">CEntrez2Client</span> adds <span class="nctnt ncbi-func">GetDefaultRequest</span> and <span class="nctnt ncbi-func">SetDefaultRequest</span> for dealing with those fields of <span class="nctnt ncbi-type">Entrez2-request</span> besides <span class="nctnt ncbi-var">request</span> itself, and <span class="nctnt ncbi-class">CID1Client</span> adds <span class="nctnt ncbi-func">{Get,Set}AllowDeadEntries</span> (off by default) to control how to handle the result choice <span class="nctnt ncbi-var">gotdeadseqentry</span>.</p></div><div class="sec" id="ch_ser.data_ser_2_2"><h4><span class="title">Implementation Details</span></h4><p>In order to get <a href="ch_app.html#ch_app.datatool">datatool</a> to generate classes for a service, you must add some settings to the corresponding <span class="nctnt ncbi-path">modulename.def</span> file. Specifically, you must set <span class="nctnt ncbi-var">[-]clients</span> to the relevant base file name (typically <span class="nctnt ncbi-monospace">service</span><span class="nctnt ncbi-code">_client</span>), and add a correspondingly named section containing the entries listed in <a href="ch_ser.html#ch_ser.T1">Table 1</a>. (If a single specification defines multiple protocols for which you would like <span class="nctnt ncbi-app">datatool</span> to generate classes, you may list multiple client names, separated by spaces.)</p><div class="table" id="ch_ser.T1"><div class="caption"><p>Table 1. Network Service Client Generation Parameters</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Name</th><th align="left" valign="top" rowspan="1" colspan="1">Value</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">class</span> (REQUIRED)</td><td align="left" valign="top" rowspan="1" colspan="1">C++ class name to use.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">service</span></td><td align="left" valign="top" rowspan="1" colspan="1">Named service to connect to; if you do not define this, you will need to override <span class="nctnt ncbi-func">x_Connect</span> in the user class.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">serialformat</span></td><td align="left" valign="top" rowspan="1" colspan="1">Serialization format: normally <span class="nctnt ncbi-monospace">AsnBinary</span>, but <span class="nctnt ncbi-monospace">AsnText</span> and <span class="nctnt ncbi-monospace">Xml</span> are also legal.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">request</span> (REQUIRED)</td><td align="left" valign="top" rowspan="1" colspan="1">ASN.1 type for requests; may include a module name, a field name (as with <span class="nctnt ncbi-monospace">Entrez2</span>), or both. Must be a CHOICE.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">reply</span> (REQUIRED)</td><td align="left" valign="top" rowspan="1" colspan="1">ASN.1 type for replies, as above.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">reply.choice_name</span></td><td align="left" valign="top" rowspan="1" colspan="1">Reply choice appropriate for requests of type <span class="nctnt ncbi-var">choice_name</span>; defaults to <span class="nctnt ncbi-var">choice_name</span> as well, and determines the return type of <span class="nctnt ncbi-func">AskChoice_name</span>. May be set to <span class="nctnt ncbi-monospace">special</span> to suppress automatic method generation and let the user class handle the whole thing.</td></tr></tbody></table></div></div></div><div class="sec" id="ch_ser.serial_verify"><h3><span class="title">Verification of Class Member Initialization</span></h3><p>When serializing an object, it is important to verify that all mandatory primitive data members (e.g. strings, integers) are given a value. The NCBI C++ Toolkit implements this through a data initialization verification mechanism. In this mechanism, the value itself is not validated; that is, it still could be semantically incorrect. The purpose of the verification is only to make sure that the member has been assigned some value. The verification also provides for a possibility to check whether the object data member has been initialized or not. This could be useful when constructing such objects in memory.</p><p>From this perspective, each data member (XXX) of a serial object generated by <span class="nctnt ncbi-app">DATATOOL</span> from an ASN or XML specification has the <span class="nctnt ncbi-func">IsSetXXX()</span> and <span class="nctnt ncbi-func">CanGetXXX()</span> methods. Also, input and output streams have <span class="nctnt ncbi-func">SetVerifyData()</span> and <span class="nctnt ncbi-func">GetVerifyData()</span> methods. The purpose of <span class="nctnt ncbi-func">CanGetXXX()</span> method is to answer the question whether it is safe or not to call the corresponding <span class="nctnt ncbi-func">GetXXX()</span>. The meaning of <span class="nctnt ncbi-func">IsSetXXX()</span> is whether the data member has been assigned a value explicitly (using assignment function call, or as a result of reading from a stream) or not. The stream's <span class="nctnt ncbi-func">SetVerifyData()</span> method defines a stream behavior in case it comes across an uninitialized data member.</p><p>There are three kinds of object data members:</p><ul><li><p>optional ones,</p></li><li><p>mandatory with a default value,</p></li><li><p>mandatory with no default value.</p></li></ul><p>Optional members and mandatory ones with no default have "no value" initially. As such, they are "ungetatable"; that is, <span class="nctnt ncbi-func">GetXXX()</span> throws an exception (this is also configurable though). Mandatory members with a default are always getable, but not always set. It is possible to assign a default value to a mandatory member with a default value. In this case it becomes set, and as such will be written into an output stream.</p><p>The discussion above refers only to primitive data members, such as strings, or integers. The behavior of containers is somewhat different. All containers are pre-created on the parent object construction, so for container data members <span class="nctnt ncbi-func">CanGetXXX()</span> always returns TRUE. This can be justified by the fact that containers have a sort of "natural default value" - empty. Also, <span class="nctnt ncbi-func">IsSetXXX()</span> will return TRUE if the container is either mandatory, or has been read (even if empty) from the input stream, or <span class="nctnt ncbi-func">SetXXX()</span> was called for it.</p><p>The following additional topics are discussed in this section:</p><ul><li><p><a href="ch_ser.html#ch_ser.serial_object_api">Initialization Verification in CSerialObject Classes</a></p></li><li><p><a href="ch_ser.html#ch_ser.serial_stream_api">Initialization Verification in Object Streams</a></p></li></ul><div class="sec" id="ch_ser.serial_object_api"><h4><span class="title">Initialization Verification in <span class="nctnt ncbi-class">CSerialObject</span> Classes</span></h4><p><span class="nctnt ncbi-class">CSerialObject</span> defines two functions to manage how uninitialized data members would be treated:</p><pre><span class="nctnt-pre ncbi-code">    static void SetVerifyDataThread(ESerialVerifyData verify);<br />    static void SetVerifyDataGlobal(ESerialVerifyData verify);</span></pre><p>The <span class="nctnt ncbi-func">SetVerifyDataThread()</span> defines the behavior of <span class="nctnt ncbi-func">GetXXX()</span> for the current thread, while the <span class="nctnt ncbi-func">SetVerifyDataGlobal()</span> for the current process. Please note, that disabling <span class="nctnt ncbi-class">CUnassignedMember</span> exceptions in <span class="nctnt ncbi-func">GetXXX()</span> function is potentially dangerous because it could silently return garbage.</p><p>The behavior of initialization verification has been designed to allow for maximum flexibility. It is possible to define it using environment variables, and then override it in a program, and vice versa. It is also possible to force a specific behavior, no matter what the program sets, or could set later on. The <span class="nctnt ncbi-type">ESerialVerifyData</span> enumerator could have the following values:</p><ul><li><p><span class="nctnt ncbi-monospace">eSerialVerifyData_Default</span></p></li><li><p><span class="nctnt ncbi-monospace">eSerialVerifyData_No</span></p></li><li><p><span class="nctnt ncbi-monospace">eSerialVerifyData_Never</span></p></li><li><p><span class="nctnt ncbi-monospace">eSerialVerifyData_Yes</span></p></li><li><p><span class="nctnt ncbi-monospace">eSerialVerifyData_Always</span></p></li></ul><p>Setting <span class="nctnt ncbi-type">eSerialVerifyData_Never</span> or <span class="nctnt ncbi-type">eSerialVerifyData_Always</span> results in a "forced" behavior: setting <span class="nctnt ncbi-type">eSerialVerifyData_Never</span> prohibits later attempts to enable verification; setting <span class="nctnt ncbi-type">eSerialVerifyData_Always</span> prohibits attempts to disable it. The default behavior could be defined from the outside, using the <span class="nctnt ncbi-var">SET_VERIFY_DATA_GET</span> environment variable:</p><pre><span class="nctnt-pre ncbi-code">    SET_VERIFY_DATA_GET ::= ( 'NO' | 'NEVER' | 'YES' | 'ALWAYS' )</span></pre><p>Alternatively, the default behavior can also be set from a program code using <span class="nctnt ncbi-func">CSerialObject::SetVerifyDataXXX()</span> functions.</p><p>Setting the environment variable to "Never/Always" overrides any attempt to change the verification behavior in the program. Setting "Never/Always" for the process overrides attempts to change it for a thread. "Yes/No" setting is less restrictive: the environment variable, if present, provides the default, which could then be overridden in a program, or thread. Here thread settings supersede the process ones.</p></div><div class="sec" id="ch_ser.serial_stream_api"><h4><span class="title">Initialization Verification in Object Streams</span></h4><p>Data member verification in object streams is a bit more complex.</p><p>First, it is possible to set the verification behavior on three different levels:</p><ul><li><p>for a specific stream (<span class="nctnt ncbi-func">SetVerifyData()</span>),</p></li><li><p>for all streams created by a current thread (<span class="nctnt ncbi-func">SetVerifyDataThread()</span>),</p></li><li><p>for all stream created by the current process (<span class="nctnt ncbi-func">SetVerifyDataGlobal()</span>).</p></li></ul><p>Second, there are more options in defining what to do in case of an uninitialized data member:</p><ul><li><p>throw an exception;</p></li><li><p>skip it on writing (write nothing), and leave uninitialized (as is) on reading;</p></li><li><p>write some default value on writing, and assign it on reading (even though there is no default).</p></li></ul><p>To accommodate these situations, the <span class="nctnt ncbi-type">ESerialVerifyData</span> enumerator has two additional values:</p><ul><li><p><span class="nctnt ncbi-monospace">eSerialVerifyData_DefValue</span></p></li><li><p><span class="nctnt ncbi-monospace">eSerialVerifyData_DefValueAlways</span></p></li></ul><p>In this case, on reading a missing data member, stream initializes it with a "default" (usually 0); on writing the unset data member, it writes it "as is". For comparison: in the "No/Never" case on reading a missing member stream could initialize it with a "garbage", while on writing it writes nothing. The latter case produces semantically incorrect output, but preserves information of what has been set, and what is not set.</p><p>The default behavior could be set similarly to CSerialObject. The environment variables are as follows:</p><pre><span class="nctnt-pre ncbi-code">    SET_VERIFY_DATA_READ  ::= ( 'NO' | 'NEVER' | 'YES' | 'ALWAYS' |<br /> 'DEFVALUE' | 'DEFVALUE_ALWAYS' )<br />    SET_VERIFY_DATA_WRITE ::= ( 'NO' | 'NEVER' | 'YES' | 'ALWAYS' |<br /> 'DEFVALUE' | 'DEFVALUE_ALWAYS' )</span></pre></div></div><div class="sec" id="ch_ser.simplified_serialization_inte"><h3><span class="title">Simplified Serialization Interface</span></h3><p>The reading and writing of serial object requires creation of special object streams which encode and decode data. While such streams provide with a greater flexibility in setting the formatting parameters, in some cases it is not needed - the default behavior is quite enough. NCBI C++ toolkit library makes it possible to use the standard I/O streams in this case, thus hiding the creation of object streams. So, the serialization would look like this:</p><pre><span class="nctnt-pre ncbi-code">cout &lt;&lt; MSerial_AsnText &lt;&lt; obj;</span></pre><p>The only information that is always needed is the output format. It is defined by the following stream manipulators:</p><ul><li><p><span class="nctnt ncbi-func">MSerial_AsnText</span></p></li><li><p><span class="nctnt ncbi-func">MSerial_AsnBinary</span></p></li><li><p><span class="nctnt ncbi-func">MSerial_Json</span></p></li><li><p><span class="nctnt ncbi-func">MSerial_Xml</span></p></li></ul><p>Few additional manipulators define the handling of un-initialized object data members:</p><ul><li><p><span class="nctnt ncbi-func">MSerial_VerifyDefault</span></p></li><li><p><span class="nctnt ncbi-func">MSerial_VerifyNo</span></p></li><li><p><span class="nctnt ncbi-func">MSerial_VerifyYes</span></p></li><li><p><span class="nctnt ncbi-func">MSerial_VerifyDefValue</span></p></li></ul></div><div class="sec" id="ch_ser.serial_filter"><h3><span class="title">Finding in input stream objects of a specific type</span></h3><p>When processing serialized data, it is pretty often that one has to find all objects of a specific type, with this type not being a root one. To make it easier, serial library defines a helper template function <span class="nctnt ncbi-func">Serial_FilterObjects</span>. The idea is to be able to define a special hook class with a single virtual function <span class="nctnt ncbi-func">Process</span> with a single parameter: object of the requested type. Input stream is being scanned then, and, when an object of the requested type is encountered, the user-supplied function is being called.</p><p>For example, suppose an input stream contains Bioseq objects, and you need to find and process all Seq-inst objects in it. First, you need to define a class that will process them:</p><pre><span class="nctnt-pre ncbi-code">Class CProcessSeqinstHook : public<br />CSerial_FilterObjectsHook&lt;CSeq_inst&gt;<br />{<br />public:<br />    virtual void Process(const CSeq_inst&amp; obj);<br />};</span></pre><p>Second, you just call filtering function specifying the root object type:</p><pre><span class="nctnt-pre ncbi-code">Serial_FilterObjects&lt;CBioseq&gt;(input_stream, new<br />CProcessSeqinstHook());</span></pre><p>Another variant of this function – <span class="nctnt ncbi-func">Serial_FilterStdObjects</span> – finds objects of standard type, not derived from <span class="nctnt ncbi-class">CSerialObject</span> – strings, for example. The usage is similar. First, define a hook class that will process data:</p><pre><span class="nctnt-pre ncbi-code">class CProcessStringHook : public CSerial_FilterObjectsHook&lt;string&gt;<br />{<br />public:<br />    virtual void Process(const string&amp; obj);<br />};</span></pre><p>Then, call the filtering function:</p><pre><span class="nctnt-pre ncbi-code">Serial_FilterStdObjects&lt;CBioseq&gt;(input_stream, new CProcessStringHook());</span></pre><p>An even more sophisticated, yet easier to use mechanism relies on multi-threading. It puts data reading into a separate thread and hides synchronization issues from client application. There are two template classes, which make it possible: <span class="nctnt ncbi-class">CIStreamObjectIterator</span> and <span class="nctnt ncbi-class">CIStreamStdIterator</span>. The former finds objects of <span class="nctnt ncbi-class">CSerialObject</span> type:</p><pre><span class="nctnt-pre ncbi-code">CIStreamObjectIterator&lt;CBioseq,CSeq_inst&gt; i(input_stream);<br />for ( ; i.IsValid(); ++i) {<br />    const CSeq_inst&amp; obj = *i;<br />    ...<br />}</span></pre><p>The latter – objects of standard type:</p><pre><span class="nctnt-pre ncbi-code">CIStreamStdIterator&lt;CBioseq,string&gt; i(input_stream);<br />for ( ; i.IsValid(); ++i) {<br />    const string&amp; obj = *i;<br />    ...<br />}</span></pre></div></div><div class="sec" id="ch_ser.iterators.html"><h2><span class="title">The NCBI C++ Toolkit Iterators</span></h2><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_ser.html#ch_ser.iterators.html_generic">STL generic iterators</a></p></li><li><p><a href="ch_ser.html#ch_ser.iterators.html_typeIt">CTypeIterator (*) and CTypeConstIterator (*)</a></p></li><li><p><a href="ch_ser.html#ch_ser.iterators.html_hier">Class hierarchies, embedded objects, and the NCBI C++ type iterators</a></p></li><li><p><a href="ch_ser.html#ch_ser.iterators.html_cobjType">CObjectIterator (*) and CObjectConstIterator (*)</a></p></li><li><p><a href="ch_ser.html#ch_ser.iterators.html_stdType">CStdTypeIterator (*) and CStdTypeConstIterator (*)</a></p></li><li><p><a href="ch_ser.html#ch_ser.iterators.html_typesIt">CTypesIterator (*)</a></p></li><li><p><a href="ch_ser.html#ch_ser.iterators.context_filter">Context filtering in type iterators</a></p></li><li><p><a href="ch_ser.html#ch_ser.iterators.html_appendix">Additional Information</a></p></li></ul><div class="sec" id="ch_ser.iterators.html_generic"><h3><span class="title"><span class="nctnt ncbi-lib">STL</span> generic iterators</span></h3><p>Iterators are an important cornerstone in the generic programming paradigm - they serve as intermediaries between generic containers and generic algorithms. Different containers have different access properties, and the interface to a generic algorithm must account for this.</p><p>The <span class="nctnt ncbi-class">vector</span> class allows <span class="nctnt ncbi-monospace">input, output, bidirectional,</span> and <span class="nctnt ncbi-monospace">random access</span> iterators. In contrast, the <span class="nctnt ncbi-class">list</span> container class does <b>not</b> allow random access to its elements. This is depicted graphically by one less strand in the ribbon connector. In addition to the iterators, the generic algorithms may require function objects such as <span class="nctnt ncbi-code">less&lt;T&gt;</span> to support the template implementations.</p><p>The STL standard iterators are designed to iterate through any STL container of homogeneous elements, e.g., <span class="nctnt ncbi-monospace">vectors, lists, deques, stacks, maps, multimaps, sets, multisets, </span>etc. A prerequisite however, is that the container must have <span class="nctnt ncbi-func">begin()</span> and <span class="nctnt ncbi-func">end()</span> functions defined on it as start and end points for the iteration.</p><p>But while these standard iterators are powerful tools for generic programming, they are of no help in iterating over the elements of <span class="nctnt ncbi-monospace">aggregate</span> objects - e.g., over the heterogeneous data members of a class object. As this is an essential operation in processing serialized data structures, the NCBI C++ Toolkit provides additional types of iterators for just this purpose. In the section on <a href="ch_ser.html#ch_ser.typeinfo.html">Runtime object type information</a>, we described the <a href="ch_ser.html#ch_ser.typeinfo.html_objtype">CMemberIterator</a> and <a href="ch_ser.html#ch_ser.typeinfo.html_objtype">CVariantIterator</a> classes, which provide access to the instance and type information for <b>all</b> of the sequence members and choice variants of a sequence or choice object. In some cases however, we may wish to visit only those data members which are of a certain type, and do not require any type information. The iterators described in this section are of this type.</p></div><div class="sec" id="ch_ser.iterators.html_typeIt"><h3><span class="title"><span class="nctnt ncbi-class">CTypeIterator</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCTypeIterator.html">*</a>) and <span class="nctnt ncbi-class">CTypeConstIterator</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCTypeConstIterator.html">*</a>)</span></h3><p>The <span class="nctnt ncbi-class">CTypeIterator</span> and <span class="nctnt ncbi-class">CTypeConstIterator</span> can be used to traverse a structured object, stopping at all data members of a specified type. For example, it is very common to represent a linked list of objects by encoding a next field that embeds an object of the same type. One way to traverse the linked list then, would be to "iterate" over all objects of that type, beginning at the head of the list. For example, suppose you have a <span class="nctnt ncbi-class">CPerson</span>class defined as:</p><pre><span class="nctnt-pre ncbi-code">class CPerson<br />{<br />public:<br />    CPerson(void);<br />    CPerson(const string&amp; name, const string&amp; address, CPerson* p);<br />    virtual ~CPerson(void);<br />    static const CTypeInfo* GetTypeInfo(void);<br />    string m_Name, m_Addr;<br />    CPerson *m_NextDoor;<br />};</span></pre><p>Given this definition, one might then define a <span class="nctnt ncbi-var">neighborhood</span> using a single <span class="nctnt ncbi-class">CPerson</span>. Assuming a function <span class="nctnt ncbi-func">FullerBrushMan(CPerson&amp;)</span> must now be applied to each person in the neighborhood, this could be implemented using a <span class="nctnt ncbi-class">CTypeIterator</span> as follows:</p><pre><span class="nctnt-pre ncbi-code">CPerson neighborhood("Moe", "123 Main St",<br />                     new CPerson("Larry", "127 Main St",<br />                     new CPerson("Curly", "131 Main St", 0)));<br />for (CTypeIterator&lt;CPerson&gt; house(Begin(neighborhood)); house; ++house ) {<br />    FullerBrushMan(*house);<br />}</span></pre><p>In this example, the data members visited by the iterator are of the same type as the top-level aggregate object, since <span class="nctnt ncbi-var">neighbor</span> is an instance of <span class="nctnt ncbi-class">CPerson</span>. Thus, the first "member" visited is the top-level object itself. This is not always the case however. The top-level object is only included in the iteration when it is an instance of the type specified in the template argument (<span class="nctnt ncbi-class">CPerson</span> in this case).</p><p>All of the NCBI C++ Toolkit type iterators are <span class="nctnt ncbi-monospace">recursive</span>. Thus, since <span class="nctnt ncbi-var">neighborhood</span> has <span class="nctnt ncbi-class">CPerson</span> data members, which in turn contain objects of type <span class="nctnt ncbi-class">CPerson</span>, all of the nested data members will also be visited by the above iterator. More generally, given a hierarchically structured object containing data elements of a given type nested several levels deep, the NCBI C++ Toolkit type iterators effectively generate a "flat" list of all these elements.</p><p>It is not difficult to imagine situations where recursive iterators such as the <span class="nctnt ncbi-class">CTypeIterator</span> could lead to infinite loops. An obvious example of this would be a doubly-linked list. For example, suppose <span class="nctnt ncbi-class">CPerson</span> had both <span class="nctnt ncbi-var">previous</span> and <span class="nctnt ncbi-var">next</span> data members, where <span class="nctnt ncbi-code">x-&gt;next-&gt;previous == x</span>. In this case, visiting <span class="nctnt ncbi-var">x</span> followed by <span class="nctnt ncbi-var">x-&gt;next</span> would lead back to <span class="nctnt ncbi-var">x</span> with no terminating condition. To address this issue, the <span class="nctnt ncbi-func">Begin()</span> function accepts an optional second argument, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EDetectLoops">eDetectLoops</a>. <span class="nctnt ncbi-var">eDetectLoops</span> is an <span class="nctnt ncbi-code">enum</span> value which, if included, specifies that the iterator should detect and avoid infinite loops. The resulting iterator will be somewhat slower but can be safely used on objects whose references might create loops.</p><p>Let's compare the syntax of this new iterator class to the standard iterators:</p><pre><span class="nctnt-pre ncbi-code">ContainerType&lt;T&gt; x;<br />for (ContainerType&lt;T&gt;::IteratorType i = x.begin(); i != x.end(); ++i)<br />for (CTypeIterator&lt;T&gt; i(Begin(ObjectName)); i; ++i)</span></pre><p>The standard iterator begins by pointing to the first item in the container <span class="nctnt ncbi-func">x.begin()</span>, and with each iteration, visits subsequent items until the end of the container <span class="nctnt ncbi-func">x.end()</span> is reached. Similarly, the <span class="nctnt ncbi-class">CTypeIterator</span> begins by pointing to the first data member of <span class="nctnt ncbi-var">ObjectName</span> that is of type <span class="nctnt ncbi-type">T</span>, and with each iteration, visits subsequent data members of type <span class="nctnt ncbi-type">T</span> until the end of the top-level object is reached.</p><p>A lot of code actually uses <span class="nctnt ncbi-code">= Begin(...)</span> instead of <span class="nctnt ncbi-code">(Begin(...))</span> to initialize iterators; although the alternate syntax is somewhat more readable and often works, some compilers can mis-handle it and give you link errors. As such, direct initialization as shown above generally works better. Also, note that this issue only applies to construction; you should (and must) continue to use <span class="nctnt ncbi-code">=</span> to reset existing iterators.</p><p>How are generic iterators such as these implemented? The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=Begin">Begin()</a> expression returns an object containing a pointer to the input object <span class="nctnt ncbi-var">ObjectName</span>, as well as a pointer to a <a href="ch_ser.html#ch_ser.typeinfo.html_ctypeinfo_ref">CTypeInfo</a> object containing <span class="nctnt ncbi-monospace">type information</span> about that object. On each iteration, the <span class="nctnt ncbi-code">++</span> operator examines the <b>current</b> type information to find the next data member which is of type <span class="nctnt ncbi-type">T</span>. The current object, its type information, and the state of iteration is pushed onto a local stack, and the iterator is then reset with a pointer to the next object found, and in turn, a pointer to its type information. Each data member of type <span class="nctnt ncbi-type">T</span> (or derived from type <span class="nctnt ncbi-type">T</span>) must be capable of providing its own type information as needed. This allows the iterator to recursively visit all data members of the specified type at all levels of nesting.</p><p>More specifically, each object included in the iteration, as well as the initial argument to <span class="nctnt ncbi-func">Begin()</span>, must have a statically implemented <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=GetTypeInfo">GetTypeInfo()</a> class member function to provide the needed type information. For example, all of the serializable objects generated by <a href="ch_app.html#ch_app.datatool">datatool</a> in the <span class="nctnt ncbi-path">src/objects</span> subtrees have <span class="nctnt ncbi-func">GetTypeInfo()</span> member functions. In order to apply type iterators to user-defined classes (as in the above example), these classes must also make their type information explicit. A set of macros described in the section on <a href="ch_ser.html#ch_ser.usrtypeinfo.html">User-defined Type Information</a> are provided to simplify the implementation of the <span class="nctnt ncbi-func">GetTypeInfo()</span> methods for user-defined classes. The example included at the end of this section (see <a href="ch_ser.html#ch_ser.iterators.html_appendix">Additional Information</a>) uses several of the C++ Toolkit type iterators and demonstrates how to apply some of these macros.</p><p>The <span class="nctnt ncbi-class">CTypeConstIterator</span> parallels the <span class="nctnt ncbi-class">CTypeIterator</span>, and is intended for use with <span class="nctnt ncbi-code">const</span> objects (i.e. when you want to prohibit modifications to the objects you are iterating over). For <span class="nctnt ncbi-code">const</span> iterators, the <span class="nctnt ncbi-func">ConstBegin()</span> function should be used in place of <span class="nctnt ncbi-func">Begin()</span>.</p></div><div class="sec" id="ch_ser.iterators.html_hier"><h3><span class="title">Class hierarchies, embedded objects, and the NCBI C++ type iterators</span></h3><p>As emphasized above, all of the objects visited by an iterator must have the <span class="nctnt ncbi-func">GetTypeInfo()</span> member function defined in order for the iterators to work properly. For an iterator that visits objects of type <span class="nctnt ncbi-type">T</span>, the type information provided by <span class="nctnt ncbi-func">GetTypeInfo()</span> is used to identify:</p><ul><li><p>data members of type <span class="nctnt ncbi-type">T</span></p></li><li><p>data members containing objects of type <span class="nctnt ncbi-type">T</span></p></li><li><p>data members derived from type <span class="nctnt ncbi-type">T</span></p></li><li><p>data members containing objects derived from type <span class="nctnt ncbi-type">T</span></p></li></ul><p>Explicit encoding of the class hierarchy via the <span class="nctnt ncbi-func">GetTypeInfo()</span> methods allows the user to deploy a type iterator over a single specified type which may in practice include a set of types via inheritance. The section <a href="ch_ser.html#ch_ser.iterators.html_appendix">Additional Information</a> includes a simple example of this feature. The preprocessor macros used in this example which support the encoding of hierarchical class relations are described in the <a href="ch_ser.html#ch_ser.usrtypeinfo.html">User-defined Type Information</a> section. A further generalization of this idea is implemented by the <a href="ch_ser.html#ch_ser.iterators.html_typesIt">CTypesIterator</a> described later.</p></div><div class="sec" id="ch_ser.iterators.html_cobjType"><h3><span class="title"><span class="nctnt ncbi-class">CObjectIterator</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial/iterator.hpp">*</a>) and <span class="nctnt ncbi-class">CObjectConstIterator</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial/iterator.hpp">*</a>)</span></h3><p>Because the <span class="nctnt ncbi-class">CObject</span> class is so central to the Toolkit, a special iterator is also defined, which can automatically distinguish <span class="nctnt ncbi-class">CObject</span>s from other class types. The syntax of a <span class="nctnt ncbi-class">CObjectIterator</span> is:</p><pre><span class="nctnt-pre ncbi-code">for (CObjectIterator i(Begin(ObjectName)); i; ++i)</span></pre><p>Note that there is no need to specify the object type to iterate over, as the type <span class="nctnt ncbi-class">CObject</span> is built into the iterator itself. This iterator will recursively visit all <span class="nctnt ncbi-class">CObject</span>s contained or referenced in <span class="nctnt ncbi-var">ObjectName</span>. The <span class="nctnt ncbi-class">CObjectConstIterator</span> is identical to the <span class="nctnt ncbi-class">CObjectIterator</span> but is designed to operate on <span class="nctnt ncbi-code">const</span> elements and uses the <span class="nctnt ncbi-func">ConstBegin()</span> function.</p><p>User-defined classes that are derived from <span class="nctnt ncbi-class">CObject</span> can also be iterated over (assuming their <span class="nctnt ncbi-func">GetTypeInfo()</span> methods have been implemented). In general however, care should be used in applying this type of iterator, as not all of the NCBI C++ Toolkit classes derived from <span class="nctnt ncbi-func">CObject</span> have implementations of the <span class="nctnt ncbi-func">GetTypeInfo()</span> method. <b>All</b> of the generated serializable objects in <span class="nctnt ncbi-path">include/objects</span> <b>do</b> have a defined <span class="nctnt ncbi-func">GetTypeInfo()</span> member function however, and thus can be iterated over using either a <span class="nctnt ncbi-class">CObjectIterator</span> or a <span class="nctnt ncbi-class">CTypeIterator</span> with an appropriate template argument.</p></div><div class="sec" id="ch_ser.iterators.html_stdType"><h3><span class="title"><span class="nctnt ncbi-class">CStdTypeIterator</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCStdTypeIterator.html">*</a>) and <span class="nctnt ncbi-class">CStdTypeConstIterator</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCStdTypeConstIterator.html">*</a>)</span></h3><p>All of the type iterators described thus far require that each object visited must provide its own type information. Hence, none of these can be applied to standard types such as <span class="nctnt ncbi-type">int, float, double</span> or the STL type <span class="nctnt ncbi-type">string</span>. The <span class="nctnt ncbi-class">CStdTypeIterator</span> and <span class="nctnt ncbi-class">CStdTypeConstIterator</span> classes selectively iterate over data members of a specified type. But for these iterators, the type <b>must</b> be a simple C type (<span class="nctnt ncbi-type">int, double, char*, etc.</span>) or an STL type <span class="nctnt ncbi-type">string</span>. For example, to iterate over all the <span class="nctnt ncbi-type">string</span> data members in a <span class="nctnt ncbi-class">CPerson</span> object, we could use:</p><pre><span class="nctnt-pre ncbi-code">for (CStdTypeIterator&lt;string&gt; i(Begin(neighborhood)); i; ++i) {<br />    cout &lt;&lt; *i &lt;&lt; ' ';<br />}</span></pre><p>The <span class="nctnt ncbi-class">CStdTypeConstIterator</span> is identical to the <span class="nctnt ncbi-class">CStdTypeIterator</span> but is designed to operate on <span class="nctnt ncbi-code">const</span> elements and requires the <span class="nctnt ncbi-func">ConstBegin()</span> function.</p><p>For examples using <span class="nctnt ncbi-class">CTypeIterator</span> and <span class="nctnt ncbi-class">CStdTypeIterator</span>, see <a href="ch_ser.html#ch_ser.ctypeiter_cpp.html">Code Sample 2 (ctypeiter.cpp)</a> and <a href="ch_ser.html#ch_ser.ctypeiter_hpp.html">Code Sample 3 (ctypeiter.hpp)</a>.</p><div class="box" id="ch_ser.ctypeiter_cpp.html"><h4><span class="title">Code Sample 2. ctypeiter.cpp</span></h4><pre><span class="nctnt-pre ncbi-code">// File name: ctypeiter.cpp<br />// Description: Demonstrate using a CTypeIterator<br />// Notes: build with xncbi and xser libraries<br /><br />#include "</span><a href="ch_ser.html#ch_ser.ctypeiter_hpp.html">ctypeiter.hpp</a><span class="nctnt-pre ncbi-code">"<br />#include &lt;serial/serial.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/objostr.hpp&gt;<br />#include &lt;serial/iterator.hpp&gt;<br />#include &lt;serial/serialimpl.hpp&gt;<br /><br />//  type information for class CPerson<br />BEGIN_CLASS_INFO(CPerson){<br />    ADD_STD_MEMBER(m_Name);<br />    ADD_STD_MEMBER(m_Addr);<br />    ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)))-&gt;SetOptional();<br />}END_CLASS_INFO<br /><br />//  type information for class CDistrict<br />BEGIN_CLASS_INFO(CDistrict){<br />    ADD_STD_MEMBER(m_Number);<br />    ADD_MEMBER(m_Blocks, STL_list, (CLASS, (CPerson)));<br />}END_CLASS_INFO<br /><br />// main and other functions<br />USING_NCBI_SCOPE;<br /><br />static void FullerBrushMan (const CPerson&amp; p) {<br />    cout &lt;&lt; "knock-knock! is " &lt;&lt; p.m_Name &lt;&lt; " home?" &lt;&lt; endl;<br />}<br /><br />int main(int argc, char** argv)<br />{<br />    // Instantiate a few CPerson objects<br />    CPerson neighborhood("Moe", "1 Main St",<br />                         new CPerson("Larry", "2 Main St",<br />                                     new CPerson("Curly", "3 Main St", 0)));<br />    CPerson another("Harpo", "2 River Rd",<br />                    new CPerson("Chico", "4 River Rd",<br />                                new CPerson("Groucho", "6 River Rd", 0)));<br /><br />    // Create a CDistrict and install some CPerson objects<br />    CDistrict district1(1);<br />    district1.AddBlock(neighborhood);<br />    district1.AddBlock(another);<br />    // Send the FullerBrushMan to all CPersons in district1<br />    for (CTypeConstIterator&lt;CPerson&gt; house = ConstBegin(district1);<br />         house; ++house ) {<br />        FullerBrushMan(*house);<br />    }<br />    // Iterate over all strings for the CPersons in district1<br />    list&lt;CPerson&gt; blocks = district1.GetBlocks();<br />    for (list&lt;CPerson&gt;::iterator b = blocks.begin(); b != blocks.end(); ++b) {<br />        for (CStdTypeIterator&lt;string&gt; i = Begin(*b); i; ++i) {<br />            cout &lt;&lt; *i &lt;&lt; ' ';<br />        }<br />        cout &lt;&lt; endl;<br />    }<br />    return 0;<br />}</span></pre></div><div class="box" id="ch_ser.ctypeiter_hpp.html"><h4><span class="title">Code Sample 3. ctypeiter.hpp</span></h4><pre><span class="nctnt-pre ncbi-code">// File name: ctypeiter.hpp<br /><br />#ifndef CTYPEITER_HPP<br />#define CTYPEITER_HPP<br /><br />#include &lt;corelib/ncbistd.hpp&gt;<br />#include &lt;corelib/ncbiobj.hpp&gt;<br />#include &lt;serial/typeinfo.hpp&gt;<br />#include &lt;string&gt;<br />#include &lt;list&gt;<br /><br />USING_NCBI_SCOPE;<br /><br />class CPerson<br />{<br />public:<br />    CPerson(void)<br />        : m_Name(0), m_Addr(0), m_NextDoor(0) {}<br />    CPerson(string n, string s, CPerson* p)<br />        : m_Name(n), m_Addr(s), m_NextDoor(p) {}<br />    virtual ~CPerson(void) {}<br />    static const CTypeInfo* GetTypeInfo(void);<br />private:<br />    string m_Name, m_Addr;<br />    CPerson *m_NextDoor;<br />};<br /><br />class CDistrict<br />{<br />public:<br />    CDistrict(void)<br />        : m_Number(0) {}<br />    CDistrict(int n) : m_Number(n) {}<br />    virtual ~CDistrict(void) {}<br />    static const CTypeInfo* GetTypeInfo(void);<br />    int m_Number;<br />    void AddBlock (const CPerson&amp; p) { m_Blocks.push_back(p); }<br />    list&lt;CPerson&gt;&amp; GetBlocks() { return m_Blocks; }<br />private:<br />    list&lt;CPerson&gt; m_Blocks;<br />};<br />#endif /* CTYPEITER_HPP */</span></pre></div></div><div class="sec" id="ch_ser.iterators.html_typesIt"><h3><span class="title"><span class="nctnt ncbi-class">CTypesIterator</span> (<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident?i=CTypesIterator">*</a>)</span></h3><p>Sometimes it is necessary to iterate over a set of types contained inside an object. The <span class="nctnt ncbi-class">CTypesIterator</span>, as its name suggests, is designed for this purpose. For example, suppose you have loaded a gene sequence into memory as a <span class="nctnt ncbi-class">CBioseq</span> (named <span class="nctnt ncbi-var">seq</span>), and want to iterate over all of its references to genes and organisms. The following sequence of statements defines an iterator that will step through all of <span class="nctnt ncbi-var">seq</span>'s data members (recursively), stopping only at references to gene and organism citations:</p><pre><span class="nctnt-pre ncbi-code">CTypesIterator i;<br />CType&lt;CGene_ref&gt;::AddTo(i);    // define the types to stop at<br />CType&lt;COrg_ref&gt;::AddTo(i);<br /><br />for (i = Begin(seq); i; ++i) {<br /><br />    if (CType&lt;CGene_ref&gt;::Match(i)) {<br />        CGene_ref* geneRef = CType&lt;CGene_ref&gt;::Get(i);<br />        ...<br />    }<br />    else if (CType&lt;COrg_ref&gt;::Match(i) {<br />        COrg_ref* orgRef = CType&lt;COrg_ref&gt;::Get(i);<br />        ...<br />    }<br />}</span></pre><p>Here, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCType.html">CType</a> is a helper template class that simplifies the syntax required to use the multiple types iterator:</p><ul><li><p><span class="nctnt ncbi-code">CType&lt;TypeName&gt;::AddTo(i)</span> specifies that iterator <span class="nctnt ncbi-var">i</span> should stop at type <span class="nctnt ncbi-type">TypeName</span>.</p></li><li><p><span class="nctnt ncbi-code">CType&lt;TypeName&gt;::Match(i)</span> returns <span class="nctnt ncbi-monospace">true</span> if the specified type <span class="nctnt ncbi-type">TypeName</span> is the type currently pointed to by iterator <span class="nctnt ncbi-var">i</span>.</p></li><li><p><span class="nctnt ncbi-code">CType&lt;TypeName&gt;::Get(i)</span> retrieves the object currently pointed to by iterator <span class="nctnt ncbi-var">i</span><b>if</b> there is a type match to <span class="nctnt ncbi-type">TypeName</span>, and otherwise returns 0. In the event there is a type match, the retrieved object is type cast to <span class="nctnt ncbi-type">TypeName</span> before it is returned.</p></li></ul><p>The <span class="nctnt ncbi-func">Begin()</span> expression is as described for the above <span class="nctnt ncbi-class">CTypeIterator</span> and <span class="nctnt ncbi-class">CTypeConstIterator</span> classes. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CTypesConstIterator">CTypesConstIterator</a> is the <span class="nctnt ncbi-code">const</span> implementation of this type of iterator, and requires the <span class="nctnt ncbi-func">ConstBegin()</span> function.</p></div><div class="sec" id="ch_ser.iterators.context_filter"><h3><span class="title">Context Filtering In Type Iterators</span></h3><p>In addition to traversing objects of a specific type one might want to specify the structural context in which such objects should appear. For example, you might want to iterate over <span class="nctnt ncbi-type">string</span> data members, but only those called <span class="nctnt ncbi-monospace">title</span>. This could be done using context filtering. Such a filter is a string with the format identical to the one used in <a href="ch_ser.html#ch_ser.stack_path_hooks">Stack Path Hooks</a> and is specified as an additional parameter of a type iterator. So, for example, the declaration of a string data member iterator with context filtering could look like this:</p><pre><span class="nctnt-pre ncbi-code">CStdTypeIterator&lt;string&gt; i(Begin(my_obj), "*.title")</span></pre></div><div class="sec" id="ch_ser.iterators.html_appendix"><h3><span class="title">Additional Information</span></h3><p>The following example demonstrates how the class hierarchy determines which data members will be included in a type iterator. The example uses five simple classes:</p><ul><li><p>Class <span class="nctnt ncbi-class">CA</span> contains a single <span class="nctnt ncbi-type">int</span> data member and is used as a target object type for the type iterators demonstrated.</p></li><li><p>class <span class="nctnt ncbi-class">CB</span> contains an <span class="nctnt ncbi-class">auto_ptr</span> to a <span class="nctnt ncbi-class">CA</span> object.</p></li><li><p>Class <span class="nctnt ncbi-class">CC</span> is derived from <span class="nctnt ncbi-class">CA</span> and is used to demonstrate the usage of class hierarchy information.</p></li><li><p>Class <span class="nctnt ncbi-class">CD</span> contains an <span class="nctnt ncbi-class">auto_ptr</span> to a <span class="nctnt ncbi-class">CC</span> object, and, since it is derived from <span class="nctnt ncbi-class">CObject</span>, can be used as the object pointed to by a <a href="ch_core.html#ch_core.smart_ptrs">CRef</a>.</p></li><li><p>Class <span class="nctnt ncbi-class">CX</span> contains both pointers-to and instances-of <span class="nctnt ncbi-class">CA, CB, CC</span>, and <span class="nctnt ncbi-class">CD</span> objects, and is used as the argument to <span class="nctnt ncbi-func">Begin()</span> for the demonstrated type iterators.</p></li></ul><p>The preprocessor macros used in this example implement the <span class="nctnt ncbi-func">GetTypeInfo()</span> methods for the classes, and are described in the section on <a href="ch_ser.html#ch_ser.usrtypeinfo.html">User-defined type information</a>.</p><pre><span class="nctnt-pre ncbi-code">// Define a simple class to use as iterator's target objects<br />class CA<br />{<br />public:<br />    CA() : m_Data(0) {};<br />    CA(int n) : m_Data(n) {};<br />    static const CTypeInfo* GetTypeInfo(void);<br />    int m_Data;<br />};<br />// Define a class containing an auto_ptr to the target class<br />class CB<br />{<br />public:<br />    CB() : m_a(0) {};<br />    static const CTypeInfo* GetTypeInfo(void);<br />    auto_ptr&lt;CA&gt; m_a;<br />};<br />// define a subclass of the target class<br />class CC : public CA<br />{<br />public:<br />    CC() : CA(0){};<br />    CC(int n) : CA(n){};<br />    static const CTypeInfo* GetTypeInfo(void);<br />};<br /><br />// define a class derived from CObject to use in a CRef<br />// this class also contains an auto_ptr to the target class<br />class CD : public CObject<br />{<br />public:<br />    CD() : m_c(0) {};<br />    static const CTypeInfo* GetTypeInfo(void);<br />    auto_ptr&lt;CC&gt; m_c;<br />};<br />// This class will be the argument to the iterator. It contains 4<br />// instances of CA - directly, through pointers, and via inheritance<br />class CX<br />{<br />public:<br />    CX() : m_a(0), m_b(0), m_d(0) {};<br />    ~CX(){};<br />    static const CTypeInfo* GetTypeInfo(void);<br />    auto_ptr&lt;CA&gt; m_a; // auto_ptr to a CA<br />    CB *m_b;          // pointer to an object containing a CA<br />    CC  m_c;          // instance of a subclass of CA<br />    CRef&lt;CD&gt; m_d;     // CRef to an object containing an auto_ptr to CC<br />};<br />//////////  Implement the GetTypeInfo() methods /////////<br />////////// (see </span><a href="ch_ser.html#ch_ser.usrtypeinfo.html">User-defined type information</a><span class="nctnt-pre ncbi-code">)  /////////<br />BEGIN_CLASS_INFO(CA)<br />{<br />    ADD_STD_MEMBER(m_Data);<br />    ADD_SUB_CLASS(CC);<br />}<br />END_CLASS_INFO<br /><br /><br />BEGIN_CLASS_INFO(CB)<br />{<br />    ADD_MEMBER(m_a, STL_auto_ptr, (CLASS, (CA)));<br />}<br />END_CLASS_INFO<br /><br /><br />BEGIN_DERIVED_CLASS_INFO(CC, CA)<br />{<br />}<br />END_DERIVED_CLASS_INFO<br /><br /><br />BEGIN_CLASS_INFO(CD)<br />{<br />    ADD_MEMBER(m_c, STL_auto_ptr, (CLASS, (CC)));<br />}<br />END_CLASS_INFO<br /><br /><br />BEGIN_CLASS_INFO(CX)<br />{<br />    ADD_MEMBER(m_a, STL_auto_ptr, (CLASS, (CA)));<br />    ADD_MEMBER(m_b, POINTER, (CLASS, (CB)));<br />    ADD_MEMBER(m_c, CLASS, (CC));<br />    ADD_MEMBER(m_d, STL_CRef, (CLASS, (CD)));<br />}<br />END_CLASS_INFO<br /><br />int main(int argc, char** argv)<br />{<br />    CB b;<br />    CD d;<br /><br />    b.m_a.reset(new CA(2));<br />    d.m_c.reset(new CC(4));<br />    CX x;<br /><br />    x.m_a.reset(new CA(1));    // auto_ptr to CA<br />    x.m_b = &amp;b;            // pointer to CB containing auto_ptr to CA<br />    x.m_c = *(new CC(3));      // instance of subclass of CA<br />    x.m_d = &amp;d;            // CRef to CD containing auto_ptr to CC<br /><br />    cout &lt;&lt; "Iterating over CA objects in x" &lt;&lt; endl &lt;&lt; endl;<br /><br />    for (CTypeIterator&lt;CA&gt; i(Begin(x)); i; ++i)<br />        cout &lt;&lt; (*i).m_Data &lt;&lt; endl;<br /><br />    cout &lt;&lt; "Iterating over CC objects in x" &lt;&lt; endl &lt;&lt; endl;<br /><br />    for (CTypeIterator&lt;CC&gt; i(Begin(x)); i; ++i)<br />        cout &lt;&lt; (*i).m_Data &lt;&lt; endl;<br /><br />    cout &lt;&lt; "Iterating over CObjects in x" &lt;&lt; endl &lt;&lt; endl;<br />    for (CObjectIterator i(Begin(x)); i; ++i) {<br />        const CD *tmp = dynamic_cast&lt;const CD*&gt;(&amp;*i);<br />        cout &lt;&lt; tmp-&gt;m_c-&gt;m_Data &lt;&lt; endl;<br />    }<br />    return 0;<br />}</span></pre><p>Figure 1 illustrates the paths traversed by <span class="nctnt ncbi-class">CTypeIterator&lt;CA&gt;</span> and <span class="nctnt ncbi-class">CTypeIterator&lt;CC&gt;</span>, where both iterators are initialized with <span class="nctnt ncbi-func">Begin(a)</span>. The data members visited by the iterator are indicated by enclosing boxes. See <a href="ch_ser.html#ch_ser.F2">Figure 1</a>.</p><div class="figure" id="ch_ser.F2"><div class="graphic"><img src="img/typeiter.gif" alt="Figure 1. Traversal path of the CTypeIterator" /></div><div class="caption"><p>Figure 1. Traversal path of the CTypeIterator</p></div></div><p>For additional examples of using the type iterators described in this section, see <a href="ch_ser.html#ch_ser.ctypeiter_cpp.html">ctypeiter.cpp</a>.</p></div></div><div class="sec" id="ch_ser.asn.html"><h2><span class="title">Processing Serial Data</span></h2><p>Although this discussion focuses on ASN.1 and XML formatted data, the data structures and tools described here have been designed to (potentially) support any formalized serial data specification. Many of the tools and objects have open-ended abstract or template implementations that can be instantiated differently to fit various specifications.</p><p>The following topics are discussed in this section</p><ul><li><p><a href="ch_ser.html#ch_ser.asn.html_headersandlibs">Accessing the object header files and serialization libraries</a></p></li><li><p><a href="ch_ser.html#ch_ser.asn.html_example1">Reading and writing serial data</a></p></li><li><p><a href="ch_ser.html#ch_ser.Reading_and_writing_binary_JSON_d">Reading and writing binary JSON data</a></p></li><li><p><a href="ch_ser.html#ch_ser.asn.html_includes">Determining Which Header Files to Include</a></p></li><li><p><a href="ch_ser.html#ch_ser.asn.html_linklibs">Determining Which Libraries to Link To</a></p></li></ul><div class="sec" id="ch_ser.asn.html_headersandlibs"><h3><span class="title">Accessing the object header files and serialization libraries</span></h3><p>Reading and writing serialized data is implemented by an integrated set of streams, filters, and object types. An application that reads encoded data files will require the object header files and libraries which define how these serial streams of data should be loaded into memory. This entails <span class="nctnt ncbi-code">#include</span> statements in your source files, as well as the associated library specifications in your makefiles. The object header and implementation files are located in the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects">include/objects</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects">src/objects</a> subtrees of the C++ tree, respectively. The header and implementation files for serialized streams and type information are in the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial">include/serial</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/serial">src/serial</a> directories.</p><p>If you have checked out the <span class="nctnt ncbi-path">objects</span> directories, but not explicitly run the <a href="ch_app.html#ch_app.datatool">datatool</a> code generator, then you will find that your <span class="nctnt ncbi-path">include/objects</span> subdirectories are (almost) empty, and the source subdirectories contain only makefiles and ASN.1 specifications. These makefiles and ASN.1 specifications can be used to build your own copies of the objects' header and implementation files, using <span class="nctnt ncbi-cmd">make all_r</span> (if you configured using the <span class="nctnt ncbi-cmd">--with-objects</span> flag), or running datatool explicitly.</p><p>However, building your own local copies of these header and implementation files is neither necessary nor recommended, as it is simpler to use the pre-generated header files and prebuilt libraries. The pre-built header and implementation files can be found in <span class="nctnt ncbi-path">$NCBI/c++/include/objects/</span> and <span class="nctnt ncbi-path">$NCBI/c++/src/objects/</span>, respectively. Assuming your makefile defines an include path to <span class="nctnt ncbi-path">$NCBI/c++/include</span>, selected object header files such as <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/general/Date.hpp">Date.hpp</a>, can be included as:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;objects/general/Date.hpp&gt;</span></pre><p>This header file (along with its implementations in the accompanying <span class="nctnt ncbi-path">src</span> directory) was generated by <a href="ch_app.html#ch_app.datatool">datatool</a> using the specifications from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/general/general.asn">src/objects/general/general.asn</a>. In order to use the classes defined in the <span class="nctnt ncbi-path">objects</span> directories, your source code should begin with the statements:</p><pre><span class="nctnt-pre ncbi-code">USING_NCBI_SCOPE;<br />using namespace objects;</span></pre><p>All of the objects' header and implementation files are generated by <span class="nctnt ncbi-app">datatool</span>, as specified in the ASN.1 specification files. The resulting object definitions however, are not in any way dependent on ASN.1 format, as they simply specify the in-memory representation of the defined data types. Accordingly, the objects themselves can be used to read, interpret, and write any type of serialized data. Format specializations on the input stream are implemented via <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStream.html">CObjectIStream</a> objects, which extract the required tags and values from the input data according to the format specified. Similarly, Format specializations on an output stream are implemented via <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStream.html">CObjectOStream</a> objects.</p></div><div class="sec" id="ch_ser.asn.html_example1"><h3><span class="title">Reading and writing serial data</span></h3><p>Let's consider a program <a href="ch_ser.html#ch_ser.xml2asn_cpp.html">xml2asn.cpp</a> that translates an XML data file containing an object of type <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mmdb1/mmdb1.asn">Biostruc</a>, to ASN.1 text and binary formats. In <span class="nctnt ncbi-func">main()</span>, we begin by initializing the diagnostic stream to write errors to a local file called <span class="nctnt ncbi-path">xml2asn.log</span>. (Exception handling, program tracing, and error logging are described in the <a href="ch_core.html#ch_core.diag">Diagnostic Streams</a> section).</p><p>An instance of the <span class="nctnt ncbi-class">CTestAsn</span> class is then created, and its member function <span class="nctnt ncbi-func">AppMain()</span> is invoked. This function in turn calls <span class="nctnt ncbi-func">CTestAsn::Run()</span>. The first three lines of code there define the XML input and ASN.1 output streams, using <a href="ch_core.html#ch_core.smart_ptrs">auto_ptr</a>, to ensure automatic destruction of these objects.</p><p>Each stream is associated with data serialization mechanisms appropriate to the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ESerialDataFormat">ESerialDataFormat</a> provided to the constructor:</p><pre><span class="nctnt-pre ncbi-code">enum ESerialDataFormat {<br />    eSerial_None      = 0,<br />    eSerial_AsnText   = 1,   /// ASN.1 text<br />    eSerial_AsnBinary = 2,   /// ASN.1 binary<br />    eSerial_Xml       = 3,   /// XML<br />    eSerial_Json      = 4    /// JSON<br />};</span></pre><p><span class="nctnt ncbi-class">CObjectIStream</span> and <span class="nctnt ncbi-class">CObjectOStream</span> are base classes which provide generic interfaces between the specific type information of a serializable object and an I/O stream. The object stream classes that will actually be instantiated by this application, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStreamXml.html">CObjectIStreamXml</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStreamAsn.html">CObjectOStreamAsn</a>, and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStreamAsnBinary.html">CObjectOStreamAsnBinary</a>, are descendants of these base classes.</p><p>Finally, a variable for the object type that will be generated from the input stream (in this case a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc.html">CBiostruc</a>) is defined, and the <span class="nctnt ncbi-class">CObject[I/O]Stream</span> operators "&lt;&lt;" and "&gt;&gt;" are used to read and write the serialized data to and from the object. (Note that it is <b>not</b> possible to simply "pass the data through", from the input stream to the output stream, using a construct like: <span class="nctnt ncbi-code">*inObject &gt;&gt; *outObject</span>). The <span class="nctnt ncbi-class">CObject[I/O]Stream</span>s know nothing about the structure of the specific object - they have knowledge only of the serialization format (text ASN, binary ASN, XML, etc.). In contrast, the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc.html">CBiostruc</a> knows nothing about I/O and serialization formats, but it contains explicit type information about itself. Thus, the <span class="nctnt ncbi-class">CObject[I/O]Stream</span>s can apply their specialized serialization methods to the data members of <span class="nctnt ncbi-class">CBiostruc</span> using the <a href="ch_ser.html#ch_ser.typeinfo.html_ctypeinfo_ref">type information</a> associated with that object's class.</p></div><div class="sec" id="ch_ser.Reading_and_writing_binary_JSON_d"><h3><span class="title">Reading and writing binary JSON data</span></h3><p>JSON is a purely text format - that is, all data values are string representations. Therefore, binary data cannot be serialized or deserialized as JSON without specifying an encoding. Furthermore, the encoding choice is not automatically stored with the encoded data, so the (de)serialization process must explicitly select an encoding.</p><p>The following code shows how to read binary JSON data:</p><pre><span class="nctnt-pre ncbi-code">// Create JSON data with a Base64 encoded binary field.<br />char jsonb[] = "{ \"Seq_data\": { \"ncbi2na\": \"ASNFZ4mrze8=\" } }";<br />CNcbiIstrstream iss(jsonb);<br /><br />// Read the JSON data into a Seq-data object, using Base64 encoding.<br />CObjectIStreamJson ijson;<br />ijson.Open(iss);<br />CSeq_data mySeq_data;<br />ijson.SetBinaryDataFormat(CObjectIStreamJson::eString_Base64);<br />ijson &gt;&gt; mySeq_data;</span></pre><p>The following code shows how to write binary JSON data:</p><pre><span class="nctnt-pre ncbi-code">// Use ASN.1 data to populate a Seq-data object.<br />char asn[] = "Seq-data ::= ncbi2na '0123456789ABCDEF'H";<br />CNcbiIstrstream iss(asn);<br />auto_ptr&lt;CObjectIStream&gt; in(CObjectIStream::Open(eSerial_AsnText, iss));<br />CSeq_data mySeq_data;<br />*in &gt;&gt; mySeq_data;<br /><br />// Write the Seq-data object in JSON format with Base64 binary encoding.<br />CObjectOStreamJson ojson(cout, false);<br />ojson.SetBinaryDataFormat(CObjectOStreamJson::eString_Base64);<br />ojson &lt;&lt; mySeq_data;</span></pre></div><div class="sec" id="ch_ser.asn.html_includes"><h3><span class="title">Determining Which Header Files to Include</span></h3><p>As always, we include the <span class="nctnt ncbi-path">corelib</span> header files, <span class="nctnt ncbi-path">ncbistd.hpp</span> and <span class="nctnt ncbi-path">ncbiapp.hpp</span>. In addition, the <span class="nctnt ncbi-path">serial</span> header files that define the generic <span class="nctnt ncbi-class">CObject[IO]Stream</span> objects are included, along with <span class="nctnt ncbi-path">serial.hpp</span>, which defines generalized serialization mechanisms including the insertion (<span class="nctnt ncbi-code">&lt;&lt;</span>) and extraction (<span class="nctnt ncbi-code">&gt;&gt;</span>) operators. Finally, we need to include the header file for the object type we will be using.</p><p>There are two source browsers that can be used to locate the appropriate header file for a particular object type. Object class names in the NCBI C++ Toolkit begin with the letter "C". Using the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/hierarchy.html">class hierarchy browser</a>, we find <span class="nctnt ncbi-class">CBiostruc</span>, derived from <span class="nctnt ncbi-class">CBiostruc_Base</span>, which is in turn derived from <span class="nctnt ncbi-class">CObject</span>. Following the <span class="nctnt ncbi-monospace">CBiostruc</span> link, we can then use the <span class="nctnt ncbi-monospace">locate</span> button to move to the LXR source code navigator, and there, find the name of the header file. In this case, we find <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb1/Biostruc.hpp">CBiostruc.hpp</a> is located in <span class="nctnt ncbi-path">include/objects/mmdb1</span>. Alternatively, if we know the name of the C++ class, the source code navigator's <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">identifier search</a> tool can be used directly. In summary, the following <span class="nctnt ncbi-code">#include</span> statements appear at the top of <a href="ch_ser.html#ch_ser.xml2asn_cpp.html">xml2asn.cpp</a>:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;corelib/ncbiapp.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/objostr.hpp&gt;<br />#include &lt;objects/mmdb1/Biostruc.hpp&gt;</span></pre></div><div class="sec" id="ch_ser.asn.html_linklibs"><h3><span class="title">Determining Which Libraries to Link To</span></h3><p>Determining which libraries must be linked to requires a bit more work and may involve some trial and error. The list of available libraries currently includes:</p><p><span class="nctnt ncbi-var">access biblio cdd featdef general medlars medline mmdb1 mmdb2 mmdb3 ncbimime objprt proj pub pubmed seq seqalign seqblock seqcode seqfeat seqloc seqres seqset submit xcgi xconnect xfcgi xhtml xncbi xser</span></p><p>It should be clear that we will need to link to the core library, <span class="nctnt ncbi-path">xncbi</span>, as well as to the serial library, <span class="nctnt ncbi-path">xser</span>. In addition, we will need to link to whatever object libraries are entailed by using a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc.html">CBiostruc</a> object. Minimally, one would expect to link to the <span class="nctnt ncbi-path">mmdb</span> libraries. This in itself is insufficient however, as the <span class="nctnt ncbi-class">CBiostruc</span> class embeds other types of objects, including PubMed citations, features, and sequences, which in turn embed additional objects such as <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDate.html">Date</a>. The makefile for <span class="nctnt ncbi-path">xml2asn.cpp</span>, <span class="nctnt ncbi-path">Makefile.xml2asn.app</span> lists the libraries required for linking in the make variable <span class="nctnt ncbi-var">LIB</span>.</p><pre><span class="nctnt-pre ncbi-code">#########################################################################<br /># This file was originally generated from by shell script "new_project.sh"<br />#########################################################################<br />APP = xml2asn<br />OBJ = xml2asn<br />LIB = mmdb1 mmdb2 mmdb3 seqloc seqfeat pub medline biblio general xser xncbi<br />LIBS = $(NCBI_C_LIBPATH) -lncbi $(ORIG_LIBS)</span></pre><p>See also the example program, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/asn2asn/asn2asn.cpp">asn2asn.cpp</a> which demonstrates more generalized translation of <span class="nctnt ncbi-type">Seq-entry</span> and <span class="nctnt ncbi-type">Bioseq-set</span> (defined in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqset/seqset.asn">seqset.asn</a>).</p><p><span class="nctnt highlight">Note:</span> Two online tools are available to help determine which libraries to link with. See the <a href="ch_faq.html#ch_faq.faq.CannotFindObjectSymbol">FAQ</a> for details.</p></div></div><div class="sec" id="ch_ser.usrtypeinfo.html"><h2><span class="title">User-defined type information</span></h2><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_ser.html#ch_ser.usrtypeinfo.html_introduction">Introduction</a></p></li><li><p><a href="ch_ser.html#ch_ser.usrtypeinfo.html_macros">Installing a GetTypeInfo() function: the BEGIN_/END_macros</a></p></li><li><p><a href="ch_ser.html#ch_ser.usrtypeinfo.html_addm">Specifying internal structure and class inheritance: the ADD_ macros</a></p></li></ul><div class="sec" id="ch_ser.usrtypeinfo.html_introduction"><h3><span class="title">Introduction</span></h3><p>Object type information, as it is used in the NCBI C++ Toolkit, is defined in the section on <a href="ch_ser.html#ch_ser.typeinfo.html">Runtime Object Type Information</a>. As described there, all of the classes and constructs defined in the serial <span class="nctnt ncbi-path">include</span> and <span class="nctnt ncbi-path">src</span> directories have a static implementation of a <span class="nctnt ncbi-func">GetTypeInfo()</span> function that yields a <a href="ch_ser.html#ch_ser.typeinfo.html_ctypeinfo_ref">CTypeInfo</a> for the object of interest. In this section, we describe how type information can also be generated and accessed for user-defined types. We begin with a review of some of the basic notions introduced in the previous discussion.</p><p>The type information for a class is stored outside any instances of that class, in a statically created <a href="ch_ser.html#ch_ser.typeinfo.html_ctypeinfo_ref">CTypeInfo</a> object. A class's type information includes the class layout, inheritance relations, external alias, and various other attributes that are independent of specific instances. In addition, the type information object provides an interface to the class's data members.</p><p>Limited type information is also available for primitive data types, enumerations, containers, and pointers. The type information for a primitive type specifies that it is an <span class="nctnt ncbi-type">int, float,</span> or <span class="nctnt ncbi-type">char</span>, etc., and whether or not that element is signed. Enumerations are a special kind of primitive type, whose type information specifies its enumeration values and named elements. Type information for containers can specify both the type of container and the type of elements. The type information for a pointer provides convenient methods of access to the type information for the type pointed to.</p><p>For all types, the type information is encoded in a static <span class="nctnt ncbi-class">CTypeInfo</span> object, which is then accessed by all instances of a given type using a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=GetTypeInfo">GetTypeInfo()</a> function. For class types, this function is implemented as a static method for the class. For non class types, <span class="nctnt ncbi-func">GetTypeInfoXxx()</span> is implemented as a static global function, where <i>Xxx</i> is a unique suffix generated from the type's name. With the first invocation of <span class="nctnt ncbi-func">GetTypeInfo()</span> for a given type, the static <span class="nctnt ncbi-class">CTypeInfo</span> object is created, which then persists (local to the function <span class="nctnt ncbi-func">GetTypeInfo()</span>) throughout execution. Subsequent calls to <span class="nctnt ncbi-func">GetTypeInfo()</span> simply return a pointer to this statically created local object.</p><p>In order to make type information about <span class="nctnt ncbi-monospace">user-defined</span> classes accessible to your application, the user-defined classes must also implement a static <span class="nctnt ncbi-func">GetTypeInfo()</span> method. A set of preprocessor <a href="ch_ser.html#ch_ser.usrtypeinfo.html_macros">macros</a> is available, which greatly simplifies this effort. A pre-requisite to using these macros however, is that the class definition must include the following line:</p><pre><span class="nctnt-pre ncbi-code">DECLARE_INTERNAL_TYPE_INFO();</span></pre><p>This pre-processor macro will generate the following in-line statement in the class definition:</p><pre><span class="nctnt-pre ncbi-code">static const NCBI_NS_NCBI::CTypeInfo* GetTypeInfo(void);</span></pre><p>As with class objects, there must be some means of declaring the type information function for an enumeration prior to using the macros which implement that function. Given an enumeration named <span class="nctnt ncbi-type">EMyEnum</span>, <span class="nctnt ncbi-code">DECLARE_ENUM_INFO(EMyEnum)</span> will generate the following declaration:</p><pre><span class="nctnt-pre ncbi-code">const CEnumeratedTypeValues* GetTypeInfo_enum_EMyEnum(void);</span></pre><p>The <span class="nctnt ncbi-macro">DECLARE_ENUM_INFO()</span> macro should appear in the header file where the enumeration is defined, immediately following the definition. The <span class="nctnt ncbi-macro">DECLARE_INTERNAL_ENUM_INFO</span> macro is intended for usage with internal class definitions, as in:</p><pre><span class="nctnt-pre ncbi-code">class ClassWithEnum {<br />    enum EMyEnum {<br />        ...<br />    };<br /><br />    DECLARE_INTERNAL_ENUM_INFO(EMyEnum);<br />    ...<br />};</span></pre><p>The C++ Toolkit also allows one to provide type information for legacy C style <span class="nctnt ncbi-code">struct</span> and <span class="nctnt ncbi-monospace">choice</span> elements defined in the C Toolkit. The mechanisms used to implement this are mentioned but not described in detail here, as it is not likely that newly-defined types will be in these categories.</p></div><div class="sec" id="ch_ser.usrtypeinfo.html_macros"><h3><span class="title">Installing a GetTypeInfo() function: the BEGIN_/END_macros</span></h3><p>Several pre-processor macros are available for the installation of the <span class="nctnt ncbi-func">GetTypeInfo()</span> functions for different types. <a href="ch_ser.html#ch_ser.T2">Table 2</a> lists six <span class="nctnt ncbi-macro">BEGIN_NAMED_*_INFO</span> macros, along with a description of the type of object each can be applied to and its expected arguments. Each macro in Table 2 has a corresponding <span class="nctnt ncbi-macro">END_*_INFO</span> macro definition.</p><div class="table" id="ch_ser.T2"><div class="caption"><p>Table 2. BEGIN_NAMED_* Macro names and their usage</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Macro name</th><th align="left" valign="top" rowspan="1" colspan="1">Used for</th><th align="left" valign="top" rowspan="1" colspan="1">Arguments</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.usrtypeinfo.html_class_ref"> BEGIN_NAMED_CLASS_INFO </a></td><td align="left" valign="top" rowspan="1" colspan="1">Non-abstract class object</td><td align="left" valign="top" rowspan="1" colspan="1">ClassAlias, ClassName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.usrtypeinfo.html_class_ref"> BEGIN_NAMED_ABSTRACT_CLASS_INFO </a></td><td align="left" valign="top" rowspan="1" colspan="1">Abstract class object</td><td align="left" valign="top" rowspan="1" colspan="1">ClassAlias, ClassName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.usrtypeinfo.html_class_ref"> BEGIN_NAMED_DERIVED_CLASS_INFO </a></td><td align="left" valign="top" rowspan="1" colspan="1">Derived subclass object</td><td align="left" valign="top" rowspan="1" colspan="1">ClassAlias, ClassName, BaseClassName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.usrtypeinfo.html_class_ref"> BEGIN_NAMED_CHOICE_INFO </a></td><td align="left" valign="top" rowspan="1" colspan="1">C++ class choice object</td><td align="left" valign="top" rowspan="1" colspan="1">ClassAlias, ClassName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.usrtypeinfo.html_class_ref"> BEGIN_NAMED_ENUM_INF </a></td><td align="left" valign="top" rowspan="1" colspan="1">Enum object</td><td align="left" valign="top" rowspan="1" colspan="1">EnumAlias, EnumName, IsInteger</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_ser.html#ch_ser.usrtypeinfo.html_class_ref"> BEGIN_NAMED_ENUM_IN_INFO </a></td><td align="left" valign="top" rowspan="1" colspan="1">internal Enum object</td><td align="left" valign="top" rowspan="1" colspan="1">EnumAlias, CppContext, EnumName, IsInteger</td></tr></tbody></table></div><p>The first four macros in Table 2 apply to C++ objects. The <span class="nctnt ncbi-macro">DECLARE_INTERNAL_TYPE_INFO()</span> macro <b>must</b> appear in the class definition's public section. These macros take two <span class="nctnt ncbi-type">string</span> arguments:</p><ul><li><p>an external alias for the type, and</p></li><li><p>the internal C++ symbolic class name</p></li></ul><p>The next two macros implement global, uniquely named functions which provide access to type information for C++ enumerations; the resulting functions are named <span class="nctnt ncbi-code">GetTypeInfo_enum_[EnumName]</span>. The <span class="nctnt ncbi-macro">DECLARE_ENUM_INFO()</span> or <span class="nctnt ncbi-macro">DECLARE_ENUM_INFO_IN()</span> macro should be used in these cases to declare the <span class="nctnt ncbi-func">GetTypeInfo*()</span> functions.</p><p>The usage of these six macros generally takes the following form:</p><pre><span class="nctnt-pre ncbi-code">BEGIN_*_INFO(ClassName)<br />{<br />    ADD_*(MemberName1);<br />    ADD_*(MemberName2);<br />    ...<br />}<br />END_*_INFO</span></pre><p>That is, the <span class="nctnt ncbi-macro">BEGIN/END</span> macros are used to generate the function's signature and enclosing block, and various <span class="nctnt ncbi-macro">ADD_*</span> macros are applied to add information about internal members and class relations.</p><div class="sec" id="ch_ser.usrtypeinfo.html_class_ref"><h4><span class="title">List of the BEGIN_/END_ macros</span></h4><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_CLASS_INFO">BEGIN_NAMED_CLASS_INFO (ClassAlias, ClassName)</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_CLASS_INFO">BEGIN_CLASS_INFO (ClassName)</a></p></li></ul><p>These macros should be used on classes that do not contain any pure virtual functions. For example, the <span class="nctnt ncbi-func">GetTypeInfo()</span> method for the <a href="ch_ser.html#ch_ser.iterators.html_typeIt">CPerson</a> class (used in the chapter on iterators) can be implemented as:</p><pre><span class="nctnt-pre ncbi-code">BEGIN_NAMED_CLASS_INFO("CPerson", CPerson)<br />{<br />    ADD_NAMED_STD_MEMBER("m_Name", m_Name); <br />    ADD_NAMED_STD_MEMBER("m_Addr", m_Addr); <br />    ADD_NAMED_MEMBER("m_NextDoor", m_NextDoor, POINTER, (CLASS, (CPerson)));<br />}<br />END_CLASS_INFO</span></pre><p>or, equivalently, as:</p><pre><span class="nctnt-pre ncbi-code">BEGIN_CLASS_INFO(CPerson)<br />{<br />    ADD_STD_MEMBER(m_Name); <br />    ADD_STD_MEMBER(m_Addr);<br />    ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)));<br />}<br />END_CLASS_INFO</span></pre><p>Here, the <span class="nctnt ncbi-class">CPerson</span> class has two <span class="nctnt ncbi-class">string</span> data members, <span class="nctnt ncbi-var">m_Name</span> and <span class="nctnt ncbi-var">m_Addr</span>, as well as a pointer to an object of the same type (<span class="nctnt ncbi-type">CPerson*</span>). All built-in C++ types such as <span class="nctnt ncbi-type">int, float, string</span> etc., use the <span class="nctnt ncbi-macro">ADD_NAMED_STD_MEMBER</span> or <span class="nctnt ncbi-macro">ADD_STD_MEMBER</span> macros. These and other macros used to add members are defined in <a href="ch_ser.html#ch_ser.usrtypeinfo.html_addm">Specifying internal structure and class inheritance: the ADD_ macros</a> and <a href="ch_ser.html#ch_ser.T3">Table 3</a>.</p><div class="table" id="ch_ser.T3"><div class="caption"><p>Table 3. ADD_* Macros and their usage</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Macro name</th><th align="left" valign="top" rowspan="1" colspan="1">Usage</th><th align="left" valign="top" rowspan="1" colspan="1">Arguments</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_STD_MEMBER </td><td align="left" valign="top" rowspan="1" colspan="1">Add a standard data member to a class</td><td align="left" valign="top" rowspan="1" colspan="1">MemberAlias, MemberName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_CLASS_MEMBER </td><td align="left" valign="top" rowspan="1" colspan="1">Add an internal class member to a class</td><td align="left" valign="top" rowspan="1" colspan="1">MemberAlias, MemberName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_SUB_CLASS </td><td align="left" valign="top" rowspan="1" colspan="1">Add a derived subclass to a class</td><td align="left" valign="top" rowspan="1" colspan="1">SubClassAlias, SubClassName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_REF_MEMBER </td><td align="left" valign="top" rowspan="1" colspan="1">Add a <span class="nctnt ncbi-class">CRef</span> data member to a class</td><td align="left" valign="top" rowspan="1" colspan="1">MemberAlias, MemberName, RefClass</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_ENUM_MEMBER </td><td align="left" valign="top" rowspan="1" colspan="1">Add an enumerated data member to a class</td><td align="left" valign="top" rowspan="1" colspan="1">MemberAlias, MemberName, EnumName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_ENUM_IN_MEMBER </td><td align="left" valign="top" rowspan="1" colspan="1">Add an externally defined enumerated data member to a class</td><td align="left" valign="top" rowspan="1" colspan="1">MemberAlias, MemberName, CppContext, EnumName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_MEMBER </td><td align="left" valign="top" rowspan="1" colspan="1">Add a data member of the type specified by <span class="nctnt ncbi-var">TypeMacro</span> to a class</td><td align="left" valign="top" rowspan="1" colspan="1">MemberAlias, MemberName, TypeMacro, TypeMacroArgs</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_STD_CHOICE_VARIANT</td><td align="left" valign="top" rowspan="1" colspan="1">Add a standard variant type to a C++ choice object</td><td align="left" valign="top" rowspan="1" colspan="1">VariantAlias, VariantName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_REF_CHOICE_VARIANT</td><td align="left" valign="top" rowspan="1" colspan="1">Add a <span class="nctnt ncbi-class">CRef</span> variant to a C++ choice object</td><td align="left" valign="top" rowspan="1" colspan="1">VariantAlias, VariantName, RefClass</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_ENUM_CHOICE_VARIANT</td><td align="left" valign="top" rowspan="1" colspan="1">Add an enumeration variant to a C++ choice object</td><td align="left" valign="top" rowspan="1" colspan="1">VariantAlias, VariantName, EnumName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_ENUM_IN_CHOICE_VARIANT</td><td align="left" valign="top" rowspan="1" colspan="1">Add an enumeration variant to a C++ choice object </td><td align="left" valign="top" rowspan="1" colspan="1">VariantAlias, VariantName, CppContext, EnumName</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_NAMED_CHOICE_VARIANT </td><td align="left" valign="top" rowspan="1" colspan="1">Add a variant of the type specified by <span class="nctnt ncbi-var">TypeMacro</span> to a C++ choice object</td><td align="left" valign="top" rowspan="1" colspan="1">VariantAlias, VariantName, TypeMacro, TypeMacroArgs </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ADD_ENUM_VALUE</td><td align="left" valign="top" rowspan="1" colspan="1">Add a named enumeration value to an <span class="nctnt ncbi-code">enum</span></td><td align="left" valign="top" rowspan="1" colspan="1">EnumValName, Value </td></tr></tbody></table></div><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_ABSTRACT_CLASS_INFO">BEGIN_NAMED_ABSTRACT_CLASS_INFO(ClassAlias, ClassName)</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_ABSTRACT_CLASS_INFO">BEGIN_ABSTRACT_CLASS_INFO(ClassName)</a></p></li></ul><p>These macros must be used on abstract base classes which contain pure virtual functions. Because these abstract classes cannot be instantiated, special handling is required in order to install their static <span class="nctnt ncbi-func">GetTypeInfo()</span> methods.</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_DERIVED_CLASS_INFO">BEGIN_NAMED_DERIVED_CLASS_INFO (ClassAlias, ClassName, BaseClassName)</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_DERIVED_CLASS_INFO">BEGIN_DERIVED_CLASS_INFO (ClassName, BaseClassName)</a></p></li></ul><p>These macros should be used on derived subclasses whose parent classes also have the <span class="nctnt ncbi-func">GetTypeInfo()</span> method implemented. Data members inherited from parent classes should not be included in the derived class type information.</p><pre><span class="nctnt-pre ncbi-code">BEGIN_DERIVED_CLASS_INFO(CA, CBase)<br />{<br />     // ... data members in CA not inherited from CBase<br />}<br />END_DERIVED_CLASS_INFO</span></pre><p><span class="nctnt highlight">NOTE:</span>The type information for classes derived directly from <span class="nctnt ncbi-class">CObject</span> does <b>not</b> however, follow this protocol. In this special case, although the class is derived from <span class="nctnt ncbi-class">CObject</span>, you should <b>not</b> use the <span class="nctnt ncbi-macro">DERIVED_CLASS</span> macros to implement <span class="nctnt ncbi-func">GetTypeInfo()</span>, but instead use the usual <span class="nctnt ncbi-macro">BEGIN_CLASS_INFO</span> macro. <span class="nctnt ncbi-class">CObject</span>'s have a slightly different interface to their type information (see <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CObjectGetTypeInfo">CObjectGetTypeInfo</a>), and apply these macros differently.</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_CHOICE_INFO class=">BEGIN_NAMED_CHOICE_INFO (ClassAlias, ClassName)</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_CHOICE_INFO">BEGIN_CHOICE_INFO (ClassName)</a></p></li></ul><p>These macros install <span class="nctnt ncbi-func">GetTypeInfo()</span> for C++<span class="nctnt ncbi-monospace">choice</span> objects, which are implemented as C++ classes. See <a href="ch_ser.html#ch_ser.choice.html">Choice objects in the C++ Toolkit</a> for a description of C++ <span class="nctnt ncbi-monospace">choice</span> objects. Each of the choice variants occurs as a data member in the class, and the macros used to add choice variants (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ADD_NAMED_CHOICE_VARIANT">ADD_NAMED_*_CHOICE_VARIANT</a>) are used similarly to those which add data members to classes (see discussion of the <a href="ch_ser.html#ch_ser.usrtypeinfo.html_addm">ADD*</a> macros below).</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_ENUM_INFO">BEGIN_NAMED_ENUM_INFO (EnumAlias, EnumName, IsInteger)</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_ENUM_INFO">BEGIN_ENUM_INFO (EnumName, IsInteger)</a></p></li></ul><p>In addition to the two arguments used by the <span class="nctnt ncbi-macro">BEGIN_*_INFO</span> macros for classes, a Boolean argument (<span class="nctnt ncbi-func">IsInteger</span>) indicates whether or not the enumeration includes arbitrary integer values or only those explicitly specified.</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_ENUM_IN_INFO">BEGIN_NAMED_ENUM_IN_INFO (EnumAlias, CppContext, EnumName, IsInteger)</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_ENUM_IN_INFO">BEGIN_ENUM_IN_INFO (CppContext, EnumName, IsInteger)</a></p></li></ul><p>These macros also implement the type information functions for C++ enumerations --but in this case, the enumeration is defined outside the scope where the macro is applied, so a <span class="nctnt ncbi-monospace">context</span> argument is required. This new argument, <span class="nctnt ncbi-func">CppContext</span>, specifies the C++ class name or external namespace where the enumeration is defined.</p><p>Again, when using the above macros to install type information, the corresponding class definitions <b>must</b> include a declaration of the static class member function <span class="nctnt ncbi-func">GetTypeInfo()</span> in the class's public section. The <span class="nctnt ncbi-macro">DECLARE_INTERNAL_TYPE_INFO()</span> macro is provided to ensure that the declaration of this method is correct. Similarly, the <span class="nctnt ncbi-macro">DECLARE_INTERNAL_ENUM_INFO</span> and <span class="nctnt ncbi-macro">DECLARE_ENUM_INFO</span> macros should be used in the header files where enumerations are defined. The <span class="nctnt ncbi-macro">DECLARE_ASN_TYPE_INFO</span> and <span class="nctnt ncbi-macro">DECLARE_ASN_CHOICE_INFO</span> macros can be used to declare the type information functions for C-style structs and choice nodes.</p></div></div><div class="sec" id="ch_ser.usrtypeinfo.html_addm"><h3><span class="title">Specifying internal structure and class inheritance: the ADD_ macros</span></h3><p>Information about internal class structure and inheritance is specified using the <span class="nctnt ncbi-macro">ADD_*</span> macros (see <a href="ch_ser.html#ch_ser.T3">Table 3</a>). Again, each macro has both a "named" and "unnamed" implementation. The arguments to all of the ADD_NAMED_* macros begin with the external alias and C++ name of the item to be added.</p><p>The ADD_* macros that take <b>only</b> an alias and a name require that the type being added must be either a built-in type or a type defined by the name argument. When adding a <span class="nctnt ncbi-class">CRef</span> data member to a class or choice object however, the class referenced by the <span class="nctnt ncbi-class">CRef</span> must be made explicit with the <span class="nctnt ncbi-var">RefClass</span> argument, which is the C++ class name for the type pointed to.</p><p>Similarly, when adding an enumerated data member to a class, the enumeration itself must be explicitly named. For example, if class <span class="nctnt ncbi-class">CMyClass</span> contains a data member <span class="nctnt ncbi-var">m_MyEnumVal</span> of type <span class="nctnt ncbi-type">EMyEnum</span>, then the BEGIN_NAMED_CLASS_INFO macro for <span class="nctnt ncbi-class">CMyClass</span> should contain the statement:</p><pre><span class="nctnt-pre ncbi-code">ADD_ENUM_MEMBER (m_MyEnumVal, EMyEnum);</span></pre><p>or, equivalently:</p><pre><span class="nctnt-pre ncbi-code">ADD_NAMED_ENUM_MEMBER ("m_MyEnumVal", m_MyEnumVal, EMyEnum);</span></pre><p>or, to define a "custom" (non-default) external alias:</p><pre><span class="nctnt-pre ncbi-code">ADD_NAMED_ENUM_MEMBER ("m_CustomAlias", m_MyEnumVal, EMyEnum);</span></pre><p>Here, <span class="nctnt ncbi-type">EMyEnum</span> is defined in the same namespace and scope as <span class="nctnt ncbi-class">CMyClass</span>. Alternatively, if the enumeration is defined in a different class or namespace (and therefore, then the <span class="nctnt ncbi-macro">ADD_ENUM_IN_MEMBER</span> macro must be used:</p><pre><span class="nctnt-pre ncbi-code">ADD_ENUM_IN_MEMBER (m_MyEnumVal, COtherClassName::, EMyEnum);</span></pre><p>In this example, <span class="nctnt ncbi-type">EMyEnum</span> is defined in a class named <span class="nctnt ncbi-class">COtherClassName</span>. The <span class="nctnt ncbi-func">CppContext</span> argument (defined here as <span class="nctnt ncbi-class">COtherClassName::</span>) acts as a scope operator, and can also be used to specify an alternative namespace. The ADD_NAMED_ENUM_CHOICE_VARIANT and ADD_NAMED_ENUM_IN_CHOICE_VARIANT macros are used similarly to provide information about enumerated choice options. The <span class="nctnt ncbi-macro">ADD_ENUM_VALUE</span> macro is used to add enumerated values to the enumeration itself, as demonstrated in the above example of the <a href="ch_ser.html#ch_ser.usrtypeinfo.html_class_ref">BEGIN_NAMED_ENUM_INFO </a>macro.</p><p>The most complex macros by far are those which use the <span class="nctnt ncbi-type">TypeMacro</span> and <span class="nctnt ncbi-var">TypeMacroArgs</span> arguments: <span class="nctnt ncbi-macro">ADD(_NAMED)_MEMBER</span> and <span class="nctnt ncbi-macro">ADD(_NAMED)_CHOICE_VARIANT</span>. These macros are more open-ended and allow for more complex specifications. We have already seen one example of using a macro of this type, in the implementation of the <span class="nctnt ncbi-func">GetTypeInfo()</span> method for <span class="nctnt ncbi-class">CPerson</span>:</p><pre><span class="nctnt-pre ncbi-code">ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)));</span></pre><p>The <span class="nctnt ncbi-macro">ADD_MEMBER</span> and <span class="nctnt ncbi-macro">ADD_CHOICE_VARIANT</span> macros always take at least two arguments:</p><p>the internal member (variant) name</p><p>the definition of the member's (variant's) type</p><p>Depending on the (second) <span class="nctnt ncbi-var">TypeMacro</span> argument, additional arguments may or may not be needed. In this example, the <span class="nctnt ncbi-var">TypeMacro</span> is <i>POINTER</i>, which <b>does require</b> additional arguments. The <span class="nctnt ncbi-var">TypeMacroArgs</span> here specify that <span class="nctnt ncbi-var">m_NextDoor</span> is a pointer to a class type whose C++ name is <span class="nctnt ncbi-class">CPerson</span>.</p><p>More generally, the remaining arguments depend on the value of <span class="nctnt ncbi-var">TypeMacro</span>, as these parameters complete the type definition. The possible strings which can occur as <span class="nctnt ncbi-var">TypeMacro</span>, along with the additional arguments required for that type, are given in <a href="ch_ser.html#ch_ser.T4">Table 4</a>.</p><div class="table" id="ch_ser.T4"><div class="caption"><p>Table 4. Type macros and their arguments</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">TypeMacro</th><th align="left" valign="top" rowspan="1" colspan="1">TypeMacroArgs </th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">CLASS </td><td align="left" valign="top" rowspan="1" colspan="1">(ClassName) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">STD </td><td align="left" valign="top" rowspan="1" colspan="1">(C++ type) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">StringStore </td><td align="left" valign="top" rowspan="1" colspan="1">() </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">null </td><td align="left" valign="top" rowspan="1" colspan="1">() </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">ENUM </td><td align="left" valign="top" rowspan="1" colspan="1">(EnumType, EnumName) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">POINTER </td><td align="left" valign="top" rowspan="1" colspan="1">(Type,Args) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">STL_multiset </td><td align="left" valign="top" rowspan="1" colspan="1">(Type,Args) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">STL_set </td><td align="left" valign="top" rowspan="1" colspan="1">(Type,Args) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">STL_multimap </td><td align="left" valign="top" rowspan="1" colspan="1">(KeyType,KeyArgs,ValueType,ValueArgs) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">STL_map </td><td align="left" valign="top" rowspan="1" colspan="1">(KeyType,KeyArgs,ValueType,ValueArgs) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">STL_list </td><td align="left" valign="top" rowspan="1" colspan="1">(Type,Args) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">STL_list_set </td><td align="left" valign="top" rowspan="1" colspan="1">(Type,Args) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">STL_vector </td><td align="left" valign="top" rowspan="1" colspan="1">(Type,Args) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">STL_CHAR_vector </td><td align="left" valign="top" rowspan="1" colspan="1">(C++ Char type) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">STL_auto_ptr </td><td align="left" valign="top" rowspan="1" colspan="1">(Type,Args)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">CHOICE </td><td align="left" valign="top" rowspan="1" colspan="1">(Type,Args) </td></tr></tbody></table></div><p>The <span class="nctnt ncbi-macro">ADD_MEMBER</span> macro generates a call to the corresponding <span class="nctnt ncbi-macro">ADD_NAMED_MEMBER</span> macro as follows:</p><pre><span class="nctnt-pre ncbi-code">#define ADD_MEMBER(MemberName,TypeMacro,TypeMacroArgs) \<br />    ADD_NAMED_MEMBER(#MemberName,MemberName,TypeMacro,TypeMacroArgs)</span></pre><p>Some examples of using the ADD_MEMBER macro are:</p><pre><span class="nctnt-pre ncbi-code">ADD_MEMBER(m_X);<br />ADD_MEMBER(m_A, STL_auto_ptr, (CLASS, (ClassName)));<br />ADD_MEMBER(m_B, STL_CHAR_vector, (char));<br />ADD_MEMBER(m_C, STL_vector, (STD, (int)));<br />ADD_MEMBER(m_D, STL_list, (CLASS, (ClassName)));<br />ADD_MEMBER(m_E, STL_list, (POINTER, (CLASS, (ClassName))));<br />ADD_MEMBER(m_F, STL_map, (STD, (long), STD, (string)));</span></pre><p>Similarly, the <span class="nctnt ncbi-macro">ADD_CHOICE_VARIANT</span> macro generates a call to the corresponding <span class="nctnt ncbi-macro">ADD_NAMED_CHOICE_VARIANT</span> macro. These macros add type information for the <a href="ch_ser.html#ch_ser.choice.html">choice object's variants.</a></p></div></div><div class="sec" id="ch_ser.typeinfo.html"><h2><span class="title">Runtime Object Type Information</span></h2><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_ser.html#ch_ser.typeinfo.html_introduction">Introduction</a></p></li><li><p><a href="ch_ser.html#ch_ser.typeinfo.html_motivation">Motivation</a></p></li><li><p><a href="ch_ser.html#ch_ser.typeinfo.html_cobjinfo">Object Information Classes</a></p></li><li><p><a href="ch_ser.html#ch_ser.typeinfo.html_usage">Usage of object type information</a></p></li></ul><div class="sec" id="ch_ser.typeinfo.html_introduction"><h3><span class="title">Introduction</span></h3><p>Run-time information about data types is necessary in several contexts, including:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">When reading, writing, and processing serialized data, where runtime information about a type's internal structure is needed.</p></dd><dt>2</dt><dd><p class="no_top_margin">When reading from an arbitrary data source, where data members' external aliases must be used to locate the corresponding class data members (e.g.<i>MyXxx</i> may be aliased as <i>my-xxx</i> in the input data file).</p></dd><dt>3</dt><dd><p class="no_top_margin">When using a generalized <a href="ch_ser.html#ch_ser.iterators.html">C++ type iterator</a> to traverse the data members of an object.</p></dd><dt>4</dt><dd><p class="no_top_margin">When accessing the object type information <i>per se</i> (without regard to any particular object instance), e.g. to dump it to a file as ASN.1 or DTD specifications (not data).</p></dd></dl><p>In the first three cases above, it is necessary to have both the object itself as well as its runtime type information. This is because in these contexts, the object is usually passed inside a generic function, as a pointer to its most base parent type <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObject.html">CObject.</a> The runtime type information is needed here, as there is no other way to ascertain the actual object's data members. In addition to providing this information, a runtime type information object provides an interface for accessing and modifying these data members.</p><p>In case (4) above, the type information is used independent of any actual object instances.</p><div class="sec" id="ch_ser.typeinfo.html_ctypeinfo_ref"><h4><span class="title">Type and Object specific info</span></h4><p>The NCBI C++ Toolkit uses two classes to support these requirements:</p><ul><li><p><b>Type information classes</b> (base class <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCTypeInfo.html">CTypeInfo</a>) are intended for internal usage only, and they encode information about a type, devoid of any instances of that type. This information includes the class layout, inheritance relations, external alias, and various other attributes such as size, which are independent of specific instances. Each data member of a class also has its own type information. Thus, in addition to providing information relevant to the member's occurrence in the class (e.g. the member name and offset), the type information for a <span class="nctnt ncbi-monospace">class</span> must also provide access to the type information for each of its <span class="nctnt ncbi-monospace">members</span>. Limited type information is also available for types other than classes, such as primitive data types, enumerations, containers, and pointers. For example, the type information for a primitive type specifies that it is an <span class="nctnt ncbi-type">int, float,</span> or <span class="nctnt ncbi-type">char</span>, etc., and whether or not that element is signed. Enumerations are a special kind of primitive type, whose type information specifies its enumeration values and named elements. Type information for containers specifies both the type of container and the type of elements that it holds.</p></li><li><p><a href="ch_ser.html#ch_ser.typeinfo.html_cobjinfo">Object information classes</a> (base class <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectTypeInfo.html">CObjectTypeInfo</a>) include a pointer to the type information as well as a pointer to the object <span class="nctnt ncbi-type">instance</span>, and provide a safe interface to that object. In situations where type information is used independent of any concrete object, the object information class simply serves as a wrapper to a type information object. Where access to an object instance is required, the object pointer provides direct access to the correctly type-cast instance, and the interface provides methods to access and/or modify the object itself or members of that object.</p></li></ul><p>The C++ Toolkit stores the type information outside any instances of that type, in a statically created <span class="nctnt ncbi-class">CTypeInfo</span> object. For class objects, this <span class="nctnt ncbi-class">CTypeInfo</span> object can be accessed by all instances of the class via a static <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=GetTypeInfo">GetTypeInfo()</a> class method. Similarly, for primitive types and other constructs that have no way of associating methods with them per se, a static globally defined <span class="nctnt ncbi-func">GetTypeInfoXxx()</span> function is used to access a static <span class="nctnt ncbi-class">CTypeInfo</span> object. (The <i>Xxx</i> suffix is used here to indicate that a globally unique name is generated for the function).</p><p>All of the automatically generated classes and constructs defined in the C++ Toolkit's <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects">objects/</a> directory already have static <span class="nctnt ncbi-func">GetTypeInfo()</span> functions implemented for them. In order to make type information about <span class="nctnt ncbi-monospace">user-defined</span> classes and elements also accessible, you will need to implement static <span class="nctnt ncbi-func">GetTypeInfo()</span> functions for these constructs. A number of pre-processor macros are available to support this activity, and are described in the section on <a href="ch_ser.html#ch_ser.usrtypeinfo.html">User-defined Type Information</a>.</p><p>Type information is often needed when the object itself has been passed anonymously, or as a pointer to its parent class. In this case, it is not possible to invoke the <span class="nctnt ncbi-func">GetTypeInfo()</span> method directly, as the object's exact type is unknown. Using a <span class="nctnt ncbi-code">&lt;static_cast&gt;</span> operator to enable the member function is also unsafe, as it may open the door to incorrectly associating an object's pointer with the wrong type information. For these reasons, the <span class="nctnt ncbi-class">CTypeInfo</span> class is intended for internal usage only, and it is the <a href="ch_ser.html#ch_ser.typeinfo.html_cobjinfo">CObjectTypeInfo</a> classes that provide a more safe and friendly user interface to type information.</p></div></div><div class="sec" id="ch_ser.typeinfo.html_motivation"><h3><span class="title">Motivation</span></h3><p>We use a simple example to help motivate the use of this <span class="nctnt ncbi-monospace">type</span> and <span class="nctnt ncbi-monospace">object</span> information model. Let us suppose that we would like to have a generic function <span class="nctnt ncbi-func">LoadObject()</span>, which can populate an object using data read from a flat file. For example, we might like to have:</p><pre><span class="nctnt-pre ncbi-code">bool LoadObject(Object&amp; myObj, istream&amp; is);</span></pre><p>where <span class="nctnt ncbi-var">myObj</span> is an instance of some subclass of <span class="nctnt ncbi-class">Object</span>. Assuming that the text in the file is of the form:</p><pre><span class="nctnt-pre ncbi-code">MemberName1 value1<br />MemberName5 value5<br />MemberName2 value2<br />:</span></pre><p>we would like to find the corresponding data member in <span class="nctnt ncbi-var">myObj</span> for each <span class="nctnt ncbi-var">MemberName</span>, and set that data member's value accordingly. Unfortunately, <span class="nctnt ncbi-var">myObj</span> cannot directly supply any useful type information, as the member names we seek are for a specific subclass of <span class="nctnt ncbi-class">Object</span>. Now suppose that we have an appropriate type information object available for <span class="nctnt ncbi-var">myObj</span>, and consider how this might be used:</p><pre><span class="nctnt-pre ncbi-code">bool LoadObject(TypeInfo&amp; info, Object&amp; myObj, istream&amp; is)<br />{<br />    string myName, myValue;<br /><br />    while ( !is.eof() ) {<br />        is &gt;&gt; myName &gt;&gt; myValue;<br />        void* member = FindMember(info, myObj, myName);<br />        AssignValue(member, myValue);<br />    }<br />}</span></pre><p>Here, we assume that our type information object, <span class="nctnt ncbi-var">info</span>, stores information about the memory offset of each data member in <span class="nctnt ncbi-var">myObj</span>, and that such information can be retrieved using some sort of identifying member name such as <span class="nctnt ncbi-var">myName</span>. This is not too difficult to imagine, and indeed, this is exactly the type of information and facility provided by the C++ Toolkit's type information classes. The <span class="nctnt ncbi-func">FindMember()</span> function just needs to return a <span class="nctnt ncbi-type">void</span> pointer to the appropriate location in memory. The <span class="nctnt ncbi-func">AssignValue()</span> function presents a much greater challenge however, as its two sole arguments are a <span class="nctnt ncbi-type">void</span> pointer and a <span class="nctnt ncbi-class">string</span>. This would be fine if the data member was indeed a <span class="nctnt ncbi-type">void</span> pointer, and a <span class="nctnt ncbi-class">string</span> value was acceptable. In general this is not the case, and stronger methods are clearly needed.</p><p>In particular, for each data member encountered, we need to retrieve the type of that member as well as its location in memory, so as to process <span class="nctnt ncbi-var">myValue</span> appropriately before assigning it. In addition, we need safer mechanisms for making such "untyped" assignments. Ideally, we would like a <span class="nctnt ncbi-func">FindMember()</span> function that returns a correctly cast pointer to that data member, along with its associated type information. This is what the <a href="ch_ser.html#ch_ser.usrtypeinfo.html_class_ref">object information classes</a> provide - a pointer to the object instance as well as a pointer to its static <span class="nctnt ncbi-monospace">type</span> information. The interface to the <span class="nctnt ncbi-class">object</span> information class also provides a number of methods such as <span class="nctnt ncbi-func">GetClassMember(), GetTypeFamily(), SetPrimitiveValue()</span>, etc., to support the type of activity described above.</p></div><div class="sec" id="ch_ser.typeinfo.html_cobjinfo"><h3><span class="title">Object Information Classes</span></h3><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_ser.html#ch_ser.typeinfo.html_objtype">CObjectTypeInfo (*)</a></p></li><li><p><a href="ch_ser.html#ch_ser.typeinfo.html_constobj">CConstObjectInfo (*)</a></p></li><li><p><a href="ch_ser.html#ch_ser.typeinfo.html_objinfo">CObjectInfo (*)</a></p></li></ul><div class="sec" id="ch_ser.typeinfo.html_objtype"><h4><span class="title"><span class="nctnt ncbi-class">CObjectTypeInfo</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectTypeInfo.html">*</a>)</span></h4><p>This is the base class for all <span class="nctnt ncbi-monospace">object</span> information classes. It is intended for usage where there is no concrete object being referenced, and all that is required is access to the type information. A <span class="nctnt ncbi-class">CObjectTypeInfo</span> contains a pointer to a low-level <span class="nctnt ncbi-class">CTypeInfo</span> object, and functions as a user-friendly wrapper class.</p><p>The constructor for <span class="nctnt ncbi-class">CObjectTypeInfo</span> takes a pointer to a <span class="nctnt ncbi-code">const CTypeInfo</span> object as its single argument. This is precisely what is returned by all of the static <span class="nctnt ncbi-func">GetTypeInfo()</span> functions. Thus, to create a <span class="nctnt ncbi-class">CObjectTypeInfo</span> for the <span class="nctnt ncbi-class">CBioseq</span> class - without reference to any particular instance of <span class="nctnt ncbi-class">CBioseq</span> - one might use:</p><p><span class="nctnt ncbi-code">CObjectTypeInfo objInfo( CBioseq::GetTypeInfo() );</span></p><p>One of the most important methods provided by the <span class="nctnt ncbi-class">CObjectTypeInfo</span> class interface is <span class="nctnt ncbi-func">GetTypeFamily()</span>, which returns an enumerated value indicating the <span class="nctnt ncbi-monospace">type family</span> for the object of interest. Five type families are defined by the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ETypeFamily">ETypeFamily</a> enumeration:</p><pre><span class="nctnt-pre ncbi-code">ETypeFamily GetTypeFamily(void) const;<br />    enum ETypeFamily {<br />    eTypeFamilyPrimitive,<br />    eTypeFamilyClass,<br />    eTypeFamilyChoice,<br />    eTypeFamilyContainer,<br />    eTypeFamilyPointer<br />};</span></pre><p>Different queries become appropriate depending on the <span class="nctnt ncbi-type">ETypeFamily</span> of the object. For example, if the object is a container, one might need to determine the type of container (e.g. whether it is a <span class="nctnt ncbi-class">list</span>, <span class="nctnt ncbi-class">map</span> etc.), and the type of element. Similarly, if an object is a primitive type (e.g. <span class="nctnt ncbi-type">int, float, string, </span>etc.), an appropriate query becomes what the value type is, and in the case of integer-valued types, whether or not it is signed. Finally, in the case of more complex objects such as class and choice objects, access to the type information for the individual data members and choice variants is needed. The following methods are included in the <span class="nctnt ncbi-class">CObjectTypeInfo</span> interface for these purposes:</p><p>For objects with family type <span class="nctnt ncbi-code">eTypeFamilyPrimitive</span>:</p><pre><span class="nctnt-pre ncbi-code">EPrimitiveValueType GetPrimitiveValueType(void) const;<br />bool IsPrimitiveValueSigned(void) const;</span></pre><p>For objects with family type <span class="nctnt ncbi-code">eTypeFamilyClass</span>:</p><pre><span class="nctnt-pre ncbi-code">CMemberIterator BeginMembers(void) const;<br />CMemberIterator FindMember(const string&amp; memberName) const;<br />CMemberIterator FindMemberByTag(int memberTag) const;</span></pre><p>For objects with family type <span class="nctnt ncbi-code">eTypeFamilyChoice</span>:</p><pre><span class="nctnt-pre ncbi-code">CVariantIterator BeginVariants(void) const;<br />CVariantIterator FindVariant(const string&amp; memberName) const;<br />CVariantIterator FindVariantByTag(int memberTag) const;</span></pre><p>For objects with family type <span class="nctnt ncbi-code">eTypeFamilyContainer</span>:</p><pre><span class="nctnt-pre ncbi-code">EContainerType GetContainerType(void) const;<br />CObjectTypeInfo GetElementType(void) const;</span></pre><p>For objects with family type <span class="nctnt ncbi-code">eTypeFamilyPointer</span>:</p><pre><span class="nctnt-pre ncbi-code">CObjectTypeInfo GetPointedType(void) const;</span></pre><p>The two additional enumerations referred to here, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EContainerType">EContainerType</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EPrimitiveValueType">EPrimitiveValueType</a>, are defined, along with <span class="nctnt ncbi-type">ETypeFamily</span>, in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial/serialdef.hpp">include/serial/serialdef.hpp</a>.</p><p>Different iterator classes are used for iterating over class data members versus choice variant types. Thus, if the object of interest is a C++ class object, then access to the type information for its members can be gained using a <span class="nctnt ncbi-class">CObjectTypeInfo::CMemberIterator</span>. The <span class="nctnt ncbi-func">BeginMembers()</span> method returns a <span class="nctnt ncbi-class">CMemberIterator</span> pointing to the first data member in the class; the <span class="nctnt ncbi-func">FindMember*()</span> methods return a <span class="nctnt ncbi-class">CMemberIterator</span> pointing to a data member whose name or tag matches the input argument. The <span class="nctnt ncbi-class">CMemberIterator</span> class is a forward iterator whose operators are defined as follows:</p><ul><li><p>the <span class="nctnt ncbi-code">++</span> operator increments the iterator (makes it point to the next class member)</p></li><li><p>the <span class="nctnt ncbi-code">()</span> operator tests that the iterator has not exceeded the legitimate range</p></li><li><p>the <span class="nctnt ncbi-code">*</span> dereferencing operator returns a <span class="nctnt ncbi-class">CObjectTypeInfo</span> for the data member the iterator currently points to</p></li></ul><p>Similarly, the <span class="nctnt ncbi-func">BeginVariants()</span> and <span class="nctnt ncbi-func">FindVariant()</span> methods allow iteration over the choice variant data types for a choice class, and the dereferencing operation yields a <span class="nctnt ncbi-class">CObjectTypeInfo</span> object for the choice variant currently pointed to by the iterator.</p></div><div class="sec" id="ch_ser.typeinfo.html_constobj"><h4><span class="title">CConstObjectInfo (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCConstObjectInfo.html">*</a>)</span></h4><p>The <span class="nctnt ncbi-class">CConstObjectInfo</span> (derived from <a href="ch_ser.html#ch_ser.typeinfo.html_objtype">CObjectTypeInfo</a>) adds an interface to access the particular instance of an object (in addition to the interface inherited from <a href="ch_ser.html#ch_ser.typeinfo.html_objtype">CObjectTypeInfo</a>, which provides access to type information only). It is intended for usage with <span class="nctnt ncbi-code">const</span> instances of the object of interest, and therefore the interface does not permit any modifications to the object. The constructor for <span class="nctnt ncbi-class">CConstObjectInfo</span> takes two arguments:</p><pre><span class="nctnt-pre ncbi-code">CConstObjectInfo(const void* instancePtr, const CTypeInfo* typeinfoPtr);</span></pre><p>(Alternatively, the constructor can be invoked with a single STL pair containing these two objects.)</p><p>Each <span class="nctnt ncbi-class">CConstObjectInfo</span> contains a pointer to the object's type information as well as a pointer to an instance of the object. The existence or validity of this instance can be checked using any of the following <span class="nctnt ncbi-class">CConstObjectInfo</span> methods and operators:</p><ul><li><p><span class="nctnt ncbi-code">bool Valid(void) const;</span></p></li><li><p><span class="nctnt ncbi-code">operator bool(void) const;</span></p></li><li><p><span class="nctnt ncbi-code">bool operator!(void) const;</span></p></li></ul><p>For <span class="nctnt ncbi-monospace">primitive</span> type objects, the <span class="nctnt ncbi-class">CConstObjectInfo</span> interface provides access to the currently assigned value using <span class="nctnt ncbi-func">GetPrimitiveValueXxx()</span>. Here, <span class="nctnt ncbi-var">Xxx</span> may be <span class="nctnt ncbi-monospace">Bool, Char, Long, ULong, Double, String, ValueString</span>, or <span class="nctnt ncbi-monospace">OctetString</span>. In general, to get a primitive value, one first applies a <span class="nctnt ncbi-code">switch</span> statement to the value returned by <span class="nctnt ncbi-func">GetPrimitiveValueType()</span>, and then calls the appropriate <span class="nctnt ncbi-func">GetPrimitiveValueXxx()</span> method depending on the branch followed, e.g.:</p><pre><span class="nctnt-pre ncbi-code">switch ( obj.GetPrimitiveValueType() ) {<br />case ePrimitiveValueBool:<br />    bool b = obj.GetPrimitiveValueBool();<br />    break;<br /><br />case ePrimitiveValueInteger:<br />    if ( obj.IsPrimitiveValueSigned() ) {<br />        long l = obj.GetPrimitiveValueLong();<br />    } else {<br />        unsigned long ul = obj.GetPrimitiveValueULong();<br />    }<br />    break;<br />    //... etc.<br />}</span></pre><p>Member iterator methods are also defined in the <span class="nctnt ncbi-class">CConstObjectInfo</span> class, with a similar interface to that found in the <span class="nctnt ncbi-class">CObjectTypeInfo</span> class. In this case however, the dereferencing operators return a <span class="nctnt ncbi-class">CConstObjectInfo</span> object - not a <span class="nctnt ncbi-class">CObjectTypeInfo</span> object - for the current member. For C++<span class="nctnt ncbi-code">class</span> objects, these member functions are:</p><ul><li><p><span class="nctnt ncbi-code">CMemberIterator BeginMembers(void) const;</span></p></li><li><p><span class="nctnt ncbi-code">CMemberIterator FindClassMember(const string&amp; memberName) const;</span></p></li><li><p><span class="nctnt ncbi-code">CMemberIterator FindClassMemberByTag(int memberTag) const;</span></p></li></ul><p>For C++ choice objects, only one variant is ever selected, and only that choice variant is instantiated. As it does not make sense to define a <span class="nctnt ncbi-code">CConstObjectInfo iterator</span> for uninstantiated variants, the method <span class="nctnt ncbi-func">GetCurrentChoiceVariant()</span> is provided instead. The dereferencing operator (*) can be applied to the object returned by this method to obtain a <span class="nctnt ncbi-class">CConstObjectInfo</span> for the variant. Of course, type information for unselected variants can still be accessed using the <span class="nctnt ncbi-class">CObjectTypeInfo</span> methods.</p><p>The <span class="nctnt ncbi-class">CConstObjectInfo</span> class also defines an element iterator for container type objects. <span class="nctnt ncbi-class">CConstObjectInfo::CElementIterator</span> is a forward iterator whose interface includes increment and testing operators. Dereferencing is implemented by the iterator's <span class="nctnt ncbi-func">GetElement()</span> method, which returns a <span class="nctnt ncbi-class">CConstObjectInfo</span> for the element currently pointed to by the iterator.</p><p>Finally, for pointer type objects, the type returned by the method <span class="nctnt ncbi-func">GetPointedObject()</span> is also a <span class="nctnt ncbi-class">CConstObjectInfo</span> for the object - not just a <span class="nctnt ncbi-class">CObjectTypeInfo</span>.</p></div><div class="sec" id="ch_ser.typeinfo.html_objinfo"><h4><span class="title">CObjectInfo (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectInfo.html">*</a>)</span></h4><p>The <span class="nctnt ncbi-class">CObjectInfo</span> class is in turn derived from <span class="nctnt ncbi-class">CConstObjectInfo</span>, and is intended for usage with <span class="nctnt ncbi-code">mutable</span> instances of the object of interest. In addition to all of the methods inherited from the parent class, the interface to this class also provides methods that allow modification of the object itself or its data members.</p><p>For primitive type objects, a set of <span class="nctnt ncbi-func">SetPrimitiveValueXxx()</span> methods are available, complimentary to the <span class="nctnt ncbi-func">GetPrimitiveValueXxx()</span> methods described above. Methods that return member iterator objects are again reimplemented, and the de-referencing operators now return a <span class="nctnt ncbi-class">CObjectInfo</span> object for that data member. As the <span class="nctnt ncbi-class">CObjectInfo</span> now points to a <span class="nctnt ncbi-code">mutable</span> object, these iterators can be used to set values for the data member. Similarly, <span class="nctnt ncbi-func">GetCurrentChoiceVariant()</span> now returns a <span class="nctnt ncbi-class">CObjectInfo</span>, as does <span class="nctnt ncbi-code">CObjectInfo::CElementIterator::GetElement()</span>.</p></div></div><div class="sec" id="ch_ser.typeinfo.html_usage"><h3><span class="title">Usage of object type information</span></h3><p>We can now reconsider how our LoadObject() function might be implemented using the <span class="nctnt ncbi-class">CObjectInfo</span> class:</p><pre><span class="nctnt-pre ncbi-code">bool LoadObject(CObjectInfo&amp; info, CNcbiIStream&amp; is)<br />{<br />    string alias, myValue;<br /><br />    while ( !is.eof() ) {<br />        is &gt;&gt; alias &gt;&gt; myValue;<br /><br />        CObjectInfo dataMember(*info.FindClassMember(alias));<br />        if (!dataMember) {<br />            ERR_POST_X(1, "Couldn't find member named:" &lt;&lt; alias);<br />        }<br />        SetValue(dataMember, myValue);<br />    }<br />}</span></pre><p>Here, <span class="nctnt ncbi-var">info</span> contains pointers to the <span class="nctnt ncbi-class">CObject</span> itself as well as to its associated <span class="nctnt ncbi-class">CTypeInfo</span> object. For each member alias read from the file, we apply <span class="nctnt ncbi-code">FindClassMember(alias)</span>, and dereference the returned iterator to retrieve a <span class="nctnt ncbi-class">CObjectInfo</span> object for that member. We then use the operator <span class="nctnt ncbi-code">()</span> to verify that the member was located, and if so, use the member's <span class="nctnt ncbi-class">CObjectInfo</span> to set a value in the function <span class="nctnt ncbi-func">SetValue()</span>:</p><pre><span class="nctnt-pre ncbi-code">void SetValue(const CObjectInfo&amp; obj, const string value)<br />{<br />    if (obj.GetTypeFamily() == eTypeFamilyPrimitive) {<br /><br />        switch ( obj.GetPrimitiveValueType() ) {<br /><br />        case ePrimitiveValueBool:<br />            obj.SetPrimitiveValueBool (atoi (value.c_str()));<br />            break;<br /><br />        case ePrimitiveValueChar:<br />            obj.SetPrimitiveValueChar (value.c_str()[0]);<br />            break;<br /><br />        //... etc<br />        }<br />    } else {<br />        ERR_POST_X(2, "Attempt to assign non-primitive from string:" &lt;&lt; value);<br />    }<br />}</span></pre><p>In this example, <span class="nctnt ncbi-func">SetValue()</span> can only assign primitive types. More generally however, the <span class="nctnt ncbi-class">CObjectInfo</span> class allows the assignment of more complex types that are simply not implemented here. Note also that the arguments to <span class="nctnt ncbi-func">SetValue()</span> are <span class="nctnt ncbi-code">const</span>, even though the function <b>does</b> modify the value of the data instance pointed to. In particular, the type <span class="nctnt ncbi-code">const CObjectInfo</span> should not be confused with the type <span class="nctnt ncbi-class">CConstObjectInfo</span>. The former specifies that object information construct is non-mutable, although the instance it points to can be modified. The latter specifies that the instance itself is non-mutable.</p><p>In addition to user-specific applications of the type demonstrated in this example, the generic implementations of the <a href="ch_ser.html#ch_ser.iterators.html">C++ type iterators</a> and the <a href="ch_ser.html#ch_ser.objstream.html">CObject[IO]Stream</a>class methods provide excellent examples of how runtime object type information can be deployed.</p><p>As a final example of how type information might be used, we consider an application whose simple task is to translate a data file on an input stream to a different format on an output stream. One important use of the object classes defined in <span class="nctnt ncbi-path">include/objects</span> is the hooks and parsing mechanisms available to applications utilizing <a href="ch_ser.html#ch_ser.objstream.html">CObject[IO]Streams</a>. The stream objects specialize in different formats (such as XML or ASN.1), and must work in concert with these type-specific object classes to interpret or generate serialized data. In some cases however, the dynamic memory allocation required for large objects may be substantial, and it is preferable to avoid actually instantiating a whole object all at once.</p><p>Instead, it is possible to use the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectStreamCopier.html">CObjectStreamCopier</a> class, described in <a href="ch_ser.html#ch_ser.objstream.html">CObject[IO]Streams</a>. Briefly, this class holds two <span class="nctnt ncbi-class">CObject[IO]Stream</span> data members pointing to the input and output streams, and a set of <span class="nctnt ncbi-code">Copy</span> methods which take a <span class="nctnt ncbi-class">CTypeInfo</span> argument. Using this class, it is easy to translate files between different formats; for example:</p><pre><span class="nctnt-pre ncbi-code">auto_ptr&lt;CObjectIStream&gt;  in(CObjectIStream::Open("mydata.xml",eSerial_Xml));<br />auto_ptr&lt;CObjectOStream&gt; out(CObjectOStream::Open("mydata.asn",eSerial_AsnBinary));<br />CObjectStreamCopier copier(*in, *out);<br />copier.Copy (CBioseq_set::GetTypeInfo());</span></pre><p>copies a <span class="nctnt ncbi-class">CBioseq_set</span> encoded in XML to a new file, reformatted in ASN.1 binary format.</p></div></div><div class="sec" id="ch_ser.choice.html"><h2><span class="title">Choice objects in the NCBI C++ Toolkit</span></h2><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_ser.html#ch_ser.choice.html_intro">Introduction</a></p></li><li><p><a href="ch_ser.html#ch_ser.choice.html_cppchoice">C++ choice objects</a></p></li></ul><div class="sec" id="ch_ser.choice.html_intro"><h3><span class="title">Introduction</span></h3><p>The <a href="ch_app.html#ch_app.datatool">datatool</a> program processes the ASN.1 specification files (<span class="nctnt ncbi-path">*.asn</span>) in the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects">src/objects/</a> directories to generate the associated C++ class definitions. The corresponding program implemented in the C Toolkit, <span class="nctnt ncbi-app">asntool</span>, used the ASN.1 specifications to generate C enums, structs, and functions. In contrast, <span class="nctnt ncbi-app">datatool</span> must generate C++ enums, classes and methods. In addition, for each defined object type, <span class="nctnt ncbi-app">datatool</span> must also generate the associated <a href="ch_ser.html#ch_ser.typeinfo.html">type information</a> method or function.</p><p>There is a significant difference in how these two tools implement ASN.1 <span class="nctnt ncbi-monospace">choice</span> elements. As an example, consider the following ASN.1 specification:</p><pre><span class="nctnt-pre ncbi-code">Object-id ::= CHOICE {<br />    id INTEGER,<br />    str VisibleString<br />}</span></pre><p>The ASN.1 <span class="nctnt ncbi-monospace">choice</span> element specifies that the corresponding object may be any one of the listed types. In this case, the possible types are an integer and a string. The approach used in <span class="nctnt ncbi-app">asntool</span> was to implement all choice objects as <span class="nctnt ncbi-type">ValNode</span>s, which were in turn defined as:</p><pre><span class="nctnt-pre ncbi-code">typedef struct valnode {<br />    unsigned choice;<br />    DataVal data;<br />    struct valnode *next;<br />} ValNode;</span></pre><p>The <span class="nctnt ncbi-type">DataVal</span> field is a <span class="nctnt ncbi-code">union</span>, which may directly store numerical values, or alternatively, hold a <span class="nctnt ncbi-type">void</span> pointer to a character string or C <span class="nctnt ncbi-code">struct</span>. Thus, to process a <span class="nctnt ncbi-monospace">choice</span> element in the C Toolkit, one could first retrieve the <span class="nctnt ncbi-monospace">choice</span> field to determine how the data should be interpreted, and subsequently, retrieve the data via the <span class="nctnt ncbi-type">DataVal</span> field. In particular, no explicit implementation of individual choice objects was used, and it was left to functions which manipulate these elements to enforce logical consistency and error checking for legitimate values. A C <span class="nctnt ncbi-code">struct</span> which included a <span class="nctnt ncbi-monospace">choice</span> element as one of its fields merely had to declare that element as type <i>ValNode</i>. This design was further complicated by the use of a <span class="nctnt ncbi-type">void</span> pointer to store non-primitive types such as <span class="nctnt ncbi-code">struct</span>s or character strings.</p><p>In contrast, the C++ <span class="nctnt ncbi-app">datatool</span> implementation of <span class="nctnt ncbi-monospace">choice</span> elements defines a class with built-in, automatic error checking for each <span class="nctnt ncbi-monospace">choice</span> object. The usage of <a href="ch_core.html#ch_core.CRef">CObject</a> class hierarchy (and the associated <a href="ch_ser.html#ch_ser.typeinfo.html">type information</a> methods) solves many of the problems associated with working with <span class="nctnt ncbi-type">void</span> pointers.</p></div><div class="sec" id="ch_ser.choice.html_cppchoice"><h3><span class="title">C++ choice objects</span></h3><p>The classes generated by <span class="nctnt ncbi-app">datatool</span> for <span class="nctnt ncbi-monospace">choice</span> elements all have the following general structure:</p><pre><span class="nctnt-pre ncbi-code">class C[AsnChoiceName] : public CObject<br />{<br />public:<br />    ...                                 // constructors and destructors<br />    DECLARE_INTERNAL_TYPE_INFO();       // declare GetTypeInfo() method<br />    enum E_Choice {                     // enumerate the class names<br />       e_not_set,                       // for the choice variants<br />       e_Xxx,<br />       ...<br />    };<br />    typedef CXxx TXxx;                  // typedef each variant class<br />    ...<br />    virtual void Reset(void);           // reset selection to none<br />    E_Choice Which(void) const;         // return m_choice<br />    void Select(E_Choice index,         // change the current selection<br />                EResetVariant reset);<br />    static string SelectionName(E_Choice index);<br />    bool IsXxx(void) const;             // true if m_choice == eXxx<br />    CXxx&amp; GetXxx(void);<br />    const CXxx&amp; GetXxx(void) const;<br />    CXxx&amp; SetXxx(void);<br />    void SetXxx(const CRef&lt;CXxx&gt;&amp; ref);<br />    ...<br />private:<br />    E_Choice m_choice;                  // choice state<br />    union {<br />       TXxx m_Xxx;<br />       ...<br />    };<br />    CObject *m_object;                  // variant's data<br />    ...<br />};</span></pre><p>For the above ASN.1 specification, <span class="nctnt ncbi-app">datatool</span> generates a class named <span class="nctnt ncbi-class">CObject_id</span>, which is derived from <a href="ch_core.html#ch_core.CObject">CObject</a>. For each choice variant in the specification, an enumerated value (in <span class="nctnt ncbi-type">E_Choice</span>), and an internal <span class="nctnt ncbi-code">typedef</span> are defined, and a declaration in the <span class="nctnt ncbi-code">union</span> data member is made. For this example then, we would have:</p><pre><span class="nctnt-pre ncbi-code">enum E_Choice {<br />    e_not_set,<br />    e_Id,<br />    e_Str<br />};<br />...<br />typedef int TId;<br />typedef string TStr;<br />...<br />union {<br />    TId m_Id;<br />    string *m_string;<br />};</span></pre><p>In this case both of the choice variants are C++ built-in types. More generally however, the choice variant types may refer to any type of object. For convenience, we refer to their C++ type names here as "CXxx",</p><p>Two private data members store information about the currently selected choice variant: <span class="nctnt ncbi-var">m_choice</span> holds the <span class="nctnt ncbi-code">enum</span> value, and <span class="nctnt ncbi-var">m_Xxx</span> holds (or points to a <span class="nctnt ncbi-class">CObject</span> containing) the variant's data. The choice object's member functions provide access to these two data members. <span class="nctnt ncbi-func">Which()</span> returns the currently selected variant's <span class="nctnt ncbi-code">E_Choice enum</span> value. Each choice variant has its own <span class="nctnt ncbi-func">Get()</span> and <span class="nctnt ncbi-func">Set()</span> methods. Each <span class="nctnt ncbi-func">GetXxx()</span> method throws an exception if the variant type for that method does not correspond to the current selection type. Thus, it is not possible to unknowingly retrieve the incorrect type of choice variant.</p><p><span class="nctnt ncbi-code">Select(e_Xxx)</span> uses a <span class="nctnt ncbi-code">switch(e_Xxx)</span> statement to initialize <span class="nctnt ncbi-var">m_Xxx</span> appropriately, sets <span class="nctnt ncbi-var">m_choice</span> to <span class="nctnt ncbi-var">e_Xxx</span>, and returns. Two <span class="nctnt ncbi-func">SetXxx()</span> methods are defined, and both use this <span class="nctnt ncbi-func">Select()</span> method. <span class="nctnt ncbi-func">SetXxx()</span> with no arguments calls <span class="nctnt ncbi-code">Select(e_Xxx)</span> and returns <span class="nctnt ncbi-var">m_Xxx</span> (as initialized by <span class="nctnt ncbi-func">Select()</span>). <span class="nctnt ncbi-func">SetXxx(TXxx&amp; value)</span> also calls <span class="nctnt ncbi-code">Select(e_Xxx)</span> but resets <span class="nctnt ncbi-var">m_Xxx</span> to <span class="nctnt ncbi-var">value</span> before returning.</p><p>Some example choice objects in the C++ Toolkit are:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDate.html">CDate</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCInt__fuzz.html">CInt_fuzz</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObject__id.html">CObject_id</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCPerson__id.html">CPerson_id</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCAnnotdesc.html">CAnnotdesc</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSeq__annot.html">CSeq_annot</a></p></li></ul></div></div><div class="sec" id="ch_ser.traverse.html"><h2><span class="title">Traversing a Data Structure</span></h2><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_ser.html#ch_ser.traverse.html_locateClass">Locating the Class Definitions</a></p></li><li><p><a href="ch_ser.html#ch_ser.traverse.html_accessMember">Accessing and Referencing Data Members</a></p></li><li><p><a href="ch_ser.html#ch_ser.traverse.html_example">Traversing a Biostruc</a></p></li><li><p><a href="ch_ser.html#ch_ser.traverse.html_iterate">Iterating Over Containers</a></p></li></ul><div class="sec" id="ch_ser.traverse.html_locateClass"><h3><span class="title">Locating the Class Definitions</span></h3><p>In general, traversing through a class object requires that you first become familiar with the internal class structure and member access functions for that object. In this section we consider how you can access this information in the source files, and apply it. The example provided here involves a <span class="nctnt ncbi-type">Biostruc</span> type which is implemented by class <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc.html">CBiostruc</a>, and its base (parent) class, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc__Base.html">CBiostruc_Base.</a></p><p>The first question is: how do I locate the class definitions implementing the object to be traversed? There are now two source browsers which you can use. To obtain a synopsis of the class, you can search the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classes.html">index</a> or the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/hierarchy.html">class hierarchy</a> of the <i>Doc++</i> browser and follow a link to the class. For example, a synopsis of the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc.html">CBiostruc</a> class is readily available. From this page, you can also access the relevant source files archived by the<i>LXR</i> browser, by following the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBiostruc">Locate CBiostruc</a> link. Alternatively, you may want to access the <i>LXR</i> engine directly by using the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBiostruc">Identifier search</a> tool.</p><p>Because we wish to determine which headers to include, the synopsis displayed by the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBiostruc">Identifier search</a> tool is most useful. There we find a single header file, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb1/Biostruc.hpp">Biostruc.hpp</a>, listed as defining the class. Accordingly, this is the header file we must include. The <span class="nctnt ncbi-class">CBiostruc</span> class inherits from the <span class="nctnt ncbi-class">CBiostruc_Base</span> class however, and we will need to consult that file as well to understand the internal structure of the <span class="nctnt ncbi-class">CBiostruc</span> class. Following a link to the parent class from the class hierarchy browser, we find the definition of the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc__Base.html">CBiostruc_Base</a> class.</p><p>This is where we must look for the definitions and access functions we will be using. However, it is the <span class="nctnt ncbi-monospace">derived user class</span> (<span class="nctnt ncbi-class">CBiostruc</span>) whose header should be included in your source files, and which should be instantiated by your local program variable. For a more general discussion of the relationship between the base parent objects and their derived user classes, see <a href="ch_proj.html#ch_proj.base_classes">Working with the serializable object classes.</a></p></div><div class="sec" id="ch_ser.traverse.html_accessMember"><h3><span class="title">Accessing and Referencing Data Members</span></h3><p>Omitting some of the low-level details of the base class, we find the <span class="nctnt ncbi-class">CBiostruc_Base</span> class has essentially the following structure:</p><pre><span class="nctnt-pre ncbi-code">class CBiostruc_Base : public CObject<br />{<br />public:<br />    // type definitions<br />    typedef list&lt; CRef&lt;CBiostruc_id&gt; &gt; TId;<br />    typedef list&lt; CRef&lt;CBiostruc_descr&gt; &gt; TDescr;<br />    typedef list&lt; CRef&lt;CBiostruc_feature_set&gt; &gt; TFeatures;<br />    typedef list&lt; CRef&lt;CBiostruc_model&gt; &gt; TModel;<br />    typedef CBiostruc_graph TChemical_graph;<br />    // Get() members<br />    const TId&amp; GetId(void) const;<br />    const TDescr&amp; GetDescr(void) const;<br />    const TChemical_graph&amp; GetChemical_graph(void) const;<br />    const TFeatures&amp; GetFeatures(void) const;<br />    const TModel&amp; GetModel(void) const;<br />    // Set() members<br />    TId&amp; SetId(void);<br />    TDescr&amp; SetDescr(void);<br />    TChemical_graph&amp; SetChemical_graph(void);<br />    TFeatures&amp; SetFeatures(void);<br />    TModel&amp; SetModel(void);<br />private:<br />    TId m_Id;<br />    TDescr m_Descr;<br />    TChemical_graph m_Chemical_graph;<br />    TFeatures m_Features;<br />    TModel m_Model;<br />};</span></pre><p>With the exception of the structure's chemical graph, each of the class's private data members is actually a <span class="nctnt ncbi-class">list</span> of references (pointers), as specified by the type definitions. For example, <span class="nctnt ncbi-type">TId</span> is a list of <a href="ch_core.html#ch_core.CRef">CRef</a> objects, where each <span class="nctnt ncbi-class">CRef</span> object points to a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc__id.html">CBiostruc_id</a>. The <span class="nctnt ncbi-class">CRef</span> class is a type of smart pointer used to hold a pointer to a reference-counted object. The dereferencing operator, when applied to a (dereferenced) iterator pointing to an element of <span class="nctnt ncbi-type">CBiostruc::TId</span>, e.g. <span class="nctnt ncbi-code">**CRef_i</span>, will return a <span class="nctnt ncbi-class">CBiostruc_id</span>. Thus, the call to <span class="nctnt ncbi-func">GetId()</span> returns a list which must then be iterated over and dereferenced to get the individual <span class="nctnt ncbi-class">CBiostruc_id</span> objects. In contrast, the function <span class="nctnt ncbi-func">GetChemicalGraph()</span> returns the object directly, as it does not involve a <span class="nctnt ncbi-class">list</span> or a <span class="nctnt ncbi-class">CRef</span>.</p><p>NOTE: It is strongly recommended that you use type names defined in the generated classes (e.g. <span class="nctnt ncbi-type">TId</span>, <span class="nctnt ncbi-type">TDescr</span>) rather than generic container names (<span class="nctnt ncbi-class">list&lt; CRef&lt;CBiostruc_id&gt; &gt;</span> etc.). The real container class may change occasionally and you will have to modify the code using generic container types every time it happens. When iterating over a container it's recommended to use <span class="nctnt ncbi-macro">ITERATE</span> and <span class="nctnt ncbi-macro">NON_CONST_ITERATE</span> macros.</p><p>The <span class="nctnt ncbi-func">GetXxx()</span> and <span class="nctnt ncbi-func">SetXxx()</span> member functions define the user interface to the class, providing methods to access and modify ("mutate") private data. In addition, most classes, including <span class="nctnt ncbi-class">CBiostruc</span>, have <span class="nctnt ncbi-func">IsSetXxx()</span> and <span class="nctnt ncbi-func">ResetXxx()</span> methods to validate and clear the data members, respectively.</p></div><div class="sec" id="ch_ser.traverse.html_example"><h3><span class="title">Traversing a Biostruc</span></h3><p>The program <span class="nctnt ncbi-path">traverseBS.cpp</span> (see <a href="ch_ser.html#ch_ser.traverse_cpp.html">Code Sample 4</a>) demonstrates how one might load a serial data file and iterate over the components of the resulting object. This example reads from a text ASN.1 Biostruc file and stores the information into a <span class="nctnt ncbi-class">CBiostruc</span> object in memory. The overloaded <span class="nctnt ncbi-func">Visit()</span> function is then used to recursively examine the object <span class="nctnt ncbi-code">CBiostruc bs</span> and its components.</p><div class="box" id="ch_ser.traverse_cpp.html"><h4><span class="title">Code Sample 4. traverseBS.cpp</span></h4><pre><span class="nctnt-pre ncbi-code">// File name: traverseBS.cpp<br />// Description: Reads an ASN.1 Biostruc text file into memory<br />// and visits its components<br /><br />#include &lt;serial/serial.hpp&gt;<br />#include &lt;serial/iterator.hpp&gt;<br />#include &lt;serial/objistr.hpp&gt;<br />#include &lt;serial/serial.hpp&gt;<br />#include &lt;objects/general/Dbtag.hpp&gt;<br />#include &lt;objects/general/Object_id.hpp&gt;<br />#include &lt;objects/seq/Numbering.hpp&gt;<br />#include &lt;objects/seq/Pubdesc.hpp&gt;<br />#include &lt;objects/seq/Heterogen.hpp&gt;<br />#include &lt;objects/mmdb1/Biostruc.hpp&gt;<br />#include &lt;objects/mmdb1/Biostruc_id.hpp&gt;<br />#include &lt;objects/mmdb1/Biostruc_history.hpp&gt;<br />#include &lt;objects/mmdb1/Mmdb_id.hpp&gt;<br />#include &lt;objects/mmdb1/Biostruc_descr.hpp&gt;<br />#include &lt;objects/mmdb1/Biomol_descr.hpp&gt;<br />#include &lt;objects/mmdb1/Molecule_graph.hpp&gt;<br />#include &lt;objects/mmdb1/Inter_residue_bond.hpp&gt;<br />#include &lt;objects/mmdb1/Residue_graph.hpp&gt;<br />#include &lt;objects/mmdb3/Biostruc_feature_set.hpp&gt;<br />#include &lt;objects/mmdb2/Biostruc_model.hpp&gt;<br />#include &lt;objects/pub/Pub.hpp&gt;<br />#include &lt;corelib/ncbistre.hpp&gt;<br /><br />#include "</span><a href="ch_ser.html#ch_ser.traverse_hpp.html">traverseBS.hpp</a><span class="nctnt-pre ncbi-code">"<br /><br />USING_NCBI_SCOPE;<br />using namespace objects;<br /><br />int CTestAsn::Run()<br />{<br />    // initialize ASN input stream<br />    auto_ptr&lt;CObjectIStream&gt;<br />        inObject(CObjectIStream::Open("1001.val", eSerial_AsnBinary));<br />    // initialize, read into, and traverse CBiostruc object<br />    CBiostruc bs;<br />    *inObject &gt;&gt; bs;<br />    Visit (bs);<br />    return 0;<br />}<br /><br />/*****************************************************************<br />*<br />* The overloaded free "visit" functions are used to explore the<br />* Biostruc and all its component members - most of which are also<br />* class objects. Each class has a public interface that provides<br />* access to its private data via "get" functions.<br />*<br />******************************************************************/<br />void Visit (const CBiostruc&amp; bs)<br />{<br />    cout &lt;&lt; "Biostruc:\n" &lt;&lt; endl;<br />    Visit (bs.GetId());<br />    Visit (bs.GetDescr());<br />    Visit (bs.GetChemical_graph());<br />    Visit (bs.GetFeatures());<br />    Visit (bs.GetModel());<br />}<br /><br />/************************************************************************<br />*<br />* TId is a type defined in the CBiostruc class as a list of CBiostruc_id,<br />* where each id has a choice state and a value. Depending on the choice<br />* state, a different get() function is used.<br />*<br />*************************************************************************/<br />void Visit (const CBiostruc::TId&amp; idList)<br />{<br />    cout &lt;&lt; "\n Visiting Ids of Biostruc:\n";<br /><br />    for (CBiostruc::TId::const_iterator i = idList.begin();<br />        i != idList.end(); ++i) {<br /><br />        // dereference the iterator to get to the id object<br />        const CBiostruc_id&amp; thisId = **i;<br />        CBiostruc_id::E_Choice choice = thisId.Which();<br />        cout &lt;&lt; "choice = " &lt;&lt; choice;<br /><br />        // select id's get member function depending on choice<br />        switch (choice) {<br />        case CBiostruc_id::e_Mmdb_id:<br />            cout &lt;&lt; " mmdbId: " &lt;&lt; thisId.GetMmdb_id().Get() &lt;&lt; endl;<br />            break;<br />        case CBiostruc_id::e_Local_id:<br />            cout &lt;&lt; " Local Id: " &lt;&lt; thisId.GetLocal_id().GetId() &lt;&lt; endl;<br />           break;<br />        case CBiostruc_id::e_Other_database:<br />            cout &lt;&lt; " Other DB Id: "<br />            &lt;&lt; thisId.GetOther_database().GetDb() &lt;&lt; endl;<br />            break;<br />        default:<br />            cout &lt;&lt; "Choice not set or unrecognized" &lt;&lt; endl;<br />        }<br />    }<br />}<br /><br />/*************************************************************************<br />*<br />* TDescr is also a type defined in the Biostruc class as a list of<br />* CBiostruc_descr, where each descriptor has a choice state and a value.<br />*<br />*************************************************************************/<br />void Visit (const CBiostruc::TDescr&amp; descList)<br />{<br />    cout &lt;&lt; "\n Visiting Descriptors of Biostruc:\n";<br /><br />    for (CBiostruc::TDescr::const_iterator i = descList.begin();<br />        i != descList.end(); ++i) {<br /><br />        // dereference the iterator to get the descriptor<br />        const CBiostruc_descr&amp; thisDescr = **i;<br />        CBiostruc_descr::E_Choice choice = thisDescr.Which();<br />        cout &lt;&lt; "choice = " &lt;&lt; choice;<br /><br />        // select the get function depending on choice<br />        switch (choice) {<br />        case CBiostruc_descr::e_Name:<br />            cout &lt;&lt; " Name: " &lt;&lt; thisDescr.GetName() &lt;&lt; endl;<br />            break;<br />        case CBiostruc_descr::e_Pdb_comment:<br />            cout &lt;&lt; " Pdb comment: " &lt;&lt; thisDescr.GetPdb_comment() &lt;&lt; endl;<br />            break;<br />        case CBiostruc_descr::e_Other_comment:<br />            cout &lt;&lt; " Other comment: " &lt;&lt; thisDescr.GetOther_comment() &lt;&lt; endl;<br />            break;<br />        case CBiostruc_descr::e_History:<br />            cout &lt;&lt; " History: " &lt;&lt; endl;<br />            Visit (thisDescr.GetHistory());<br />            break;<br />        case CBiostruc_descr::e_Attribution:<br />            cout &lt;&lt; " Attribute: " &lt;&lt; endl;<br />            Visit (thisDescr.GetAttribution());<br />            break;<br />        default:<br />            cout &lt;&lt; "Choice not set or unrecognized" &lt;&lt; endl;<br />        }<br />    }<br />    VisitWithIterator (descList);<br />}<br /><br />/****************************************************************************<br />*<br />* An alternate way to visit the descriptor nodes using a </span><a href="ch_ser.html#ch_ser.iterators.html_stdType">CStdTypeIterator</a><span class="nctnt-pre ncbi-code"><br />*<br />****************************************************************************/<br />void VisitWithIterator (const CBiostruc::TDescr&amp; descList)<br />{<br />    cout &lt;&lt; "\n Revisiting descriptor list with string iterator...:\n";<br /><br />    for (CBiostruc::TDescr::const_iterator i1 = descList.begin();<br />        i1 != descList.end(); ++i1) {<br /><br />        const CBiostruc_descr&amp; thisDescr = **i1;<br /><br />        for (CStdTypeConstIterator&lt;NCBI_NS_STD::string&gt;<br />            i = ConstBegin(thisDescr); i; ++i) {<br />            cout &lt;&lt; "next descriptor" &lt;&lt; *i &lt;&lt; endl;<br />        }<br />    }<br />}<br /><br />/****************************************************************************<br />*<br />* Chemical graphs contain lists of descriptors, molecule_graphs, bonds, and<br />* residue graphs. Here we just visit some of the descriptors.<br />*<br />****************************************************************************/<br />void Visit (const CBiostruc::TChemical_graph&amp; G)<br />{<br />    cout &lt;&lt; "\n\n Visiting Chemical Graph of Biostruc\n";<br /><br />    const CBiostruc_graph::TDescr&amp; descList = G.GetDescr();<br />    for (CBiostruc_graph::TDescr::const_iterator i = descList.begin();<br />        i != descList.end(); ++i) {<br /><br />        // dereference the iterator to get the descriptor<br />        const CBiomol_descr&amp; thisDescr = **i;<br />        CBiomol_descr::E_Choice choice = thisDescr.Which();<br />        cout &lt;&lt; "choice = " &lt;&lt; choice;<br /><br /><br />        // select the get function depending on choice<br />        switch (choice) {<br />        case CBiomol_descr::e_Name:<br />            cout &lt;&lt; " Name: " &lt;&lt; thisDescr.GetName() &lt;&lt; endl;<br />            break;<br />        case CBiomol_descr::e_Pdb_class:<br />            cout &lt;&lt; " Pdb class: " &lt;&lt; thisDescr.GetPdb_class() &lt;&lt; endl;<br />            break;<br />        case CBiomol_descr::e_Pdb_source:<br />            cout &lt;&lt; " Pdb Source: " &lt;&lt; thisDescr.GetPdb_source() &lt;&lt; endl;<br />            break;<br />        case CBiomol_descr::e_Pdb_comment:<br />            cout &lt;&lt; " Pdb comment: " &lt;&lt; thisDescr.GetPdb_comment() &lt;&lt; endl;<br />            break;<br />        case CBiomol_descr::e_Other_comment:<br />            cout &lt;&lt; " Other comment: " &lt;&lt; thisDescr.GetOther_comment() &lt;&lt; endl;<br />            break;<br />        case CBiomol_descr::e_Organism: // skipped<br />        case CBiomol_descr::e_Attribution:<br />            break;<br />        case CBiomol_descr::e_Assembly_type:<br />            cout &lt;&lt; " Assembly Type: " &lt;&lt; thisDescr.GetAssembly_type() &lt;&lt; endl;<br />            break;<br />        case CBiomol_descr::e_Molecule_type:<br />            cout &lt;&lt; " Molecule Type: " &lt;&lt; thisDescr.GetMolecule_type() &lt;&lt; endl;<br />            break;<br />        default:<br />            cout &lt;&lt; "Choice not set or unrecognized" &lt;&lt; endl;<br />        }<br />    }<br />}<br /><br />void Visit (const CBiostruc::TFeatures&amp;)<br />{<br />    cout &lt;&lt; "\n\n Visiting Features of Biostruc\n";<br />}<br /><br />void Visit (const CBiostruc::TModel&amp;)<br />{<br />    cout &lt;&lt; "\n\n Visiting Models of Biostruc\n";<br />}<br /><br />int main(int argc, const char* argv[])<br />{<br />    // initialize diagnostic stream<br />    CNcbiOfstream diag("traverseBS.log");<br />    SetDiagStream(&amp;diag);<br /><br />    CTestAsn theTestApp;<br />    return theTestApp.AppMain(argc, argv);<br />}</span></pre></div><p><span class="nctnt ncbi-code">Visit(bs)</span> simply calls <span class="nctnt ncbi-func">Visit()</span> on each of the <span class="nctnt ncbi-class">CBiostruc</span> data members, which are accessed using <span class="nctnt ncbi-code">bs.GetXxx()</span>. The information needed to write each of these functions - the data member types and member function signatures - is contained in the respective header files. For example, looking at <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb1/Biostruc_.hpp">Biostruc_.hpp</a>, we learn that the structure's descriptor list can be accessed using <span class="nctnt ncbi-func">GetDescr()</span>, and that the type returned is a list of pointers to descriptors:</p><pre><span class="nctnt-pre ncbi-code">typedef list&lt; CRef&lt;CBiostruc_descr&gt; &gt; TDescr;<br />const TDescr&amp; GetDescr(void) const;</span></pre><p>Consulting the base class for <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBiostruc_descr_Base">CBiostruc_desc</a> in turn, we learn that this class has a <span class="nctnt ncbi-monospace">choice state</span> defining the type of value stored there as well as the method that should be used to access that value. This leads to an implementation of <a href="ch_ser.html#ch_ser.traverse_cpp.html">Visit(CBiostruc::TDescr DescrList)</a> that uses an iterator over its list argument and a switch statement over the current descriptor's choice state.</p></div><div class="sec" id="ch_ser.traverse.html_iterate"><h3><span class="title">Iterating Over Containers</span></h3><p>Most of the <span class="nctnt ncbi-func">Visit()</span> functions implemented here rely on standard STL iterators to walk through a list of objects. The general syntax for using an iterator is:</p><pre><span class="nctnt-pre ncbi-code">ContainerType ContainerName;<br />for (ContainerType::IteratorType<br />    i = ContainerName.begin(); i != ContainerName.end(); ++i) {<br /><br />    ObjectType ObjectName = *i;<br />    // ...<br />}</span></pre><p>Dereferencing the iterator is required, as the iterator behaves like a pointer that traverses consecutive elements of the container. For example, to iterate over the list of descriptors in the <i>Biostruc</i>, we use a container of type <span class="nctnt ncbi-type">CBiostruc::TDescr</span>, and an iterator of type <span class="nctnt ncbi-code">const_iterator</span> to ensure that the data is not mutated in the body of the loop. Because the descriptor list contains pointers (<a href="ch_core.html#ch_core.CRef">CRefs</a>) to objects, we will actually need to dereference <b>twice</b> to get to the objects themselves.</p><pre><span class="nctnt-pre ncbi-code">for (CBiostruc::TDescr::const_iterator i = descList.begin();<br />    i != descList.end(); ++i) {<br /><br />    const CBiostruc_descr&amp; thisDescr = **i;<br />    // ...<br />}</span></pre><p>In traversing the descriptor list in this example, we handled each type of descriptor with an explicit <span class="nctnt ncbi-code">case</span> statement. In fact, however, we really only visit those descriptors whose types have string representations: <span class="nctnt ncbi-type">TName, TPdb_comment</span>, and <span class="nctnt ncbi-type">TOther_comment</span>. The other two descriptor types, <span class="nctnt ncbi-type">THistory</span> and <span class="nctnt ncbi-type">TAttribute</span>, are objects that are "visited" recursively, but the associated visit functions are not actually implemented (see <a href="ch_ser.html#ch_ser.traverse_hpp.html">Code Sample 5</a>, <span class="nctnt ncbi-path">traverseBS.hpp</span>).</p><div class="box" id="ch_ser.traverse_hpp.html"><h4><span class="title">Code Sample 5. traverseBS.hpp</span></h4><pre><span class="nctnt-pre ncbi-code">// File name traverseBS.hpp<br /><br />#ifndef NCBI_TRAVERSEBS__HPP<br />#define NCBI_TRAVERSEBS__HPP<br /><br />#include &lt;corelib/ncbistd.hpp&gt;<br />#include &lt;corelib/ncbiapp.hpp&gt;<br /><br />USING_NCBI_SCOPE;<br />using namespace objects;<br /><br />// class CTestAsn<br />class CTestAsn : public CNcbiApplication {<br />public:<br />    virtual int Run ();<br />};<br /><br />void Visit(const CBiostruc&amp;);<br />void Visit(const CBiostruc::TId&amp;);<br />void Visit(const CBiostruc::TDescr&amp;);<br />void Visit(const CBiostruc::TChemical_graph&amp;);<br />void Visit(const CBiostruc::TFeatures&amp;);<br />void Visit(const CBiostruc::TModel&amp;);<br />void Visit(const CBiostruc_history&amp;) {<br />    cout &lt;&lt; "visiting history" &lt;&lt; endl;<br />};<br /><br />// Not implemented<br />void Visit(const CBiostruc_descr::TAttribution&amp;) {};<br />void VisitWithIterator (const CBiostruc::TDescr&amp; descList);<br /><br />#endif /* NCBI_TRAVERSEBS__HPP */</span></pre></div><p>The NCBI C++ Toolkit provides a rich and powerful <a href="ch_ser.html#ch_ser.iterators.html">set of iterators</a> for various application needs. An alternative to using the above <span class="nctnt ncbi-code">switch</span> statement to visit elements of the descriptor list would have been to use an NCBI <a href="ch_ser.html#ch_ser.iterators.html_stdType">CStdTypeIterator</a> that only visits strings. For example, we could implement the Visit function on a <span class="nctnt ncbi-type">CBiostruc::TDescr</span> as follows:</p><pre><span class="nctnt-pre ncbi-code">void Visit (const CBiostruc::TDescr&amp; descList)<br />{<br />    for (CBiostruc::TDescr::const_iterator i1 = descList.begin();<br />        i1 != descList.end(); ++i1) {<br /><br />        for (CStdTypeConstIterator&lt;string&gt; i = ConstBegin(**i1); i; ++i) {<br />            cout &lt;&lt; *i &lt;&lt; endl;<br />        }<br />    }<br />}</span></pre><p>In this example, the iterator will skip over all but the string data members.</p><p>The <span class="nctnt ncbi-class">CStdTypeIterator</span> is one of several iterators which makes use of an object's <span class="nctnt ncbi-monospace">type information</span> to implement the desired functionality. We began this section by positing that the traversal of an object requires an a priori knowledge of that object's internal structure. This is not strictly true however, if type information for the object is also available. An object's type information specifies the class layout, inheritance relations, data member names, and various other attributes such as size, which are independent of specific instances. All of the C++ type iterators described in <a href="ch_ser.html#ch_ser.iterators.html">The NCBI C++ Toolkit Iterators</a> section utilize type information, which is the topic of a previous section: <a href="ch_ser.html#ch_ser.typeinfo.html">Runtime Object Type Information</a>.</p></div></div><div class="sec" id="ch_ser.SOAP_support"><h2><span class="title">SOAP support</span></h2><p>The NCBI C++ Toolkit SOAP server and client provide a limited level of support of SOAP 1.1 over HTTP, and use the document binding style with a literal schema definition. Document/literal is the style that most Web services platforms were focusing on when this feature was introduced. Parsing of WSDL (Web services description language) specification and automatic C++ code generation are not supported. Still, since the WSDL message types section uses XML schema, and since the application is capable of parsing Schema, the majority of the C++ code generation can be done automatically.</p><div class="sec" id="ch_ser.SOAP_message"><h3><span class="title">SOAP message</span></h3><p>The core section of the SOAP specification is the messaging framework. The client sends a request and receives a response in the form of a SOAP message. A SOAP message is a one-way transmission between SOAP nodes: from a SOAP sender to a SOAP receiver. The root element of a SOAP message is the <span class="nctnt ncbi-monospace">Envelope</span>. The <span class="nctnt ncbi-monospace">Envelope</span> contains an optional <span class="nctnt ncbi-monospace">Header</span> element followed by a mandatory <span class="nctnt ncbi-monospace">Body</span> element. The <span class="nctnt ncbi-monospace">Body</span> element represents the message payload - it is a generic container that can contain any number of elements from any namespace.</p><p>In the Toolkit, the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=CSoapMessage">CSoapMessage</a> class defines <span class="nctnt ncbi-monospace">Header</span> and <span class="nctnt ncbi-monospace">Body</span> containers. Serializable objects (derived from the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=CSerialObject">CSerialObject</a> class) can be added into these containers using <span class="nctnt ncbi-func">AddObject()</span> method. Such a message object can then be sent to a message receiver. The response will also come in the form of an object derived from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=CSoapMessage">CSoapMessage</a>. At this time, it is possible to investigate its contents using <span class="nctnt ncbi-func">GetContent()</span> method; or ask directly for an object of a specific type using the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=SOAP_GetKnownObject">SOAP_GetKnownObject()</a> template function.</p></div><div class="sec" id="ch_ser.SOAP_client_CSoapHtt"><h3><span class="title">SOAP client (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSoapHttpClient">CSoapHttpClient</a>)</span></h3><p>The SOAP client is the initial SOAP sender - a node that originates a SOAP message. Knowing the SOAP receiver's URL, it sends a SOAP request and receives a response using the <span class="nctnt ncbi-func">Invoke()</span> method.</p><p>Internally, data objects in the Toolkit SOAP library are serialized and de-serialized using serializable objects streams. Since each serial data object also provides access to its type information, writing such objects is a straightforward operation. Reading the response is not that transparent. Before actually parsing incoming data, the SOAP processor should decide which object type information to use. Hence, a client application should tell the SOAP processor what types of data objects it might encounter in the incoming data. If the processor recognizes the object's type, it will parse the incoming data and store it as an instance of the recognized type. Otherwise, the processor will parse the data into an instance of the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CAnyContentObject">CAnyContentObject</a> class.</p><p>So, a SOAP client must:</p><ul><li><p>Define the server's URL.</p></li><li><p>Register the object types that might be present in the incoming data (using the <span class="nctnt ncbi-func">RegisterObjectType()</span> method).</p></li></ul><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSoapHttpClient">CSoapHttpClient</a> class also has methods for getting and setting the server URL and the default namespace.</p></div><div class="sec" id="ch_ser.SOAP_server_CSoapSer"><h3><span class="title">SOAP server (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSoapServerApplication">CSoapServerApplication</a>)</span></h3><p>The SOAP server receives SOAP mesages from a client and processes the contents of the SOAP Body and SOAP Header.</p><p>The processing of incoming requests is done with the help of "message listeners" - the server methods which analyze requests (in the form of objects derived from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=CSoapMessage">CSoapMessage</a>) and create responses. It is possible to have more than one listener for each message. When such a listener returns TRUE, the SOAP server base class object passes the request to the next listener, if it exists, and so on.</p><p>The server can return a WSDL specification if the specification file name is passed to the server's constructor and the file is located with the server.</p></div><div class="sec" id="ch_ser.Sample_SOAP_server_a"><h3><span class="title">Sample SOAP server and client</span></h3><p>The Toolkit contains a simple example of SOAP client and server in its <span class="nctnt ncbi-path">src/sample/app/soap</span> folder.</p><p>The sample SOAP server supports the following operations:</p><p><span class="nctnt ncbi-func">GetDescription()</span> - server receives an empty object of type Description, and it sends back a single string;</p><p><span class="nctnt ncbi-func">GetVersion()</span> - server receives a string, and it sends back two integer numbers and a string;</p><p><span class="nctnt ncbi-func">DoMath()</span> - server receives a list of Operand objects (two integers and an enumerated value), and it sends back a list of integers</p><p>The starting point is the WSDL specification - <span class="nctnt ncbi-path">src\sample\app\soap\server\soap_server_sample.wsdl</span></p><p>Both client and server use data objects whose types are described in the message types section of WSDL specification. So, we extract the XML schema part of the specification into a separate file, and create a static library - <span class="nctnt ncbi-lib">soap_dataobj</span>. All code in this library is generated automatically by .</p><div class="sec" id="ch_ser.Sample_server"><h4><span class="title">Sample server</span></h4><p>Server is a CGI application. In its constructor we define the name of WSDL specification file and the default namespace for the data objects. Since server's ability to return a WSDL specification upon request from a client is optional, it is possible to give an empty file name here. Once the name is not empty, the WSDL file should be deployed alongside the server.</p><p>During initialization server should register incoming object types and message listeners:</p><p><span class="nctnt ncbi-code">// Register incoming object types, so the SOAP message parser can</span></p><p><span class="nctnt ncbi-code">// recognize these objects in incoming data and parse them correctly.</span></p><p><span class="nctnt ncbi-code">RegisterObjectType(CVersion::GetTypeInfo);</span></p><p><span class="nctnt ncbi-code">RegisterObjectType(CMath::GetTypeInfo);</span></p><p><span class="nctnt ncbi-code">// Register SOAP message processors.</span></p><p><span class="nctnt ncbi-code">// It is possible to set more than one listeners for a particular message;</span></p><p><span class="nctnt ncbi-code">// such listeners will be called in the order of registration.</span></p><p><span class="nctnt ncbi-code">AddMessageListener((TWebMethod)(&amp;CSampleSoapServerApplication::GetDescription), "Description");    AddMessageListener((TWebMethod)(&amp;CSampleSoapServerApplication::GetDescription2), "Description");</span></p><p><span class="nctnt ncbi-code">AddMessageListener((TWebMethod)(&amp;CSampleSoapServerApplication::GetVersion), "Version");</span></p><p><span class="nctnt ncbi-code">AddMessageListener((TWebMethod)(&amp;CSampleSoapServerApplication::DoMath), "Math");</span></p><p>Note that while it is possible to register the <span class="nctnt ncbi-monospace">Description</span> type, it does not make much sense: the object has no content, so there is no difference whether it will be parsed correctly or not.</p><p>Message listeners are user-defined functions that process incoming messages. They analyze the content of SOAP message request and populate the response object.</p></div><div class="sec" id="ch_ser.Sample_client"><h4><span class="title">Sample client</span></h4><p>Unlike SOAP server, SOAP client object has nothing to do with <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=CCgiApplication">CCgiApplication</a> class. It is "just" an object. As such, it can be created and destroyed when appropriate. Sample SOAP client constructor defines the server URL and the default namespace for the data objects. Its constructor is the proper place to register incoming object types:</p><p><span class="nctnt ncbi-code">// Register incoming object types, so the SOAP message parser can</span></p><p><span class="nctnt ncbi-code">// recognize these objects in incoming data and parse them correctly.</span></p><p><span class="nctnt ncbi-code">RegisterObjectType(CDescriptionText::GetTypeInfo);</span></p><p><span class="nctnt ncbi-code">RegisterObjectType(CVersionResponse::GetTypeInfo);</span></p><p><span class="nctnt ncbi-code">RegisterObjectType(CMathResponse::GetTypeInfo);</span></p><p>Other methods encapsulate operations supported by the SOAP server, which the client talks to. Common schema is to create two SOAP message object - request and response, populate request object, call <span class="nctnt ncbi-func">Invoke()</span> method of the base class, and extract the meaningful data from the response.</p></div></div></div><div class="sec" id="ch_ser.ch_ser_test_cases"><h2><span class="title">Test Cases [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/serial/test">src/serial/test</a>]</span></h2><p><a href="ch_proj.html#ch_proj.ser_object">Available Serializable Classes</a> (as per NCBI ASN.1 Specifications) [Library <span class="nctnt ncbi-path">xobjects</span>: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects">src</a>]</p><p>The ASN.1 data objects are automatically built from their corresponding specifications in the NCBI ASN.1 data model, using <a href="ch_app.html#ch_app.datatool">DATATOOL</a> to generate all of the required source code. This set of serializable classes defines an interface to many important sequence and sequence-aware objects that users may directly employ, or extend with their own code. An <span class="nctnt ncbi-monospace">Object Manager</span><a href="ch_objmgr.html">(see below)</a> coordinates and simplifies the use of these ASN.1-derived objects.</p><p>Serializable Classes</p><ul><li><p>access [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/access">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/access">src</a>]</p></li><li><p>biblio [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/biblio">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/biblio">src</a>]</p></li><li><p>cdd [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/cdd">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/cdd">src</a>]</p></li><li><p>cn3d [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/cn3d">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/cn3d">src</a>]</p></li><li><p>docsum [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/docsum">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/docsum">src</a>]</p></li><li><p>entrez2 [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/entrez2">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/entrez2">src</a>]</p></li><li><p>featdef [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/featdef">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/featdef">src</a>]</p></li><li><p>general [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/general">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/general">src</a>]</p></li><li><p>id1 [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/id1">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/id1">src</a>]</p></li><li><p>medlars [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/medlars">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/medlars">src</a>]</p></li><li><p>medline [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/medline">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/medline">src</a>]</p></li><li><p>mim [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mim">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mim">src</a>]</p></li><li><p>mla [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mla">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mla">src</a>]</p></li><li><p>mmdb1 [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb1">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mmdb1">src</a>]</p></li><li><p>mmdb2 [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb2">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mmdb2">src</a>]</p></li><li><p>mmdb3 [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb3">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mmdb3">src</a>]</p></li><li><p>ncbimime [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/ncbimime">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/ncbimime">src</a>]</p></li><li><p>objprt [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/objprt">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/objprt">src</a>]</p></li><li><p>proj [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/proj">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/proj">src</a>]</p></li><li><p>pub [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/pub">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/pub">src</a>]</p></li><li><p>pubmed [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/pubmed">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/pubmed">src</a>]</p></li><li><p>seq [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seq">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seq">src</a>]</p></li><li><p>seqalign [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqalign">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqalign">src</a>]</p></li><li><p>seqblock [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqblock">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqblock">src</a>]</p></li><li><p>seqcode [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqcode">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqcode">src</a>]</p></li><li><p>seqfeat [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqfeat">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqfeat">src</a>]</p></li><li><p>seqloc [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqloc">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqloc">src</a>]</p></li><li><p>seqres [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqres">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqres">src</a>]</p></li><li><p>seqset [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqset">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqset">src</a>]</p></li><li><p>submit [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/submit">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/submit">src</a>]</p></li><li><p>taxon1 [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/taxon1">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/taxon1">src</a>]</p></li></ul><p>A Test Application Using the Serializable ASN.1 Classes</p><ul><li><p>asn2asn [<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/source//src/app/asn2asn">src</a>]</p></li></ul></div></div></div><div class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_ser.objstream.html">CObject[IO]Streams</a></li><li><a href="#ch_ser.iterators.html">The NCBI C++ Toolkit Iterators</a></li><li><a href="#ch_ser.asn.html">Processing Serial Data</a></li><li><a href="#ch_ser.usrtypeinfo.html">User-defined type information</a></li><li><a href="#ch_ser.typeinfo.html">Runtime Object Type Information</a></li><li><a href="#ch_ser.choice.html">Choice objects in the NCBI C++ Toolkit</a></li><li><a href="#ch_ser.traverse.html">Traversing a Data Structure</a></li><li><a href="#ch_ser.SOAP_support">SOAP support</a></li><li><a href="#ch_ser.ch_ser_test_cases">Test Cases [src/serial/test]</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_ser.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input name="__symbol" size="22" style="vertical-align:                                          middle;" onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />   <input value="Search" style="vertical-align: middle;" onclick="javasrcipt:SymbolSearch('toolkit');" type="button" /></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><span title="Search in the C/C++ source code and in this Book">All</span></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" /><span title="Search in the C/C++ source code,  this Book, and Wiki">All</span></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><span title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</span></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><span title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</span></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><span title="Locate the Toolkit library(es) where the symbol is defined">Library</span></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><span title="Locate the Toolkit library(es) where the symbol is defined">Library</span></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li><li class="internal-only">LXR: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident">internal</a></li><li class="internal-only">Doxygen: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml">internal</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li><a href="http://www.ncbi.nlm.nih.gov/bookshelf/br.fcgi?book=toolkit&amp;part=ch_getcode_svn#ch_getcode_svn.code_retrieval">Server</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++">Web
                            (dev)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++">Web
                            (extra)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components">Web (prod)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit">Wiki</a></li><li class="internal-only"><a href="http://jira/browse/CXX">JIRA</a></li><li class="internal-only"><a href="http://intranet/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download</a></li><li><a href="pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
