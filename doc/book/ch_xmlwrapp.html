<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>XmlWrapp (XML parsing and handling, XSLT, XPath) - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_xmlwrapp" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="js/jig/1.7/js/jig.min.js"></script><script type="text/javascript" src="js/toolkitSymbolSearch.js"></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents â–¾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access - SQL, Berkley DB</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_xmlauthor.html">29. XML Authoring using Word</a></li><li class="half_rhythm"><a href="ch_faq.html">30. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">31. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a><ul class="simple-list"><li class="half_rhythm"><a href="release_notes.html">Release Notes (Version 9, May 2012)</a></li><li class="half_rhythm"><a href="release_notes_7-05_2011.html">Release Notes (Version 7, May 2011)</a></li><li class="half_rhythm"><a href="release_notes_06_29_2010.html">Release Notes (June, 2010)</a></li><li class="half_rhythm"><a href="release_notes_05_15_2009.html">Release Notes (May, 2009)</a></li><li class="half_rhythm"><a href="release_notes_12_24_2008.html">Release Notes (December, 2008)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2008.html">Release Notes (March, 2008)</a></li><li class="half_rhythm"><a href="release_notes_08_27_2007.html">Release Notes (August, 2007)</a></li><li class="half_rhythm"><a href="release_notes_03_12_2007.html">Release Notes (March, 2007)</a></li><li class="half_rhythm"><a href="release_notes_08_14_2006.html">Release Notes (August, 2006)</a></li><li class="half_rhythm"><a href="release_notes_04_30_2006.html">Release Notes (April 30, 2006)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2005.html">Release Notes (December 31, 2005)</a></li><li class="half_rhythm"><a href="release_notes_10_03_2005.html">Release Notes (August, 2005)</a></li><li class="half_rhythm"><a href="release_notes_05_05_2005.html">Release Notes (April, 2005)</a></li><li class="half_rhythm"><a href="release_notes_03_09_2005.html">Release Notes (February, 2005)</a></li><li class="half_rhythm"><a href="release_notes_11_22_2004.html">Release Notes (November 22, 2004)</a></li><li class="half_rhythm"><a href="release_notes_10_2_2004.html">Release Notes (October 2, 2004)</a></li><li class="half_rhythm"><a href="release_notes_7_8_2004.html">Release Notes (July 8, 2004)</a></li><li class="half_rhythm"><a href="release_notes_april_16_2004.html">Release Notes (April 16, 2004)</a></li><li class="half_rhythm"><a href="release_notes_12_08_2003.html">Release Notes (December 8, 2003)</a></li><li class="half_rhythm"><a href="release_notes_08_01_2003.html">Release Notes (August 1, 2003)</a></li></ul></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="part4.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="part5.html">Next &gt;</a></div></div><div class="meta_content"><h1><span class="label">21</span><span class="title">XmlWrapp (XML parsing and handling, XSLT, XPath)</span></h1><p class="small">Created: August 2, 2009; Last Update: April 16, 2012.</p></div><div class="body_content"><div class="sec"><h2><span class="title">Overview</span></h2><div class="sec"><h3><span class="title">Introduction</span></h3><p>The NCBI C++ Toolkit has incorporated and enhanced the open source <a href="http://sourceforge.net/projects/xmlwrapp">XmlWrapp</a> package, which provides a simplified way for developers to work with XML. This chapter discusses the NCBI-enhanced XmlWrapp package and how to use it.</p></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p><ul><li><p><a href="#ch_xmlwrapp.General_Information">General Information</a></p></li><li><p><a href="#ch_xmlwrapp.XmlWrapp_Classes">XmlWrapp Classes</a></p></li><li><p><a href="#ch_xmlwrapp.How_To">How To</a></p><ul><li><p><a href="#ch_xmlwrapp._Create_a_Document_fr">Create a Document from an std::string Object</a></p></li><li><p><a href="#ch_xmlwrapp._Create_a_Document_fr_1">Create a Document from a File</a></p></li><li><p><a href="#ch_xmlwrapp.Save_a_Document_to_a">Save a Document or Node to a File</a></p></li><li><p><a href="#ch_xmlwrapp.Iterate_Over_Nodes">Iterate Over Nodes</a></p></li><li><p><a href="#ch_xmlwrapp.Insert_and_Remove_No">Insert and Remove Nodes</a></p></li><li><p><a href="#ch_xmlwrapp.Iterate_Over_Attribu">Iterate Over Attributes</a></p></li><li><p><a href="#ch_xmlwrapp.Insert_and_Remove_At">Insert and Remove Attributes</a></p></li><li><p><a href="#ch_xmlwrapp.Work_with_XML_Namesp">Work with XML Namespaces</a></p></li><li><p><a href="#ch_xmlwrapp.Use_an_Event_Parser">Use an Event Parser</a></p></li><li><p><a href="#ch_xmlwrapp.Make_an_XSLT_Transfo">Make an XSLT Transformation</a></p></li><li><p><a href="#ch_xmlwrapp.Run_an_XPath_Query">Run an XPath Query</a></p></li><li><p><a href="#ch_xmlwrapp.Run_an_XPath_Query_with_a_De">Run an XPath Query with a Default Namespace</a></p></li><li><p><a href="#ch_xmlwrapp.Use_an_XML_Catalog">Use an XML Catalog</a></p></li></ul></li><li><p><a href="#ch_xmlwrapp.Warning_Collaborative_Use_of">Warning: Collaborative Use of XmlWrapp and libxml2</a></p></li><li><p><a href="#ch_xmlwrapp.Implementation_Details">Implementation Details</a></p><ul><li><p><a href="#ch_xmlwrapp.Copying_and_Referencing_Node">Copying and Referencing Nodes</a></p></li><li><p><a href="#ch_xmlwrapp.Using_Namespaces_with_XPath">XPath Expressions and Namespaces</a></p></li><li><p><a href="#ch_xmlwrapp.Containers_of_Attributes__It">Containers of Attributes - Iteration and Size</a></p></li><li><p><a href="#ch_xmlwrapp.Changing_Default_Attributes">Changing Default Attributes</a></p></li><li><p><a href="#ch_xmlwrapp.Safe_and_Unsafe_Namespaces">Safe and Unsafe Namespaces</a></p></li></ul></li><li><p><a href="#ch_xmlwrapp.FAQ">FAQ</a></p></li></ul></div></div><div class="sec" id="ch_xmlwrapp.General_Information"><h2><span class="title">General Information</span></h2><p><span class="nctnt ncbi-lib">libxmlwrapp</span> is a generic XML handling C++ library built on top of widespread <span class="nctnt ncbi-lib">libxml2</span> / <span class="nctnt ncbi-lib">libxslt</span> C libraries. The main features of <span class="nctnt ncbi-lib">libxmlwrapp</span> are:</p><ul><li><p>Tree parser (DOM)</p></li><li><p>Event parser (SAX)</p></li><li><p>Creation / removal of nodes, attributes and documents</p></li><li><p>Searching nodes and attributes</p></li><li><p>XSLT transformation support</p></li><li><p>DTD validation support</p></li><li><p>XML catalog support</p></li></ul><p>In addition, NCBI has enhanced <span class="nctnt ncbi-lib">libxmlwrapp</span> by:</p><ul><li><p>Adding support for XPath.</p></li><li><p>Implementing full-featured XML namespace support for both nodes and attributes.</p></li><li><p>Adding XSD validation support.</p></li><li><p>Extending the functionality of some existing classes.</p></li><li><p>Adapting the demo code and test cases to work within the NCBI framework.</p></li><li><p>Fixing some bugs in <span class="nctnt ncbi-lib">libxmlwrapp</span>.</p></li></ul><p>The figure below illustrates the relationship between your C++ application and the XML libraries:</p><p><span><img src="img/Overview.png" alt="Image Overview.png" /></span></p><p>One goal of the <span class="nctnt ncbi-lib">libxmlwrapp</span> library is to be a very thin wrapper around <span class="nctnt ncbi-lib">libxml2</span> / <span class="nctnt ncbi-lib">libxslt</span> and to provide a simple yet powerful C++ interface without compromising speed. To achieve this goal, the library does not implement expensive run-time validity checks, and it is possible to write compilable C++ code that will cause a segmentation fault. For example, it is possible to create an unsafe <span class="nctnt ncbi-lib">libxmlwrapp</span> namespace object that points to an existing <span class="nctnt ncbi-lib">libxml2</span> namespace, then destroy the pointed-to namespace. This results in the unsafe <span class="nctnt ncbi-lib">libxmlwrapp</span> namespace object containing a dangling pointer. Subsequent access of the pointer will cause an exception or abnormal termination.</p><p>The original open source <a href="http://sourceforge.net/projects/xmlwrapp">libxmlwrapp</a> 0.6.0 was extended and modified to fit the NCBI C++ Toolkit build framework and API functionality requirements. Later, the functional changes introduced in 0.6.1 and 0.6.2 were patched into the NCBI code. Specific NCBI enhancements to <span class="nctnt ncbi-lib">libxmlwrapp</span> include:</p><ul><li><p>XPath support:</p><ul><li><p>XPath queries can be run based on XPath expressions. The queries return node sets which can be iterated.</p></li></ul></li><li><p>A new class, <span class="nctnt ncbi-class">xml::schema</span>, was added for XSD support.</p></li><li><p>Implementing a full-featured XML namespace class, for use by both nodes and attributes, with these features:</p><ul><li><p>Each node and attribute may be assigned to a namespace, or have their assignment removed. The assigned namespace can be retrieved.</p></li><li><p>Each node and attribute may contain a list of namespace definitions. Namespace definitions can be added to or removed from this list. The list can be retrieved.</p></li><li><p><span class="nctnt ncbi-lib">libxmlwrapp</span> namespace objects can be either safe or unsafe. Safe namespace objects prevent program crashes by eliminating potentially invalid pointers. Using unsafe namespace objects requires less time and memory, but may result in invalid pointers and may cause a crash. See the <a href="ch_xmlwrapp.html#ch_xmlwrapp.Safe_and_Unsafe_Namespaces">safe and unsafe namespaces</a> section for more details.</p></li><li><p>Nodes and attributes can now be searched by namespace as well as by name.</p></li></ul></li><li><p>Error handling was enhanced (or added) for tree and event parsing, and for DTD and XSD validation. Formerly, only the last message was retained and processing stopped on the first error. Now all messages are retained and processing only stops if a fatal error is encountered.</p></li><li><p>Adapting the demo code and test cases to work within the NCBI framework.</p></li><li><p>Fixing some bugs in <span class="nctnt ncbi-lib">libxmlwrapp</span>:</p><ul><li><p><span class="nctnt ncbi-lib">libxmlwrapp</span> 0.6.0 did not copy the namespace when it copied an attribute. The NCBI enhancement copies the assigned namespace (and all namespace definitions contained by an attribute) when it is copied.</p></li><li><p>The Sun WorkShop compiler failed to compile <span class="nctnt ncbi-lib">libxmlwrapp</span> 0.6.0 because it was missing a definition for the STL distance algorithm. The NCBI enhancement conditionally defines this template for this compiler.</p></li><li><p>The XML parser in <span class="nctnt ncbi-lib">libxmlwrapp</span> 0.6.0 failed to detect a certain form of mal-formed document. NCBI found and fixed this bug. The patch was submitted to the <span class="nctnt ncbi-lib">libxmlwrapp</span> project and was accepted.</p></li></ul></li></ul><p>The NCBI enhancements retain the generic nature of <span class="nctnt ncbi-lib">libxmlwrapp</span>, and are not tailored to any particular application domain.</p><p><span class="nctnt ncbi-lib">libxmlwrapp</span> demo <a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++/src/internal/demo/misc/xmlwrapp">applications</a> and <a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++/src/internal/test/misc/xmlwrapp">unit tests</a> are available inside NCBI, but the most common and basic usage examples are given in the <a href="ch_xmlwrapp.html#ch_xmlwrapp.How_To">next section</a>.</p><p>All the <span class="nctnt ncbi-lib">libxmlwrapp</span> functionality resides in the the C++ namespaces <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/namespacexml.html">xml::</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/namespacexslt.html">xslt::</a>, and all the code is Doxygen-style commented.</p></div><div class="sec" id="ch_xmlwrapp.XmlWrapp_Classes"><h2><span class="title">XmlWrapp Classes</span></h2><p><span><img src="img/ch_xmlwrapp_classes.png" alt="Image ch_xmlwrapp_classes.png" /></span></p><p>The figure above shows the most important classes in the <span class="nctnt ncbi-lib">libxmlwrapp</span> library. XML can be parsed from a file, memory buffer, or stream, creating a <span class="nctnt ncbi-lib">libxmlwrapp</span> document object. One of the most important things you can get from the document object is the document root node.</p><p>Several classes in the figure are marked with the small "circled-i" symbol in the corner. This mark means that the class supports iterators and const iterators. The node class is a container of other nodes and you can iterate over immediate node children similar to how you do with STL containers.</p><p>A node may have an XML namespace and also may define namespaces. To support this, <span class="nctnt ncbi-lib">libxmlwrapp</span> provides the XML namespace class, <span class="nctnt ncbi-class">ns</span>.</p><p>An XML node may have attributes as well, so <span class="nctnt ncbi-lib">libxmlwrapp</span> has the <span class="nctnt ncbi-class">attributes</span> class. This class is a container of attributes so both const and non-const iterators are provided.</p><p>The XPath support includes the <span class="nctnt ncbi-class">xpath_expression</span> and <span class="nctnt ncbi-class">node_set</span> classes. <span class="nctnt ncbi-class">xpath_expression</span> objects hold a single expression. <span class="nctnt ncbi-class">node_set</span> objects are created as the result of executing an XPath query for a given node. The <span class="nctnt ncbi-class">node_set</span> class is a container so it supports iterators.</p><p>To support XSD schema validation and DTD validation, <span class="nctnt ncbi-lib">libxmlwrapp</span> has the <span class="nctnt ncbi-class">schema</span> and <span class="nctnt ncbi-class">dtd</span> classes. These classes work together with the <span class="nctnt ncbi-class">document</span> class.</p><p>Warnings, errors and fatal errors may occur during the parsing and validating. To collect them, <span class="nctnt ncbi-lib">libxmlwrapp</span> provides the <span class="nctnt ncbi-class">error_messages</span> class. The <span class="nctnt ncbi-class">error_messages</span> class includes the <span class="nctnt ncbi-func">print()</span> method, which returns a string containing a newline-separated list of messages. It also includes the <span class="nctnt ncbi-func">has_warnings()</span>, <span class="nctnt ncbi-func">has_errors()</span>, and <span class="nctnt ncbi-func">has_fatal_errors()</span> methods in case you are interested in the presence of a specific type of message. Note that errors and fatal errors are considered separately, so <span class="nctnt ncbi-func">has_fatal_errors()</span> may return <span class="nctnt ncbi-code">true</span> while <span class="nctnt ncbi-func">has_errors()</span> returns <span class="nctnt ncbi-code">false</span>.</p></div><div class="sec" id="ch_xmlwrapp.How_To"><h2><span class="title">How To</span></h2><p>This section includes compact code fragments that show the essence of how to achieve typical goals using <span class="nctnt ncbi-lib">libxmlwrapp</span>. The examples do not illustrate all the features of <span class="nctnt ncbi-lib">libxmlwrapp</span> and are not intended to be complete and compilable. Your code will need to include the necessary headers, use try-catch blocks, check for errors, and validate the XML document.</p><div class="sec" id="ch_xmlwrapp._Create_a_Document_fr"><h3><span class="title">Create a Document from an std::string Object</span></h3><pre><span class="nctnt-pre ncbi-code">std::string         xmldata( "&lt;TagA&gt;"<br />                                 "&lt;TagB&gt;stuff&lt;/TagB&gt;"<br />                             "&lt;/TagA&gt;" );<br />xml::document       doc( xmldata.c_str(), xmldata.size(), NULL );</span></pre></div><div class="sec" id="ch_xmlwrapp._Create_a_Document_fr_1"><h3><span class="title">Create a Document from a File</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document       doc( "MyFile.xml", NULL );</span></pre><p><span class="nctnt highlight">Note:</span> The second parameter above is a pointer to an <span class="nctnt ncbi-class">error_messages</span> object, which stores any messages collected while parsing the XML document (a <span class="nctnt ncbi-code">NULL</span> value can be passed if you're not interested in collecting error messages). For example:</p><pre><span class="nctnt-pre ncbi-code">xml::error_messages msgs;<br />xml::document       doc( "MyFile.xml", &amp;msgs );<br />std:cout &lt;&lt; msgs.print() &lt;&lt; std:endl;</span></pre></div><div class="sec" id="ch_xmlwrapp.Save_a_Document_to_a"><h3><span class="title">Save a Document or Node to a File</span></h3><p>The simplest way is inserting into a stream:</p><pre><span class="nctnt-pre ncbi-code">// save document<br />xml::document       xmldoc( "abook" );  // "abook" is the root node<br />std::ofstream       f( "doc_file.xml" );<br /><br />f &lt;&lt; xmldoc;<br />f.close();<br /><br />// save node<br />xml::node           n( "the_one" );<br />std::ofstream       node_file( "node_file.xml" );<br /><br />node_file &lt;&lt; n &lt;&lt; std::endl;<br />f.close();</span></pre><p>The simplest way provides no control on how the output is formatted, but there is an alternative set of functions that accept formatting flags:</p><pre><span class="nctnt-pre ncbi-code">xml::document::save_to_string(...)<br />xml::document::save_to_stream(...)<br />xml::document::save_to_file(...)<br />xml::node::node_to_string(...)</span></pre><p>For example, if you do not want to have the XML declaration at the beginning of the document then you might have code similar to:</p><pre><span class="nctnt-pre ncbi-code">xml::document       doc( "example.xml", NULL );<br />std::string         s;<br /><br />doc.save_to_string( s, xml::save_op_no_decl );</span></pre><p>For a complete list of available formatting flags, see <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/namespacexml.html#8599801d006476631c27a732819b9995"><tt>enum xml::save_options</tt></a>.</p></div><div class="sec" id="ch_xmlwrapp.Iterate_Over_Nodes"><h3><span class="title">Iterate Over Nodes</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document       doc( "MyFile.xml", NULL );<br />xml::node &amp;         root = doc.get_root_node();<br /><br />xml::node::const_iterator   child( root.begin() );<br />xml::node::const_iterator   child_end( root.end() );<br /><br />std::cout &lt;&lt; "root node is '" &lt;&lt; root.get_name() &lt;&lt; "'\n";<br />for ( ; child != child_end; ++child ) <br />{<br />    if ( child-&gt;is_text() ) continue;<br />    std::cout &lt;&lt; "child node '" &lt;&lt; child-&gt;get_name() &lt;&lt; "'" &lt;&lt; std:endl;<br />}</span></pre></div><div class="sec" id="ch_xmlwrapp.Insert_and_Remove_No"><h3><span class="title">Insert and Remove Nodes</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document           doc( "MyFile2.xml", NULL );<br />xml::node &amp;             root = doc.get_root_node();<br />xml::node::iterator     i = root.find( "insert_before", root.begin() );<br /><br />root.insert( i, xml::node("inserted") );<br />i = root.find( "to_remove", root.begin() );<br />root.erase( i );</span></pre></div><div class="sec" id="ch_xmlwrapp.Iterate_Over_Attribu"><h3><span class="title">Iterate Over Attributes</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document              doc( "MyFile.xml", NULL );<br />const xml::attributes &amp;    attrs = doc.get_root_node().get_attributes();<br /><br />xml::attributes::const_iterator   i = attrs.begin();<br />xml::attributes::const_iterator   end = attrs.end();<br /><br />for ( ; i!=end; ++i )<br />{<br />    std::cout &lt;&lt; i-&gt;get_name() &lt;&lt; "=" &lt;&lt; i-&gt;get_value() &lt;&lt; std:endl;<br />}</span></pre></div><div class="sec" id="ch_xmlwrapp.Insert_and_Remove_At"><h3><span class="title">Insert and Remove Attributes</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document           doc( "MyFile.xml", NULL );<br />xml::attributes &amp;       attrs = doc.get_root_node().get_attributes();<br /><br />attrs.insert( "myAttr", "attrValue" );<br />xml::attributes::iterator i = attrs.find( "attrToRemove" );<br />attrs.erase( i );</span></pre></div><div class="sec" id="ch_xmlwrapp.Work_with_XML_Namesp"><h3><span class="title">Work with XML Namespaces</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document           doc( "MyFile.xml", NULL );<br />xml::node &amp;             root = doc.get_root_node();<br />xml::ns                 rootSpace( root.get_namespace() );<br /><br />std::cout &lt;&lt; "Root namespace: " &lt;&lt; rootSpace.get_prefix() &lt;&lt; "-&gt;"<br />          &lt;&lt; rootSpace.get_uri() &lt;&lt; std:endl;<br /><br />xml::attributes &amp;           attrs = root.get_attributes();<br />xml::attributes::iterator   attr( attrs.find( "firstAttr" ) );<br />xml::ns                     attrSpace( attr-&gt;get_namespace() );<br /><br />std::cout &lt;&lt; "Attribute namespace: " &lt;&lt; attrSpace.get_prefix() &lt;&lt; "-&gt;"<br />          &lt;&lt; attrSpace.get_uri() &lt;&lt; std:endl;<br />root.add_namespace_definition( xml::ns( "myPrefix", "myURI" ),<br />                               xml::node::type_throw_if_exists );<br />root.set_namespace( "myPrefix" );<br />attr-&gt;set_namespace( "myPrefix" );</span></pre></div><div class="sec" id="ch_xmlwrapp.Use_an_Event_Parser"><h3><span class="title">Use an Event Parser</span></h3><p>For those within NCBI, there is <a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++/src/internal/test/misc/xmlwrapp/event/test_event.cpp?revision=156258&amp;view=markup">sample code</a> showing how to use an event parser.</p></div><div class="sec" id="ch_xmlwrapp.Make_an_XSLT_Transfo"><h3><span class="title">Make an XSLT Transformation</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document         doc( "example.xml", NULL );<br />xslt::stylesheet      style( "example.xsl" );<br />xml::document         result = style.apply( doc );<br />std::string           tempString;<br /><br />result.save_to_string( tempString );<br />// or<br />std::cout &lt;&lt; "Result:\n" &lt;&lt; result &lt;&lt; std:endl;</span></pre><p>If the outcome of applying the stylesheet is a valid XML document, the <span class="nctnt ncbi-code">result</span> variable will hold the transformed content - otherwise it will hold a blank XML document (i.e. "<span class="nctnt ncbi-monospace">&lt;blank/&gt;</span>").</p></div><div class="sec" id="ch_xmlwrapp.Run_an_XPath_Query"><h3><span class="title">Run an XPath Query</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document                  doc( "example.xml", NULL );<br />xml::node &amp;                    root = doc.get_root_node();<br />xml::xpath_expression          expr( "/root/child" );<br />const xml::node_set            nset( root.run_xpath_query( expr ) );<br />size_t                         nnum( 0 );<br />xml::node_set::const_iterator  k( nset.begin() );<br /><br />for ( ; k != nset.end(); ++k )<br />    cout &lt;&lt; "Node #" &lt;&lt; nnum++ &lt;&lt; endl<br />         &lt;&lt; *k &lt;&lt; endl;</span></pre><p>Please note that the <span class="nctnt ncbi-var">node_set</span> object holds a set of references to the nodes from the document which is used to run the XPath query. Therefore you can change the nodes in the original document if you use a non-constant <span class="nctnt ncbi-var">node_set</span> and non-constant iterators.</p><p>The <span class="nctnt ncbi-var">xpath_expression</span> object also supports:</p><ul><li><p>pre-compilation of the XPath query string</p></li><li><p>namespace registration (a single namespace or a list of namespaces)</p></li></ul></div><div class="sec" id="ch_xmlwrapp.Run_an_XPath_Query_with_a_De"><h3><span class="title">Run an XPath Query with a Default Namespace</span></h3><p>The XPath specification does not support default namespaces, and it considers all nodes without prefixes to be in the null namespace, not the default namespace. This creates a problem when you want to search for nodes to which a default namespace applies, because the default namespace cannot be directly matched. For example, the following code will not find any matches:</p><pre><span class="nctnt-pre ncbi-code">std::string                     xmldata("&lt;A xmlns=\"http://nlm.nih.gov\"&gt;"<br />                                            "&lt;B&gt;&lt;C&gt;stuff&lt;/C&gt;&lt;/B&gt;"<br />                                        "&lt;/A&gt;" );<br />xml::document                   doc( xmldata.c_str(), xmldata.size(),<br />                                     NULL );<br />xml::node &amp;                     root = doc.get_root_node();<br />xml::xpath_expression           expr( "//B/C" );<br />const xml::node_set             nset( root.run_xpath_query( expr ) );<br />size_t                          nnum( 0 );<br />xml::node_set::const_iterator   k( nset.begin() );<br /><br />for ( ; k != nset.end(); ++k )<br />    cout &lt;&lt; "Node #" &lt;&lt; nnum++ &lt;&lt; endl<br />         &lt;&lt; *k &lt;&lt; endl;</span></pre><p>The solution is to create a special namespace with the sole purpose of associating a made-up prefix with the URI of the default namespace. Use that namespace when creating the XPath expression, and prefix the nodes in your XPath expression with your made-up prefix. This prefix should be distinct from other prefixes in the document. The following code will find the desired node:</p><pre><span class="nctnt-pre ncbi-code">std::string                     xmldata("&lt;A xmlns=\"http://nlm.nih.gov\"&gt;"<br />                                            "&lt;B&gt;&lt;C&gt;stuff&lt;/C&gt;&lt;/B&gt;"<br />                                        "&lt;/A&gt;" );<br />xml::document                   doc( xmldata.c_str(), xmldata.size(),<br />                                     NULL );<br />xml::node &amp;                     root = doc.get_root_node();<br /><br />                                // here we add a made-up namespace<br />xml::ns                         fake_ns( "fake_pfx", "http://nlm.nih.gov" );<br /><br />                                // now we register the made-up namespace and<br />                                // use the made-up prefix<br />xml::xpath_expression           expr( "//fake_pfx:B/fake_pfx:C", fake_ns );<br /><br />const xml::node_set             nset( root.run_xpath_query( expr ) );<br />size_t                          nnum( 0 );<br />xml::node_set::const_iterator   k( nset.begin() );<br /><br />for ( ; k != nset.end(); ++k )<br />    cout &lt;&lt; "Node #" &lt;&lt; nnum++ &lt;&lt; endl<br />         &lt;&lt; *k &lt;&lt; endl;</span></pre></div><div class="sec" id="ch_xmlwrapp.Use_an_XML_Catalog"><h3><span class="title">Use an XML Catalog</span></h3><p>The <span class="nctnt ncbi-var">XML_CATALOG_FILES</span> environment variable may be used in one of three ways to control the XML catalog feature of <span class="nctnt ncbi-lib">libxml2</span> â€“ i.e. the way <span class="nctnt ncbi-lib">libxml2</span> resolves unreachable external URI's:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">If <span class="nctnt ncbi-var">XML_CATALOG_FILES</span> is not set in the process environment then the default catalog will be used.</p></dd><dt>2</dt><dd><p class="no_top_margin">If it is set to an empty value then the default catalog will be deactivated and there will be no resolution of unreachable external URI's.</p></dd><dt>3</dt><dd><p class="no_top_margin">If it is set to a space-separated list of catalog files, then <span class="nctnt ncbi-lib">libxml2</span> will use these files to resolve external URI's. Any invalid paths will be silently ignored.</p></dd></dl><p>The default catalog is <span class="nctnt ncbi-path">/etc/xml/catalog</span> for non-Windows systems. For Windows, the default catalog is <span class="nctnt ncbi-path">&lt;module_path&gt;\..\etc\catalog</span>, where <span class="nctnt ncbi-path">&lt;module_path&gt;</span> is the path to the installed <span class="nctnt ncbi-path">libxml2.dll</span>, if available, otherwise the path to the running program.</p><p>The <span class="nctnt ncbi-var">XML_CATALOG_FILES</span> environment variable is read once before the first parsing operation, and then any specified catalogs are used globally for URI resolution in all subsequent parsing operations. Therefore, if the <span class="nctnt ncbi-var">XML_CATALOG_FILES</span> value is to be set programmatically, it must be done prior to the first parsing operation.</p><p>There is another environment variable (<span class="nctnt ncbi-var">XML_DEBUG_CATALOG</span>) to control debug output.  If it is defined, then debugging output will be enabled.</p></div></div><div class="sec" id="ch_xmlwrapp.Warning_Collaborative_Use_of"><h2><span class="title">Warning: Collaborative Use of XmlWrapp and libxml2</span></h2><p>XmlWrapp uses the <span class="nctnt ncbi-var">_private</span> field of the raw <span class="nctnt ncbi-lib">libxml2 </span><span class="nctnt ncbi-type">xmlNode</span> data structure for internal purposes. Therefore, if <span class="nctnt ncbi-lib">libxml2</span> and XmlWrapp are used collaboratively then this field must not be used in client code. If it is used, it may cause a core dump or other undefined behavior.</p></div><div class="sec" id="ch_xmlwrapp.Implementation_Details"><h2><span class="title">Implementation Details</span></h2><div class="sec" id="ch_xmlwrapp.Copying_and_Referencing_Node"><h3><span class="title">Copying and Referencing Nodes</span></h3><p><span class="nctnt ncbi-class">xml::node</span> objects are frequently required when working with XML documents. There are two ways to work with a given node:</p><ul><li><p>by referencing it; or</p></li><li><p>by copying it.</p></li></ul><p>This example shows both ways:</p><pre><span class="nctnt-pre ncbi-code">xml::document       doc( "example.xml", NULL );<br />xml::node_set       nset( doc.get_root_node().<br />                                  run_xpath_query( "/root/child" ) );<br /><br />// Iterate over the result node set<br />xml::node_set::iterator     k = nset.begin();<br />for ( ; k != nset.end(); ++k ) {<br /><br />    // just reference the existing node<br />    xml::node &amp;     node_ref = *k;<br /><br />    // create my own copy (which I'll own and destroy)<br />    xml::node *     my_copy = k-&gt;detached_copy();<br /><br />    // Do something<br />    ...<br /><br />    // Don't forget this<br />    delete my_copy;<br />}</span></pre><p>What is the difference between the <span class="nctnt ncbi-var">node_ref</span> and <span class="nctnt ncbi-var">my_copy</span> variables?</p><p>The <span class="nctnt ncbi-var">node_ref</span> variable refers to a node in the original document loaded from <span class="nctnt ncbi-path">example.xml</span>. If you change something using the <span class="nctnt ncbi-var">node_ref</span> variable youâ€™ll make changes in the original document object.</p><p>The <span class="nctnt ncbi-var">my_copy</span> variable is a recursive copy of the corresponding node together with all used namespace definitions, non-default attributes, and nested nodes. The copy has no connection to the original document. The <span class="nctnt ncbi-var">my_copy</span> variable has no parent node and has no links to the internal and external subsets (DTDs) which the original document could have. If you change something using the <span class="nctnt ncbi-var">my_copy</span> variable youâ€™ll make changes in the copy but not in the original document. Obviously it takes more time to create such a recursive copy of a node.</p><p><span class="nctnt highlight">Note:</span> It is recommended to pass nodes by reference when appropriate to maximize performance and avoid modification of copies.</p></div><div class="sec" id="ch_xmlwrapp.Using_Namespaces_with_XPath"><h3><span class="title">Using Namespaces with XPath Expressions</span></h3><p>XmlWrapp provides the <span class="nctnt ncbi-class">xml::xpath_expression</span> class for building reusable XPath expressions. If namespaces are involved then one of the constructors which accept a namespace or a list of namespaces should be used. Otherwise the XPath query results may not have the nodes you expect to get.</p><p>XmlWrapp also provides a convenience method for the nodes: <span class="nctnt ncbi-func">xml::node::run_xpath_query( const char *  expr)</span>. This method builds an <span class="nctnt ncbi-class">xpath_expression</span> internally and registers all the effective namespaces for the certain node. While it is very convenient as you donâ€™t need to know in advance what the namespace definitions are, this method has some drawbacks:</p><ul><li><p>The internally built <span class="nctnt ncbi-class">xpath_expression</span> is not reusable, so it gets rebuilt every time a query is run - even if the same expression was used before.</p></li><li><p>The list of effective namespace definitions for a certain node can be quite long and may exceed your actual needs. It takes time to build such a list and to register them all so it affects the performance.</p></li></ul><p>Recommendations:</p><ul><li><p>If you need the best performance then use <span class="nctnt ncbi-class">xml::xpath_expression</span> explicitly and do not forget to provide a list of the required namespaces.</p></li><li><p>If you arenâ€™t concerned about performance then use one of the <span class="nctnt ncbi-func">xml::node::run_xpath_query( const char *  expr)</span> methods.</p></li></ul></div><div class="sec" id="ch_xmlwrapp.Containers_of_Attributes__It"><h3><span class="title">Containers of Attributes - Iteration and Size</span></h3><p>Sometimes it is necessary to iterate over a node's attributes or to find an attribute. Letâ€™s take a simple example:</p><pre>&lt;?xml version="1.0" ?&gt;<br />&lt;root xmlns:some_ns="http://the.com"<br />      attr1       = "val1"<br />      foo         = "fooVal"<br />      some_ns:bar = "barVal"&gt;<br />&lt;/root&gt;</pre><p>XmlWrapp provides an STL-like way of iterating over the attributes, e.g:</p><pre><span class="nctnt-pre ncbi-code">void f( const xml::node &amp;  theNode ) {<br />    const xml::attributes &amp;  attrs = theNode.get_attributes();<br /><br />    for ( xml::attributes::const_iterator  k = attrs.begin();<br />          k != attrs.end(); ++k )<br />        cout &lt;&lt; "Attribute name: " &lt;&lt; k-&gt;get_name()<br />             &lt;&lt; " value: " &lt;&lt; k-&gt;get_value() &lt;&lt; endl;<br />}</span></pre><p>You may notice that iterators are used here and the iterators can be incremented.</p><p><span class="nctnt highlight">Note:</span> Although iterating over attributes is STL-like, searching for an attribute is only partially STL-like. Iterators returned by the <span class="nctnt ncbi-func">find()</span> method cannot be incremented, but both operator <span class="nctnt ncbi-code">-&gt;</span> and operator <span class="nctnt ncbi-code">*</span> can be used. The following code will work:</p><pre><span class="nctnt-pre ncbi-code">void f( const xml::node &amp;  theNode, const char *  attrName ) {<br />    const xml::attributes &amp;          attrs = theNode.get_attributes();<br />    xml::attributes::const_iterator  found = attrs.find( attrName );<br /><br />    if ( found != attrs.end() )<br />        cout &lt;&lt; "Found name: " &lt;&lt; (*found).get_name()<br />             &lt;&lt; "Found value: " &lt;&lt; found-&gt;get_value() &lt;&lt; endl;<br />}</span></pre><p>but this code will generate an exception:</p><pre><span class="nctnt-pre ncbi-code">void f( const xml::node &amp;  theNode, const char *  attrName ) {<br />    const xml::attributes &amp;          attrs = theNode.get_attributes();<br />    xml::attributes::const_iterator  found = attrs.find( attrName );<br /><br />    if ( found != attrs.end() )<br />        ++found;  // Exception is guaranteed here<br />}</span></pre><p>This implementation detail is related to the limitations of <span class="nctnt ncbi-lib">libxml2</span> with respect to default attributes. Letâ€™s take an example that has a DTD:</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;!DOCTYPE root PUBLIC "something" "my.dtd" [<br />&lt;!ATTLIST root defaultAttr CDATA "defaultVal"&gt;<br />]&gt;<br />&lt;root xmlns:some_ns="http://the.com"<br />      attr1       = "val1"<br />      foo         = "fooVal"<br />      some_ns:bar = "barVal"&gt;<br />&lt;/root&gt;</pre><p>This example introduces a default attribute called defaultAttr for the root node. The <span class="nctnt ncbi-lib">libxml2</span> library stores default and non-default attributes separately. The library provides very limited access the default attributes - there is no way to iterate over them and the only possible way to get a default attribute is to search for it explicitly. For example:</p><pre><span class="nctnt-pre ncbi-code">void f( const xml::node &amp;  theNode ) {<br />    const xml::attributes &amp;          attrs = theNode.get_attributes();<br />    xml::attributes::const_iterator  found = attrs.find( "defaultAttr" );<br /><br />    if ( found != attrs.end() ) {<br />        cout &lt;&lt; "Default? " &lt;&lt; found-&gt;is_default() &lt;&lt; endl;<br />        cout &lt;&lt; "Name: " &lt;&lt; found-&gt;get_name()<br />             &lt;&lt; " Value: " &lt;&lt; found-&gt;get_value() &lt;&lt; endl;<br />    }<br />}</span></pre><p>XmlWrapp forbids incrementing iterators provided by <span class="nctnt ncbi-func">xml::attributes::find(...)</span> methods because:</p><ul><li><p><span class="nctnt ncbi-lib">libxml2</span> has limited support for working with default attributes; and</p></li><li><p>iterators provided by the <span class="nctnt ncbi-func">xml::attributes::find()</span> methods may point to either a default or a non-default attribute.</p></li></ul><p><span class="nctnt highlight">Note:</span> This <span class="nctnt ncbi-lib">libxml2</span> limitation affects the <span class="nctnt ncbi-func">xml::attributes::size()</span> method behavior. It will always provide the number of non-default attributes and will never include the number of default attributes regardless of whether or not a node has default attributes.</p></div><div class="sec" id="ch_xmlwrapp.Changing_Default_Attributes"><h3><span class="title">Changing Default Attributes</span></h3><p><span class="nctnt ncbi-lib">libxml2</span> does not provide the ability to change a default attribute. XmlWrapp does provide this ability, but at the cost of implicitly converting the default attribute into a non-default attribute. Consider the following document:</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;!DOCTYPE root PUBLIC "something" "my.dtd" [<br />&lt;!ATTLIST root language CDATA "EN"&gt;<br />]&gt;<br />&lt;root xmlns:some_ns="http://the.com"<br />      some_ns:bar = "barVal"&gt;<br />&lt;/root&gt;</pre><p>The code below demonstrates changing a default attribute and is totally OK as explained in the comments (error handling is omitted for clarity):</p><pre><span class="nctnt-pre ncbi-code">xml::document               doc( "example.xml", NULL );<br />xml::node &amp;                 root = doc.get_root_node();<br />xml::attributes &amp;           attrs = root.get_attributes();<br />xml::attributes::iterator   j = attrs.find( "language" );<br /><br />// Here j points to the default attribute<br />assert( j-&gt;is_default() == true );<br /><br />// Now suppose we need to change the default language to French.<br />// It is forbidden to change the default attribute's values because<br />// the default attribute might be applied to many nodes while a change<br />// could be necessary for a single node only.<br />// So, to make a change operation valid, XmlWrapp first converts the default<br />// attribute to a non-default one and then changes its value.<br /><br />j-&gt;set_value( "FR" );<br /><br />// Now the iterator j is still valid and points to a non-default attribute<br />assert( j != attrs.end() );<br />assert( j-&gt;is_default() == false );<br /><br />// If you decide to save the document at this point then youâ€™ll see<br />// the root node with one node attribute language="FR"</span></pre><p>A similar conversion will happen if you decide to change a default attribute namespace.</p><p>XmlWrapp will also ensure that all iterators pointing to the same attribute remain consistent when multiple iterators point to the same default attribute and one of them is changed. For example:</p><pre><span class="nctnt-pre ncbi-code">xml::document               doc( "example.xml", NULL );<br />xml::node &amp;                 root = doc.get_root_node();<br />xml::attributes &amp;           attrs = root.get_attributes();<br />xml::attributes::iterator   j = attrs.find( "language" );<br />xml::attributes::iterator   k = attrs.find( "language" );<br /><br />// Here we have two iterators j and k pointing to the same default attribute<br />assert( j-&gt;is_default() == true );<br />assert( k-&gt;is_default() == true );<br /><br />// Now the attribute is implicitly converted to a non-default one<br />// using one of the iterators<br />j-&gt;set_value( "FR" );<br /><br />// Both j and k iterators are now pointing to a non-default (ex-default)<br />// attribute<br />assert( j-&gt;is_default() == false );<br />assert( k-&gt;is_default() == false );<br /><br />// And of course:<br />assert( j-&gt;get_value() == std::string( "FR" ) );<br />assert( k-&gt;get_value() == std::string( "FR" ) );</span></pre><p>For a diagram illustrating how the XmlWrapp library handles iterators and changed default attributes, please see <a href="ch_xmlwrapp.html#ch_xmlwrapp.1.2">Figure 1, Phantom Attributes</a>.</p><div class="figure" id="ch_xmlwrapp.1.2"><div class="graphic"><img src="img/ch_xmlwrapp_phantom_attr.png" alt="Figure 1. Phantom Attributes." /></div><div class="caption"><p>Figure 1. Phantom Attributes.</p></div></div></div><div class="sec" id="ch_xmlwrapp.Safe_and_Unsafe_Namespaces"><h3><span class="title">Safe and Unsafe Namespaces</span></h3><p>XmlWrapp provides a wrapper class called <span class="nctnt ncbi-class">xml::ns</span> to work with namespaces. The <span class="nctnt ncbi-class">xml::ns</span> class can be of two types: safe and unsafe.</p><p>To understand the difference between them it is necessary to know how <span class="nctnt ncbi-lib">libxml2</span> works with namespaces. Namespace structures in <span class="nctnt ncbi-lib">libxml2</span> store two pointers to character strings - a namespace prefix and a namespace URI. These structures are stored in a linked list and each XML document element that might have a namespace has a pointer that points to a namespace structure. Thus, namespaces can be uniquely identified by either a namespace pointer or by a prefix / URI pair.</p><p>XmlWrapp covers both ways. The <span class="nctnt ncbi-class">xml::ns</span> can store its own copies of the namespace prefix and URI, and in this case the namespace is called safe. Or, the <span class="nctnt ncbi-class">xml::ns</span> can store just a pointer to the corresponding namespace structure, and in this case the namespace is called unsafe.</p><p><span><img src="img/ch_xmlwrapp_xmlns.png" alt="Image ch_xmlwrapp_xmlns.png" /></span></p><p>A safe namespace can be constructed based on strings provided by the user or by making copies of the prefix and URI strings extracted from the <span class="nctnt ncbi-lib">libxml2</span> low level structure. Having a copy of the strings makes it absolutely safe to manipulate namespaces - it is even possible to get a namespace from one document, destroy the document, and then apply the stored namespace to another document.</p><p>When XmlWrapp receives an unsafe namespace for a namespace manipulation operation, it does not perform any checks and uses the raw pointer as-is. So there is a chance to break your document and even cause your application to core dump if an unsafe namespace is used improperly. For example the user may take an unsafe namespace from one document, destroy the document, and then apply the stored unsafe namespace to another document. At the time the original document is destroyed the low level namespace structure is destroyed as well but the pointer to the namespace is still stored so any access operation will cause problems.</p><p>Unsafe namespaces have some advantages though. They require less memory and they work faster. So the recommendation is to use safe namespaces unless you really need the best possible performance and slight reduction of the memory footprint.</p></div></div><div class="sec" id="ch_xmlwrapp.FAQ"><h2><span class="title">FAQ</span></h2><p><b>Q. Is </b><span class="nctnt ncbi-lib">libxmlwrapp</span><b> thread safe?</b></p><p>A. As safe as <span class="nctnt ncbi-lib">libxml2</span> and <span class="nctnt ncbi-lib">libxslt</span> are. It is still better to avoid simultaneous processing of the same document from many threads.</p><p><b>Q. Does </b><span class="nctnt ncbi-lib">libxmlwrapp</span> <b>support XML catalogs?</b></p><p>A. Yes, to the extent that <span class="nctnt ncbi-lib">libxml2</span> supports them. All the <span class="nctnt ncbi-lib">libxml2</span> fuctionality is available, but there is no special support code for XML catalogs in the <span class="nctnt ncbi-lib">libxmlwrapp</span> library. See the <a href="ch_xmlwrapp.html#ch_xmlwrapp.Use_an_XML_Catalog">How to Use an XML Catalog</a> section for details.</p><p><b>Q. What header files do I need to include?</b></p><p>A. You need <span class="nctnt ncbi-code">&lt;misc/xmlwrapp/xmlwrapp.hpp&gt;</span> for functionality that resides in the<span class="nctnt ncbi-code"> xml::</span> C++ namespace, and <span class="nctnt ncbi-code">&lt;misc/xmlwrapp/xsltwrapp.hpp&gt;</span> for functionality that resides in the <span class="nctnt ncbi-code">xslt::</span> C++ namespace.</p><p><b>Q. What do I need to add to my Makefile?</b></p><p>A. You need to add the following:</p><pre>LIB = xmlwrapp xncbi<br />LIBS = $(LIBXML_LIBS) $(LIBXSLT_LIBS) $(ORIG_LIBS)<br />CPPFLAGS = $(LIBXML_INCLUDE) $(LIBXSLT_INCLUDE) $(ORIG_CPPFLAGS)<br />REQUIRES = LIBXML LIBXSLT</pre></div></div></div><div class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_xmlwrapp.General_Information">General Information</a></li><li><a href="#ch_xmlwrapp.XmlWrapp_Classes">XmlWrapp Classes</a></li><li><a href="#ch_xmlwrapp.How_To">How To</a></li><li><a href="#ch_xmlwrapp.Warning_Collaborative_Use_of">Warning: Collaborative Use of XmlWrapp and libxml2</a></li><li><a href="#ch_xmlwrapp.Implementation_Details">Implementation Details</a></li><li><a href="#ch_xmlwrapp.FAQ">FAQ</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_xmlwrapp.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input name="__symbol" size="22" style="vertical-align:                                          middle;" onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />Â Â  <input value="Search" style="vertical-align: middle;" onclick="javasrcipt:SymbolSearch('toolkit');" type="button" /></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><span title="Search in the C/C++ source code and in this Book">All</span></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" /><span title="Search in the C/C++ source code,  this Book, and Wiki">All</span></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><span title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</span></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><span title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</span></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><span title="Locate the Toolkit library(es) where the symbol is defined">Library</span></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><span title="Locate the Toolkit library(es) where the symbol is defined">Library</span></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li><li class="internal-only">LXR: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident">internal</a></li><li class="internal-only">Doxygen: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml">internal</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li><a href="http://www.ncbi.nlm.nih.gov/bookshelf/br.fcgi?book=toolkit&amp;part=ch_getcode_svn#ch_getcode_svn.code_retrieval">Server</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++">Web
                            (dev)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++">Web
                            (extra)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components">Web (prod)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit">Wiki</a></li><li class="internal-only"><a href="http://jira/browse/CXX">JIRA</a></li><li class="internal-only"><a href="http://intranet/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download</a></li><li><a href="pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
