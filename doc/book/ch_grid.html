<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Distributed Computing - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_grid" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="js/jig/1.7/js/jig.min.js"></script><script type="text/javascript" src="js/toolkitSymbolSearch.js"></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents ▾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access - SQL, Berkley DB</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_xmlauthor.html">29. XML Authoring using Word</a></li><li class="half_rhythm"><a href="ch_faq.html">30. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">31. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a><ul class="simple-list"><li class="half_rhythm"><a href="release_notes.html">Release Notes (Version 9, May 2012)</a></li><li class="half_rhythm"><a href="release_notes_7-05_2011.html">Release Notes (Version 7, May 2011)</a></li><li class="half_rhythm"><a href="release_notes_06_29_2010.html">Release Notes (June, 2010)</a></li><li class="half_rhythm"><a href="release_notes_05_15_2009.html">Release Notes (May, 2009)</a></li><li class="half_rhythm"><a href="release_notes_12_24_2008.html">Release Notes (December, 2008)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2008.html">Release Notes (March, 2008)</a></li><li class="half_rhythm"><a href="release_notes_08_27_2007.html">Release Notes (August, 2007)</a></li><li class="half_rhythm"><a href="release_notes_03_12_2007.html">Release Notes (March, 2007)</a></li><li class="half_rhythm"><a href="release_notes_08_14_2006.html">Release Notes (August, 2006)</a></li><li class="half_rhythm"><a href="release_notes_04_30_2006.html">Release Notes (April 30, 2006)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2005.html">Release Notes (December 31, 2005)</a></li><li class="half_rhythm"><a href="release_notes_10_03_2005.html">Release Notes (August, 2005)</a></li><li class="half_rhythm"><a href="release_notes_05_05_2005.html">Release Notes (April, 2005)</a></li><li class="half_rhythm"><a href="release_notes_03_09_2005.html">Release Notes (February, 2005)</a></li><li class="half_rhythm"><a href="release_notes_11_22_2004.html">Release Notes (November 22, 2004)</a></li><li class="half_rhythm"><a href="release_notes_10_2_2004.html">Release Notes (October 2, 2004)</a></li><li class="half_rhythm"><a href="release_notes_7_8_2004.html">Release Notes (July 8, 2004)</a></li><li class="half_rhythm"><a href="release_notes_april_16_2004.html">Release Notes (April 16, 2004)</a></li><li class="half_rhythm"><a href="release_notes_12_08_2003.html">Release Notes (December 8, 2003)</a></li><li class="half_rhythm"><a href="release_notes_08_01_2003.html">Release Notes (August 1, 2003)</a></li></ul></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="ch_debug.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="ch_app.html">Next &gt;</a></div></div><div class="meta_content"><h1><span class="label">23</span><span class="title">Distributed Computing</span></h1><p class="small">Created: May 14, 2007; Last Update: August 9, 2012.</p></div><div class="body_content"><div class="sec"><h2><span class="title">Overview</span></h2><p>The overview for this chapter consists of the following topics:</p><ul><li><p>Introduction</p></li><li><p>Chapter Outline</p></li></ul><div class="sec"><h3><span class="title">Introduction</span></h3><p>This chapter describes the NCBI GRID framework. This framework allows creating, running and maintaining a scalable, load-balanced and fault-tolerant pool of network servers (<a href="#ch_grid.Worker_Nodes">Worker Nodes</a>).</p><p>Note: Users within NCBI may find additional information on the <a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/GRID">internal Wiki page</a>.</p></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p><ul><li><p><a href="#ch_grid.Getting_Help">Getting Help</a></p></li><li><p><a href="#ch_grid.GRID_Overview">GRID Overview</a></p><ul><li><p><a href="#ch_grid._Purpose">Purpose</a></p></li><li><p><a href="#ch_grid.Components">Components</a></p></li><li><p><a href="#ch_grid.Architecture_and_Dat">Architecture and Data Flow</a></p></li><li><p><a href="#ch_grid.The_GRID_Farm">The GRID Farm</a></p></li></ul></li><li><p><a href="#ch_grid.Worker_Nodes">Worker Nodes</a></p><ul><li><p><a href="#ch_grid.Create_a_GRID_Worker">Create a GRID Worker Node from scratch</a></p></li><li><p><a href="#ch_grid.Converting_an_existi">Converting an existing CGI application into a GRID Node</a></p></li><li><p><a href="#ch_grid._Wrapping_an_existing">Wrapping an existing CGI application into a GRID Node</a></p></li><li><p><a href="#ch_grid._Wrapping_an_existing_1">Wrapping an existing command-line application into a GRID Node</a></p></li><li><p><a href="#ch_grid.Worker_Node_Cleanup_">Worker Node Cleanup Procedure</a></p></li></ul></li><li><p><a href="#ch_grid.Job_Submitters">Job Submitters</a></p></li><li><p><a href="#ch_grid.CServer_Multithreade">Implementing a Network Server</a></p></li><li><p><a href="#ch_grid.GRID_Utilities">GRID Utilities</a></p></li></ul></div></div><div class="sec" id="ch_grid.Getting_Help"><h2><span class="title">Getting Help</span></h2><p>Users at NCBI have the following sources for help:</p><ul><li><p><a href="http://jira/secure/CreateIssue!default.jspa">JIRA</a> for submitting a request or bug report. Select project <a href="http://jira.be-md.ncbi.nlm.nih.gov/browse/CXX">C++ Toolkit</a> and component <a href="http://jira.be-md.ncbi.nlm.nih.gov/browse/CXX/component/10197">GRID</a>.</p></li><li><p>Mailing lists:</p><ul><li><p>The <a href="http://www.ncbi.nlm.nih.gov/mailman/listinfo/grid">grid</a> mailing list (grid@ncbi.nlm.nih.gov) for general GRID-related discussion and announcements.</p></li><li><p>The <a href="http://www.ncbi.nlm.nih.gov/mailman/listinfo/grid-core">grid-core</a> mailing list (grid-core@ncbi.nlm.nih.gov) for getting help using or trouble-shooting a GRID service.</p></li></ul></li><li><p>The GRID developers:</p><ul><li><p><a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/Dmitry_Kazimirov">Dmitry Kazimirov</a> for questions about Client-side APIs, <a href="ch_grid.html#ch_grid.Worker_Nodes">Worker Nodes</a>, auxiliary tools and utilities, administration - setup, installation, upgrades, and documentation.</p></li><li><p><a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/Pavel_Ivanov">Pavel Ivanov</a> for <a href="ch_app.html#ch_app.ncbi_netcache_service">NetCache</a> server questions.</p></li><li><p><a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/Victor_Joukov">Victor Joukov</a> for <a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/NetSchedule">NetSchedule</a> server questions.</p></li><li><p><a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/Denis_Vakatov">Denis Vakatov</a> for supervision questions.</p></li></ul></li></ul></div><div class="sec" id="ch_grid.GRID_Overview"><h2><span class="title">GRID Overview</span></h2><p>The following sections provide an overview of the GRID system:</p><ul><li><p><a href="ch_grid.html#ch_grid._Purpose">Purpose</a></p></li><li><p><a href="ch_grid.html#ch_grid.Components">Components</a></p></li><li><p><a href="ch_grid.html#ch_grid.Architecture_and_Dat">Architecture and Data Flow</a></p></li><li><p><a href="ch_grid.html#ch_grid.The_GRID_Farm">The GRID Farm</a></p></li></ul><div class="sec" id="ch_grid._Purpose"><h3><span class="title">Purpose</span></h3><p>The NCBI GRID is a framework to create, run and maintain a scalable, load-balanced and fault-tolerant pool of network servers (<a href="ch_grid.html#ch_grid.Worker_Nodes">Worker Nodes</a>).</p><p>It includes independent components that implement distributed data storage and job queueing. It also provides APIs and frameworks to implement worker nodes and job submitters.</p><p>Worker nodes can be written from scratch, but there are also convenience APIs and frameworks to easily create worker nodes out of existing C++ CGI code, or even from CGI or command-line scripts and executables.</p><p>There is also a GRID farm where developers can jump-start their distributed computation projects.</p><p>Two PowerPoint presentations have additional information about the NCBI GRID:</p><ul><li><p><a href="ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools++/DOC/PPT/GRID-Dec14-2006/GRID_Dec14_2006.pps">ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools++/DOC/PPT/GRID-Dec14-2006/GRID_Dec14_2006.pps</a></p></li><li><p><a href="ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools++/DOC/PPT/NCBI-Grid.ppt">ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools++/DOC/PPT/NCBI-Grid.ppt</a></p></li></ul></div><div class="sec" id="ch_grid.Components"><h3><span class="title">Components</span></h3><p>The NCBI GRID framework is built of the following components:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Network job queue (<a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/NetSchedule">NetSchedule</a>)</p></dd><dt>2</dt><dd><p class="no_top_margin">Network data storage (<a href="ch_app.html#ch_app.ncbi_netcache_service">NetCache</a>)</p></dd><dt>3</dt><dd><p class="no_top_margin">Server-side APIs and tools to develop <a href="ch_grid.html#ch_grid.Worker_Nodes">Worker Nodes</a>:</p><dl class="labeled-list"><dt>a</dt><dd><p class="no_top_margin"><a href="ch_grid.html#ch_grid._Wrapping_an_existing_1">Out of an existing command-line executable</a></p></dd><dt>b</dt><dd><p class="no_top_margin"><a href="ch_grid.html#ch_grid._Wrapping_an_existing">Out of an existing CGI executable</a></p></dd><dt>c</dt><dd><p class="no_top_margin"><a href="ch_grid.html#ch_grid.Converting_an_existi">Out of an existing CGI code</a> (if it's written using the <a href="ch_cgi.html">NCBI C++ CGI framework</a>)</p></dd><dt>d</dt><dd><p class="no_top_margin"><a href="ch_grid.html#ch_grid.Create_a_GRID_Worker">Create a GRID Worker Node from scratch</a></p></dd></dl></dd><dt>4</dt><dd><p class="no_top_margin">Client-side API</p></dd><dt>5</dt><dd><p class="no_top_margin">Remote CGI -- enables moving the actual CGI execution to the grid.</p></dd><dt>6</dt><dd><p class="no_top_margin"><a href="ch_grid.html#ch_grid.GRID_Utilities">GRID Utilities</a> for remote administration, monitoring, retrieval and submission (<span class="nctnt ncbi-app">netschedule_control</span>, <span class="nctnt ncbi-app">netcache_control</span>, <span class="nctnt ncbi-app">ns_remote_job_control</span>, <span class="nctnt ncbi-app">ns_submit_remote_job</span>, etc.)</p></dd></dl><p>All these components are fully portable, in the sense that they can be built and then run and communicate with each other across all platforms that are supported by the NCBI C++ Toolkit (UNIX, MS-Windows, MacOSX).</p><p>The NetCache and NetSchedule components can be used independently of each other and the rest of the grid framework - they have their respective client APIs. Worker Nodes get their tasks from NetSchedule, and may also use NetCache to get the data related to the tasks and to store the results of computation. Remote-CGI allows one to easily convert an existing CGI into a back-end worker node -- by a minor, 1 line of source code, modification. It can solve the infamous "30-sec CGI timeout" problem.</p><p>All these components can be load-balanced and are highly scalable. For example, one can just setup 10 NetCache servers or 20 Worker Nodes on new machines, and the storage/computation throughput would increase linearly. Also, NetCache and NetSchedule are lighting-fast.</p><p>To provide more flexibility, load balancing, and fault-tolerance, it is highly advisable to pool NetSchedule and NetCache servers using <a href="ch_app.html#ch_app.Load_Balancing_Servi">NCBI Load Balancer and Service Mapper</a> (LBSM).</p></div><div class="sec" id="ch_grid.Architecture_and_Dat"><h3><span class="title">Architecture and Data Flow</span></h3><p><a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/NetSchedule">NetSchedule</a> and <a href="ch_app.html#ch_app.ncbi_netcache_service">NetCache</a> servers create a media which Submitters and <a href="ch_grid.html#ch_grid.Worker_Nodes">Worker Nodes</a> use to pass and control jobs and related data:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Submitter prepares input data and stores it in the pool of NetCache servers, recording keys to the data in the job's description.</p></dd><dt>2</dt><dd><p class="no_top_margin">Submitter submits the job to the appropriate queue in the pool of NetSchedule servers.</p></dd><dt>3</dt><dd><p class="no_top_margin">Worker Node polls "its" queue on the NetSchedule servers for jobs, and takes the submitted job for processing.</p></dd><dt>4</dt><dd><p class="no_top_margin">Worker Node retrieves the job's input data from the NetCache server(s) and processes the job.</p></dd><dt>5</dt><dd><p class="no_top_margin">Worker Node stores the job's results in NetCache and changes the job's status to "<span class="nctnt ncbi-monospace">done</span>" in NetSchedule.</p></dd><dt>6</dt><dd><p class="no_top_margin">Submitter sees that the job is done and reads its result from NetCache.</p></dd></dl><p>The following diagram illustrates this flow of control and data:</p><p><span><img src="img/grid-collab.png" alt="Image grid-collab.png" /></span></p></div><div class="sec" id="ch_grid.The_GRID_Farm"><h3><span class="title">The GRID Farm</span></h3><p>To help developers jump-start their distributed computation projects, there is a small farm of machines for general use, running:</p><ul><li><p>Several flavors of job queues</p></li><li><p>Several flavors of network data storage</p></li><li><p>A framework to run and maintain users' <a href="ch_grid.html#ch_grid.Worker_Nodes">Worker Nodes</a></p></li></ul><p><span class="nctnt highlight">NOTE:</span> Most of the GRID components can be deployed or used outside of the GRID framework (applications can communicate with the components directly via the components' own client APIs). However, in many cases it is beneficial to use the whole GRID framework from the start.</p><p>NCBI users can find more information on the <a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/GRID_Farm">GRID farm Wiki page</a>.</p></div></div><div class="sec" id="ch_grid.Worker_Nodes"><h2><span class="title">Worker Nodes</span></h2><p>The following sections describe how to create, configure and run worker nodes:</p><ul><li><p><a href="ch_grid.html#ch_grid.Create_a_GRID_Worker">Create a GRID Worker Node from scratch</a></p></li><li><p><a href="ch_grid.html#ch_grid.Converting_an_existi">Converting an existing CGI application into a GRID Node</a></p></li><li><p><a href="ch_grid.html#ch_grid._Wrapping_an_existing">Wrapping an existing CGI application into a GRID Node</a></p></li><li><p><a href="ch_grid.html#ch_grid._Wrapping_an_existing_1">Wrapping an existing command-line application into a GRID Node</a></p></li><li><p><a href="ch_grid.html#ch_grid.Worker_Node_Cleanup_">Worker Node Cleanup Procedure</a></p></li></ul><div class="sec" id="ch_grid.Create_a_GRID_Worker"><h3><span class="title">Create a GRID Worker Node from scratch</span></h3><p>The following sections describe how to Create a GRID Worker Node from scratch:</p><ul><li><p><a href="ch_grid.html#ch_grid._Purpose_3">Purpose</a></p></li><li><p><a href="ch_grid.html#ch_grid._Diagram">Diagram</a></p></li></ul><div class="sec" id="ch_grid._Purpose_1"><h4><span class="title">Purpose</span></h4><p>Framework to create a multithreaded server that can run on a number of machines and serve the requests using <a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/NetSchedule">NetSchedule</a> and <a href="ch_app.html#ch_app.ncbi_netcache_service">NetCache</a> services to exchange the job info and data.</p></div><div class="sec" id="ch_grid._Diagram"><h4><span class="title">Diagram</span></h4><p><a href="ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools++/DOC/PPT/IMAGES/GRID_Dec14_2006/Slide3.PNG">ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools++/DOC/PPT/IMAGES/GRID_Dec14_2006/Slide3.PNG</a></p></div></div><div class="sec" id="ch_grid.Converting_an_existi"><h3><span class="title">Converting an existing CGI application into a GRID Node</span></h3><p>The following sections describe how to convert an existing CGI application into a GRID node:</p><ul><li><p><a href="ch_grid.html#ch_grid._Purpose_3">Purpose</a></p></li><li><p><a href="ch_grid.html#ch_grid.Converting_a_CGI_int">Converting a CGI into a Remote-CGI server</a></p></li><li><p><a href="ch_grid.html#ch_grid._Diagram_3">Diagram</a></p></li><li><p><a href="ch_grid.html#ch_grid.Features_and_benefit">Features and benefits</a></p></li></ul><div class="sec" id="ch_grid._Purpose_2"><h4><span class="title">Purpose</span></h4><p>With a rather simple and formal conversion, a CGI's real workload can be moved from the Web servers to any other machines. It also helps to work around the infamous "30-sec Web timeout problem".</p></div><div class="sec" id="ch_grid.Converting_a_CGI_int"><h4><span class="title">Converting a CGI into a Remote-CGI server</span></h4><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Modify the code of your original CGI to make it a standalone Remote-CGI server (<a href="ch_grid.html#ch_grid.Worker_Nodes">Worker Node</a>). The code conversion is very easy and formal:</p><dl class="labeled-list"><dt>a</dt><dd><p class="no_top_margin">Change application's base class from <span class="nctnt ncbi-class">CCgiApplication</span> to <span class="nctnt ncbi-class">CRemoteCgiApp</span></p></dd><dt>b</dt><dd><p class="no_top_margin">Link the application with the library <span class="nctnt ncbi-lib">xgridcgi</span> rather than with <span class="nctnt ncbi-lib">xcgi</span></p></dd></dl></dd><dt>2</dt><dd><p class="no_top_margin">Replace your original CGIs by a one-line shell scripts that calls "remote CGI gateway" (<span class="nctnt ncbi-app">cgi2rcgi.cgi</span>) application.</p></dd><dt>3</dt><dd><p class="no_top_margin">Match "remote CGI gateways" against Remote-CGI servers:</p><dl class="labeled-list"><dt>a</dt><dd><p class="no_top_margin">Ask us to register your remote CGI in the GRID framework</p></dd><dt>b</dt><dd><p class="no_top_margin">Define some extra parameters in the configuration files of "remote CGI gateway" and Remote-CGI servers to connect them via the GRID framework</p></dd></dl></dd><dt>4</dt><dd><p class="no_top_margin">Install and run your Remote-CGI servers on as many machines as you need. They don't require Web server, and can be installed even on PCs and Macs.</p></dd></dl></div><div class="sec" id="ch_grid._Diagram_1"><h4><span class="title">Diagram</span></h4><p><a href="ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools++/DOC/PPT/IMAGES/GRID_Dec14_2006/Slide1.PNG">ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools++/DOC/PPT/IMAGES/GRID_Dec14_2006/Slide1.PNG</a></p></div><div class="sec" id="ch_grid.Features_and_benefit"><h4><span class="title">Features and benefits</span></h4><ul><li><p>Solves 30-sec Web server timeout problem.</p></li><li><p>Provides software infrastructure for back-end computation farm for CGIs. Cross-platform, Unix-Windows compatible, minimal administration.</p></li><li><p>Existing CGIs can be easily converted into back-end worker nodes.</p></li><li><p>While the request is being executed by the Remote-CGI server, the user can be interactively provided with a standard or customized progress report.</p></li><li><p>Can be used for parallel network programming.</p></li><li><p>High availability infrastructure. All central components can have 2-3 times reservation to accommodate request peak hours and possible hardware failures.</p></li><li><p>Remote-CGI servers are extremely mobile.</p></li><li><p>Remote-CGI servers can be administered (gentle shutdown, request statistics, etc.) using special tool.</p></li><li><p>Easy to debug, as the Remote-CGI server can be run under debugger or any memory checker on any machine (UNIX or MS-Windows)</p></li></ul></div></div><div class="sec" id="ch_grid._Wrapping_an_existing"><h3><span class="title">Wrapping an existing CGI application into a GRID Node</span></h3><p>The following sections describe how to wrap an existing CGI application into a GRID Node:</p><ul><li><p><a href="ch_grid.html#ch_grid.Running_existing_CGI">Running existing CGI executable through Grid Framework</a></p></li><li><p><a href="ch_grid.html#ch_grid._Diagram_3">Diagram</a></p></li></ul><div class="sec" id="ch_grid.Running_existing_CGI"><h4><span class="title">Running existing CGI executable through Grid Framework</span></h4><p>In this case a real CGI does not need to be modified at all and <span class="nctnt ncbi-app">remote_cgi</span> utility serves as an intermediate between NetSchedule service and a real CGI. The real CGI and <span class="nctnt ncbi-app">remote_cgi</span> utility go to the server side. The <span class="nctnt ncbi-app">remote_cgi</span> gets a job from NetSchedule service, deserializes the CGI request and <span class="nctnt ncbi-var">stdin</span> stream and runs the real CGI with this data. When the CGI finishes the <span class="nctnt ncbi-app">remote_cgi</span> utility serializes its <span class="nctnt ncbi-var">stdout</span> stream and sends it back to the client.</p><p>On the client side (front-end) <span class="nctnt ncbi-app">cgi2rcgi</span> sees that the job’s status is changed to “done” gets the data sent by the server side (back-end), deserializes it and writes it on its <span class="nctnt ncbi-var">stdout</span>.</p><p><span class="nctnt ncbi-app">cgi2rcgi</span> utility has two html template files to define its look. The first file is <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/grid/cgi2rcgi/cgi2rcgi.html">cgi2rcgi.html</a> (can be redefined in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/grid/cgi2rcgi/cgi2rcgi.ini">cgi2rcgi.ini</a> file) which is the main html template file and it contains all common html tags for the particular application. It also has to have two required tags.</p><p><span class="nctnt ncbi-monospace">&lt;@REDIRECT@&gt;</span> should be inside <span class="nctnt ncbi-monospace">&lt;head&gt;</span> tag and is used to inject a page reloading code.</p><p><span class="nctnt ncbi-monospace">&lt;@VIEW@&gt;</span> should be inside <span class="nctnt ncbi-monospace">&lt;body&gt;</span> tag and is to render information about a particular job’s status.</p><p>The second file is cgi2rcgi.inc.html (can be redefined in cgi2.rcgi.ini) which defines tags for particular job’s states. The tag for the particular job’s state replaces <span class="nctnt ncbi-monospace">&lt;@VIEW@&gt;</span> tag in the main html template file.</p></div><div class="sec" id="ch_grid._Diagram_2"><h4><span class="title">Diagram</span></h4><p><a href="ftp://ftp.ncbi.nlm.nih.gov/toolbox/ncbi_tools++/DOC/PPT/IMAGES/GRID_Dec14_2006/Slide1.PNG">ftp://ftp.ncbi.nlm.nih.gov/toolbox/ncbi_tools++/DOC/PPT/IMAGES/GRID_Dec14_2006/Slide1.PNG</a></p></div></div><div class="sec" id="ch_grid._Wrapping_an_existing_1"><h3><span class="title">Wrapping an existing command-line application into a GRID Node</span></h3><p>The following sections describe how to wrap an existing CGI application into a GRID Node:</p><ul><li><p><a href="ch_grid.html#ch_grid.Running_arbitrary_ap">Running arbitrary applications through Grid Framework</a></p></li><li><p><a href="ch_grid.html#ch_grid._Diagram_3">Diagram</a></p></li></ul><div class="sec" id="ch_grid.Running_arbitrary_ap"><h4><span class="title">Running arbitrary applications through Grid Framework</span></h4><p>The client side collects a command line, a <span class="nctnt ncbi-var">stdin</span> stream and some other parameters, serialize them and through Grid Framework to the server side. On the server side <span class="nctnt ncbi-app">remote_app</span> utility picks up submitted job, deserializes the command line, the <span class="nctnt ncbi-var">stdin</span> and other parameters, and starts a new process with the application and the input data. Then <span class="nctnt ncbi-app">remote_app</span> waits for the process to finish collecting its <span class="nctnt ncbi-var">stdout</span>, <span class="nctnt ncbi-var">stdin</span> and <span class="nctnt ncbi-var">errcode</span>. After that it serializes collected data and sends it back to the client side. The application for run is set in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/grid/remote_app/remote_app.ini">remote_app.ini</a> configuration file.</p><p><b>Source code: </b><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/grid/remote_app/remote_app_wn.cpp">src/app/grid/remote_app/remote_app_wn.cpp</a></p><p><b>Config file: </b><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/grid/remote_app/remote_app.ini">remote_app.ini</a></p><p>Classes that should be used to prepare an input data a remote application and get its results are <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CRemoteAppRequest&amp;d=">CRemoteAppRequest</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CRemoteAppResult&amp;d=">CRemoteAppResult</a>. See also <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCGridClient.html">CGridClient</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCGridClientApp.html">CGridClientApp</a>.</p><p><b>Client example: </b><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/netschedule/remote_app_client_sample.cpp">src/sample/app/netschedule/remote_app_client_sample.cpp</a></p><p><b>Config file: </b><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/netschedule/remote_app_client_sample.ini">src/sample/app/netschedule/remote_app_client_sample.ini</a></p><p><span class="nctnt ncbi-app">ns_submit_remote_job</span> utility allows submitting a job for a remote application from its command line or a jobs file. See <span class="nctnt ncbi-app">ns_submit_remote_job –help</span>.</p><p><b>Jobs file format:</b></p><p>Each line in the file represents one job (lines starting with ‘<span class="nctnt ncbi-monospace">#</span>’ are ignored). Each job consists of several parameters. Each parameter has in the form: <span class="nctnt ncbi-monospace">name="value"</span>. The parameter’s value must be wrapped in double quotes. All of these parameters are optional. Supported parameters:</p><ul><li><p><span class="nctnt ncbi-monospace">args</span> – command line arguments.</p></li><li><p><span class="nctnt ncbi-monospace">aff</span> – affinity token.</p></li><li><p><span class="nctnt ncbi-monospace">tfiles</span> – a list of semicolon-separated file names which will be transferred to the server side.</p></li><li><p><span class="nctnt ncbi-monospace">jout</span> – a file name where the application’s output to <span class="nctnt ncbi-var">stdout</span> will be stored.</p></li><li><p><span class="nctnt ncbi-monospace">jerr</span> – a file name where the application’s output to <span class="nctnt ncbi-var">stderr</span> will be stored.</p></li><li><p><span class="nctnt ncbi-monospace">runtime</span> – a time in seconds of the remote application’s running time. If the application is running longer then this time it is assumed to be failed and its execution is terminated.</p></li><li><p><span class="nctnt ncbi-monospace">exclusive</span> – instructs the <span class="nctnt ncbi-app">remote_app</span> to not get any other jobs from the NetSchedule service while this job is being executed.</p></li></ul></div><div class="sec" id="ch_grid._Diagram_3"><h4><span class="title">Diagram</span></h4><p><a href="ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools++/DOC/PPT/IMAGES/GRID_Dec14_2006/Slide2.PNG">ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools++/DOC/PPT/IMAGES/GRID_Dec14_2006/Slide2.PNG</a></p></div></div><div class="sec" id="ch_grid.Worker_Node_Cleanup_"><h3><span class="title">Worker Node Cleanup Procedure</span></h3><p>The following sections describe the procedure for cleaning up Worker Nodes:</p><ul><li><p><a href="ch_grid.html#ch_grid._Purpose_3">Purpose</a></p></li><li><p><a href="ch_grid.html#ch_grid.Job_Cleanup">Job Cleanup</a></p></li><li><p><a href="ch_grid.html#ch_grid.Worker_Node_Cleanup_">Worker Node Cleanup</a></p></li></ul><div class="sec" id="ch_grid._Purpose_3"><h4><span class="title">Purpose</span></h4><p>It is necessary to provide a framework to support worker node and job cleanup. For example, a job may create temporary files that need to be deleted, or a worker node may need to clean up resources shared by multiple jobs.</p><p>To receive cleanup events, the worker node must implement interface <span class="nctnt ncbi-class">IWorkerNodeCleanupEventListener</span>. The interface has a single abstract method:</p><p><span class="nctnt ncbi-code">void HandleEvent(EWorkerNodeCleanupEvent cleanup_event)</span></p><p>At the time of the call, <span class="nctnt ncbi-var">cleanup_event</span> will be set to either <span class="nctnt ncbi-var">eRegularCleanup</span> (for normal cleanup) or <span class="nctnt ncbi-var">eOnHardExit</span> (for an emergency shutdown).</p><p>There are two types of listeners: those called after each job is done and those called when the worker node is shutting down.</p></div><div class="sec" id="ch_grid.Job_Cleanup"><h4><span class="title">Job Cleanup</span></h4><p>Listeners of the first type (per-job cleanup) are installed in the <span class="nctnt ncbi-code">Do()</span> method via a call to <span class="nctnt ncbi-code">CWorkerNodeJobContext::GetCleanupEventSource()-&gt;AddListener()</span>:</p><pre>class CMyWorkerNodeJob : public IWorkerNodeJob<br />/* ... */<br />virtual int Do(CWorkerNodeJobContext&amp; context)<br />{<br />    context.GetCleanupEventSource()-&gt;AddListener( new CMyWorkerNodeJobCleanupListener(resources_to_free));<br />}</pre></div><div class="sec" id="ch_grid.Worker_Node_Cleanup"><h4><span class="title">Worker Node Cleanup</span></h4><p>Listeners of the second type (worker node cleanup) are installed in the constructor of the <span class="nctnt ncbi-class">IWorkerNodeJob</span>-derived class via a call to <span class="nctnt ncbi-code">IWorkerNodeInitContext::GetCleanupEventSource()-&gt;AddListener()</span>:</p><pre>class CMyWorkerNodeJob : public IWorkerNodeJob<br />/* ... */<br />CMyWorkerNodeJob(const IWorkerNodeInitContext&amp; context)<br />{<br />    context.GetCleanupEventSource()-&gt;AddListener( new CMyWorkerNodeCleanupListener(resources_to_free));<br />}</pre><p>Note that depending on the current value of the <span class="nctnt ncbi-monospace">[server]/reuse_job_object</span> configuration parameter, this constructor of <span class="nctnt ncbi-class">CMyWorkerNodeJob</span> can be called multiple times - either once per job or once per worker thread, so additional guarding may be required.</p><p>The approach of doing worker node cleanup described above is a newer approach, but there is an older approach which may also be used:</p><p>The <span class="nctnt ncbi-class">IGridWorkerNodeApp_Listener</span> interface has two methods, <span class="nctnt ncbi-code">OnGridWorkerStart()</span> and <span class="nctnt ncbi-code">OnGridWorkerStop()</span> which are called during worker node initialization and shutdown respectively. A handler implementing this interface can be installed using the <span class="nctnt ncbi-code">SetListener()</span> method of <span class="nctnt ncbi-class">CGridWorkerApp</span>. The code that calls the <span class="nctnt ncbi-code">OnGridWorkerStop()</span> method will run in the context of the dedicated cleanup thread and also respect the <span class="nctnt ncbi-var">force_close</span> parameter.</p><p>The older method does not require the guarding that the new method requires.</p></div></div></div><div class="sec" id="ch_grid.Job_Submitters"><h2><span class="title">Job Submitters</span></h2><p>An API is available to submit tasks to <a href="ch_grid.html#ch_grid.Worker_Nodes">Worker Nodes</a>, and to monitor and control the submitted tasks.</p></div><div class="sec" id="ch_grid.CServer_Multithreade"><h2><span class="title">Implementing a Network Server</span></h2><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCServer.html">CServer</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIServer__ConnectionFactory.html">IServer_ConnectionFactory</a>, and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIServer__ConnectionHandler.html">IServer_ConnectionHandler</a> classes provide a framework for creating multithreaded network servers with one-thread-per-request scheduling. The server creates a pool of connection handlers for maintaining the socket connections, and a pool of threads for handling the socket events. With each socket event, <span class="nctnt ncbi-class">CServer</span> allocates a thread from the thread pool to handle the event, thereby making it possible to serve a large number of concurrent requests efficiently.</p><p>The following topics discuss the various aspects of implementing a network server:</p><ul><li><p><a href="ch_grid.html#ch_grid.Server_Configuration">Typical Client-Server Interactions</a></p><ul><li><p><a href="ch_grid.html#ch_grid.Protocols">Protocols</a></p></li><li><p><a href="ch_grid.html#ch_grid.Request_Format">Request Format</a></p></li><li><p><a href="ch_grid.html#ch_grid.Request_Format">Response Handling</a></p></li></ul></li><li><p><a href="ch_grid.html#ch_grid.Typical_ClientServer_Interaction">The CServer Framework Classes</a></p><ul><li><p><a href="ch_grid.html#ch_grid.The_CServer_Framework_Classes">CServer</a></p></li><li><p><a href="ch_grid.html#ch_grid.IServer_ConnectionFactory">IServer_ConnectionFactory</a></p></li><li><p><a href="ch_grid.html#ch_grid.IServer_ConnectionHandler">IServer_ConnectionHandler</a></p></li></ul></li><li><p><a href="ch_grid.html#ch_grid.State_Events_and_Flow_of_Control">State, Events, and Flow of Control</a></p></li><li><p><a href="ch_grid.html#ch_grid.Socket_Closure_and_Lifetime">Socket Closure and Lifetime</a></p></li><li><p><a href="ch_grid.html#ch_grid.Diagnostics">Diagnostics</a></p></li><li><p><a href="ch_grid.html#ch_grid.Diagnostics">Handling Exceptions</a></p></li><li><p><a href="ch_grid.html#ch_grid.Server_Configuration">Server Configuration</a></p></li><li><p><a href="ch_grid.html#ch_grid.Other_Resources">Other Resources</a></p></li></ul><div class="sec" id="ch_grid.Typical_ClientServer_Interaction"><h3><span class="title">Typical Client-Server Interactions</span></h3><p>The <span class="nctnt ncbi-class">CServer</span> framework is based on sockets and imposes few constraints on client-server interactions. Servers can support many concurrent connections, and the client and server can follow any protocol, provided that they handle errors. If the protocol includes a server response, then the client and server should alternate between requests and responses on a given connection.</p><p>Typical client-server interactions differ in the following categories:</p><ul><li><p><a href="ch_grid.html#ch_grid.Protocols">Protocols</a></p></li><li><p><a href="ch_grid.html#ch_grid.Request_Format">Request Format</a></p></li><li><p><a href="ch_grid.html#ch_grid.Request_Format">Response Handling</a></p></li></ul><div class="sec" id="ch_grid.Protocols"><h4><span class="title">Protocols</span></h4><p>The simplest protocol is probably a consistent pattern of a client request followed by a server response. The <a href="http://mini.ncbi.nlm.nih.gov/1k2qd">Track Manager</a> server uses this protocol.</p><p>The <a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c%2B%2B/src/app/netschedule/">NetScheduler</a> server follows a modified request / response protocol. It expects three "messages" - two information lines followed by a command line - then it returns a response.</p><p>The <a href="http://mini.ncbi.nlm.nih.gov/1k2qn">Genome Pipeline</a> server protocol adds a client acknowledgment to the interaction. A missing or corrupt acknowledgment triggers a rollback of the transaction.</p><p>Your server can follow whatever pattern of requests and responses is appropriate for the service. Note that a given server is not limited to a fixed communication pattern. As long as the client and server follow the same rules, the protocol can be adapted to whatever is appropriate at the moment.</p></div><div class="sec" id="ch_grid.Request_Format"><h4><span class="title">Request Format</span></h4><p>At a low level, the server simply receives bytes through a socket, so it must parse the input data into separate requests.</p><p>Perhaps the easiest request format to parse simply delimits requests with newlines - this is the request format used by the <a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c%2B%2B/src/app/netschedule/">NetScheduler</a> server.</p><p>A more robust way to define the request and response formats is with an ASN.1 specification. NCBI servers that use an ASN.1-defined request format include:</p><ul><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qe">Ideogram</a></p></li><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qo">OS Gateway</a></p></li><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qd">Track Manager</a></p></li><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qn">Genome Pipeline</a></p></li></ul></div><div class="sec" id="ch_grid.Response_Handling"><h4><span class="title">Response Handling</span></h4><p>Servers may be implemented to respond immediately (i.e. in the same thread execution where the request is read), or to delay their responses until the socket indicates that the client is ready to receive. Responding immediately can make the code simpler, but may not be optimal for resource scheduling.</p><p>NCBI Servers that use respond immediately include:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c%2B%2B/src/app/netschedule/">NetScheduler</a></p></li><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qe">Ideogram</a></p></li></ul><p>NCBI servers that delay their response include:</p><ul><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qo">OS Gateway</a></p></li><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qd">Track Manager</a></p></li><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qn">Genome Pipeline</a></p></li></ul></div></div><div class="sec" id="ch_grid.The_CServer_Framework_Classes"><h3><span class="title">The CServer Framework Classes</span></h3><p>The main classes in the <span class="nctnt ncbi-class">CServer</span> framework are:</p><ul><li><p><a href="ch_grid.html#ch_grid.The_CServer_Framework_Classes">CServer</a></p></li><li><p><a href="ch_grid.html#ch_grid.IServer_ConnectionFactory">IServer_ConnectionFactory</a></p></li><li><p><a href="ch_grid.html#ch_grid.IServer_ConnectionHandler">IServer_ConnectionHandler</a></p></li></ul><div class="sec" id="ch_grid.CServer"><h4><span class="title">CServer</span></h4><p>The <span class="nctnt ncbi-class">CServer</span> class manages connections, socket event handling for reading and writing, timer and timeout events, and error conditions. <span class="nctnt ncbi-class">CServer</span> creates a connection pool and a thread pool. When a client request arrives, a socket is established and assigned to one of the connection handler objects. For each socket event (e.g. connection opened, data arrival, client ready for data, etc.), a thread is allocated from the pool to serve that particular event and is returned to the pool when the handler finishes. You can use <span class="nctnt ncbi-class">CServer</span> directly, but typically it is subclassed.</p><p>If you want to provide a gentle shutdown ability, then create a <span class="nctnt ncbi-class">CServer</span> subclass and override <span class="nctnt ncbi-func">ShutdownRequested()</span>. It should return true when the application-specific logic determines that the server is no longer needed - for example, if a shutdown command has been received; if a timeout has expired with no client communication; if a watchfile has been updated; etc. A typical subclass could also include a <span class="nctnt ncbi-func">RequestShutdown()</span> method that sets a flag that is in turn checked by <span class="nctnt ncbi-func">ShutdownRequested()</span>. This approach makes it easy to trigger a shutdown from a client.</p><p>If you want to process data in the main thread on timeout, then create a <span class="nctnt ncbi-class">CServer</span> subclass, override <span class="nctnt ncbi-func">ProcessTimeout()</span>, and use <span class="nctnt ncbi-func">GetParameters()</span> / <span class="nctnt ncbi-func">SetParameters()</span> to replace the <span class="nctnt ncbi-var">accept_timeout</span> parameter with the proper value for your application.</p><p>If you don't want to provide a gentle shutdown ability and you don't want to process data in the main thread on timeout, then you can use <span class="nctnt ncbi-class">CServer</span> directly.</p><p>Your server application will probably define, configure, start listening, and run a <span class="nctnt ncbi-class">CServer</span> object in its <span class="nctnt ncbi-func">Run()</span> method - something like:</p><pre><span class="nctnt-pre ncbi-code">CMyServer server;<br />server.SetParameters(params);<br />server.AddListener(new CMyConnFactory(&amp;server), params.port);<br />server.Run();</span></pre></div><div class="sec" id="ch_grid.IServer_ConnectionFactory"><h4><span class="title">IServer_ConnectionFactory</span></h4><p>The connection factory simply creates connection handler objects. It is registered with the server and is called when building the connection pool.</p><p>It is possible to create a server application without defining your own connection factory (the <span class="nctnt ncbi-class">CServer</span> framework has a default factory). However you must create a connection factory if you want to pass server-wide parameters to your connection handler objects - for example to implement a gentle shutdown.</p><p>The connection factory class can be as simple as:</p><pre><span class="nctnt-pre ncbi-code">class CMyConnFactory : public IServer_ConnectionFactory<br />{<br />public:<br />    CMyConnFactory(CMyServer * server)<br />    : m_Server(server) {}<br />    ~CMyConnFactory(void) {}<br />    virtual IServer_ConnectionHandler * Create(void)<br />    {<br />        return new CMyConnHandler(m_Server);<br />    }<br />private:<br />    CMyServer * m_Server;<br />};</span></pre></div><div class="sec" id="ch_grid.IServer_ConnectionHandler"><h4><span class="title">IServer_ConnectionHandler</span></h4><p>Classes derived from <span class="nctnt ncbi-class">IServer_ConnectionHandler</span> do the actual work of handling requests. The primary methods are:</p><ul><li><p><span class="nctnt ncbi-func">GetEventsToPollFor()</span> - This method identifies the socket events that should be handled by this connection, and can establish a timer.</p></li><li><p><span class="nctnt ncbi-func">OnOpen()</span> - Indicates that a client has opened a connection. The socket can be configured here.</p></li><li><p><span class="nctnt ncbi-func">OnClose()</span> - Indicates that a connection was closed. Note that connections can be closed by either the server or the client (the closer is indicated by a parameter).</p></li><li><p><span class="nctnt ncbi-func">OnRead()</span> - Indicates that a client has sent data. This is where you should parse the data coming from the socket.</p></li><li><p><span class="nctnt ncbi-func">OnWrite()</span> - Indicates that a client is ready to receive data. This is where you should write the response to the socket.</p></li><li><p><span class="nctnt ncbi-func">OnTimeout()</span> - Indicates that a client has been idle for too long. The connection will be closed synchronously after this method is called.</p></li><li><p><span class="nctnt ncbi-func">OnTimer()</span> - Called when the timer established by <span class="nctnt ncbi-func">GetEventsToPollFor()</span> has expired.</p></li><li><p><span class="nctnt ncbi-func">OnOverflow()</span> - Called when there's a problem with the connection - for example, the connection pool cannot accommodate another connection. <span class="nctnt highlight">Note:</span> The connection is destroyed after this call.</p></li></ul><p>The <span class="nctnt ncbi-func">OnOpen()</span>, <span class="nctnt ncbi-func">OnRead()</span>, and <span class="nctnt ncbi-func">OnWrite()</span> methods are pure virtual and must be implemented by your server.</p><p><span class="nctnt highlight">Note:</span> If your client-server protocol is line-oriented, you can use <span class="nctnt ncbi-class">IServer_LineMessageHandler</span> instead of <span class="nctnt ncbi-class">IServer_ConnectionHandler</span>. In this case you would implement the <span class="nctnt ncbi-func">OnMessage()</span> method instead of <span class="nctnt ncbi-func">OnRead()</span>.</p></div></div><div class="sec" id="ch_grid.State_Events_and_Flow_of_Control"><h3><span class="title">State, Events, and Flow of Control</span></h3><p>Generally, your connection handler class should follow a state model and implement the <span class="nctnt ncbi-func">GetEventsToPollFor()</span> method, which will use the state to select the events that will be handled. This is typically how the connection state is propagated and how socket events result in the flow of control being passed to the events handlers.</p><p><span class="nctnt highlight">Note:</span> You don't need to implement a state model or the <span class="nctnt ncbi-func">GetEventsToPollFor()</span> method if you immediately write any reponses in the same handler that performs the reading. For line-oriented protocols, your connection handler can inherit from <span class="nctnt ncbi-class">IServer_LineMessageHandler</span> instead of from <span class="nctnt ncbi-class">IServer_ConnectionHandler</span>. <span class="nctnt ncbi-class">IServer_LineMessageHandler</span> implements <span class="nctnt ncbi-func">OnRead()</span> and parses the input into lines, calling <span class="nctnt ncbi-func">OnMessage()</span> for each line. In this case you would both read from and write to the client in the <span class="nctnt ncbi-func">OnMessage()</span> method (and implement a dummy <span class="nctnt ncbi-func">OnWrite()</span> method).</p><p>For servers that implement a state model and follow a simple request / response protocol, the state variable should be initialized to "reading"; set to "writing" after the request is read in the <span class="nctnt ncbi-func">OnRead()</span> method; and set to "reading" after the response is sent in the <span class="nctnt ncbi-func">OnWrite()</span> method. This results in an orderly alternation between reading and writing. The <span class="nctnt ncbi-func">GetEventsToPollFor()</span> method uses the current connection state (the current state corresponds to the next expected event) to select the appropriate event to respond to. For example:</p><pre><span class="nctnt-pre ncbi-code">EIO_Event CMyConnHandler::GetEventsToPollFor(const CTime** alarm_time)<br />{<br />    return (m_State == eWriting) ? eIO_Write : eIO_Read;<br />}</span></pre><p>Your state model should reflect the communication protocol and can be more complex than a simple read / write alternation. It could include acknowledgements, queuing, timed responses, etc. Of course it should include error handling.</p><p><span class="nctnt ncbi-func">GetEventsToPollFor()</span> is guaranteed to not be called at the same time as the event handling functions (<span class="nctnt ncbi-func">OnOpen()</span>, <span class="nctnt ncbi-func">OnRead()</span>, etc.), so you shouldn't guard the variables they use with mutexes.</p><p><span class="nctnt ncbi-func">GetEventsToPollFor()</span> is called from the main thread while the other socket event handling methods  are called from various threads allocated from the thread pool.</p></div><div class="sec" id="ch_grid.Socket_Closure_and_Lifetime"><h3><span class="title">Socket Closure and Lifetime</span></h3><p>Nominally, sockets are owned by (and therefore closed by) the <span class="nctnt ncbi-class">CServer</span> framework. However, there may be cases where your derived class will need to manually close or take ownership of the socket.</p><ul><li><p>Well-behaved clients will close a connection when they have no more outstanding requests and have completed reading the responses to all requests made on the connection. <span class="nctnt ncbi-class">CServer</span>-based applications are intended to operate in this paradigm. In this case, and barring exceptional circumstances, you don't need to close or take ownership of the socket.<br /><br /><span class="nctnt highlight">Note:</span> If connections are not closed by the client after reading the response, then you may run out of file descriptors. If you have a high connection volume and try to mitigate slow connection closings by closing connections in your code, you run the risk of terminating the connection before the client has read all the data.</p></li><li><p><span class="nctnt ncbi-class">CServer</span> will automatically close a connection after an inactivity timeout. You don't need to manage sockets in this case (again barring exceptional circumstances).</p></li><li><p>If you encounter problems such as a broken protocol, an invalid command, or an exception in an event handler, then you should close the connection from your code.</p></li><li><p>If you need to close a connection from your code, you should do so by calling <span class="nctnt ncbi-func">CServer::CloseConnection()</span> - not by explicitly closing the socket object. The <span class="nctnt ncbi-class">CServer</span> framework generally owns the socket and therefore needs to manage it.</p></li><li><p><span class="nctnt highlight">Note:</span> There is one case when the <span class="nctnt ncbi-class">CServer</span> framework shouldn't own the socket. If you create a <span class="nctnt ncbi-class">CConn_SocketStream</span> on an existing socket, then you must take ownership as shown here:<br /><br /><span class="nctnt ncbi-code">SOCK sk = GetSocket().GetSOCK();</span><br /><span class="nctnt ncbi-code">GetSocket().SetOwnership(eNoOwnership);</span><br /><span class="nctnt ncbi-code">GetSocket().Reset(0, eTakeOwnership, eCopyTimeoutsToSOCK);</span><br /><span class="nctnt ncbi-code">AutoPtr&lt;CConn_SocketStream&gt; stream = new CConn_SocketStream(sk);</span><br /></p></li></ul></div><div class="sec" id="ch_grid.Diagnostics"><h3><span class="title">Diagnostics</span></h3><p>To facilitate logfile analysis, the more detailed "new" log posting format is recommended. To enable the new format, call <span class="nctnt ncbi-func">SetOldPostFormat()</span> before calling <span class="nctnt ncbi-func">AppMain()</span>:</p><pre><span class="nctnt-pre ncbi-code">int main(int argc, const char* argv[])<br />{<br />    GetDiagContext().SetOldPostFormat(false);<br />    return CMyServerApp().AppMain(argc, argv);<br />}</span></pre><p>Grouping diagnostics into request-specific blocks is very helpful for post-processing. To facilitate this, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDiagContext.html">CDiagContext</a> provides the <span class="nctnt ncbi-func">PrintRequestStart()</span>, <span class="nctnt ncbi-func">PrintRequestStop()</span>, <span class="nctnt ncbi-func">Extra()</span>, and various <span class="nctnt ncbi-func">Print()</span>, methods.</p><p>The <span class="nctnt ncbi-func">CDiagContext::SetRequestContext()</span> method enables you to use a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCRequestContext.html">CRequestContext</a> object to pass certain request-specific information - such as request ID, client IP, bytes sent, request status, etc. - to the diagnostics context. The request context information can be invaluable when analyzing logs.</p><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCRequestContext.html">CRequestContext</a> objects are merely convenient packages for passing information - they can be preserved across multiple events or re-created as needed. However, as <span class="nctnt ncbi-class">CObject</span>-derived objects, they should be wrapped by <span class="nctnt ncbi-class">CRef</span> to avoid inadvertent deletion by code accepting a <span class="nctnt ncbi-class">CRef</span> parameter.</p><p>The following code fragments show examples of API calls for creating request-specific blocks in the logfile. Your code will be slightly different and may make these calls in different event handlers (for example, you might call <span class="nctnt ncbi-func">PrintRequestStart()</span> in <span class="nctnt ncbi-func">OnRead()</span> and <span class="nctnt ncbi-func">PrintRequestStop()</span> in <span class="nctnt ncbi-func">OnWrite()</span>).</p><pre><span class="nctnt-pre ncbi-code">// Set up the request context:<br />CRef&lt;CRequestContext&gt; rqst_ctx(new CRequestContext());<br />rqst_ctx-&gt;SetRequestID();<br />rqst_ctx-&gt;SetClientIP(socket.GetPeerAddress(eSAF_IP));<br /><br />// Access the diagnostics context:<br />CDiagContext &amp; diag_ctx(GetDiagContext());<br />diag_ctx.SetRequestContext(rqst_ctx.GetPointer());<br /><br />// Start the request block in the log:<br />diag_ctx.PrintRequestStart()<br />        .Print("peer", "1.2.3.4")<br />        .Print("port", 5555);<br /><br />// Other relevant info...<br />CDiagContext_Extra extra(diag_ctx.Extra());<br />extra.Print("name1", "value1")<br />     .Print("name2", "value2");<br /><br />// Terminate the request block in the log.<br />rqst_ctx-&gt;SetBytesRd(socket.GetCount(eIO_Read));<br />rqst_ctx-&gt;SetBytesWr(socket.GetCount(eIO_Write));<br />rqst_ctx-&gt;SetRequestStatus(eStatus_OK);<br />diag_ctx.PrintRequestStop();</span></pre><p>Code like the above will result in <a href="http://mini.ncbi.nlm.nih.gov/1k2vj">AppLog</a> entries that look similar to:</p><p><span><img src="img/ch_grid_cserver_applog.png" alt="Image ch_grid_cserver_applog.png" /></span></p><p>Each thread has its own diagnostics context. Therefore, simultaneous calls to <span class="nctnt ncbi-func">GetDiagContext().SetRequestContext()</span> in multiple event handlers will not interfere with each other.</p><p>The connection handler should ensure that each request-start has a corresponding request-stop - for example by writing the request-stop in a destructor if it wasn't already written.</p></div><div class="sec" id="ch_grid.Handling_Exceptions"><h3><span class="title">Handling Exceptions</span></h3><p>There are server application-wide configuration parameters to control whether or not otherwise-unhandled exceptions will be caught by the server. See the <a href="ch_grid.html#ch_grid.Server_Configuration">Server Configuration</a> section for details.</p><p>Your event handler code should be wrapped in try-catch blocks, and if an exception is caught then the connection should be closed by calling <span class="nctnt ncbi-func">CServer::CloseConnection()</span> - not by explicitly closing the socket object.</p><p>See the <a href="ch_grid.html#ch_grid.Socket_Closure_and_Lifetime">Socket Closure and Lifetime</a> section for related information.</p></div><div class="sec" id="ch_grid.Server_Configuration"><h3><span class="title">Server Configuration</span></h3><p>The following configuration parameters can be used to fine-tune <span class="nctnt ncbi-class">CServer</span>-derived server behavior:</p><div class="table" id="ch_grid.T.nc_parameterbrief_descriptiond"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Parameter</th><th align="left" valign="top" rowspan="1" colspan="1">Brief Description</th><th align="left" valign="top" rowspan="1" colspan="1">Default</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">CSERVER_CATCH_UNHANDLED_EXCEPTIONS</span></td><td align="left" valign="top" rowspan="1" colspan="1">Controls whether <span class="nctnt ncbi-class">CServer</span> should catch exceptions.</td><td align="left" valign="top" rowspan="1" colspan="1">true</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">NCBI_CONFIG__THREADPOOL__CATCH_UNHANDLED_EXCEPTIONS</span></td><td align="left" valign="top" rowspan="1" colspan="1">Controls whether <span class="nctnt ncbi-class">CThreadInPool_ForServer</span> should catch exceptions.</td><td align="left" valign="top" rowspan="1" colspan="1">true</td></tr></tbody></table></div><p>See the <a href="http://www.ncbi.nlm.nih.gov/books/NBK7164/#ch_libconfig.libconfig_connect">connection library configuration reference</a> for more information on configuration parameters.</p></div><div class="sec" id="ch_grid.Other_Resources"><h3><span class="title">Other Resources</span></h3><p>Here are some places to look for reference and to see how to <span class="nctnt ncbi-class">CServer</span> is used in practice:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCServer.html">CServer Class Reference</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c%2B%2B/src/connect/test/test_server.cpp">CServer test application</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c%2B%2B/src/app/netschedule/">NetScheduler</a></p></li><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qe">Ideogram</a> (NCBI only)</p></li><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qo">OS Gateway</a> (NCBI only)</p></li><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qd">Track Manager</a> (NCBI only)</p></li><li><p><a href="http://mini.ncbi.nlm.nih.gov/1k2qn">Genome Pipeline</a> (NCBI only)</p></li></ul></div></div><div class="sec" id="ch_grid.GRID_Utilities"><h2><span class="title">GRID Utilities</span></h2><p>The following sections describe the GRID Utilities:</p><ul><li><p><a href="ch_grid.html#ch_grid.netschedule_control">netschedule_control</a></p></li><li><p><a href="ch_grid.html#ch_grid.ns_remote_job_contro">ns_remote_job_control</a></p></li><li><p><a href="ch_grid.html#ch_grid._Alternate_list_input">Alternate list input and output</a></p></li></ul><div class="sec" id="ch_grid.netschedule_control"><h3><span class="title">netschedule_control</span></h3><p><b>DESCRIPTION:</b></p><p>NCBI NetSchedule control utility. This program can be used to operate NetSchedule servers and server groups from the command line.</p><p><b>OPTIONS:</b></p><div class="table" id="ch_grid.T3"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1">-h</td><td align="left" valign="top" rowspan="1" colspan="1">Print brief usage and description; ignore other arguments.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-help</td><td align="left" valign="top" rowspan="1" colspan="1">Print long usage and description; ignore other arguments.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-xmlhelp</td><td align="left" valign="top" rowspan="1" colspan="1">Print long usage and description in XML format; ignore other arguments.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-version-full</td><td align="left" valign="top" rowspan="1" colspan="1">Print extended version data; ignore other arguments.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-service &lt;SERVICE_NAME&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Specifies a NetSchedule service name to use. It can be either an LBSMD service name or a server name / port number pair separated by a colon, such as: <span class="nctnt ncbi-monospace">host:1234</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-queue &lt;QUEUE_NAME&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">The queue name to operate with.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-jid &lt;JOB_ID&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">This option specifies a job ID for those operations that need it.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-shutdown</td><td align="left" valign="top" rowspan="1" colspan="1">This command tells the specified server to shut down. The server address is defined by the <span class="nctnt ncbi-monospace">-service</span> option. An LBSMD service name cannot be used with <span class="nctnt ncbi-monospace">-shutdown</span>.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-shutdown_now</td><td align="left" valign="top" rowspan="1" colspan="1">The same as <span class="nctnt ncbi-monospace">-shutdown</span> but does not wait for job termination.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-log &lt;ON_OFF&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Switch server side logging on and off.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-monitor</td><td align="left" valign="top" rowspan="1" colspan="1">Starts monitoring of the specified queue. Events associated with that queue will be dumped to the standard output of <span class="nctnt ncbi-monospace">netschedule_control</span> until it's terminated with <span class="nctnt ncbi-monospace">Ctrl-C</span>.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-ver</td><td align="left" valign="top" rowspan="1" colspan="1">Prints server version(s) of the server or the group of servers specified by the <span class="nctnt ncbi-monospace">-service</span> option.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-reconf</td><td align="left" valign="top" rowspan="1" colspan="1">Send a request to reload server configuration.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-qlist</td><td align="left" valign="top" rowspan="1" colspan="1">List available queues.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-qcreate</td><td align="left" valign="top" rowspan="1" colspan="1">Create queue (qclass should be present, and comment is an optional parameter).</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-qclass &lt;QUEUE_CLASS&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Class for queue creation.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-comment &lt;COMMENT&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Optional parameter for the <span class="nctnt ncbi-monospace">-qcreate</span> command</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-qdelete</td><td align="left" valign="top" rowspan="1" colspan="1">Delete the specified queue.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-drop</td><td align="left" valign="top" rowspan="1" colspan="1">Unconditionally drop ALL jobs in the specified queue.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-stat &lt;STAT_TYPE&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Print queue statistics. Available values for <span class="nctnt ncbi-monospace">STAT_TYPE</span>: <span class="nctnt ncbi-monospace">all</span>, <span class="nctnt ncbi-monospace">brief</span>.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-affstat &lt;AFFINITY_NAME&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Print queue statistics summary based on affinity.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-dump</td><td align="left" valign="top" rowspan="1" colspan="1">Print queue dump or job dump if <span class="nctnt ncbi-monospace">-jid</span> parameter is specified.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-reschedule &lt;JOB_ID&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Reschedule the job specified by the <span class="nctnt ncbi-monospace">JOB_ID</span> parameter.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-cancel &lt;JOB_ID&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Cancel the specified job.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-qprint &lt;JOB_STATUS&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Print queue content for the specified job status.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-count &lt;QUERY_STRING&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Count all jobs within the specified queue with tags set by query string.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-count_active</td><td align="left" valign="top" rowspan="1" colspan="1">Count active jobs in all queues.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-show_jobs_id &lt;QUERY_STRING&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Show all job IDs by query string.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-query &lt;QUERY_STRING&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Perform a query on the jobs withing the specified queue.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-fields &lt;FIELD_LIST&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Fields (separated by ','), which should be returned by one of the above query commands.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-select &lt;QUERY_STRING&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Perform a select query on the jobs withing the specified queue.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-showparams</td><td align="left" valign="top" rowspan="1" colspan="1">Show service parameters.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-read &lt;BATCH_ID_OUTPUT,JOB_IDS_OUTPUT,LIMIT,TIMEOUT&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Retrieve IDs of the completed jobs and change their state to Reading.<br /><br />For the first two parameters, the <a href="ch_grid.html#ch_grid.Alternate_list_outpu">Alternate list output</a> format can be used.<br /><br /><b>Parameter descriptions:</b><br /><span class="nctnt ncbi-var">BATCH_ID_OUTPUT</span><ul class="simple-list"><li><p>Defines where to send the ID of the retrieved jobs. Can be either a file name or '-'.</p></li></ul><span class="nctnt ncbi-var">JOB_IDS</span><ul class="simple-list"><li><p>Defines where to send the list of jobs that were switched to the state <span class="nctnt ncbi-monospace">Reading</span>. Can be either a file name or '-'.</p></li></ul><span class="nctnt ncbi-var">LIMIT</span><ul class="simple-list"><li><p>Maximum number of jobs retrieved.</p></li></ul><span class="nctnt ncbi-var">TIMEOUT</span><ul class="simple-list"><li><p>Timeout before jobs will be switched back to the state <span class="nctnt ncbi-monospace">Done</span> so that they can be returned again in response to another <span class="nctnt ncbi-monospace">-read</span>.</p></li></ul><br /><b>Examples:</b><br /><pre>    netschedule_control -service NS_Test -queue test \<br />        -read batch_id.txt,job_ids.lst,100,300<br />    netschedule_control -service NS_Test -queue test \<br />        -read -,job_ids.lst,100,300<br />    netschedule_control -service NS_Test -queue test \<br />        -read batch_id.txt,-,100,300</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-read_confirm &lt;JOB_LIST&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Mark jobs in <span class="nctnt ncbi-monospace">JOB_LIST</span> as successfully retrieved. The <a href="ch_grid.html#ch_grid._Alternate_list_input">Alternate list input</a> format can be used to specify <span class="nctnt ncbi-monospace">JOB_LIST</span>. If this operation succeeds, the specified jobs will change their state to <span class="nctnt ncbi-monospace">Confirmed</span>.<br /><br />Examples:<br /><pre>    netschedule_control -service NS_Test -queue test \<br />        -read_confirm @job_ids.lst<br />    netschedule_control -service NS_Test -queue test \<br />        -read_confirm - &lt; job_ids.lst<br />    netschedule_control -service NS_Test -queue test \<br />        -read_confirm JSID_01_4_130.14.24.10_9100,JSID_01_5_130.14.24.10_9100</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-read_rollback &lt;JOB_LIST&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Undo the <span class="nctnt ncbi-monospace">-read</span> operation for the specified jobs thus making them available for the subsequent <span class="nctnt ncbi-monospace">-read</span> operations. See the description of <span class="nctnt ncbi-monospace">-read_confirm</span> for information on the <span class="nctnt ncbi-monospace">JOB_LIST</span> argument and usage examples.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-read_fail &lt;JOB_LIST&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Undo the <span class="nctnt ncbi-monospace">-read</span> operation for the specified jobs thus making them available for the subsequent <span class="nctnt ncbi-monospace">-read</span> operations. This command is similar to <span class="nctnt ncbi-monospace">-read_rollback</span> with the exception that it also increases the counter of the job result reading failures for the specified jobs. See the description of <span class="nctnt ncbi-monospace">-read_confirm</span> for information on the <span class="nctnt ncbi-monospace">JOB_LIST</span> argument and usage examples.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-logfile &lt;LOG_FILE&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">File to which the program log should be redirected.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-conffile &lt;INI_FILE&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Override configuration file name (by default, <span class="nctnt ncbi-path">netschedule_control.ini</span>).</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-version</td><td align="left" valign="top" rowspan="1" colspan="1">Print version number; ignore other arguments.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-dryrun</td><td align="left" valign="top" rowspan="1" colspan="1">Do nothing, only test all preconditions.</td></tr></tbody></table></div></div><div class="sec" id="ch_grid.ns_remote_job_contro"><h3><span class="title">ns_remote_job_control</span></h3><p>DESCRIPTION:</p><p>This utility acts as a submitter for the remote_app daemon. It initiates job execution on remote_app, and then checks the status and the results of the job.</p><p>OPTIONS:</p><div class="table" id="ch_grid.T4"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1">-h</td><td align="left" valign="top" rowspan="1" colspan="1">Print brief usage and description; ignore other arguments.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-help</td><td align="left" valign="top" rowspan="1" colspan="1">Print long usage and description; ignore other arguments.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-xmlhelp</td><td align="left" valign="top" rowspan="1" colspan="1">Print long usage and description in XML format; ignore other arguments.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-q &lt;QUEUE&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">NetSchedule queue name.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-ns &lt;SERVICE&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">NetSchedule service address (service_name or host:port).</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-nc &lt;SERVICE&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">NetCache service address (service_name or host:port).</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-jlist &lt;STATUS&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Show jobs by status. STATUS can be one of the following:<ul><li><p><span class="nctnt ncbi-monospace">all</span></p></li><li><p><span class="nctnt ncbi-monospace">canceled</span></p></li><li><p><span class="nctnt ncbi-monospace">done</span></p></li><li><p><span class="nctnt ncbi-monospace">failed</span></p></li><li><p><span class="nctnt ncbi-monospace">pending</span></p></li><li><p><span class="nctnt ncbi-monospace">returned</span></p></li><li><p><span class="nctnt ncbi-monospace">running</span></p></li></ul><br /></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-qlist</td><td align="left" valign="top" rowspan="1" colspan="1">Print the list of queues available on the specified NetSchedule server or a group of servers identified by the service name.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-wnlist</td><td align="left" valign="top" rowspan="1" colspan="1">Show registered worker nodes.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-jid &lt;JOB_ID&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Show information on the specified job.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-bid &lt;BLOB_ID&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Show NetCache blob contents.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-attr &lt;ATTRIBUTE&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Show one of the following job attributes:<ul><li><p><span class="nctnt ncbi-monospace">cmdline</span></p></li><li><p><span class="nctnt ncbi-monospace">progress</span></p></li><li><p><span class="nctnt ncbi-monospace">raw_input</span></p></li><li><p><span class="nctnt ncbi-monospace">raw_output</span></p></li><li><p><span class="nctnt ncbi-monospace">retcode</span></p></li><li><p><span class="nctnt ncbi-monospace">status</span></p></li><li><p><span class="nctnt ncbi-monospace">stdin</span></p></li><li><p><span class="nctnt ncbi-monospace">stdout</span></p></li><li><p><span class="nctnt ncbi-monospace">stderr</span></p></li></ul><br /><br />Alternatively, the ATTRIBUTE parameter can be specified as one of the following attribute sets:<ul><li><p><span class="nctnt ncbi-monospace">standard</span></p></li><li><p><span class="nctnt ncbi-monospace">full</span></p></li><li><p><span class="nctnt ncbi-monospace">minimal</span></p></li></ul><br /></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-stdout &lt;JOB_IDS&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Dump concatenated standard output streams of the specified jobs. The <span class="nctnt ncbi-monospace">JOB_IDS</span> argument can be specified in the <a href="ch_grid.html#ch_grid._Alternate_list_input">Alternate list input</a> format.<br />Examples:<br /><pre>    ns_remote_job_control -ns NS_Test -q test \<br />        -stdout JSID_01_4_130.14.24.10_9100,JSID_01_5_130.14.24.10_9100<br />    ns_remote_job_control -ns NS_Test -q test -stdout @job_ids.lst<br />    ns_remote_job_control -ns NS_Test -q test -stdout - &lt; job_ids.lst</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-stderr &lt;JOB_IDS&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Dump concatenated standard error streams of the specified jobs. The <span class="nctnt ncbi-monospace">JOB_IDS</span> argument can be specified in the <a href="ch_grid.html#ch_grid._Alternate_list_input">Alternate list input</a> format. See the description of the <span class="nctnt ncbi-monospace">-stdout</span> command for examples.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-cancel &lt;JOB_ID&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Cancel the specified job.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-cmd &lt;COMMAND&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Apply one of the following commands to the queue specified by the <span class="nctnt ncbi-monospace">-q</span> option:<ul><li><p><span class="nctnt ncbi-monospace">drop_jobs</span></p></li><li><p><span class="nctnt ncbi-monospace">kill_nodes</span></p></li><li><p><span class="nctnt ncbi-monospace">shutdown_nodes</span></p></li></ul><br /></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-render &lt;OUTPUT_FORMAT&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Set the output format of the informational commands like <span class="nctnt ncbi-monospace">-qlist</span>. The format can be either of the following: <span class="nctnt ncbi-monospace">text</span>, <span class="nctnt ncbi-monospace">xml</span>.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-of &lt;OUTPUT_FILE&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Output file for operations that actually produce output.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-logfile &lt;LOG_FILE&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">File to which the program log should be redirected.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-conffile &lt;INI_FILE&gt;</td><td align="left" valign="top" rowspan="1" colspan="1">Override configuration file name (by default, <span class="nctnt ncbi-monospace">ns_remote_job_control.ini</span>).</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-version</td><td align="left" valign="top" rowspan="1" colspan="1">Print version number; ignore other arguments.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-version-full</td><td align="left" valign="top" rowspan="1" colspan="1">Print extended version data; ignore other arguments.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-dryrun</td><td align="left" valign="top" rowspan="1" colspan="1">Do nothing, only test all preconditions.</td></tr></tbody></table></div></div><div class="sec" id="ch_grid._Alternate_list_input"><h3><span class="title">Alternate list input and output</span></h3><p>This section describes two alternative methods of printing the results of operations that generate lists (e.g. lists of job IDs) and three methods of inputting such lists as command line arguments.</p><div class="sec" id="ch_grid.Alternate_list_outpu"><h4><span class="title">Alternate list output</span></h4><p>The <span class="nctnt ncbi-monospace">-read</span> command of <span class="nctnt ncbi-monospace">netschedule_control</span> produces a list of job IDs as its output. This list can be sent either to a file (if a file name is specified) or to <span class="nctnt ncbi-var">stdout</span> (if a dash ('-') is specified in place of the file name).</p><p><b>Example:</b></p><pre>    # Read job results: send batch ID to STDOUT,<br />    # and the list of jobs to job_ids.lst<br />    netschedule_control -service NS_Test -queue test \<br />        -read -,job_ids.lst,10,300</pre></div><div class="sec" id="ch_grid._Alternate_list_input_1"><h4><span class="title">Alternate list input</span></h4><p>There are three ways one can specify a list of arguments in a command line option that accepts the Alternate list input format (like the -stdout and stderr options of ns_remote_job_conrol):</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Via a comma-separated (or a space-separated) list.</p></dd><dt>2</dt><dd><p class="no_top_margin">By using a text file (one argument per line). The name of the file must be prefixed with '@' to distinguish from the explicit enumeration of the previous case.</p></dd><dt>3</dt><dd><p class="no_top_margin">Via <span class="nctnt ncbi-var">stdin</span> (denoted by '-'). This variant does not differ from using a text file except that list items are red from the standard input - one item per line.</p></dd></dl><p><b>Examples:</b></p><pre>    # Concatenate and print stdout<br />    ns_remote_job_control -ns NS_Test -q rmcgi_sample \<br />        -stdout JSID_01_4_130.14.24.10_9100,JSID_01_5_130.14.24.10_9100<br /><br />    # Confirm job result reading for batch #6<br />    netschedule_control -service NS_Test -queue test \<br />        -read_confirm 6,@job_ids.lst<br /><br />    # The same using STDIN<br />    netschedule_control -service NS_Test -queue test \<br />        -read_confirm 6,- &lt; job_ids.lst</pre></div></div></div></div></div><div id="tkb_internal" class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_grid.Getting_Help">Getting Help</a></li><li><a href="#ch_grid.GRID_Overview">GRID Overview</a></li><li><a href="#ch_grid.Worker_Nodes">Worker Nodes</a></li><li><a href="#ch_grid.Job_Submitters">Job Submitters</a></li><li><a href="#ch_grid.CServer_Multithreade">Implementing a Network Server</a></li><li><a href="#ch_grid.GRID_Utilities">GRID Utilities</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_grid.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                        middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />  					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                        middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" /><label for="iToolkitAll" title="Search in the C/C++ source code,  this Book, and Wiki">All</label></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><label for="iLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><label for="iLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><span class="bkp_prtlt_txt"> LXR: </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a><span class="bkp_prtlt_txt"> / </span><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Doxygen: </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a><span class="bkp_prtlt_txt"> / </span><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><span class="bkp_prtlt_txt"> Documentation: </span><a href="/books/NBK7170/#ch_getcode_svn.code_retrieval">in-house</a><span class="bkp_prtlt_txt"> / </span><a href="/books/NBK7170/#ch_getcode_svn.external">public</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (dev): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a><span class="bkp_prtlt_txt"> / </span><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c++/" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (extra): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (prod): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lib_search/libsearch.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Search Tool</a></li><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/depgraphs/dglistdeps.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Dependencies Tool</a></li><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Wiki</a></li><li class="internal-only"><a href="http://jira/browse/CXX" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">JIRA</a></li><li class="internal-only"><a href="http://intranet/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="/books/NBK7156/">Release Notes</a></li><li><a href="/books/NBK7170/#ch_getcode_svn.ftp_download">Download</a></li><li><a href="/books/NBK7160/pdf/TOC.pdf">PDF of the book</a></li><li><a href="/books/NBK7147/">Coding Style</a></li><li><a href="/books/NBK7177/#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div><div id="tkb_public" class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_grid.Getting_Help">Getting Help</a></li><li><a href="#ch_grid.GRID_Overview">GRID Overview</a></li><li><a href="#ch_grid.Worker_Nodes">Worker Nodes</a></li><li><a href="#ch_grid.Job_Submitters">Job Submitters</a></li><li><a href="#ch_grid.CServer_Multithreade">Implementing a Network Server</a></li><li><a href="#ch_grid.GRID_Utilities">GRID Utilities</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_grid.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                        middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />  					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                        middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr><td colspan="2"><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td></tr><tr><td colspan="2"><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td colspan="2"><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="/books/NBK7170/#ch_getcode_svn.external">Documentation</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c++/" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Web (dev)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lib_search/libsearch.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Search Tool</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/depgraphs/dglistdeps.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Dependencies Tool</a></li><li><a href="/books/NBK7156/">Release Notes</a></li><li><a href="/books/NBK7170/#ch_getcode_svn.ftp_download">Download</a></li><li><a href="/books/NBK7160/pdf/TOC.pdf">PDF of the book</a></li><li><a href="/books/NBK7147/">Coding Style</a></li><li><a href="/books/NBK7177/#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
