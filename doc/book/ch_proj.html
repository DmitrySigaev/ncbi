<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Project Creation and Management - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_proj" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="js/jig/1.7/js/jig.min.js"></script><script type="text/javascript" src="js/toolkitSymbolSearch.js"></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents ▾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access - SQL, Berkley DB</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_xmlauthor.html">29. XML Authoring using Word</a></li><li class="half_rhythm"><a href="ch_faq.html">30. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">31. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a><ul class="simple-list"><li class="half_rhythm"><a href="release_notes.html">Release Notes (Version 9, May 2012)</a></li><li class="half_rhythm"><a href="release_notes_7-05_2011.html">Release Notes (Version 7, May 2011)</a></li><li class="half_rhythm"><a href="release_notes_06_29_2010.html">Release Notes (June, 2010)</a></li><li class="half_rhythm"><a href="release_notes_05_15_2009.html">Release Notes (May, 2009)</a></li><li class="half_rhythm"><a href="release_notes_12_24_2008.html">Release Notes (December, 2008)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2008.html">Release Notes (March, 2008)</a></li><li class="half_rhythm"><a href="release_notes_08_27_2007.html">Release Notes (August, 2007)</a></li><li class="half_rhythm"><a href="release_notes_03_12_2007.html">Release Notes (March, 2007)</a></li><li class="half_rhythm"><a href="release_notes_08_14_2006.html">Release Notes (August, 2006)</a></li><li class="half_rhythm"><a href="release_notes_04_30_2006.html">Release Notes (April 30, 2006)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2005.html">Release Notes (December 31, 2005)</a></li><li class="half_rhythm"><a href="release_notes_10_03_2005.html">Release Notes (August, 2005)</a></li><li class="half_rhythm"><a href="release_notes_05_05_2005.html">Release Notes (April, 2005)</a></li><li class="half_rhythm"><a href="release_notes_03_09_2005.html">Release Notes (February, 2005)</a></li><li class="half_rhythm"><a href="release_notes_11_22_2004.html">Release Notes (November 22, 2004)</a></li><li class="half_rhythm"><a href="release_notes_10_2_2004.html">Release Notes (October 2, 2004)</a></li><li class="half_rhythm"><a href="release_notes_7_8_2004.html">Release Notes (July 8, 2004)</a></li><li class="half_rhythm"><a href="release_notes_april_16_2004.html">Release Notes (April 16, 2004)</a></li><li class="half_rhythm"><a href="release_notes_12_08_2003.html">Release Notes (December 8, 2003)</a></li><li class="half_rhythm"><a href="release_notes_08_01_2003.html">Release Notes (August 1, 2003)</a></li></ul></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="ch_build.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="ch_style.html">Next &gt;</a></div></div><div class="meta_content"><h1><span class="label">6</span><span class="title">Project Creation and Management</span></h1><p class="small">Last Update: March 27, 2012.</p></div><div class="body_content"><div class="sec"><h2><span class="title">Overview</span></h2><p>The overview for this chapter consists of the following topics:</p><ul><li><p>Introduction</p></li><li><p>Chapter Outline</p></li></ul><div class="sec"><h3><span class="title">Introduction</span></h3><p>This chapter discusses the setup procedures for starting a new project such as the location of makefiles, header files, source files, etc. It also discusses the SVN tree structure and how to use SVN for tracking your code changes, and how to manage the development environment.</p></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p><ul><li><p><a href="ch_proj.html#ch_proj.start_new_proj">Starting New Projects</a></p><ul><li><p><a href="ch_proj.html#ch_proj.new_proj_struct">New Projects: Location and File Structure </a></p><ul><li><p><a href="ch_proj.html#ch_proj.new_project_Starting">new_project: Starting a New Project outside the C++ Toolkit Tree</a></p></li><li><p><a href="ch_proj.html#ch_proj.Creating_a_New_Proje">Creating a New Project Inside the C++ Toolkit Tree</a></p></li></ul></li><li><p><a href="ch_proj.html#ch_proj.cvs_tree_struct">Projects and the Toolkit's SVN Tree Structure</a></p></li><li><p><a href="ch_proj.html#ch_proj.src_include_dirs">Creating source and include SVN dirs for a new C++ project</a></p></li><li><p><a href="ch_proj.html#ch_proj.new_modules">Starting New Modules </a></p></li><li><p><a href="ch_proj.html#ch_proj.meta_makefiles">Meta-makefiles (to provide multiple and/or recursive builds)</a></p></li><li><p><a href="ch_proj.html#ch_proj.proj_makefiles">Project makefiles</a></p><ul><li><p><a href="ch_proj.html#ch_proj.make_proj_lib">Example 1: Customized makefile to build a library</a></p></li><li><p><a href="ch_proj.html#ch_proj.make_proj_app">Example 2: Customized makefile to build an application</a></p></li><li><p><a href="ch_proj.html#ch_proj.usr_def_makefile">Example 3: User-defined makefile to build... whatever</a></p></li></ul></li><li><p><a href="ch_proj.html#ch_proj.makefile_hierarchy">An example of the NCBI C++ makefile hierarchy ("corelib/")</a></p></li></ul></li><li><p><a href="ch_proj.html#ch_proj.work_env">Managing the Work Environment</a></p><ul><li><p><a href="ch_proj.html#ch_proj.daily_builds">Obtaining the Very Latest Builds</a></p></li><li><p><a href="ch_proj.html#ch_proj.outside_tree">Working in a separate directory</a></p><ul><li><p><a href="ch_proj.html#ch_proj.outside_dir_loc">Setting up Directory Location </a></p></li><li><p><a href="ch_proj.html#ch_proj.outside_tree_makefile">The Project's Makefile </a></p></li><li><p><a href="ch_proj.html#ch_proj.outside_testing">Testing your setup </a></p></li></ul></li><li><p><a href="ch_proj.html#ch_proj.work_sub_tree">Working Independently In a C++ Subtree</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_tree">Working within the C++ source tree</a></p><ul><li><p><a href="ch_proj.html#ch_proj.inside_checkout">Checkout the source tree and configure a build directory</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_makefiles">The project's directories and makefiles</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_make_meta">Makefile.in meta files</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_example">An example meta-makefile and its associated project makefiles</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_make_exec">Executing make</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_cust_make">Custom project makefile: Makefile.myProj</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_lib_make">Library project makefile: Makefile.myProj.lib</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_app_make">Application project makefile: Makefile.myProj.app</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_tests">Definition and running tests</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_config">The configure scripts</a></p></li></ul></li><li><p><a href="ch_proj.html#ch_proj.ser_object">Working with the serializable object classes</a></p><ul><li><p><a href="ch_proj.html#ch_proj.ser_objects_intro">Serializable Objects</a></p></li><li><p><a href="ch_proj.html#ch_proj.locate_ser_objects">Locating and browsing serializable objects in the C++ Toolkit</a></p></li><li><p><a href="ch_proj.html#ch_proj.base_classes">Base classes and user classes</a></p></li><li><p><a href="ch_proj.html#ch_proj.add_to_usr_classes">Adding methods to the user classes</a></p><ul><li><p><a href="ch_proj.html#ch_proj.src_code_work_env">Checking out source code, configuring the working environment, building the libraries</a>.</p></li><li><p><a href="ch_proj.html#ch_proj.proj_add_methods">Adding methods</a></p></li></ul></li></ul></li></ul></li></ul></div></div><div class="sec" id="ch_proj.start_new_proj"><h2><span class="title">Starting New Projects</span></h2><p>The following assumes that you have all of the necessary Toolkit components. If you need to obtain part or the Toolkit's entire source tree, consult the <a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">FTP instructions</a> or <a href="ch_getcode_svn.html#ch_getcode_svn.code_retrieval">SVN checkout procedures</a>. Please visit the <a href="ch_start.html">Getting Started</a> page for a broad overview of the NCBI C++ Toolkit and its use.</p><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_proj.html#ch_proj.new_proj_struct">New Projects: Location and File Structure</a></p><ul><li><p><a href="ch_proj.html#ch_proj.new_project_Starting">new_project: Starting a New Project outside the C++ Toolkit Tree</a></p></li><li><p><a href="ch_proj.html#ch_proj.Creating_a_New_Proje">Creating a New Project Inside the C++ Toolkit Tree</a></p></li></ul></li><li><p><a href="ch_proj.html#ch_proj.cvs_tree_struct">Projects and the Toolkit's SVN Tree Structure</a></p></li><li><p><a href="ch_proj.html#ch_proj.src_include_dirs">Creating source and include SVN dirs for a new C++ project</a></p></li><li><p><a href="ch_proj.html#ch_proj.new_modules">Starting New Modules </a></p></li><li><p><a href="ch_proj.html#ch_proj.meta_makefiles">Meta-makefiles (to provide multiple and/or recursive builds)</a></p></li><li><p><a href="ch_proj.html#ch_proj.proj_makefiles">Project makefiles</a></p><ul><li><p><a href="ch_proj.html#ch_proj.make_proj_lib">Example 1: Customized makefile to build a library</a></p></li><li><p><a href="ch_proj.html#ch_proj.make_proj_app">Example 2: Customized makefile to build an application</a></p></li><li><p><a href="ch_proj.html#ch_proj.usr_def_makefile">Example 3: User-defined makefile to build... whatever</a></p></li></ul></li><li><p><a href="ch_proj.html#ch_proj.makefile_hierarchy">An example of the NCBI C++ makefile hierarchy ("corelib/")</a></p></li></ul><div class="sec" id="ch_proj.new_proj_struct"><h3><span class="title">New Projects: Location and File Structure</span></h3><p>Before creating the new project, you must decide if you need to work within a C++ source tree (or subtree) or merely need to link with the Toolkit libraries and work in a separate directory. The later case is simpler and allows you to work independently in a private directory, but it is not an option if the Toolkit source, headers, or <span class="nctnt ncbi-monospace">makefiles</span> are to be directly used or altered during the new project's development.</p><ul><li><p><a href="ch_proj.html#ch_proj.inside_tree">Work in the Full Toolkit Source Tree</a></p></li><li><p><a href="ch_proj.html#ch_proj.work_sub_tree">Work in a Toolkit Subtree</a></p></li><li><p><a href="ch_proj.html#ch_proj.outside_tree">Work in a Separate Directory</a></p></li></ul><p>Regardless of where you build your new project, it must adopt and maintain a particular structure. Specifically, each project's <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src">source tree</a> relative to <span class="nctnt ncbi-path">$NCBI/c++</span> should contain:</p><ul><li><p><span class="nctnt ncbi-path">include/*.hpp</span> -- project's public headers</p></li><li><p><span class="nctnt ncbi-path">src/*.{cpp, hpp}</span> -- project's source files and private headers</p></li><li><p><span class="nctnt ncbi-path">src/Makefile.in</span> -- a <a href="ch_proj.html#ch_proj.meta_makefiles">meta-makefile</a> template to specify which local projects (described in <span class="nctnt ncbi-path">Makefile.*.in</span>) and sub-projects (located in the project subdirectories) must be built</p></li><li><p><span class="nctnt ncbi-path">src/Makefile.&lt;project_name&gt;.{lib, app}[.in]</span> -- one or more <span class="nctnt ncbi-monospace">customized makefiles</span> to build a library or an application</p></li><li><p><span class="nctnt ncbi-path">src/Makefile.*[.in]</span> -- "free style" makefiles (if any)</p></li><li><p>sub-project directories (if any)</p></li></ul><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_proj.html#ch_proj.new_project_Starting">new_project: Starting a New Project outside the C++ Toolkit Tree</a></p></li><li><p><a href="ch_proj.html#ch_proj.Creating_a_New_Proje">Creating a New Project Inside the C++ Toolkit Tree</a></p></li></ul><div class="sec" id="ch_proj.new_project_Starting"><h4><span class="title"><span class="nctnt ncbi-app">new_project</span>: Starting a New Project outside the C++ Toolkit Tree</span></h4><p>Script usage:</p><pre><span class="nctnt-pre ncbi-cmd">new_project &lt;name&gt; &lt;type&gt;[/&lt;subtype&gt;] [builddir]</span></pre><p><span class="nctnt highlight">NOTE</span>: in NCBI, you can (and should) invoke common scripts simply by name - i.e. without path or extension. The proper script located in the pre-built NCBI C++ toolkit directory will be invoked.</p><p>This script will create a startup makefile for a new project which uses the NCBI C++ Toolkit (and possibly the C Toolkit as well). Replace <span class="nctnt ncbi-cmd">&lt;type&gt;</span> with <span class="nctnt ncbi-cmd">lib</span> for libraries or <span class="nctnt ncbi-cmd">app</span> for applications.</p><p>Sample code will be included in the project directory for new applications. Different samples are available for <span class="nctnt ncbi-cmd">type=app[/basic]</span> (a command-line argument demo application based on the <a href="ch_core.html">corelib</a> library), <span class="nctnt ncbi-cmd">type=app/cgi</span> (for a <a href="ch_cgi.html">CGI or Fast-CGI</a> application), <span class="nctnt ncbi-cmd">type=app/objmgr</span> (for an application using the <span class="nctnt ncbi-monospace">Object Manager</span>), <span class="nctnt ncbi-cmd">type=app/objects</span> (for an application using ASN.1 objects), and many others.</p><p>You will need to slightly edit the resultant makefile to:</p><ul><li><p>specify the name of your library (or application)</p></li><li><p>specify the list of source files going to it</p></li><li><p>modify some preprocessor, compiler, etc. flags, if needed</p></li><li><p>modify the set of additional libraries to link to it (if it's an application), if needed</p></li></ul><p>For example:</p><pre><span class="nctnt-pre ncbi-cmd">new_project foo app/basic</span></pre><p>creates a model makefile <span class="nctnt ncbi-path">Makefile.foo_app</span> to build an application using tools and flags hard-coded in <span class="nctnt ncbi-path">$NCBI/c++/Debug/build/Makefile.mk</span>, and headers from <span class="nctnt ncbi-path">$NCBI/c++/include/</span>. The file <span class="nctnt ncbi-path">/tmp/foo/foo.cpp</span> is also created; you can either replace this with your own <span class="nctnt ncbi-path">foo.cpp</span> or modify its sample code as required.</p><p>Now, after specifying the application name, list of source files, etc., you can just go to the created working directory <span class="nctnt ncbi-path">foo/</span> and build your application using:</p><pre><span class="nctnt-pre ncbi-cmd">make -f Makefile.foo_app</span></pre><p>You can easily change the active version of NCBI C++ Toolkit by manually setting variable <span class="nctnt ncbi-var">$(builddir)</span> in the file <span class="nctnt ncbi-path">Makefile.foo_app</span> to the desired Toolkit path, e.g.,</p><pre><span class="nctnt-pre ncbi-cmd">builddir = $(NCBI)/c++/GCC-Release/build</span></pre><p>In many cases, you work on your own project which <b>is a part</b> of the NCBI C++ tree, and you do not want to check out, update and rebuild the whole NCBI C++ tree. Instead, you just want to use headers and libraries of the pre-built NCBI C++ Toolkit to build your project. In these cases, use the <a href="ch_getcode_svn.html#ch_getcode_svn.import_project_sh">import_project</a> script instead of <span class="nctnt ncbi-path">new_project</span>.</p><p><span class="nctnt highlight">Note for users inside NCBI:</span> To be able to view debug information in the Toolkit libraries for Windows builds, you will need to have the <span class="nctnt ncbi-cmd">S:</span> drive mapped to <span class="nctnt ncbi-path">\\snowman\win-coremake\Lib</span>. By default, <span class="nctnt ncbi-path">new_project</span> will make this mapping for you if it's not already done.</p></div><div class="sec" id="ch_proj.Creating_a_New_Proje"><h4><span class="title">Creating a New Project Inside the C++ Toolkit Tree</span></h4><p>To create your new project (e.g., "bar_proj") directories in the NCBI C++ Toolkit source tree (assuming that the entire NCBI C++ Toolkit has been <a href="ch_getcode_svn.html#ch_getcode_svn.chkout_complete_tree">checked out</a> to directory <span class="nctnt ncbi-path">foo/c++/</span>):</p><pre><span class="nctnt-pre ncbi-cmd">cd foo/c++/include &amp;&amp; mkdir bar_proj &amp;&amp; svn add bar_proj<br />cd foo/c++/src     &amp;&amp; mkdir bar_proj &amp;&amp; svn add bar_proj</span></pre><p>From there, you can now <a href="ch_proj.html#ch_proj.new_modules">add</a> and edit your project C++ files.</p><p>NOTE: remember to add this new project directory to the <span class="nctnt ncbi-var">$(SUB_PROJ)</span> list of the upper level <a href="ch_build.html#ch_build.makefiles_meta">meta-makefile</a> configurable template (e.g., for this particular case, to <span class="nctnt ncbi-path">foo/c++/src/Makefile.in</span>).</p></div></div><div class="sec" id="ch_proj.cvs_tree_struct"><h3><span class="title">Projects and the Toolkit's SVN Tree Structure</span></h3><p>(For the overall NCBI C++ SVN tree structure see <a href="ch_getcode_svn.html#ch_getcode_svn.source_tree">SVN details</a>.)</p><p>Even if you work outside of the C++ tree, it is necessary to understand how the Toolkit uses <span class="nctnt ncbi-monospace">makefiles</span>, <span class="nctnt ncbi-monospace">meta-makefiles</span>, and <span class="nctnt ncbi-monospace">makefile templates</span>, and the SVN tree structure.</p><p>The standard SVN location for NCBI C++/STL projects is <span class="nctnt ncbi-path">$SVNROOT/internal/c++/</span>. Public header files (<span class="nctnt ncbi-path">*.hpp, *.inl</span>) of all projects are located below the <span class="nctnt ncbi-path">$SVNROOT/internal/c++/include/</span> directory. <span class="nctnt ncbi-path">$SVNROOT/internal/c++/src/</span> directory has just the same hierarchy of subdirectories as <span class="nctnt ncbi-path">.../include/</span>, and its very top level contains:</p><ul><li><p>Templates of generic makefiles (<span class="nctnt ncbi-path">Makefile.*.in</span>):</p><ul><li><p><span class="nctnt ncbi-path">Makefile.in</span> -- makefile to perform a recursive build in all project subdirectories</p></li><li><p><span class="nctnt ncbi-path">Makefile.meta.in</span> -- included by all makefiles that provide both local and recursive builds</p></li><li><p><span class="nctnt ncbi-path">Makefile.lib.in</span> -- included by all makefiles that perform a "standard" library build, when building only static libraries.</p></li><li><p><span class="nctnt ncbi-path">Makefile.dll.in</span> -- included by all makefiles that perform a "standard" library build, when building only shared libraries.</p></li><li><p><span class="nctnt ncbi-path">Makefile.both.in</span> -- included by all makefiles that perform a "standard" library build, when building both static and shared libraries.</p></li><li><p><span class="nctnt ncbi-path">Makefile.lib.tmpl.in</span> -- serves as a template for the project <span class="nctnt ncbi-monospace">customized makefiles</span> (<span class="nctnt ncbi-path">Makefile.*.lib[.in]</span>) that perform a "standard" library build</p></li><li><p><span class="nctnt ncbi-path">Makefile.app.in</span> -- included by all makefiles that perform a "standard" application build</p></li><li><p><span class="nctnt ncbi-path">Makefile.lib.tmpl.in</span> -- serves as a template for the project <span class="nctnt ncbi-monospace">customized makefiles</span> (<span class="nctnt ncbi-path">Makefile.*.app[.in]</span>) that perform a "standard" application build</p></li><li><p><span class="nctnt ncbi-path">Makefile.rules.in, Makefile.rules_with_autodep.in</span> -- instructions for building object files; included by most other makefiles</p></li><li><p><span class="nctnt ncbi-path">Makefile.mk.in</span> -- included by all makefiles; sets a lot of configuration variables</p></li></ul></li><li><p>The contents of each project are detailed <a href="ch_proj.html#ch_proj.new_proj_struct">above</a>. If your project is to become part of the Toolkit tree, you need to ensure that all <span class="nctnt ncbi-monospace">makefiles</span> and <span class="nctnt ncbi-path">Makefile*.in</span> templates are available so the master <span class="nctnt ncbi-monospace">makefiles</span> can properly configure and build it (see "<a href="ch_proj.html#ch_proj.meta_makefiles">Meta-Makefiles</a>" and "<a href="ch_proj.html#ch_proj.proj_makefiles">Project Makefiles"</a> below). You will also need to <a href="ch_proj.html#ch_proj.src_include_dirs">prepare SVN directories</a> to hold the new source and header files.</p></li></ul></div><div class="sec" id="ch_proj.src_include_dirs"><h3><span class="title">Creating source and include SVN dirs for a new C++ project</span></h3><p>To create your new project (e.g., "bar_proj") directories in the NCBI C++ SVN tree to directory <span class="nctnt ncbi-path">foo/c++/</span>):</p><pre><span class="nctnt-pre ncbi-code">cd foo/c++/include &amp;&amp; mkdir bar_proj &amp;&amp; SVN add -m "Project Bar" bar_proj<br />cd foo/c++/src     &amp;&amp; mkdir bar_proj &amp;&amp; SVN add -m "Project Bar" bar_proj</span></pre><p>Now you can <a href="ch_proj.html#ch_proj.new_modules">add</a> and edit your project C++ files in there.</p><p><span class="nctnt highlight">NOTE:</span> remember to add this new project directory to the <span class="nctnt ncbi-var">$(SUB_PROJ)</span> list of the upper level <a href="ch_proj.html#ch_proj.meta_makefiles">meta-makefile</a> configurable template (e.g., for this particular case, to <span class="nctnt ncbi-path">foo/c++/src/Makefile.in</span>).</p></div><div class="sec" id="ch_proj.new_modules"><h3><span class="title">Starting New Modules</span></h3><p>Projects in the NCBI C++ Toolkit consist of “modules”, which are most often a pair of source <span class="nctnt ncbi-path">(*.cpp</span>) and header (<span class="nctnt ncbi-path">*.hpp</span>) files. To help create new modules, template source and header files may be used, or you may modify the sample code generated by the script <a href="ch_proj.html#ch_proj.new_project_Starting">new_project</a>. The template source and header files are <span class="nctnt ncbi-path">.../doc/public/framewrk.cpp</span> and <span class="nctnt ncbi-path">.../doc/public/framewrk.hpp</span>. The template files contain a standard startup framework so that you can just cut-and-paste them to start a new module (just don't forget to replace the "framewrk" stubs by your new module name).</p><ul><li><p>Header file (*.hpp) -- API for the external users. Ideally, this file contains only (well-commented) declarations and inline function implementations for the public interface. No less, and no more.</p></li><li><p>Source file (*.cpp) -- Definitions of non-inline functions and internally used things that should not be included by other modules.</p></li></ul><p>On occasion, a second private header file is required for good encapsulation. Such second headers should be placed in the same directory as the module source file.</p><p>Each and every source file <b>must</b> include the NCBI disclaimer and (preferably) Subversion keywords (e.g. $Id$). Then, the header file must be protected from double-inclusion, and it must define any inlined functions.</p></div><div class="sec" id="ch_proj.meta_makefiles"><h3><span class="title">Meta-makefiles (to provide multiple and/or recursive builds)</span></h3><p>All projects from the NCBI C++ hierarchy are tied together by a set of <span class="nctnt ncbi-monospace">meta-makefiles</span> which are present in all project source directories and provide a uniform and easy way to perform both local and recursive builds. See more detail on the <a href="ch_build.html">Working with Makefiles</a> page. A typical <span class="nctnt ncbi-monospace">meta-makefile</span> template (e.g. <span class="nctnt ncbi-path">Makefile.in</span> in your <span class="nctnt ncbi-path">foo/c++/src/bar_proj/</span> dir) looks like that:</p><pre><span class="nctnt-pre ncbi-code"># Makefile.bar_u1, Makefile.bar_u2 ...<br />USR_PROJ = bar_u1 bar_u2 ...<br /># Makefile.bar_l1.lib, Makefile.bar_l2.lib ...<br />LIB_PROJ = bar_l1 bar_l2 ...<br /># Makefile.bar_a1.app, Makefile.bar_a2.app ...<br />APP_PROJ = bar_a1 bar_l2 ...<br />SUB_PROJ = app sub_proj1 sub_proj2<br />srcdir = @srcdir@<br />include @builddir@/Makefile.meta</span></pre><p>This template separately specifies instructions for user, library and application projects, along with a set of three sub-projects that can be made. The mandatory final two lines <span class="nctnt ncbi-code">"srcdir = @srcdir@ ; include @builddir@/Makefile.meta"</span> define the <a href="ch_build.html#ch_build.std_build_targets">standard build targets</a>.</p></div><div class="sec" id="ch_proj.proj_makefiles"><h3><span class="title">Project makefiles</span></h3><p>Just like the configurable template <span class="nctnt ncbi-path">Makefile.meta.in</span> is used to ease and standardize the writing of <a href="ch_proj.html#ch_proj.meta_makefiles">meta-makefiles</a>, so there are templates to help in the creation of "regular" project makefiles to build a library or an application. These auxiliary template makefiles are described on the "<a href="ch_build.html#ch_build.makefiles_hierarch">Working with Makefiles</a>" page and listed <a href="ch_proj.html#ch_proj.cvs_tree_struct">above</a>. The <span class="nctnt ncbi-app">configure</span>'d versions of these templates get put at the very top of a <span class="nctnt ncbi-monospace">build tree</span>.</p><p>In addition to the <span class="nctnt ncbi-monospace">meta-makefile</span> that must be defined for each project, a customized makefile <span class="nctnt ncbi-path">Makefile.&lt;project_name&gt;.[app|lib]</span> must also be provided. The following three sections give examples of <span class="nctnt ncbi-monospace">customized makefiles</span> for a <a href="ch_proj.html#ch_proj.make_proj_lib">library</a> and an <a href="ch_proj.html#ch_proj.make_proj_app">application</a>, along with a case where a <a href="ch_proj.html#ch_proj.usr_def_makefile">user-defined</a> <span class="nctnt ncbi-monospace">makefile</span> is required.</p><p>You have great latitude in specifying optional packages, features and projects in <span class="nctnt ncbi-monospace">makefiles</span>. The macro <span class="nctnt ncbi-var">REQUIRES</span> in the examples is one way to allows you access them. See the "<span class="nctnt ncbi-monospace">Working with Makefiles</span>" page for a <a href="ch_build.html#ch_build.packages_opt">complete list</a>; the configuration page gives the corresponding <a href="ch_config.html#ch_config.ch_configprohibit_sy">configure options</a>.</p><p>The following examples are discussed in this section:</p><ul><li><p><a href="ch_proj.html#ch_proj.make_proj_lib">Example 1: Customized makefile to build a library</a></p></li><li><p><a href="ch_proj.html#ch_proj.make_proj_app">Example 2: Customized makefile to build an application</a></p></li><li><p><a href="ch_proj.html#ch_proj.usr_def_makefile">Example 3: User-defined makefile to build... whatever</a></p></li></ul><div class="sec" id="ch_proj.make_proj_lib"><h4><span class="title">Example 1: Customized makefile to build a library</span></h4><p>Here is an example of a <span class="nctnt ncbi-monospace">customized makefile</span> to build library <span class="nctnt ncbi-lib">libxmylib.a</span> from two source files <span class="nctnt ncbi-path">xmy_src1.cpp</span> and <span class="nctnt ncbi-path">xmy_src2.c</span>, and one pre-compiled object file <span class="nctnt ncbi-path">some_obj1.o</span>. To make the example even more realistic, we assume that the said source files include headers from the NCBI C Toolkit.</p><pre><span class="nctnt-pre ncbi-code">LIB      = xmylib<br />SRC      = xmy_src1 xmy_src2<br />OBJ      = some_obj1<br />REQUIRES = xrequirement<br />CFLAGS   = $(ORIG_CFLAGS)   -abc -DFOOBAR_NOT_CPLUSPLUS<br />CXXFLAGS = $(FAST_CXXFLAGS) -xyz<br />CPPFLAGS = $(ORIG_CPPFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)</span></pre><ul><li><p>Skip building this library if <span class="nctnt ncbi-monospace">xrequirement</span> (<a href="ch_build.html#ch_build.packages_opt">an optional package or project</a>) is disabled or unavailable.</p></li><li><p>Compile <span class="nctnt ncbi-path">xmy_src1.cpp</span> using the C++ compiler <span class="nctnt ncbi-var">$(CXX)</span> with the flags <span class="nctnt ncbi-cmd">$(FAST_CXXFLAGS) -xyz $(CPPFLAGS)</span>, which are the C++ flags for faster code, some additional flags specified by the user, and the original preprocessor flags.</p></li><li><p>Compile <span class="nctnt ncbi-path">xmy_src2.c</span> using the C compiler <span class="nctnt ncbi-var">$(CC)</span> with the flags <span class="nctnt ncbi-cmd">$(ORIG_CFLAGS) -abc -DFOOBAR_NOT_CPLUSPLUS $(CPPFLAGS)</span>, which are the original C flags, some additional flags specified by the user, and the original preprocessor flags.</p></li><li><p>Using <span class="nctnt ncbi-var">$(AR)</span> and <span class="nctnt ncbi-var">$(RANLIB)</span> [<span class="nctnt ncbi-var">$(LINK_DLL)</span> if building a shared library], compose the library <span class="nctnt ncbi-lib">libxmylib.a</span> [<span class="nctnt ncbi-lib">libxmylib.so</span>] from the resultant object files, plus the pre-compiled object file <span class="nctnt ncbi-path">some_obj1.o</span>.</p></li><li><p>Copy <span class="nctnt ncbi-lib">libxmylib.*</span> to the top-level <span class="nctnt ncbi-path">lib/</span> directory of the <span class="nctnt ncbi-monospace">build tree</span> (for the later use by other projects).</p></li></ul><p>This <span class="nctnt ncbi-monospace">customized makefile</span> should be referred to as <span class="nctnt ncbi-path">xmylib</span> in the <span class="nctnt ncbi-var">LIB_PROJ</span> macro of the relevant <a href="ch_proj.html#ch_proj.meta_makefiles">meta-makefile</a>. As usual, <a href="ch_build.html#ch_build.build_make_macros">Makefile.mk</a> will be implicitly included.</p><p>This <span class="nctnt ncbi-monospace">customized makefile</span> can be used to build both <span class="nctnt ncbi-monospace">static</span> and <a href="ch_config.html#ch_config.Building_Shared_Libr">dynamic (DLL)</a> versions of the library. To encourage its build as a <span class="nctnt ncbi-monospace">DLL</span> on the capable platforms, you can explicitly specify:</p><pre><span class="nctnt-pre ncbi-code">LIB_OR_DLL = dll</span></pre><p>or</p><pre><span class="nctnt-pre ncbi-code">LIB_OR_DLL = both</span></pre><p>Conversely, if you want the library be always built as <span class="nctnt ncbi-monospace">static</span>, specify:</p><pre><span class="nctnt-pre ncbi-code">LIB_OR_DLL = lib</span></pre></div><div class="sec" id="ch_proj.make_proj_app"><h4><span class="title">Example 2: Customized makefile to build an application</span></h4><p>Here is an example of a <span class="nctnt ncbi-monospace">customized makefile</span> to build the application <span class="nctnt ncbi-app">my_exe</span> from three source files, <span class="nctnt ncbi-path">my_main.cpp</span>, <span class="nctnt ncbi-path">my_src1.cpp</span>, and <span class="nctnt ncbi-path">my_src2.c</span>. To make the example even more realistic, we assume that the said source files include headers from the NCBI SSS DB packages, and the target executable uses the NCBI C++ libraries <a href="ch_proj.html#ch_proj.make_proj_lib">libxmylib.*</a> and <span class="nctnt ncbi-lib">libxncbi.*</span>, plus NCBI SSS DB, SYBASE, and system network libraries. We assume further that the user would prefer to link statically against libxmylib if building the toolkit as both shared and static libraries (<span class="nctnt ncbi-cmd">configure --with-dll --with-static ...</span>), but is fine with a shared libxncbi.</p><pre><span class="nctnt-pre ncbi-code">APP      = my_exe<br />SRC      = my_main my_src1 my_src2<br />OBJ      = some_obj<br />LIB      = xmylib$(STATIC) xncbi<br />REQUIRES = xrequirement<br />CPPFLAGS = $(ORIG_CPPFLAGS) $(NCBI_SSSDB_INCLUDE)<br />LIBS     = $(NCBI_SSSDB_LIBS) $(SYBASE_LIBS) $(NETWORK_LIBS) $(ORIG_LIBS)</span></pre><ul><li><p>Skip building this library if <span class="nctnt ncbi-monospace">xrequirement</span> (<a href="ch_build.html#ch_build.packages_opt">an optional package or project</a>) is disabled or unavailable.</p></li><li><p>Compile <span class="nctnt ncbi-path">my_main.cpp</span> and <span class="nctnt ncbi-path">my_src1.cpp</span> using the C++ compiler <span class="nctnt ncbi-var">$(CXX)</span> with the flags <span class="nctnt ncbi-var">$(CXXFLAGS)</span> (see Note below).</p></li><li><p>Compile <span class="nctnt ncbi-path">my_src2.c</span> using the C compiler <span class="nctnt ncbi-var">$(CC)</span> with the flags <span class="nctnt ncbi-var">$(CFLAGS)</span> (see Note below).</p></li><li><p>Using <span class="nctnt ncbi-var">$(CXX)</span> as a linker, build an executable <span class="nctnt ncbi-app">my_exe</span> from the object files <span class="nctnt ncbi-path">my_main.o, my_src1.o, my_src2.o</span>, the precompiled object file <span class="nctnt ncbi-path">some_obj.o</span>, NCBI C++ Toolkit libraries <a href="ch_proj.html#ch_proj.make_proj_lib">libxmylib.a</a> and <span class="nctnt ncbi-lib">libxncbi.*</span>, and NCBI SSS DB, SYBASE, and system network libraries (see Note below).</p></li><li><p>Copy the application to the top-level <span class="nctnt ncbi-path">bin/</span> directory of the <span class="nctnt ncbi-monospace">build tree</span> (for later use by other projects).</p></li></ul><p><span class="nctnt highlight">Note:</span> Since we did not redefine <span class="nctnt ncbi-var">CFLAGS</span>, <span class="nctnt ncbi-var">CXXFLAGS</span>, or <span class="nctnt ncbi-var">LDFLAGS</span>, their default values <span class="nctnt ncbi-var">ORIG_*FLAGS</span> (obtained during the <span class="nctnt ncbi-monospace">build tree </span><a href="ch_config.html#ch_config.Configuration_and_In">configuration</a>) will be used.</p><p>This <span class="nctnt ncbi-monospace">customized makefile</span> should be referred to as <span class="nctnt ncbi-app">my_exe</span> in the <span class="nctnt ncbi-var">APP_PROJ</span> macro of the relevant <a href="ch_proj.html#ch_proj.meta_makefiles">meta-makefile</a>. Note also, that the <a href="ch_build.html#ch_build.build_make_macros">Makefile.mk</a> will be implicitly included.</p></div><div class="sec" id="ch_proj.usr_def_makefile"><h4><span class="title">Example 3: User-defined makefile to build... whatever</span></h4><p>In some cases, we may need more functionality than the <span class="nctnt ncbi-monospace">customized makefiles</span> (designed to build libraries and applications) can provide.</p><p>So, if you have a "regular" non-customized <span class="nctnt ncbi-monospace">user makefile</span>, and you want to make from it, then you must enlist this <span class="nctnt ncbi-monospace">user makefile</span> in the <span class="nctnt ncbi-var">USR_PROJ</span> macro of the project's <a href="ch_proj.html#ch_proj.meta_makefiles">meta-makefile</a>.</p><p>Now, during the project build (and before any <span class="nctnt ncbi-monospace">customized makefiles</span> are processed), your makefile will be called with one of the <a href="ch_build.html#ch_build.build_make_proj_target">standard make targets</a> from the project's build directory. Additionally, the <a href="ch_build.html#ch_build.T1">builddir</a> and <a href="ch_build.html#ch_build.T1">srcdir</a> macros will be passed to your makefile (via the <span class="nctnt ncbi-app">make</span> command line).</p><p>In most cases, it is necessary to know your "working environment"; i.e., tools, flags and paths (those that you use in your <span class="nctnt ncbi-monospace">customized makefiles</span>). This can be easily done by including <a href="ch_build.html#ch_build.build_make_macros">Makefile.mk</a> in your makefile.</p><p>Shown below is a real-life example of a <span class="nctnt ncbi-monospace">user makefile</span>:</p><ul><li><p>build an auxiliary application using the customized makefile <span class="nctnt ncbi-path">Makefile.hc_gen_obj.app</span> (this part is a tricky one...)</p></li><li><p>use the resultant application <span class="nctnt ncbi-path">$(bindir)/hc_gen_obj</span> to generate the source and header files <span class="nctnt ncbi-path">humchrom_dat.[ch]</span> from the data file <span class="nctnt ncbi-path">humchrom.dat</span></p></li><li><p>use the script <span class="nctnt ncbi-app">$(top_srcdir)/scripts/if_diff.sh</span> to replace the previous copies (if any) of <span class="nctnt ncbi-path">humchrom_dat.[ch]</span> with the newly generated versions if and only if the new versions are different (or there were no old versions).</p></li></ul><p>And, of course, it provides build rules for all the <a href="ch_build.html#ch_build.build_make_proj_target">standard make targets</a>.</p><pre><span class="nctnt-pre ncbi-code">File $(top_srcdir)/src/internal/humchrom/Makefile.hc_gen_obj:<br /># Build a code generator for hard-coding the chrom data into<br /># an obj file<br /># Generate header and source "humchrom_dat.[ch]" from data<br /># file "humchrom.dat"<br /># Deploy the header to the compiler-specific include dir<br /># Compile source code<br />#################################<br />include $(builddir)/Makefile.mk<br />BUILD__HC_GEN_OBJ = $(MAKE) -f "$(builddir)/Makefile.app.tmpl" \<br />srcdir="$(srcdir)" TMPL="hc_gen_obj" $(MFLAGS)<br />all_r: all<br />all: build_hc_gen_obj humchrom_dat.dep<br />purge_r: purge<br />purge:   x_clean<br />    $(BUILD__HC_GEN_OBJ) purge<br />clean_r: clean<br />clean:   x_clean<br />    $(BUILD__HC_GEN_OBJ) clean<br />x_clean:<br />    -rm -f humchrom_dat.h<br />    -rm -f humchrom_dat.c<br />build_hc_gen_obj:<br />    $(BUILD__HC_GEN_OBJ) all<br />humchrom_dat.dep: $(srcdir)/data/humchrom.dat $(bindir)/hc_gen_obj<br />    -cp -p humchrom_dat.c humchrom_dat.save.c<br />    $(bindir)/hc_gen_obj -d $(srcdir)/data/humchrom.dat<br />        -f humchrom_dat<br />    $(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.h<br />        $(incdir)/humchrom_dat.h<br />    -rm humchrom_dat.h<br />    $(top_srcdir)/scripts/if_diff.sh "mv" humchrom_dat.c<br />       humchrom_dat.save.c<br />    mv humchrom_dat.save.c humchrom_dat.c<br />    touch humchrom_dat.dep</span></pre></div></div><div class="sec" id="ch_proj.makefile_hierarchy"><h3><span class="title">An example of the NCBI C++ makefile hierarchy ("corelib/")</span></h3><p>See also the <a href="ch_start.html#ch_start.F1">source</a> and <a href="ch_start.html#ch_start.F2">build</a> hierarchy charts.</p><p><span class="nctnt ncbi-path">c++/src/Makefile.in</span>:</p><pre>SUB_PROJ = corelib cgi html @serial@ @internal@<br />include @builddir@/Makefile.meta<br /></pre><p><span class="nctnt ncbi-path">c++/src/corelib/Makefile.in</span>:</p><pre>LIB_PROJ = corelib<br />SUB_PROJ = test<br />srcdir = @srcdir@<br />include @builddir@/Makefile.meta<br /></pre><p><span class="nctnt ncbi-path">c++/src/corelib/Makefile.corelib.lib</span>:</p><pre>SRC = ncbidiag ncbiexpt ncbistre ncbiapp ncbireg ncbienv ncbistd<br />LIB = xncbi<br /></pre><p><span class="nctnt ncbi-path">c++/src/corelib/test/Makefile.in</span>:</p><pre>APP_PROJ = coretest<br />srcdir = @srcdir@<br />include @builddir@/Makefile.meta<br /></pre></div></div><div class="sec" id="ch_proj.work_env"><h2><span class="title">Managing the Work Environment</span></h2><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_proj.html#ch_proj.daily_builds">Obtaining the Very Latest Builds</a></p></li><li><p><a href="ch_proj.html#ch_proj.outside_tree">Working in a separate directory</a></p><ul><li><p><a href="ch_proj.html#ch_proj.outside_dir_loc">Setting up Directory Location </a></p></li><li><p><a href="ch_proj.html#ch_proj.outside_tree_makefile">The Project's Makefile </a></p></li><li><p><a href="ch_proj.html#ch_proj.outside_testing">Testing your setup </a></p></li></ul></li><li><p><a href="ch_proj.html#ch_proj.work_sub_tree">Working Independently In a C++ Subtree</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_tree">Working within the C++ source tree</a></p><ul><li><p><a href="ch_proj.html#ch_proj.inside_checkout">Checkout the source tree and configure a build directory</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_makefiles">The project's directories and makefiles</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_make_meta">Makefile.in meta files</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_example">An example meta-makefile and its associated project makefiles</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_make_exec">Executing make</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_cust_make">Custom project makefile: Makefile.myProj</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_lib_make">Library project makefile: Makefile.myProj.lib</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_app_make">Application project makefile: Makefile.myProj.app</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_tests">Definition and running tests</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_config">The configure scripts</a></p></li></ul></li><li><p><a href="ch_proj.html#ch_proj.ser_object">Working with the serializable object classes</a></p><ul><li><p><a href="ch_proj.html#ch_proj.ser_objects_intro">Serializable Objects</a></p></li><li><p><a href="ch_proj.html#ch_proj.locate_ser_objects">Locating and browsing serializable objects in the C++ Toolkit</a></p></li><li><p><a href="ch_proj.html#ch_proj.base_classes">Base classes and user classes</a></p></li><li><p><a href="ch_proj.html#ch_proj.add_to_usr_classes">Adding methods to the user classes</a></p><ul><li><p><a href="ch_proj.html#ch_proj.src_code_work_env">Checking out source code, configuring the working environment, building the libraries.</a></p></li><li><p><a href="ch_proj.html#ch_proj.proj_add_methods">Adding methods</a></p></li></ul></li></ul></li></ul><div class="sec" id="ch_proj.daily_builds"><h3><span class="title">Obtaining the Very Latest Builds</span></h3><p>Each new nightly build is available in the <span class="nctnt ncbi-path">$NCBI/c++.by-date/{date}</span> subdirectory. This is done regardless of whether the build succeeds or not.</p><p>There are defined symlinks into this directory tree. They include:</p><ul><li><p><span class="nctnt ncbi-path">$NCBI/c++</span> - Symbolic link to <span class="nctnt ncbi-path">$NCBI/c++.production</span>.</p></li><li><p><span class="nctnt ncbi-path">$NCBI/c++.potluck</span> - The most recent nightly build. It contains whatever libraries and executables have managed to build, and it can miss some of the libraries and/or executables. Use it if you desperately need yesterday's bug fix and do not care of the libraries which are missing.</p></li><li><p><span class="nctnt ncbi-path">$NCBI/c++.metastable</span> - The most recent nightly build for which the compilation (but not necessarily the test suite) succeeded in all configurations on the given platform. Please note that some projects, including the entire "<span class="nctnt ncbi-path">gui</span>" tree, are considered expendable due to their relative instability and therefore not guaranteed to be present.</p></li><li><p><span class="nctnt ncbi-path">$NCBI/c++.current</span> - Symbolic link to <span class="nctnt ncbi-path">$NCBI/c++.metastable</span>.</p></li><li><p><span class="nctnt ncbi-path">$NCBI/c++.stable</span> - The most recent nightly build for which the nightly build (INCLUDING the gui projects) succeeded AND the test suite passed all critical tests on the given platform. This would be the preferred build most of the time for the developers whose projects make use of the actively developed C++ Toolkit libraries. It is usually relatively recent (usually no more than 1 or 2 weeks behind), and at the same time quite stable.</p></li><li><p><span class="nctnt ncbi-path">$NCBI/c++.frozen</span> - A "production candidate" build made out of the production codebase. There are usually two such builds made for each version of production codebase -- one is for the original production build, and another (usually made in about 2 months after the original production build) is the follow-up bugfix build.</p></li><li><p><span class="nctnt ncbi-path">$NCBI/c++.production</span> - The most recent production snapshot. This is determined based on general stability of the Toolkit and it is usually derived off the codebase of one of the prior "<span class="nctnt ncbi-path">c++.stable</span>" builds. Its codebase is the same for all platforms and configurations. It is installed only on the major NCBI development platforms (Linux, MS-Windows, MacOS, and Solaris/SPARC). It is the safest bet for long-term development. It changes rarely, once in 1 to 3 months. Also, unlike all other builds mentioned here it is guaranteed to be accessible for at least a year (or more), and its DLLs are installed on all (including production) Linux hosts.</p></li><li><p><span class="nctnt ncbi-path">$NCBI/c++.prod-head</span> - This build is for NCBI developers to quickly check their planned stable component commits using <a href="ch_getcode_svn.html#ch_getcode_svn.import_project_sh">import_project</a>. It is based on the repository path <span class="nctnt ncbi-path">toolkit/production/candidates/production.HEAD</span> – which is the HEAD SVN revision of the C+ Stable Components on which the latest c++.production build was based. It is available for both 32- and 64- bit Linux.</p></li><li><p><span class="nctnt ncbi-path">$NCBI/c++.trial</span> - This build is for NCBI developers to quickly check their planned stable component commits using <a href="ch_getcode_svn.html#ch_getcode_svn.import_project_sh">import_project</a>. It is based on the repository path <span class="nctnt ncbi-path">toolkit/production/candidates/trial</span> – which is usually a codebase for the upcoming production build. It is available for both 32- and 64- bit Linux</p></li></ul></div><div class="sec" id="ch_proj.outside_tree"><h3><span class="title">Working in a separate directory</span></h3><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_proj.html#ch_proj.outside_dir_loc">Setting up Directory Location </a></p></li><li><p><a href="ch_proj.html#ch_proj.outside_tree_makefile">The Project's Makefile </a></p></li><li><p><a href="ch_proj.html#ch_proj.outside_testing">Testing your setup </a></p></li></ul><div class="sec" id="ch_proj.outside_dir_loc"><h4><span class="title">Setting up Directory Location</span></h4><p>There are two topics relevant to writing an application using the NCBI C++ Toolkit:</p><ul><li><p>Where to place the source and header files for the project</p></li><li><p>How to create a makefile which can link to the correct C++ libraries</p></li></ul><p>What you put in your makefile will depend on where you define your working directory. In this discussion, we assume you will be working <b>outside</b> the NCBI C++ tree, say in a directory called <span class="nctnt ncbi-path">NewProj</span>. This is where you will write both your source and header files. The first step then, is to create the new working directory and use the <a href="ch_proj.html#ch_proj.new_project_Starting">new_project</a> script to install a makefile there:</p><pre><span class="nctnt-pre ncbi-cmd">mkdir NewProj<br />new_project NewProj app $NCBI/c++/GCC-Debug/build<br />    Created a model makefile "/home/zimmerma/NewProj/Makefile.NewProj_app".</span></pre><p>The syntax of the script command is:</p><pre><span class="nctnt-pre ncbi-cmd">new_project &lt;project_name&gt; &lt;app | lib&gt; [builddir]</span></pre><p>where: - <span class="nctnt ncbi-cmd">project_name</span> is the name of the directory you will be working in - <span class="nctnt ncbi-cmd">app (lib)</span> is used to indicate whether you will be building an application or a library - <span class="nctnt ncbi-cmd">builddir</span> (optional) specifies what version of the pre-built NCBI C++ Toolkit libraries to link to</p><p>Several build environments have been pre-configured and are available for developing on various platforms using different compilers, in either <b>debug</b> or <b>release</b> mode. These environments include custom-made configuration files, makefile templates, and links to the appropriate pre-built C++ Toolkit libraries. To see a list of the available environments for the platform you are working on, use: <span class="nctnt ncbi-cmd">ls -d $NCBI/c++/*/build</span>. For example, on <span class="nctnt ncbi-monospace">Solaris</span>, the build directories currently available are shown in <a href="ch_proj.html#ch_proj.T1">Table 1</a>.</p><div class="table" id="ch_proj.T1"><div class="caption"><p>Table 1. Build Directories</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Directory</th><th align="left" valign="top" rowspan="1" colspan="1">Compiler</th><th align="left" valign="top" rowspan="1" colspan="1">Version</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-path">/netopt/ncbi_tools/c++/Debug/build </span></td><td align="left" valign="top" rowspan="1" colspan="1">Sun Workshop</td><td align="left" valign="top" rowspan="1" colspan="1">Debug </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-path">/netopt/ncbi_tools/c++/Debug64/build </span></td><td align="left" valign="top" rowspan="1" colspan="1">Sun Workshop</td><td align="left" valign="top" rowspan="1" colspan="1">Debug (64 bit) </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-path">/netopt/ncbi_tools/c++/DebugMT/build </span></td><td align="left" valign="top" rowspan="1" colspan="1">Sun Workshop</td><td align="left" valign="top" rowspan="1" colspan="1">Debug (Multi-thread safe)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-path">/netopt/ncbi_tools/c++/Release/build </span></td><td align="left" valign="top" rowspan="1" colspan="1">Sun Workshop</td><td align="left" valign="top" rowspan="1" colspan="1">Release </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-path">/netopt/ncbi_tools/c++/ReleaseMT/build </span></td><td align="left" valign="top" rowspan="1" colspan="1">Sun Workshop</td><td align="left" valign="top" rowspan="1" colspan="1">Release (Multi-thread safe)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-path">/netopt/ncbi_tools/c++/GCC-Debug/build </span></td><td align="left" valign="top" rowspan="1" colspan="1">GCC </td><td align="left" valign="top" rowspan="1" colspan="1">Debug </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-path">/netopt/ncbi_tools/c++/GCC-Release/build</span></td><td align="left" valign="top" rowspan="1" colspan="1">GCC </td><td align="left" valign="top" rowspan="1" colspan="1">Release </td></tr></tbody></table></div><p>In the example above, we specified the GNU compiler debug environment: <span class="nctnt ncbi-path">$NCBI/c++/GCC-Debug/build</span>. For a list of currently supported compilers, see the <a href="release_notes.html">release notes</a>. Running the <span class="nctnt ncbi-app">new_project</span> script will generate a ready-to-use makefile in the directory you just created. For a more detailed description of this and other scripts to assist you in the set-up of your working environment, see <a href="ch_proj.html#ch_proj.start_new_proj">Starting a new C++ project</a>.</p></div><div class="sec" id="ch_proj.outside_tree_makefile"><h4><span class="title">The Project's Makefile</span></h4><p>The file you just created with the above script will be called <span class="nctnt ncbi-path">Makefile.NewProj_app</span>. In addition to other things, you will see definitions for: - <span class="nctnt ncbi-var">$(builddir) </span>- a path to the build directory specified in the last argument to the above script - <span class="nctnt ncbi-var">$(srcdir) </span>- the path to your current working directory (".") - <span class="nctnt ncbi-var">$(APP) </span>- the application name - <span class="nctnt ncbi-var">$(OBJ) </span>- the names of the object modules to build and link to the application - <span class="nctnt ncbi-var">$(LIB)</span> - specific libraries to link to in the NCBI C++ Toolkit - <span class="nctnt ncbi-var">$(LIBS) </span>- all other libraries to link to (outside the C++ Toolkit)</p><p><span class="nctnt ncbi-path">$(builddir)/lib</span> specifies the library path (-L), which in this case points to the GNU debug versions of the NCBI C++ Toolkit libraries. $(LIB) lists the individual libraries in this path that you will be linking to. Minimally, this should include <span class="nctnt ncbi-path">xncbi</span> - the library which implements the foundational classes for the C++ tools. Additional library names (e.g. <span class="nctnt ncbi-path">xhtml, xcgi, </span>etc.) can be added here.</p><p>Since the shell script assumes you will be building a single executable with the same name as your working directory, the application is defined simply as <span class="nctnt ncbi-app">NewProj</span>. Additional targets to build can be added in the area indicated towards the end of the file. The list of objects (OBJ) should include the names (without extensions) of all source files for the application (APP). Again, the script makes the simplest assumption, i.e. that there is a single source file named <span class="nctnt ncbi-path">NewProj.cpp</span>. Additional source names can be added here.</p></div><div class="sec" id="ch_proj.outside_testing"><h4><span class="title">Testing your setup</span></h4><p>For a very simple application, this makefile is ready to be run. Try it out now, by creating the file <span class="nctnt ncbi-path">NewProj.cpp</span>:</p><pre><span class="nctnt-pre ncbi-code">// File name: NewProj.cpp<br />#include &lt;iostream&gt;<br />using namespace std;<br />int main() {<br />cout &lt;&lt; "Hello again, world" &lt;&lt; endl;<br />}</span></pre><p>and running:</p><pre><span class="nctnt-pre ncbi-code">make -f Makefile.NewProj_app</span></pre><p>Of course, it wasn't necessary to set up the directories and makefiles to accomplish this much, as this example does not use any of the C++ classes or resources defined in the NCBI C++ Toolkit. But having accomplished this, you are now prepared to write an actual application, such as described in <a href="ch_core.html#ch_core.writing_simple_app">Writing a simple application project</a></p><p>Most real applications will at a minimum, require that you <span class="nctnt ncbi-code">#include </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/corelib/ncbistd.hpp">ncbistd.hpp</a> in your header file. In addition to defining some basic NCBI C++ Toolkit objects and templates, this header file in turn includes other header files that define the C Toolkit data types, NCBI namespaces, debugging macros, and exception classes. A set of <a href="ch_proj.html#ch_proj.new_modules">template</a> files are also provided for your use in developing new applications.</p></div></div><div class="sec" id="ch_proj.work_sub_tree"><h3><span class="title">Working Independently In a C++ Subtree</span></h3><p>An alternative to developing a new project from scratch is to work within a subtree of the main NCBI C++ source tree so as to utilize the header, source, and make files defined for that subtree. One way to do this would be to check out the entire source tree and then do all your work within the selected subtree(s) only. A better solution is to create a new working directory and check out only the relevant subtrees into that directory. This is somewhat complicated by the distributed organization of the C++ SVN tree: header files are (recursively) contained in an <span class="nctnt ncbi-path">include</span> subtree, while source files are (recursively) contained in a <span class="nctnt ncbi-path">src</span> subtree. Thus, multiple checkouts may be required to set things up properly, and the customized makefiles (<span class="nctnt ncbi-path">Makefile.*.app</span>) will need to be modified. The shell script <a href="ch_getcode_svn.html#ch_getcode_svn.import_project_sh">import_project</a> will do all of this for you. The syntax is:</p><pre><span class="nctnt-pre ncbi-cmd">import_project subtree_name [builddir]</span></pre><p>where: - <span class="nctnt ncbi-var">subtree</span> is the path to a selected directory inside <span class="nctnt ncbi-path">internal/c++/src/</span> - <span class="nctnt ncbi-var">builddir</span> (optional) specifies what version of the pre-built NCBI C++ Toolkit libraries to link to</p><p>As a result of executing this shell script, you will have a new directory created with the pathname <span class="nctnt ncbi-path">./internal/c++/</span> whose structure contains "slices" of the original SVN tree. Specifically, you will find:</p><pre><span class="nctnt-pre ncbi-path">./internal/c++/include/subtree_name<br />./internal/c++/src/subtree_name</span></pre><p>The <span class="nctnt ncbi-path">src</span> and <span class="nctnt ncbi-path">include</span> directories will contain all of the requested subtree's source and header files along with any hierarchically defined subdirectories. In addition, the script will create new makefiles with the suffix <i>*_app</i>. These makefiles are generated from the original <a href="ch_proj.html#ch_proj.make_proj_app">customized makefiles</a> (<span class="nctnt ncbi-path">Makefile.*.app</span>) located in the original <span class="nctnt ncbi-path">src</span> subtrees. The customized makefiles were designed to work only in conjunction with the build directories in the larger NCBI C++ tree; the newly created makefiles can be used directly in your new working directories.</p><p>The NCBI C++ Toolkit project directories, along with the libraries they implement and the logical modules they entail, are summarized in the <a href="part3.html">Library Reference</a>.</p><p>Two project directories, <span class="nctnt ncbi-path">internal </span>and <span class="nctnt ncbi-path">objects</span>, are not intended for general use, and the mechanisms in the <a href="ch_getcode_svn.html#ch_getcode_svn.import_project_sh">import_project</a> script for generating makefiles are not guaranteed to work for these. The <span class="nctnt ncbi-path">objects</span> subdirectories are used as the original repositories for ASN.1 specifications, and subsequently, for writing the object definitions and implementations created by the <span class="nctnt ncbi-app">datatool</span> program. These definitions are available for use in your application as described in the section <a href="ch_ser.html#ch_ser.asn.html">Processing ASN.1 Data</a>. The <span class="nctnt ncbi-path">internal </span>subdirectory is used for in-house development, and is the recommended work area for new projects.</p></div><div class="sec" id="ch_proj.inside_tree"><h3><span class="title">Working within the C++ source tree</span></h3><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_proj.html#ch_proj.inside_checkout">Checkout the source tree and configure a build directory</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_makefiles">The project's directories and makefiles</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_make_meta">Makefile.in meta files</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_example">An example meta-makefile and its associated project makefiles</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_make_exec">Executing make</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_cust_make">Custom project makefile: Makefile.myProj</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_lib_make">Library project makefile: Makefile.myProj.lib</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_app_make">Application project makefile: Makefile.myProj.app</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_tests">Definition and running tests</a></p></li><li><p><a href="ch_proj.html#ch_proj.inside_config">The configure scripts</a></p></li></ul><p>Most users will find that working in a <span class="nctnt ncbi-monospace">checked-out</span> subtree or a private directory is preferable to working directly in the C++ source tree. There are two good reasons to avoid doing so:</p><ul><li><p>Building your own versions of the extensive libraries can be very time-consuming.</p></li><li><p>There is no guarantee that the library utilities your private code links to have not become obsolete.</p></li></ul><p>This section is provided for those developers who must work within the source tree. The <a href="part3.html">Library Reference</a> provides more complete and technical discussion of the topics reviewed here, and many links to the relevant sections are provided. This page is provided as an overview of material presented in the Library Reference and on the <a href="ch_build.html">Working with Makefiles</a> pages.</p><div class="sec" id="ch_proj.inside_checkout"><h4><span class="title">Checkout (<a href="ch_getcode_svn.html#ch_getcode_svn.source_tree">*</a>) the source tree and configure a build directory</span></h4><p>To checkout full Toolkit tree:</p><p><span class="nctnt ncbi-cmd">svn co https://svn.ncbi.nlm.nih.gov/repos/toolkit/trunk/internal/c++ c++</span></p><p>or, if you don't need internal projects:</p><p><span class="nctnt ncbi-cmd">svn co https://svn.ncbi.nlm.nih.gov/repos/toolkit/trunk/c++ c++</span></p><p>Once you have done so, you will need to run one of the <span class="nctnt ncbi-app">configure</span> scripts in the Toolkit's root directory. For example, to configure your environment to work with the <span class="nctnt ncbi-app">gcc</span> compiler (on any platform), just run: <span class="nctnt ncbi-app">./configure</span>.</p><p>Users working under Windows should consult the <a href="ch_config.html#ch_config.MS_Windows">MS Visual C++</a> section in the chapter on <a href="ch_config.html">Configuring and Building the Toolkit</a>.</p><p>The <a href="ch_config.html#ch_config.Configuration_and_In">configure script</a> is a multi-platform configuration shell script (generated from <span class="nctnt ncbi-path">configure.in</span> using <span class="nctnt ncbi-app">autoconf</span>). Here are some pointers to sections that will help you configure the build environment:</p><ul><li><p><a href="ch_config.html#ch_config.Special_Consideratio">Wrapper scripts</a> supporting various platforms</p></li><li><p><a href="ch_config.html#ch_config.Running_the_configur">Optional configuration flags</a></p></li></ul><p>The <span class="nctnt ncbi-app">configure</span> script concludes with a message describing how to build the C++ Toolkit libraries. If your application will be working with ASN.1 data, use the <span class="nctnt ncbi-cmd">--with-objects</span> flag in running the <span class="nctnt ncbi-app">configure</span> script, so as to populate the <span class="nctnt ncbi-path">include/objects</span> and <span class="nctnt ncbi-path">src/objects</span> subdirectories and build the <span class="nctnt ncbi-path">objects</span> libraries. The <span class="nctnt ncbi-path">objects</span> directories and libraries can also be updated separately from the rest of the compilation, by executing <span class="nctnt ncbi-app">make</span> inside the <span class="nctnt ncbi-path">build/objects</span> directory. Prior to doing so however, you should always verify that your <span class="nctnt ncbi-path">build/bin</span> directory contains the latest version of <span class="nctnt ncbi-app">datatool</span>.</p></div><div class="sec" id="ch_proj.inside_makefiles"><h4><span class="title">The project's directories and makefiles</span></h4><p>To start a new project ("<span class="nctnt ncbi-path">myProj</span>"), you should begin by creating both a <span class="nctnt ncbi-path">src</span> and an <span class="nctnt ncbi-path">include</span> subtree for that project inside the C++ tree. In general, all header files that will be accessed by multiple source modules outside the project directory should be placed in the <span class="nctnt ncbi-path">include</span> directory. Header files that will be used solely inside the project's <span class="nctnt ncbi-path">src</span> directory should be placed in the <span class="nctnt ncbi-path">src</span> directory, along with the implementation files.</p><p>In addition to the C++ source files, the <span class="nctnt ncbi-path">src</span> subtrees contain <span class="nctnt ncbi-monospace">meta-makefiles</span> named <span class="nctnt ncbi-path">Makefile.in</span>, which are used by the <span class="nctnt ncbi-app">configure</span> script to generate the corresponding makefiles in the <span class="nctnt ncbi-path">build</span> subtrees. Figure 1 shows slices of the directory structure reflecting the correspondences between the <span class="nctnt ncbi-monospace">meta-makefiles</span> in the <span class="nctnt ncbi-path">src</span> subtrees and makefiles in the <span class="nctnt ncbi-path">build</span> subtrees. Figure 2 is a sketch of the entire C++ tree in which these directories are defined.</p><p>During the configuration process, each of the <span class="nctnt ncbi-monospace">meta-makefiles</span> in the top-level of the <span class="nctnt ncbi-path">src</span> tree is translated into a corresponding makefile in the top-level of the <span class="nctnt ncbi-path">build</span> tree. Then, for each project directory containing a <span class="nctnt ncbi-path">Makefile.in</span>, the <span class="nctnt ncbi-app">configure</span> script will: (1) create a corresponding subdirectory of the same name in the <span class="nctnt ncbi-path">build</span> tree if it does not already exist, and (2) generate a corresponding makefile in the project's <span class="nctnt ncbi-path">build</span> subdirectory. The contents of the project's <span class="nctnt ncbi-path">Makefile.in</span> in the <span class="nctnt ncbi-path">src</span> subdirectory determine what is written to the project's makefile in the <span class="nctnt ncbi-path">build</span> subdirectory. Project subdirectories that do not contain a <span class="nctnt ncbi-path">Makefile.in</span> file are ignored by the <span class="nctnt ncbi-app">configure</span> script.</p><p>Thus, you will also need to create a <span class="nctnt ncbi-monospace">meta-makefile</span> in the newly created <span class="nctnt ncbi-path">src/myProj</span> directory before configuring your <span class="nctnt ncbi-path">build</span> directory to include the new project. The <span class="nctnt ncbi-app">configure</span> script will then create the corresponding subtree in the <span class="nctnt ncbi-path">build</span> directory, along with a new makefile generated from the <span class="nctnt ncbi-path">Makefile.in</span> you created. See Makefile Hierarchy (Chapter 4, <a href="ch_build.html#ch_build.F1">Figure 1</a>) and <a href="ch_proj.html#ch_proj.F1">Figure 1</a>.</p><div class="figure" id="ch_proj.F1"><div class="graphic"><img src="img/cpptree.jpg" alt="Figure 1. Meta makefiles and the makefiles they generate" /></div><div class="caption"><p>Figure 1. Meta makefiles and the makefiles they generate</p></div></div></div><div class="sec" id="ch_proj.inside_make_meta"><h4><span class="title">Makefile.in meta files</span></h4><p>The meta-makefile <span class="nctnt ncbi-path">myProj/Makefile.in</span> should define at least one of the following macros:</p><ul><li><p><span class="nctnt ncbi-var">USR_PROJ</span> (optional) - a list of names for user-defined makefiles.<br />This macro is provided for the usage of ordinary stand-alone makefiles which do not utilize the <span class="nctnt ncbi-app">make</span> commands contained in additional makefiles in the top-level <span class="nctnt ncbi-path">build</span> directory. Each <span class="nctnt ncbi-monospace">p_i</span> listed in <span class="nctnt ncbi-monospace">USR_PROJ = p_1 ... p_N</span> must have a corresponding <a href="ch_proj.html#ch_proj.inside_cust_make">Makefile.p_i</a> in the project's source directory. When <span class="nctnt ncbi-app">make</span> is executed, the <span class="nctnt ncbi-app">make</span> directives contained in these files will be executed directly to build the targets as specified.</p></li><li><p><span class="nctnt ncbi-var">LIB_PROJ</span> (optional) - a list of names for library makefiles.<br />For each library <span class="nctnt ncbi-monospace">l_i</span> listed in <span class="nctnt ncbi-monospace">LIB_PROJ = l_1 ... l_N</span>, you must have created a corresponding project makefile named <a href="ch_proj.html#ch_proj.inside_lib_make">Makefile.l_i.lib</a> in the project's source directory. When <span class="nctnt ncbi-app">make</span> is executed, these library project makefiles will be used along with <span class="nctnt ncbi-path">Makefile.lib</span> and <span class="nctnt ncbi-path">Makefile.lib.tmpl</span> (located in the top-level of the <span class="nctnt ncbi-path">build</span> tree) to build the specified libraries.</p></li><li><p><span class="nctnt ncbi-var">APP_PROJ</span> (optional) - a list of names for application makefiles.<br />Similarly, each application (<span class="nctnt ncbi-monospace">p1, p2, ..., pN</span>) listed under <span class="nctnt ncbi-var">APP_PROJ</span> must have a corresponding project makefile named <a href="ch_proj.html#ch_proj.inside_app_make">Makefile.p*.app</a> in the project's source directory. When <span class="nctnt ncbi-app">make</span> is executed, these application project makefiles will be used along with <span class="nctnt ncbi-path">Makefile.app</span> and <span class="nctnt ncbi-path">Makefile.app.tmpl</span> to build the specified executables.</p></li><li><p><span class="nctnt ncbi-var">SUB_PROJ</span> (optional) - a list of names for subproject directories (used on recursive makes).<br />The <span class="nctnt ncbi-var">SUB_PROJ</span> macro is used to recursively define <span class="nctnt ncbi-app">make</span> targets; items listed here define the subdirectories rooted in the project's source directory where <span class="nctnt ncbi-app">make</span> should also be executed.</p></li></ul><p>The <span class="nctnt ncbi-path">Makefile.in</span> meta file in the project's source directory defines a kind of road map that will be used by the <span class="nctnt ncbi-app">configure</span> script to generate a makefile (<span class="nctnt ncbi-path">Makefile</span>) in the corresponding directory of the <span class="nctnt ncbi-path">build</span> tree. <span class="nctnt ncbi-path">Makefile.in</span> does <i>not</i> participate in the actual execution of <span class="nctnt ncbi-app">make</span>, but rather, defines what will happen at that time by directing the <span class="nctnt ncbi-app">configure</span> script in the creation of the <span class="nctnt ncbi-path">Makefile</span> that <b>will</b> be executed (see also the description of <a href="ch_build.html#ch_build.std_build_targets">Makefile targets</a>).</p></div><div class="sec" id="ch_proj.inside_example"><h4><span class="title">An example meta-makefile and its associated project makefiles</span></h4><p>A simple example should help to make this more concrete. Assuming that <span class="nctnt ncbi-path">myProj</span> is used to develop an application named <span class="nctnt ncbi-path">myProj</span>, <span class="nctnt ncbi-path">myProj/Makefile.in</span> should contain the following:</p><pre><span class="nctnt-pre ncbi-code">####### Example: src/myProj/Makefile.in<br />APP_PROJ = myProj<br />srcdir = @srcdir@<br />include @builddir@/Makefile.meta</span></pre><p>The last two lines in <span class="nctnt ncbi-path">Makefile.in</span> should always be exactly as shown here. These two lines specify <span class="nctnt ncbi-app">make</span> variable templates using the <span class="nctnt ncbi-var">@var_name@</span> syntax. When generating the corresponding makefile in the <span class="nctnt ncbi-path">build</span> directory, the <span class="nctnt ncbi-app">configure</span> script will substitute each identifier name bearing that notation with full path definitions.</p><p>The corresponding makefile in <span class="nctnt ncbi-path">build/myProj</span> generated by the <span class="nctnt ncbi-app">configure</span> script for this example will then contain:</p><pre><span class="nctnt-pre ncbi-code">####### Example: myBuild/build/myProj/Makefile<br /># Generated automatically from Makefile.in by configure.<br />APP_PROJ = myProj<br />srcdir = /home/zimmerma/internal/c++/src/myProj<br />include /home/zimmerma/internal/c++/myBuild/build/Makefile.meta</span></pre><p>As demonstrated in this example, the <span class="nctnt ncbi-var">@srcdir@</span> and <span class="nctnt ncbi-var">@builddir@</span> aliases in the makefile template have been replaced with absolute paths in the generated makefile, while the definition of <span class="nctnt ncbi-var">APP_PROJ</span> is copied verbatim.</p><p>The only build target in this example is <span class="nctnt ncbi-path">myProj</span>. <span class="nctnt ncbi-path">myProj</span> is specified as an application - not a library - because it is listed under <span class="nctnt ncbi-var">APP_PROJ</span> rather than under <span class="nctnt ncbi-var">LIB_PROJ</span>. Accordingly, there must also be a file named <span class="nctnt ncbi-path">Makefile.myProj.app</span> in the <span class="nctnt ncbi-path">src/myProj</span> directory. A project's application makefile specifies:</p><ul><li><p><span class="nctnt ncbi-var">APP</span> - the name to be used for the resulting executable</p></li><li><p><span class="nctnt ncbi-var">OBJ</span> - a list of object files to use in the compilation</p></li><li><p><span class="nctnt ncbi-var">LIB</span> - a list of NCBI C++ Toolkit libraries to use in the linking</p></li><li><p><span class="nctnt ncbi-var">LIBS</span> - a list of other libraries to use in the linking</p></li></ul><p>There may be any number of application or library makefiles for the project, Each application should be listed under <span class="nctnt ncbi-var">APP_PROJ</span> and each library should be listed under <span class="nctnt ncbi-var">LIB_PROJ</span> in <span class="nctnt ncbi-path">Makefile.in</span>. A suitable application makefile for this simple example might contain just the following text:</p><pre><span class="nctnt-pre ncbi-code">####### Example: src/myProj/Makefile.myProj.app<br />APP = myProj<br />OBJ = myProj<br />LIB = xncbi</span></pre><p>In this simple example, the <span class="nctnt ncbi-var">APP_PROJ</span> definition in <span class="nctnt ncbi-path">Makefile.in</span> is identical to the definitions of both <span class="nctnt ncbi-var">APP</span> and <span class="nctnt ncbi-var">OBJ</span> in <span class="nctnt ncbi-path">Makefile.myProj.app</span>. This is not always the case, however, as the <span class="nctnt ncbi-var">APP_PROJ</span> macro is used to define which makefiles in the <span class="nctnt ncbi-path">src</span> directory should be used during compilation, while <span class="nctnt ncbi-var">APP</span> defines the name of the resulting executable and <span class="nctnt ncbi-var">OBJ</span> specifies the names of object files. (Project makefiles for applications are described in more detail <a href="ch_proj.html#ch_proj.inside_app_make">below</a>.)</p></div><div class="sec" id="ch_proj.inside_make_exec"><h4><span class="title">Executing make</span></h4><p>Given these makefile definitions, executing <span class="nctnt ncbi-cmd">make all_r</span> in the <span class="nctnt ncbi-path">build</span> project subdirectory indirectly causes <span class="nctnt ncbi-path">build/Makefile.meta</span> to be executed, which sets the following chain of events in motion:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">For each <span class="nctnt ncbi-path">proj_name</span> listed in <a href="ch_proj.html#ch_proj.inside_make_meta">USR_PROJ</a>, <span class="nctnt ncbi-path">Makefile.meta</span> first tests to see if <span class="nctnt ncbi-path">Makefile.proj_name</span> is available in the current <span class="nctnt ncbi-path">build</span> directory, and if so, executes:<br /><br /><span class="nctnt ncbi-cmd">make -f Makefile.proj_name builddir="$(builddir)"</span><br /><span class="nctnt ncbi-cmd">srcdir="$(srcdir)" $(MFLAGS)</span><br /><br />Otherwise, <span class="nctnt ncbi-path">Makefile.meta</span> assumes the required makefile is in the project's source directory, and executes:<br /><br /><span class="nctnt ncbi-cmd">make -f $(srcdir)/Makefile.proj_name builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS)</span><br /><br />In either case, the important thing to note here is that the commands contained in the project's makefiles are executed directly and are <b>not</b> combined with additional makefiles in the top-level <span class="nctnt ncbi-path">build</span> directory. The aliased <span class="nctnt ncbi-var">srcdir</span>, <span class="nctnt ncbi-var">builddir</span>, and <span class="nctnt ncbi-var">MFLAGS</span> are still available and can be referred to inside <span class="nctnt ncbi-path">Makefile.proj_name</span>. By default, the resulting libraries and executables are written to the <span class="nctnt ncbi-path">build</span> directory only.<br /></p></dd><dt>2</dt><dd><p class="no_top_margin">For each <span class="nctnt ncbi-lib">lib_name</span> listed in <a href="ch_proj.html#ch_proj.inside_make_meta">LIB_PROJ</a>,<br /><br /><span class="nctnt ncbi-cmd">make -f $(builddir)/Makefile.lib.tmpl</span><br /><br />is executed. This in turn specifies that <span class="nctnt ncbi-path">$(builddir)/Makefile.mk</span>, <span class="nctnt ncbi-path">$(srcdir)/Makefile.lib_name.lib</span>, and <span class="nctnt ncbi-path">$(builddir)/Makefile.lib</span> should be included in the generated makefile commands that actually get executed. The resulting libraries are written to the <span class="nctnt ncbi-path">build</span> subdirectory and copied to the <span class="nctnt ncbi-path">lib</span> subtree.</p></dd><dt>3</dt><dd><p class="no_top_margin">For each <span class="nctnt ncbi-app">app_name</span> listed in <a href="ch_proj.html#ch_proj.inside_make_meta">APP_PROJ</a>,<br /><br /><span class="nctnt ncbi-cmd">make -f $(builddir)/Makefile.app.tmpl</span><br /><br />is executed. This in turn specifies that <span class="nctnt ncbi-path">$(builddir)/Makefile.mk</span>, <span class="nctnt ncbi-path">$(srcdir)/Makefile.app_name.app</span>, and <span class="nctnt ncbi-path">$(builddir)/Makefile.app</span> should be included in the generated makefile commands that actually get executed. The resulting executables are written to the <span class="nctnt ncbi-path">build</span> subdirectory and copied to the <span class="nctnt ncbi-path">bin</span> subtree.</p></dd><dt>4</dt><dd><p class="no_top_margin">For each <span class="nctnt ncbi-path">dir_name</span> listed in <a href="ch_proj.html#ch_proj.inside_make_meta">SUB_PROJ</a> (on <span class="nctnt ncbi-cmd">make all_r</span>),<br /><br /><span class="nctnt ncbi-cmd">cd dir_name</span><br /><span class="nctnt ncbi-cmd">make all_r</span><br /><br />is executed. Steps (1) - (3) are then repeated in the project subdirectory.</p></dd></dl><p>More generally, for each subdirectory listed in <span class="nctnt ncbi-var">SUB_PROJ</span>, the <span class="nctnt ncbi-app">configure</span> script will create a relative subdirectory inside the new <span class="nctnt ncbi-path">build</span> project directory, and generate the new subdirectory's <span class="nctnt ncbi-path">Makefile</span> from the corresponding meta-makefile in the <span class="nctnt ncbi-path">src</span> subtree. Note that each subproject directory must also contain its own <span class="nctnt ncbi-path">Makefile.in</span> along with the corresponding project makefiles. The recursive make commands, <span class="nctnt ncbi-cmd">make all_r, make clean_r</span>, and <span class="nctnt ncbi-cmd">make purge_r</span> all refer to this definition of the subprojects to define what targets should be recursively built or removed.</p></div><div class="sec" id="ch_proj.inside_cust_make"><h4><span class="title">Custom project makefile: Makefile.myProj (<a href="ch_proj.html#ch_proj.usr_def_makefile">*</a>)</span></h4><p>As described, regular makefiles contained in the project's <span class="nctnt ncbi-path">src</span> directory will be invoked from the <span class="nctnt ncbi-path">build</span> directory if their suffixes are specified in the <span class="nctnt ncbi-var">USR_PROJ</span> macro. This macro is originally defined in the project's <span class="nctnt ncbi-path">src</span> directory in the <span class="nctnt ncbi-path">Makefile.in</span> meta file, and is propagated to the corresponding <span class="nctnt ncbi-path">Makefile</span> in the <span class="nctnt ncbi-path">build</span> directory by the <span class="nctnt ncbi-app">configure</span> script.</p><p>For example, if <span class="nctnt ncbi-monospace">USR_PROJ = myProj</span> in the <span class="nctnt ncbi-path">build</span> directory's <span class="nctnt ncbi-path">Makefile</span>, executing <span class="nctnt ncbi-app">make</span> will cause <span class="nctnt ncbi-path">Makefile.myProj</span> (the project makefile) to be executed. This project makefile may be located in either the current <span class="nctnt ncbi-path">build</span> directory <b>or</b> the corresponding <span class="nctnt ncbi-path">src</span> directory. In either case, although the makefile is executed directly, references to the source or object files (contained in the project makefile) must give complete paths to those files. In the first case, <span class="nctnt ncbi-app">make</span> is invoked as: <span class="nctnt ncbi-cmd">make -f Makefile.myProj</span>, so the makefile is located in the current working (<span class="nctnt ncbi-path">build</span>) directory but the source files are not. In the second case, <span class="nctnt ncbi-app">make</span> is invoked as:</p><p><span class="nctnt ncbi-cmd">make -f $(srcdir)/Makefile.myProj</span>,</p><p>so both the project makefile <b>and</b> the source files are non-local. For example:</p><pre><span class="nctnt-pre ncbi-code">####### Makefile.myProj<br />include $(NCBI)/ncbi.mk<br /># use the NCBI default compiler for this platform<br />CC = $(NCBI_CC)<br /># along with the default include<br />INCPATH = $(NCBI_INCDIR)<br /># and library paths<br />LIBPATH = $(NCBI_LIBDIR)<br />all: $(srcdir)/myProj.c<br />    $(CC) -o myProj $(srcdir)/myProj.c $(NCBI_CFLAGS) -I($INCPATH) \<br />    -L($LIBPATH) -lncbi<br />    cp -p myProj $(builddir)/bin<br />clean:<br />    -rm  myProj myProj.o<br />purge: clean<br />    -rm  $(builddir)/bin/myProj</span></pre><p>will cause the C program <span class="nctnt ncbi-path">myProj</span> to be built directly from <span class="nctnt ncbi-path">Makefile.myProj</span> using the default C compiler, library paths, include paths, and compilation flags defined in <span class="nctnt ncbi-path">ncbi.mk</span>. The executables and libraries generated from the targets specified in <span class="nctnt ncbi-var">USR_PROJ</span> are by default written to the current <span class="nctnt ncbi-path">build</span> directory only. In this example however, they are also explicitly copied to the <span class="nctnt ncbi-path">bin</span> directory, and accordingly, the <span class="nctnt ncbi-cmd">purge</span> directives also remove the copied executable.</p></div><div class="sec" id="ch_proj.inside_lib_make"><h4><span class="title">Library project makefile: Makefile.myProj.lib (<a href="ch_proj.html#ch_proj.make_proj_lib">*</a>)</span></h4><p><span class="nctnt ncbi-path">Makefile.lib_name.lib</span> should contain the following macro definitions:</p><ul><li><p><span class="nctnt ncbi-var">$(SRC)</span> - the names of all source files to compile and include in the library</p></li><li><p><span class="nctnt ncbi-var">$(OBJ)</span> - the names of any pre-compiled object files to include in the library</p></li><li><p><span class="nctnt ncbi-var">$(LIB)</span> - the name of the library being built</p></li></ul><p>In addition, any of the make variables defined in <span class="nctnt ncbi-path">build/Makefile.mk</span>, such as <span class="nctnt ncbi-var">$CPPFLAGS</span>, <span class="nctnt ncbi-var">$LINK</span>, etc., can be referred to and/or redefined in the project makefile, e.g.:</p><pre><span class="nctnt-pre ncbi-code">CFLAGS   = $(ORIG_CFLAGS)   -abc -DFOOBAR_NOT_CPLUSPLUS<br />CXXFLAGS = $(ORIG_CXXFLAGS) -xyz<br />CPPFLAGS = $(ORIG_CPPFLAGS) -UFOO -DP1_PROJECT -I$(NCBI_C_INCLUDE)<br />LINK     = purify $(ORIG_LINK)</span></pre><p>For an example from the Toolkit, see <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/corelib/Makefile.corelib.lib">Makefile.corelib.lib</a>, and for a documented example, see <a href="ch_proj.html#ch_proj.make_proj_lib">example 1 above</a>. This customized makefile can be used to build both static and dynamic (DLL) versions of the library. To build as a DLL on the appropriate platforms, you can explicitly specify:</p><pre><span class="nctnt-pre ncbi-code">LIB_OR_DLL = dll</span></pre><p>Conversely, if you want the library to always be built as static, specify:</p><pre><span class="nctnt-pre ncbi-code">LIB_OR_DLL = lib</span></pre></div><div class="sec" id="ch_proj.inside_app_make"><h4><span class="title">Application project makefile: Makefile.myProj.app (<a href="ch_proj.html#ch_proj.make_proj_app">*</a>)</span></h4><p><span class="nctnt ncbi-path">Makefile.app_name.app</span> should contain the following macro definitions:</p><ul><li><p><span class="nctnt ncbi-var">$(SRC)</span> - the names of the object modules to build and link to the application</p></li><li><p><span class="nctnt ncbi-var">$(OBJ)</span> - the names of any pre-compiled object files to include in the linking</p></li><li><p><span class="nctnt ncbi-var">$(LIB)</span> - specific libraries in the NCBI C++ Toolkit to include in the linking</p></li><li><p><span class="nctnt ncbi-var">$(LIBS)</span> - all other libraries to link to (outside the C++ Toolkit)</p></li><li><p><span class="nctnt ncbi-var">$(APP)</span> - the name of the application being built</p></li></ul><p>For example, if C Toolkit libraries should also be included in the linking, use:</p><pre><span class="nctnt-pre ncbi-code">LIBS = $(NCBI_C_LIBPATH) -lncbi $(ORIG_LIBS)</span></pre><p>The project's application makefile can also redefine the compiler and linker, along with other flags and tools affecting the build process, as described above for <span class="nctnt ncbi-path">Makefile.*.lib</span> files. For an example from the Toolkit, see <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/corelib/test/Makefile.coretest.app">Makefile.coretest.app</a>, and for a documented example, see <a href="ch_proj.html#ch_proj.make_proj_app">example 2 above</a>.</p></div><div class="sec" id="ch_proj.inside_tests"><h4><span class="title">Definition and running tests</span></h4><p>To include an application into the testsuite it is necessary to add just one line into its makefile <span class="nctnt ncbi-path">Makefile.app_name.app</span>:</p><pre><span class="nctnt-pre ncbi-code">CHECK_CMD =</span></pre><p>or</p><pre><span class="nctnt-pre ncbi-code">CHECK_CMD = command line to run application test</span></pre><p>If command line is not specified that a program which specified by makefiles' variable <span class="nctnt ncbi-var">$(APP)</span> will be executed (without any parameters).</p><p>If there are files (such as a script or data) that you will need around, set <span class="nctnt ncbi-var">$(CHECK_COPY)</span> to point to them:</p><pre><span class="nctnt-pre ncbi-code">CHECK_COPY = file1 file2 dir1 dir2</span></pre><p>All specified files and directories will be copied to the build or special check directory (depends from platform) before running tests. One of the copied files can be, for example, a shell script which specified in the command line of <span class="nctnt ncbi-var">$(CHECK_CMD)</span>. Note that all paths to copied files and directories must be relative from the applications' source directory.</p><p>By default the applications' execution time is limited by 200 seconds. You can set the new limit using next line:</p><pre><span class="nctnt-pre ncbi-code">CHECK_TIMEOUT = &lt;time in seconds&gt;</span></pre><p>If application continues execution after specified time, it will be terminated and test marked as FAILED.</p><p>If you'd like to get nightly test results automatically emailed to you, add your email address to the <span class="nctnt ncbi-macro">WATCHERS</span> macro in the makefile. Note that the <span class="nctnt ncbi-macro">WATCHERS</span> macro has replaced the <span class="nctnt ncbi-macro">CHECK_AUTHORS</span> macro which had a similar purpose.</p></div><div class="sec" id="ch_proj.inside_config"><h4><span class="title">The configure scripts</span></h4><p>A number of <a href="ch_config.html#ch_config.Special_Consideratio">compiler-specific wrappers</a> for different platforms are described in the chapter on <a href="ch_config.html">configuring and building</a>. Each of these wrappers performs some pre-initialization for the tools and flags used in the <span class="nctnt ncbi-app">configure</span> script before running it. The compiler-specific wrappers are in the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/compilers">c++/compilers</a> directory. The <span class="nctnt ncbi-app">configure</span> script serves two very different types of function: (1) it tests the selected compiler and environment for a multitude of features and generates <span class="nctnt ncbi-code">#include</span> and <span class="nctnt ncbi-code">#define</span> statements accordingly, and (2) it reads the <span class="nctnt ncbi-path">Makefile.in</span> files in the <span class="nctnt ncbi-path">src</span> directories and creates the corresponding <span class="nctnt ncbi-path">build</span> subtrees and makefiles accordingly.</p><p>Frequently during development it is necessary to make minor adjustments to the <span class="nctnt ncbi-path">Makefile.in</span> files, such as adding new projects or subprojects to the list of targets. In these contexts however, the compiler, environment, and source directory structures remain unchanged, and <span class="nctnt ncbi-app">configure</span> is actually doing much more work than is necessary. In fact, there is even some risk of failing to re-create the same configuration environment if the user does not exactly duplicate the same set of configure flags when re-running <span class="nctnt ncbi-app">configure</span>. In these situations, it is preferable to run an auxiliary script named <a href="ch_config.html#ch_config.ch_configpre_built_h">config.status</a>, located at the top level of the <span class="nctnt ncbi-path">build</span> directory in a subdirectory named <span class="nctnt ncbi-path">status</span>.</p><p>In contrast, changes to the <span class="nctnt ncbi-path">src</span> directory structure, or the addition/deletion of <span class="nctnt ncbi-path">Makefile.in</span> files, all require re-running the <span class="nctnt ncbi-app">configure</span> script, as these actions require the creation/deletion of subdirectories in the <span class="nctnt ncbi-path">build</span> tree and/or the creation/deletion of the associated <span class="nctnt ncbi-path">Makefile</span> in those directories.</p></div></div><div class="sec" id="ch_proj.ser_object"><h3><span class="title">Working with the serializable object classes</span></h3><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_proj.html#ch_proj.ser_objects_intro">Serializable Objects</a></p></li><li><p><a href="ch_proj.html#ch_proj.locate_ser_objects">Locating and browsing serializable objects in the C++ Toolkit</a></p></li><li><p><a href="ch_proj.html#ch_proj.base_classes">Base classes and user classes</a></p></li><li><p><a href="ch_proj.html#ch_proj.add_to_usr_classes">Adding methods to the user classes</a></p><ul><li><p><a href="ch_proj.html#ch_proj.src_code_work_env">Checking out source code, configuring the working environment, building the libraries</a></p></li><li><p><a href="ch_proj.html#ch_proj.proj_add_methods">Adding methods</a></p></li></ul></li></ul><div class="sec" id="ch_proj.ser_objects_intro"><h4><span class="title">Serializable Objects</span></h4><p>All of the ASN.1 data types defined in the C Toolkit have been re-implemented in the C++ Toolkit as serializable objects. Header files for these classes can be found in the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects">include/objects</a> directories, and their implementations are located in the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects">src/objects</a> directories. and</p><p>The implementation of these classes as serializable objects has a number of implications. It must be possible to use expressions like: <span class="nctnt ncbi-code">instream &gt;&gt; myObject</span> and <span class="nctnt ncbi-code">outstream &lt;&lt; myObject, </span>where specializations are entailed for the <span class="nctnt ncbi-monospace">serial format</span> of the iostreams (ASN.1, XML, etc.), as well as for the internal structure of the object. The C++ Toolkit deploys several <a href="ch_ser.html#ch_ser.objstream.html">object stream classes</a> that specialize in various formats, and which know how to access and apply the <a href="ch_ser.html#ch_ser.typeinfo.html">type information </a>that is associated with the serializable object.</p><p>The type information for each class is defined in a separate static <a href="ch_ser.html#ch_ser.typeinfo.html_ctypeinfo_ref">CTypeInfo</a> object, which can be accessed by all instances of that class. This is a very powerful device, which allows for the implementation of many features generally found only in languages which have built-in class reflection. Using the Toolkit's serializable objects will require some familiarity with the usage of this type information, and several sections of this manual cover these topics (see <a href="ch_ser.html#ch_ser.typeinfo.html">Runtime Object Type Information</a> for a general discussion).</p></div><div class="sec" id="ch_proj.locate_ser_objects"><h4><span class="title">Locating and browsing serializable objects in the C++ Toolkit</span></h4><p>The top level of the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects">include/objects</a> subtree is a set of subdirectories, where each subdirectory includes the public header files for a separately compiled library. Similarly, the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects">src/objects</a> subtree includes a set of subtrees containing the source files for these libraries. Finally, your <span class="nctnt ncbi-path">build/objects</span> directory will contain a corresponding set of build subtrees where these libraries are actually built.</p><p>If you checked out the entire C++ SVN tree, you may be surprised to find that initially, the <span class="nctnt ncbi-path">include/objects</span> subtrees are empty, and the subdirectories in the <span class="nctnt ncbi-path">src/objects</span> subtree contain only ASN.1 modules. This is because both the header files and source files are auto-generated from the ASN.1 specifications by the <a href="ch_app.html#ch_app.datatool">datatool</a> program. As described in <a href="ch_proj.html#ch_proj.inside_tree">Working within the C++ source tree</a>, you can build everything by running <span class="nctnt ncbi-cmd">make all_r</span> in the build directory.</p><p><span class="nctnt highlight">Note:</span> If you would like to have the <span class="nctnt ncbi-lib">objects</span> libraries built locally, you <b>must</b> use the <span class="nctnt ncbi-cmd">--with-objects</span> flag when running the <span class="nctnt ncbi-app">configure</span> script.</p><p>You can also access the pre-generated serializable objects in the public area, using the source browsers to locate the objects you are particularly interested in. For example, if you are seeking the new class definition for the <span class="nctnt ncbi-monospace">Bioseq struct</span> defined in the C Toolkit, you can search for the <span class="nctnt ncbi-class">CBioseq</span> class, using either the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a> identifier search tool, or the Doxygen <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/hierarchy.html">class hierarchy</a> browser. Starting with the name of the data object as it appears in the ASN.1 module, two simple rules apply in deriving the new C++ class name:</p><ul><li><p>The one letter 'C' (for class) prefix should precede the ASN.1 name</p></li><li><p>All hyphens ('-') should be replaced by underscores ('_')</p></li></ul><p>For example, <span class="nctnt ncbi-monospace">Seq-descr </span>becomes <span class="nctnt ncbi-class">CSeq_descr</span>.</p></div><div class="sec" id="ch_proj.base_classes"><h4><span class="title">Base classes and user classes</span></h4><p>The classes whose names are derived in this manner are called the <span class="nctnt ncbi-monospace">user classes</span>, and each also has a corresponding <span class="nctnt ncbi-monospace">base class </span>implementation. The name of the <span class="nctnt ncbi-monospace">base class</span> is arrived at by appending <span class="nctnt ncbi-monospace">"_Base"</span> to the <span class="nctnt ncbi-monospace">user class</span> name. Most of the <span class="nctnt ncbi-monospace">user classes </span>are empty wrapper classes that do not bring any new functionality or data members to the inherited <span class="nctnt ncbi-monospace">base class</span>; they are simply provided as a platform for development. In contrast, the <span class="nctnt ncbi-monospace">base classes</span> are <b>not</b> intended for public use (other than browsing), and should never be modified.</p><p>More generally, the <span class="nctnt ncbi-monospace">base classes</span> should <i>never</i> be instantiated or accessed directly in an application. The relation between the two source files and the classes they define reflects a general design used in developing the object libraries: the base class files are auto-generated by <a href="ch_app.html#ch_app.datatool">datatool</a> according to the ASN.1 specifications in the <span class="nctnt ncbi-path">src/objects</span> directories; the inherited class files (the so-called <span class="nctnt ncbi-monospace">user classes</span>) are intended for developers who can extend these classes to support features above and beyond the ASN.1 specifications.</p><p>Many applications will involve a "tangled hierarchy" of these objects, reflecting the complexity of the real world data that they represent. For example, a <span class="nctnt ncbi-class">CBioseq_set</span> contains a list of <span class="nctnt ncbi-class">CSeq_entry</span> objects, where each <span class="nctnt ncbi-class">CSeq_entry</span> is, in turn, a <a href="ch_ser.html#ch_ser.choice.html">choice</a> between a <span class="nctnt ncbi-class">CBioseq</span> and a <span class="nctnt ncbi-class">CBioseq_set</span>.</p><p>Given the potential for this complexity of interactions, a critical design issue becomes how one can ensure that methods which may have been defined only in the <span class="nctnt ncbi-monospace">user class</span> will be available for all instances of that class. In particular, these instances may occur as contained elements of another object which is compiled in a different library. These inter-object dependencies are the motivation for the <span class="nctnt ncbi-monospace">user classes</span>. As shown in <a href="ch_proj.html#ch_proj.F2">Figure 2</a>, all references to external objects which occur inside the <span class="nctnt ncbi-monospace">base classes</span>, access external <span class="nctnt ncbi-monospace">user classes</span>, so as to include any methods which may be defined only in the <span class="nctnt ncbi-monospace">user classes</span>:</p><div class="figure" id="ch_proj.F2"><div class="graphic"><img src="img/user_base.gif" alt="Figure 2. Example of complex relationships between base classes and user classes" /></div><div class="caption"><p>Figure 2. Example of complex relationships between base classes and user classes</p></div></div><p>In most cases, adding non-virtual methods to a <span class="nctnt ncbi-monospace">user class</span> will <b>not</b> require re-compiling any libraries except the one which defines the modified object. Note however, that adding non-static data members and/or <span class="nctnt ncbi-code">virtual</span> methods to the <span class="nctnt ncbi-monospace">user classes </span><b>will change</b> the class layouts, and in these cases only, will entail recompiling any external library objects which access these classes.</p></div><div class="sec" id="ch_proj.add_to_usr_classes"><h4><span class="title">Adding methods to the user classes</span></h4><p><span class="nctnt highlight">Note:</span> This section describes the steps currently required to add new methods to the <span class="nctnt ncbi-monospace">user classes</span>. It is subject to change, and there is no guarantee the material here is up-to-date. In general, it is not recommended practice to add methods to the <span class="nctnt ncbi-monospace">user classes</span>, unless your purpose is to extend these classes across all applications as part of a development effort.</p><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_proj.html#ch_proj.src_code_work_env">Checking out source code, configuring the working environment, building the libraries.</a></p></li><li><p><a href="ch_proj.html#ch_proj.proj_add_methods">Adding methods</a></p></li></ul><div class="sec" id="ch_proj.src_code_work_env"><h5><span class="title">Checking out source code, configuring the working environment, building the libraries</span></h5><ul><li><p>Create a working directory (e.g. <span class="nctnt ncbi-path">Work</span>) and check out the C++ tree to that directory:, using either SVN checkout or the shell script, <span class="nctnt ncbi-cmd">svn_core &lt;dirname&gt;</span>.</p></li><li><p><a href="ch_config.html#ch_config.Running_the_configur">Configure</a> the environment to work inside this tree using one of the configure scripts, according to the platform you will be working on. Be sure to include the <span class="nctnt ncbi-cmd">--with-objects</span> flag in invoking the <span class="nctnt ncbi-app">configure</span> script.</p></li><li><p>Build the <span class="nctnt ncbi-lib">xncbi</span>, <span class="nctnt ncbi-lib">xser</span> and <span class="nctnt ncbi-lib">xser</span> libraries, and run <span class="nctnt ncbi-cmd">datatool</span> to create the objects header and source files, and build all of the object module libraries:</p></li></ul><pre><span class="nctnt-pre ncbi-cmd"># Build the core library<br />cd path_to_compile_dir/build/corelib<br />make<br /># Build the util library<br />cd path_to_compile_dir/build/util<br />make<br /># might as well build datatool and avoid possible version skew cd path_to_compile_dir/build/serial make all_r<br /># needed for a few projects<br />cd path_to_compile_dir/build/connect<br />make<br />cd path_to_compile_dir/build/objects<br />make all_r<br /></span></pre><p><br />Here <span class="nctnt ncbi-var">path_to_compile_dir</span> is set to the compile work directory which depends on the compiler settings (e.g: <span class="nctnt ncbi-path">~/Work/internal/GCC-Debug</span>). In addition to creating the header and source files, using <span class="nctnt ncbi-cmd">make all_r </span>(instead of just <span class="nctnt ncbi-app">make</span>) will build all the libraries. All libraries that are built are also copied to the <span class="nctnt ncbi-path">lib</span> dir, e.g.:<span class="nctnt ncbi-path">~/Work/internal/c++/GCC-Debug/lib</span>. Similarly, all executables (such as <span class="nctnt ncbi-app">asn2asn</span>) are copied to the bin dir, e.g.: <span class="nctnt ncbi-path">~/Work/internal/c++/GCC-Debug/bin</span>.</p><p>You are now ready to edit the user class files and add methods.</p></div><div class="sec" id="ch_proj.proj_add_methods"><h5><span class="title">Adding methods</span></h5><p>As an example, suppose that we would like to add a method to the <span class="nctnt ncbi-class">CSeq_inst</span> class to calculate sequence length, e.g.:<span class="nctnt ncbi-func">CSeq_inst::CalculateLength()</span>. We begin by adding a declaration of this method to the public section of the user class definition in <span class="nctnt ncbi-path">Seq_inst.hpp</span>:</p><pre><span class="nctnt-pre ncbi-code">class CSeq_inst : public CSeq_inst_Base<br />{<br />public:<br />    CSeq_inst(void);<br />    ~CSeq_inst(void);<br />    static CSeq_inst* New(void)<br />        {<br />            return new CSeq_inst(eCanDelete);<br />        }<br />    int CalculateLength() const;<br />protected:<br />    CSeq_inst(ECanDelete);<br />};</span></pre><p>and in the source file, <span class="nctnt ncbi-path">Seq_inst.cpp</span>, we implement</p><pre><span class="nctnt-pre ncbi-code">int CSeq_inst::CalculateLength() const<br />{<br />    // implementation goes here<br />}</span></pre><p>These files are in the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seq">include/objects/seq</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seq">src/objects/seq</a> subdirectories, respectively. Once you have made the modifications to the files, you need to recompile the <span class="nctnt ncbi-lib">seq</span> library, <span class="nctnt ncbi-lib">libseq.a</span>, i.e.:</p><pre><span class="nctnt-pre ncbi-cmd">cd path_to_compile_dir/GCC-Debug/build/objects/seq<br />make</span></pre><p>Here <span class="nctnt ncbi-var">path_to_compile_dir </span>is set to the compile work directory which depends on the compiler settings (e.g: <span class="nctnt ncbi-path">~/Work/internal/GCC-Debug</span>). The new method can now be invoked from within a <span class="nctnt ncbi-class">CBioseq</span> object as: <span class="nctnt ncbi-code">myBioseq.GetInst().CalculateLength().</span></p><p>The key issue that determines whether or not you will need to rebuild any <span class="nctnt ncbi-monospace">external</span> libraries that use the modified user class involves the class layout in memory. All of the external libraries which reference the object refer to the class layout that existed prior to the changes you have made. Thus, if your modifications do <b>not</b> affect the class layout, you do not have to rebuild any external libraries. Changes that <i>do</i> affect memory mapping include:</p><ul><li><p>The addition of new, non-static data members</p></li><li><p>The addition of virtual methods</p></li></ul><p>If you have added either of the above to the <span class="nctnt ncbi-monospace">user class</span>, then you will need to identify all external objects which use your object, and recompile the libraries in which these objects are defined.</p></div></div></div></div></div></div><div class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_proj.start_new_proj">Starting New Projects</a></li><li><a href="#ch_proj.work_env">Managing the Work Environment</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_proj.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                          middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />   
					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                          middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" /><label for="iToolkitAll" title="Search in the C/C++ source code,  this Book, and Wiki">All</label></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><label for="iLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><label for="iLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li><li class="internal-only">LXR: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident">internal</a></li><li class="internal-only">Doxygen: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml">internal</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li><a href="http://www.ncbi.nlm.nih.gov/bookshelf/br.fcgi?book=toolkit&amp;part=ch_getcode_svn#ch_getcode_svn.code_retrieval">Server</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++">Web
                            (dev)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++">Web
                            (extra)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components">Web (prod)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit">Wiki</a></li><li class="internal-only"><a href="http://jira/browse/CXX">JIRA</a></li><li class="internal-only"><a href="http://intranet/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download</a></li><li><a href="pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
