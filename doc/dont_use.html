<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Prohibited and discouraged C++/STL features</title>
  </head>

  <body>
	 <h1>Prohibited and discouraged C++/STL features</h1>

	 <ul>
		<li> <a href="#ref_STL">STL bad guys</a>
	 <ul>
		<li> <a href="#ref_STL_NonStd">Non-standard STL classes</a>
	 </ul>
		<li> <a href="#ref_CPP">C++ bad guys</a>
	 <ul>
		<li> <a href="#ref_CPP_OpOverload">Operation overload</a>
		<li> <a href="#ref_CPP_OpAssignment">Assignment and copy constructor overload</a>
		<li> <a href="#ref_CPP_Namespace">Namespaces</a>
		<li> <a href="#ref_CPP_NoArg">Omitting <i>"void"</i> in a no-arg function proto</a>
	 </ul> </ul>

	 <br></br>

	 <a name="ref_STL">
	 <h2><u>STL bad guys</u></h2>

	 <a name="ref_STL_NonStd"> <h3>Non-standard STL classes</h3> <p>
	 Don't use <i>hash</i> or the <i>rope</i> classes from
	 some versions of the STL.
	 These are non-standard additions. If you have questions about what
	 is/isn't in the standard library, consult the 
	 <a href="http://www.cygnus.com/misc/wp/dec96pub/">draft standard</a>.</p>


	 <br></br>
	 <a name="ref_CPP">
	 <h2><u>C++ bad guys</u></h2>

	 <a name="ref_CPP_OpOverload"> <h3>Operation overload</h3> <p>
	 Do not use operator overloading for the objects where
    they have unnatural or ambiguous meaning. E.g. the defining of operation
	 "==" for your class <i>"CFoo"</i> so that there exist { CFoo a,b,c; } such
	 that <i>(a == b)</i> and  <i>(b == c)</i> are <i>true</i>
	 while <i>(a == c)</i> is <i>false</i> would be a very bad idea.
	 It turns out that otherwise, especially in large projects, people have
	 different ideas of what an overloaded operator means, leading to all
	 sorts of bugs.

	 <a name="ref_CPP_OpAssignment"> <h3>Assignment and copy constructor overload</h3> <p>
	 Be advised that the default initialization
	 <i>{CFoo foo = bar;}</i> and assignment<i>{CFoo foo; ...; foo = bar;}</i>
	 do a member-by-member copying. This is not suitable and can be dangerous
	 sometimes. And if you decide overwrite this default behaviour by your own
	 code like:
	 <pre>
class CFoo {
    // a copy constructor for initialization
    CFoo(const CFoo& bar) { ... }
    // an overloaded assignment(=) operator
    CFoo& operator=(const CFoo& bar) { if (&bar != this) ... }
};
	 </pre>
	 it is <b>extremely important</b> that:
	 <ul>
		<li> <b>both</b> copy constructor and overloaded assignment be defined
		<li> they have <b>just the same</b> meaning that is
		<i>{CFoo foo = bar;}</i> is equivalent to <i>{CFoo foo;  foo = bar;}</i>
		<li> there is a check for a <b>self-assignment</b> case in your
		overloaded assignment operation
	 </ul>


	 <a name="ref_CPP_Namespace"> <h3>Namespaces</h3> <p>
	 Do not define your own namespaces at all.
	 Instead, if you want to ensure that you will not get into a name conflict,
	 see the workaround (<a href="style.html#ref_Prefix">quasi-namespace</a>)
	 technique.
	 Do not engage foreign namespaces(with <i>"using namespace XXX;"</i>)
	 unless this is practically unavoidable.
	 For the use of STL namespace see the
	 <a href="tips.html#STL_tips">NCBI_USING_STL preprocessor macro</a>.

	 <a name="ref_CPP_NoArg"> <h3>Omitting <i>"void"</i> in a no-arg function proto</h3> <p>
	 Do not omit <i>"void"</i> in prototype of a function without arguments
	 (e.g. always write <i>"int f(<b>void</b>)"</i>
	 rather than just <i>"int f()"</i>).

	 <br></br>
	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:lewisg@ncbi.nlm.nih.gov">Lewis Geer</a></address></td>
		  <td align=right>($Revision$)</td></tr>
		<tr>
		  <td><address><a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td></tr>
	 </table>
  </body>
</html>
