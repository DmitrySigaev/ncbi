<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>C++/STL pit-falls and discouraged/prohibited features</title>
  </head>

  <body>
	 <h1>C++/STL pit-falls and discouraged/prohibited features</h1>

	 <ul>
		<li> <a href="#ref_STL">STL and standard C++ library's bad guys</a>
	 <ul>
		<li> <a href="#ref_STL_Stream">Old vs. new stream classes</a>
		<li> <a href="#ref_STL_NonStd">Non-standard classes</a>
	 </ul>
		<li> <a href="#ref_CPP">C++ bad guys</a>
	 <ul>
		<li> <a href="#ref_CPP_OpOverload">Operation overload</a>
		<li> <a href="#ref_CPP_OpAssignment">Assignment and copy constructor overload</a>
		<li> <a href="#ref_CPP_Namespace">Namespaces</a>
		<li> <a href="#ref_CPP_NoArg">Omitting <i>"void"</i> in a no-arg function proto</a>
		<li> <a href="#ref_CPP_Malloc">Do not mix malloc and new</a>
	 </ul> </ul>

	 <br></br>

	 <a name="ref_STL"></a>
	 <h2><u>STL and standard C++ library's bad guys</u></h2>

	 <br></br>
	 <a name="ref_STL_Stream"></a> <h3>Old vs. new stream classes</h3>

	 <p> 
	 <p><i>#include &lt;ncbistre.hpp&gt;</i> 

	 <p>
	 Do not use the new iostream library included with Sunpro C++ 5.0 early
	 access release refresh. It is extremely buggy. Instead we will use the
	 older version of iostream.h by default.
<p>
	 It was a big question if we should use "old-fashioned" C++ stream
	 classes(from <i>#include &lt;iostream.h&gt;, etc.</i>) or
	 "templated" ones(from <i>#include &lt;iostream&gt;, etc.</i>).
	 Some platforms do not support "new" streams yet; and although
	 there is a way to import most STL classes and string template class
	 using package like <a href="tips.html#ref_STL">STLport</a>, however
	 C++ stream classes usually cannot be implemented formally(yet in full)
	 by a third party because of their close interaction with the underlying
	 file system.

	 <p>
	 The solution is to use an "<b>intersection</b>" between the new and old
	 stream functionality, and thus allow one to use either
	 old or new streams depending on whether the given platform supports
	 new streams or not. Thus, for the reason of the "old/new streams"
	 portability, one <b>must</b> use:
	 <ul>
		<li> <i>#include &lt;ncbistre.hpp&gt;</i> (for now, it also
		gets <i>#include</i>'d in <i> &lt;ncbistd.hpp&gt;</i>)
	 </ul>
	 and <b>must never</b> do directly:
	 <ul>
		<li> <i>#include &lt;iostream&gt;, etc.</i>
		<li> <i>#include &lt;iostream.h&gt;, etc.</i>
	 </ul>

	 Then, <b>always</b> use:
	 <ul>
		<li> <i>"CNcbiIstream", "CNcbiOstream", etc.</i>
	 </ul>
	 and <b>never</b> use:
	 <ul>
		<li> <i>"istream", "ostream", etc.</i> or even
		<li> <i>"::istream", "::ostream", etc.</i> or <i>"std::istream", "std::ostream", etc.</i>
	 </ul>
	 and, of course, the use of stream iterators and
	 "<i>stringstream</i>"-related classes (from <i>&lt;sstream&gt;</i>)
	 is not allowed as well.

	 <p>
	 By following this approach, we should be able to use both "new" and "old"
	 stream libs now "for free". The needed code discipline will be maintained
	 "automagically" as any "old streams"-only and "new streams"-only code
	 would not compile immediately. On the other hand, we reserve a possibility
	 to replace "<i>typedef</i>"s by derived classes with added functionality
	 (e.g. in order to extend the new/old stream API intersection area, or to
	 add some features like overriden <i>overflow()</i>/<i>underflow()</i> callbacks).

	 <p>
	 If compiler supports both "old" and "new" C++ streams then
	 "old-fashioned" C++ libs will be engaged by default.
	 This can be alternated by <i>#defin</i>'ing preprocessor variable
	 "<i>NCBI_USE_NEW_IOSTREAM</i>".


	 <br></br>
	 <br></br>
	 <a name="ref_STL_NonStd"></a> <h3>Non-standard STL classes</h3> <p>
	 Don't use <i>hash</i> or the <i>rope</i> classes from
	 some versions of the STL.
	 These are non-standard additions. If you have questions about what
	 is/isn't in the standard library, consult the 
	 <a href="http://www.cygnus.com/misc/wp/">C++ standards</a>.</p>


	 <br></br>
	 <a name="ref_CPP"></a>
	 <h2><u>C++ bad guys</u></h2>

	 <a name="ref_CPP_OpOverload"></a> <h3>Operation overload</h3> <p>
	 Do not use operator overloading for the objects where
    they have unnatural or ambiguous meaning. E.g. the defining of operation
	 "==" for your class <i>"CFoo"</i> so that there exist { CFoo a,b,c; } such
	 that <i>(a == b)</i> and  <i>(b == c)</i> are <i>true</i>
	 while <i>(a == c)</i> is <i>false</i> would be a very bad idea.
	 It turns out that otherwise, especially in large projects, people have
	 different ideas of what an overloaded operator means, leading to all
	 sorts of bugs.

	 <a name="ref_CPP_OpAssignment"></a> <h3>Assignment and copy constructor overload</h3> <p>
	 Be advised that the default initialization
	 <i>{CFoo foo = bar;}</i> and assignment<i>{CFoo foo; ...; foo = bar;}</i>
	 do a member-by-member copying. This is not suitable and can be dangerous
	 sometimes. And if you decide overwrite this default behaviour by your own
	 code like:
	 <pre>
class CFoo {
    // a copy constructor for initialization
    CFoo(const CFoo& bar) { ... }
    // an overloaded assignment(=) operator
    CFoo& operator=(const CFoo& bar) { if (&bar != this) ... }
};
	 </pre>
	 it is <b>extremely important</b> that:
	 <ul>
		<li> <b>both</b> copy constructor and overloaded assignment be defined
		<li> they have <b>just the same</b> meaning that is
		<i>{CFoo foo = bar;}</i> is equivalent to <i>{CFoo foo;  foo = bar;}</i>
		<li> there is a check for a <b>self-assignment</b> case in your
		overloaded assignment operation
	 </ul>

	 In many cases when you dont want to have the assignment and copy
	 constructor at all, just add to your class something like:
<pre>
class CFoo {
    .............................
private: 
    // Prohibit default initialization and assignment
    CFooClass(const CFooClass&) { _TROUBLE; }
    CFooClass& operator=(const CFooClass&) { _TROUBLE;  return *this; }
};
</pre>

	 <br></br>
	 <a name="ref_CPP_Namespace"></a> <h3>Namespaces</h3> <p>
	 Do not define your own namespaces at all.
	 Instead, if you want to ensure that you will not get into a name conflict,
	 see the workaround (<a href="style.html#ref_Prefix">quasi-namespace</a>)
	 technique.
	 Do not engage foreign namespaces (with <i>"using namespace XXX;"</i>)
	 unless this is practically unavoidable.
	 For the use of standard C++ template classes(including STL) and/or
	 NCBI namespaces
	 <a href="style.html#ref_Scope">click here</a>.

	 <a name="ref_CPP_NoArg"></a> <h3>Omitting <i>"void"</i> in a no-arg function proto</h3> <p>
	 Do not omit <i>"void"</i> in prototype of a function without arguments
	 (e.g. always write <i>"int f(<b>void</b>)"</i>
	 rather than just <i>"int f()"</i>).

	 <a name="ref_CPP_Malloc"></a> <h3>Do not mix malloc and new</h3> <p>
	 On some platforms, malloc and new may use completely different memory
	 managers, so never "free()" what you created using "new" and never "delete"
	 what you created using "malloc()".  Also, when calling C code from C++
	 <b>always</b> allocate any structs or other items using "malloc()".
	 The C routine may use "realloc()" or "free()" on the items, which can cause
	 memory corruption if you allocated using "new."

	 <br>
	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:lewisg@ncbi.nlm.nih.gov">Lewis Geer</a></address></td>
		  <td align=right>($Revision$)</td></tr>
		<tr>
		  <td><address><a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td></tr>
	 </table>
  
</body></html>
