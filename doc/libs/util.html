<!--#set var="TITLE" value="Util library" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1><a NAME="top"></a>Util library</h1>

<h2>Containers</h2>

<ul>
<li>
<a href="#CWeakMapKey">CWeakMapKey&lt;typename Object></a></li>

<li>
<a href="#CWeakMap">CWeakMap&lt;typename Object></a></li>

<li>
<a href="#CRange">CRange&lt;typename Coordinate = int></a></li>

<li>
<a href="#CRangeMap">CRangeMap&lt;typename Object, typename Coordinate
= int></a></li>

<li>
<a href="#CRangeMultiMap">CRangeMultimap&lt;typename Object, typename Coordinate
= int></a></li>

<li>
<a href="#CIntervalTree">CIntervalTree</a></li>
</ul>

<h2>I/O classes</h2>

<ul>
<li>
<a href="util_io.html#CIStreamBuffer">CIStreamBuffer</a></li>

<li>
<a href="util_io.html#COStreamBuffer">COStreamBuffer</a></li>

<li>
<a href="util_io.html#CByteSource">CByteSource</a></li>

<ul>
<li>
<a href="util_io.html#CStreamByteSource">CStreamByteSource</a></li>

<li>
<a href="util_io.html#CFStreamByteSource">CFStreamByteSource</a></li>

<li>
<a href="util_io.html#CFileByteSource">CFileByteSource</a></li>

<li>
<a href="util_io.html#CMemoryByteSource">CMemoryByteSource</a></li>
</ul>

<li>
<a href="util_io.html#CByteSourceReader">CByteSourceReader</a></li>

<ul>
<li>
CStreamByteSourceReader</li>

<li>
CFileByteSourceReader</li>

<li>
CSubFileByteSource</li>

<li>
CMemoryByteSourceReader</li>
</ul>

<li>
<a href="util_io.html#CSubSourceCollector">CSubSourceCollector</a></li>

<ul>
<li>
CMemorySourceCollector</li>

<li>
CFileSourceCollector</li>
</ul>
</ul>

<h2>Other classes</h2>

<ul>
<li>
<a href="#CLightString">CLightString</a></li>

<li>
<a href="#CChecksum">CChecksum</a></li>
</ul>
Exceptions
<ul>
<li>
CIOException</li>

<li>
CEofException</li>
</ul>

<h1>
Classes descriptions</h1>

<hr WIDTH="100%">
<h2>
<a NAME="CWeakMapKey"></a>template&lt;typename Object> class CWeakMapKey</h2>

<pre>&nbsp;&nbsp;&nbsp; #include &lt;util/weakmap.hpp></pre>
This class is used in conjunction with <a href="#CWeakMap">CWeakMap</a>.
<br>
<hr WIDTH="100%">
<h2>
<a NAME="CWeakMap"></a>template&lt;typename Object> class CWeakMap</h2>

<pre>&nbsp;&nbsp;&nbsp; #include &lt;util/weakmap.hpp></pre>
This class is used in conjunction with <a href="#CWeakMapKey">CWeakMapKey</a>.
<br>It is extension for regular maps with additional feature: it automatically
removes elements from map when corresponding key is destructed.
<br>Key is of type <a href="#CWeakMapKey">CWeakMapKey&lt;Object></a>.
<p>//&nbsp;&nbsp; Generic example of usage of these templates:
<p>#include &lt;util/weakmap.hpp>
<p>class CKey
<br>{
<br>public:
<br>&nbsp;&nbsp;&nbsp; CWeakMapKey&lt;string> m_MapKey;
<br>};
<p>void Test(void)
<br>{
<br>&nbsp;&nbsp;&nbsp; // declare map object
<br>&nbsp;&nbsp;&nbsp; CWeakMap&lt;string> map;
<br>&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // declare temporary key
object
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CKey key;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // insert string value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; map.insert(key.m_MapKey,
"value");
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; map.size();
// == 1
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; map.empty();
// == false
<br>&nbsp;&nbsp;&nbsp; } // end of block: key object is destructed and
map forgets about value
<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; map.size(); // == 0
<br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; map.empty(); // == true
<br>};
<br>&nbsp;
<h3>
typedefs</h3>

<blockquote>
<pre>key_type
mapped_type
value_type
iterator
const_iterator</pre>

<blockquote>are the same as in standard C++ template map&lt;>.</blockquote>
</blockquote>

<h3>
methods</h3>

<blockquote>
<pre>size_t size() const;
bool empty() const;

const_iterator begin() const;
const_iterator end() const;
const_iterator find() const;

iterator begin();
iterator end();
iterator find();</pre>

<blockquote>are the same as in standard C++ template map&lt;>.</blockquote>
</blockquote>

<blockquote>
<pre>void insert(key_type&amp; key, const mapped_type&amp; value);
void erase(key_type&amp; key);</pre>

<blockquote>do the same as corresponding methods of standard C++ template
map&lt;>.
<br>They differ only in return type.</blockquote>
</blockquote>

<hr WIDTH="100%">
<h2>
<a NAME="CRange"></a>template&lt;typename Coordinate> class CRange</h2>
Class for storing information about some interval (from:to).
<br>From and to points are inclusive.
<br>&nbsp;
<h3>
typedefs</h3>

<blockquote>
<pre>position_type</pre>

<blockquote>synonym of Coordinate.</blockquote>
</blockquote>

<h3>
methods</h3>

<blockquote>
<pre>CRange();
CRange(position_type from, position_type to);</pre>

<blockquote>constructors</blockquote>

<pre>static position_type GetEmptyFrom();
static position_type GetEmptyTo();
static position_type GetWholeFrom();
static position_type GetWholeTo();</pre>

<blockquote>get special coordinate values</blockquote>

<pre>static CRange&lt;position_type> GetEmpty();
static CRange&lt;position_type> GetWhole();</pre>

<blockquote>get special interval objects</blockquote>

<pre>bool HaveEmptyBound() const;</pre>

<blockquote>check if any bound have special 'empty' value</blockquote>

<pre>bool HaveInfiniteBound() const;</pre>

<blockquote>check if any bound have special 'whole' value</blockquote>

<pre>bool Empty() const;</pre>

<blockquote>check if interval is empty (any bound have special 'empty'
value or left bound greater then right bound)</blockquote>

<pre>bool Regular() const;</pre>

<blockquote>check if interval's bounds are not special and length is positive</blockquote>

<pre>position_type GetFrom() const;
position_type GetTo() const;
position_type GetLength() const;</pre>

<blockquote>get parameters of interval</blockquote>

<pre>CRange&lt;position_type>&amp; SetFrom();
CRange&lt;position_type>&amp; SetTo();</pre>

<blockquote>set bounds of interval</blockquote>

<pre>CRange&lt;position_type>&amp; SetLength();</pre>

<blockquote>set length of interval leaving left bound (from) unchanged</blockquote>

<pre>CRange&lt;position_type>&amp; SetLengthDown();</pre>

<blockquote>set length of interval leaving right bound (to) unchanged</blockquote>

<pre>bool IntersectingWith(CRange&lt;position_type> range) const;</pre>

<blockquote>check if non empty intervals intersect</blockquote>

<pre>bool IntersectingWithPossiblyEmpty(CRange&lt;position_type> range) const;</pre>

<blockquote>check if intervals intersect</blockquote>
</blockquote>

<hr WIDTH="100%">
<h3>
<a NAME="CRangeMap"></a>template&lt;typename Object, typename Coordinate
= int> class CRangeMap</h3>
Class for storing and retrieving data using interval as key.
<br>Also allows efficient iteration over intervals intersecting with specified
interval.
<br>Time of iteration is proportional to amount of intervals produced by
iterator.
<br>In some cases, algorithm is not so efficient and may slowdown.
<br>
<hr WIDTH="100%">
<h3>
<a NAME="CRangeMultiMap"></a>template&lt;typename Object, typename Coordinate
= int> class CRangeMultiMap</h3>
Almost the same as <a href="#CRangeMap">CRangeMap</a> but allows several
values have the same key interval.
<br>
<hr WIDTH="100%">
<h3>
<a NAME="CIntervalTree"></a>class CIntervalTree</h3>
Class with the same functionality as <a href="#CRangeMap">CRangeMap</a>
but using different algorithm.
<br>It is faster and its speed is not affected by type of data but it uses
more memory (triple as <a href="#CRangeMap">CRangeMap</a>) and, as a result,
less efficient when amount of interval in set is quite big.
<br>It uses about 140 bytes per interval for 64 bit program so you can
calculate if CIntervalTree is acceptable. For example, it becomes less
efficient than <a href="#CRangeMap">CRangeMap</a> when total memory becomes
greater than processor cache.
<br>
<hr WIDTH="100%">
<h3>
<a NAME="CLightString"></a>class CLightString</h3>
Class for storing information about char strings. Unlike standard C++ string
class it doesn't take ownership over string contents. So, char array containing
string value should exist for whole life of holding CLightString object.
This char array should be deleted (if needed) after CLightString object
destruction by some other mechanism.
<br>Note that for efficiency sort order of CLightString differs from standard.
It compares first by string length, then by string contents, so here is
an example of sorted data:
<blockquote>
<pre>"a"
"z"
"aa"
"az"
"zz"
"aaa"</pre>
</blockquote>
which, if sorted by standard comparison will look like:
<blockquote>
<pre>"a"
"aa"
"aaa"
"az"
"z"
"zz"</pre>
</blockquote>

<hr WIDTH="100%">
<h3>
<a NAME="CChecksum"></a>class CChecksum</h3>
Class for CRC32 checksum calculation.
<br>It also have methods for adding and checking checkum line in text files.
<p>
<hr>
<address>
<a href="mailto:vasilche@ncbi.nlm.nih.gov">Eugene Vasilchenko</a></address>

<br><!-- Created: Mon Jan 29 13:58:54 EST 2001 --><!-- hhmts start -->Last
modified: Mon Jan 29 13:58:56 EST 2001<!-- hhmts end -->

<!--#include virtual="../ssi/footer.shtml" -->
