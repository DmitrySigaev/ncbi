<!--#set var="TITLE" value="NCBI DBAPI Middle Layer Docs" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->


<!--<B><FONT FACE="Arial" SIZE=4><P>DBAPI Interface Overview.</P></B></FONT><P>&nbsp;</P>-->
<h3>NCBI C++ Toolkit:  DBAPI Middle-Layer Interface Reference</h3>

<a name="ref_ObjHierarcy"></a>
<B><FONT FACE="Arial"><P>Object hierarchy</P>
</B></FONT>
<P><IMG SRC="dbapi_middle.gif" WIDTH=681 HEIGHT=464></P>


<P>&nbsp;</P>
<a name="ref_Includes"></a>
<B><FONT FACE="Arial"><P>Includes</P>
</B></FONT><P>For most purposes one file is sufficient to be included into the user source file: <tt>dbapi.hpp.</tt> </P>

<PRE>
#include &lt;dbapi/dbapi.hpp&gt;  <FONT FACE="Arial"><B>or,</B></FONT>
#include &lt;dbapi/driver/drivers.hpp&gt; <FONT FACE="Arial">(for static linkage only!)</FONT>
</PRE>

<a name="ref_Objects"></a>
<B><FONT FACE="Arial"><P>Objects</P>
</B></FONT><P>All objects are returned by pointers to respective interfaces. Null (0) value is valid meaning no object returned.</P>

<a name="ref_ObjLifeCycle"></a>
<B><FONT FACE="Arial"><P>Object Life Cycle</P>
</B></FONT><P>The general rule is that any child object is valid only in the scope of it’s parent object. This is  because most of the objects share the same internal structures. There is no need to delete every object explicitly, all created objects will be deleted upon program exit.</P>

<a name="ref_CVariant"></a>
<B><FONT FACE="Arial"><P>CVariant type</P>
</B></FONT><P>CVariant type is used to represent any database data type (except BLOBs). It is an object, not a pointer, so it behaves like a primitive C++ type. Basic comparison operators are supported <FONT FACE="Courier New">(==, !=, &lt; </FONT>)  for identical internal types. If types are not identical, CVariantException is thrown. CVariant has a set of getters to extract a value of a particular type, e.g. GetInt4(), GetByte(), GetString(), etc. If GetString() is called for a different type, like DateTime or integer it tries to convert it to a string. It it doesn't succeed, CVariantException is thrown. There is a set of factory methods (static functions) for creating CVariants of a particular type, such as CVariant::BigInt(), CVariant::SmallDateTime(), CVariant::VarBinary(), etc. For more details please see comments in variant.hpp file.</P>
<P>&nbsp;</P>

<a name="ref_ChooseDriver"></a>
<B><FONT FACE="Arial"><P>Choosing the driver</P>
</B></FONT>
<P>There are several drivers for work with different SQL servers on different platforms. The names of implemented ones are "ctlib" (Sybase), "dblib"(MS SQL), "ftds" (cross platform). For static linkage these drivers should be registered manually, for dynamic linkage this is not necessary. CDriverManager object maintains all registered drivers.</P>

<blockquote>
<pre>
CDriverManager &amp;dm = CDriverManager::GetInstance();
DBAPI_RegisterDriver_CTLIB(dm);
DBAPI_RegisterDriver_DBLIB(dm);

</pre>
</blockquote>

<a name="ref_SrcCnxns"></a>
<B><FONT FACE="Arial"><P>Data Source and Connections</P>
</B></FONT><P>The interface that defines the database platform to work with is called IDataSource. To create the object, represented by this interface, the method CreateDs(const string&amp; driver) is used The IDataSource can create objects represented by IConnection interface, which are responsible for the connection to the database. It is highly recommended to specify database name as argument to the CreateConnction() method, or use SetDatabase() method in CConneciton object instead of using reqular SQL statement, otherwise the library won't be able to track the current database. </P>

<blockquote>
<PRE>
IDataSource *ds = dm.CreateDs("ctlib");
IConnection *conn = ds-&gt;CreateConnection();
conn-&gt;Connect("user", "password", "server", "database");
IStatement *stmt = conn-&gt;CreateStatement();

</PRE>
</blockquote>

</FONT><P>Every additional call to IConnection::CreateStatement() results in cloning the connection for each statement. These connections inherit the same default database, which was specified in Connect() or SetDatabase() method. Thus if the default database was changed by calling SetDatabase(), all subsequent cloned connections created by CreateStatement() will inherit this particular default database.</P>


<a name="ref_MainLoop"></a>
<B><FONT FACE="Arial"><P>Main loop</P>
</B></FONT><P>The library simulates the main result-retrieving loop of the Sybase client library by using <FONT FACE="Courier New">IStatement::HasMoreResults()</FONT> method:</P>

<blockquote>
<PRE>
stmt-&gt;Execute(&quot;select …&quot;);
while( stmt-&gt;HasMoreResults() ) {
    if( stmt-&gt;HasRows() ) {
        IResultSet *rs = stmt-&gt;GetResultset();

        // Retrieve results, if any
        while( rs-&gt;Next() ) {
            int col1 = rs-&gt;GetVariant(1).GetInt4();
            ...
        }
    }
}

</PRE>
</blockquote>


</FONT><P>This method should be called until it returns false, which means that no more results is available. It returns as soon as a result is ready. The type of the result can be obtained by calling <FONT FACE="Courier New">IResultSet::GetResultType()</FONT> method. Supported result types are <FONT FACE="Courier New">eRowResult, eParamResult, eComputeResult, eStatusResult, eCursorResult</FONT>. The method IStatement::GetRowCount() returns the number of updated or deleted rows.</P>

<P>The IStatement::ExecuteUpdate() method is used for SQL statements that do not return rows:</P>

<blockquote>
<PRE>
stmt-&gt;ExecuteUpdate("update...");
int rows = stmt-&gt;GetRowCount();

</PRE>
</blockquote>

<P>The method IStatement::GetResultSet() returns IResultSet object. The method IResultSet::Next() actually does fetch, so it should be always called first. It returns false when no more fetch data is available. All column data, except Image and Text is represented by a single CVariant object. The method IResultSet::GetVariant() takes one parameter – column number. Column numbers start with 1. </P>
<P>&nbsp;</P>


<a name="ref_IOParams"></a>
<B><FONT FACE="Arial"><P>Input and Output Parameters</P>
</B></FONT><P>The method ICallableStatement::SetParam(const CVariant&amp; v, const string&amp; name) is used to pass parameters to stored procedures and dynamic SQL statements. To ensure the parameter type it is recommended to use CVariant type factories (static methods) to create a CVariant of the required internal type. There is few examples: CVariant::Int4(Int4 *p), CVariant::TinyInt(UInt1 *p), CVariant::VarChar(const char *p, size_t len ) etc. There is also corresponding constructors, like CVariant::CVariant(Int4 v), CVariant::CVariant(const string&amp; s)..., but the user must ensure the proper type conversion in the arguments, and not all internal types can be created using constructors. Output parameters are set by ICallableStatement::SetOutputParam(const CVariant&amp; v, const string&amp; name) method, where the first argument is null CVariant of a particular type, e.g. SetOutputParam(CVariant::SmallInt(0), "@arg").</P>

<a name="ref_StoredProcs"></a>
<B><FONT FACE="Arial"><P>Stored Procedures</P>
</B></FONT><P>The ICallableStatement object is used for calling stored procedures. Fist get the object itself by calling IConnection::PrepareCall(). Then set any parameters. If parameter name is empty, the calls to SetParam should be in exact order of the actual parameters. Retrieve results in the main loop. Get status using ICallableStatement::GetReturnStatus() method.</P>

<blockquote>
<PRE>
ICallableStatement *cstmt = conn-&gt;PrepareCall(&quot;ProcName&quot;);
Uint1 status = 1;
cstmt-&gt;SetParam(CVariant(&quot;test&quot;), &quot;@test_input&quot;);
cstmt-&gt;SetParam(CVariant::TinyInt(&amp;status), &quot;@status&quot;);
cstmt-&gt;SetOutputParam(CVariant::Int(0), &quot;@result&quot;);

cstmt-&gt;Execute();

while(cstmt-&gt;HasMoreResults()) {
    if( cstmt-&gt;HasRows() ) {
        IResultSet *rs = cstmt-&gt;GetResultSet();
        switch( rs-&gt;GetResultType() ) {
            case eRowResult:
                  while(rs-&gt;Next()) {

                  // retrieve row results

                  }
                  break;
            case eParamResult:
                  while(rs-&gt;Next()) {

                  // Retrieve parameter row

                  }
                  break;
        }
    }
}

// Get status
int status = cstmt-&gt;GetReturnStatus();

</PRE>
</blockquote>

<a name="ref_Cursors"></a>
<B><FONT FACE="Arial"><P>Cursors</P>
</B></FONT><P>The library currently supports basic cursor features such as setting parameters and cursor update and delete operations.</P>

<blockquote>
<PRE>
ICursor *cur = conn-&gt;CreateCursor("table_cur", "select ... for update of ...");
IResultSet *rs = cur-&gt;Open();
while(rs-&gt;Next()) {
    cur-&gt;Update(table, sql_statement_for_update);
}
cur-&gt;Close();

</PRE>
</blockquote>

<a name="ref_Libraries"></a>
<B><FONT FACE="Arial"><P>Libraries</P>
</B></FONT><FONT FACE="Courier New">
</FONT><P>The following libraries should be used (the order is significant):</P>
<dl>
	<dt><b>for ctlib</b> (Sybase):</dt>
	<dd><FONT FACE="Courier New"><P>dbapi dbapi_driver_ctlib dbapi_driver</P>
	</FONT><P>plus corresponding Sybase libraries.</P>
	</dd>

	<dt><b>for dblib</b> (MS SQL):</dt>
	<dd><FONT FACE="Courier New"><P>dbapi dbapi_driver_dblib dbapi_driver </P>
	</FONT><P>plus Sybase <FONT FACE="Courier New">sybdb</P></FONT>
	</dd>
</dl>

<p>
<hr>
<table border=0 width="100%" cellspacing=0>
<tr>
<td align=left>
  <address><a href="mailto:kholodov@ncbi.nlm.nih.gov">Michael Kholodov</a></address>
</td>
<!-- <td align=center><i>$Revision$</i></td> -->
<td align=right><i>$Date$</i></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
