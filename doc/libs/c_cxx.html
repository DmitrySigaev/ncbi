<!--#set var="TITLE" value="Using NCBI C and C++ Toolkits together" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>Using NCBI C and C++ Toolkits together</h1>

<font size=1><span class="ncbi_note">Note</span>: Due to security issues, not all links in the public version
of this file could be accessible by outside NCBI users. Unrestricted version of this document is available to
inside NCBI users at:
<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/libs/c_cxx.html" class="ncbi_url">http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/libs/c_cxx.html</a>.
</font>

<h2>Contents</h2>

<ol>
<ul>
    <li> <a href="#ref_Overview">Overview</a>
    <li> <a href="#ref_SharedSources">Shared Sources</a>
    <ul>
         <li> <a href="#ref_ConnectLib">CONNECT Library</a>
         <li> <a href="#ref_ASN">ASN.1 Specifications</a>
    </ul>
    <li> <a href="#ref_RunTimeResources">Run-Time Resources</a>
    <ul>
         <li> <a href="#ref_LOG">LOG and CNcbiDiag</a>
         <li> <a href="#ref_REG">REG and CNcbiRegistry</a>
         <li> <a href="#ref_LOCK">MT_LOCK and CRWLock</a>
         <li> <a href="#ref_ConnectCxx">CONNECT Library in C++ Code</a>
         <ul>
              <li><a href="#ref_SettingLOG">Setting LOG</a>
              <li><a href="#ref_SettingREG">Setting REG</a>
              <li><a href="#ref_SettingLOCK">Setting MT-Locking</a>
              <li><a href="#ref_CONNECT_Init_Cxx">Convenience call CONNECT_Init()</a>
         </ul>
         <li> <a href="#ref_CToolkitDiag">C Toolkit diagnostics redirection</a>
         <li> <a href="#ref_ConnectC">CONNECT Library in C Code</a>
         <ul>
              <li><a href="#ref_CONNECT_Init_C">Convenience call CONNECT_Init()</a>
         </ul>
    </ul>
</ul>
</ol>

<p>
<hr>


<a name="ref_Overview"></a><h2>Overview</h2>

When using both C and C++ Toolkits together in a single application,
it is very important to understand that there are some resources shared between the two.
This document describes how to safely use both Toolkits together,
and how to gain from their cooperation.

<p>
<hr>


<a name="ref_SharedSources"></a><h2>Shared Sources</h2>

To maintain a sort of uniformity and ease in source code maintenance,
<span class="ncbi_proj">CONNECT</span> library is the first library of both Toolkits kept
same at the source code level. To provide data interoperability,
ASN.1 specifications have to be identical in both Toolkits, too.


<a name="ref_ConnectLib"></a><h3>CONNECT  Library</h3>

<a href="../lxr/source/include/connect"><span class="ncbi_proj">CONNECT</span></a> library is at the moment the only part of C code
of both Toolkits, which is kept same in its entirety in both Toolkits.
The old API of <span class="ncbi_proj">CONNECT</span> library is still supported by means of
simple wrapper code, which is situated in the C Toolkit only.
There is an external <a href="../lxr/source/scripts/internal/c_toolkit/check_sync.sh">safety script</a>,
which periodically (controlled by a <span class="ncbi_util">cron</span> daemon) checks and maintains source file indentity.
Conventionally, all development for <span class="ncbi_proj">CONNECT</span> library is done within the C++ Toolkit tree.
When a modified source file is committed to the CVS repository
but is not yet updated in the C Toolkit tree, the safety script detects
the discrepancy, and then could be used to eliminate it by copying
the newer file over. If for some reason the modified version
is mistakenly checked into C Toolkit tree then the safety
script alerts the situation.

<p>
<hr>


<a name="ref_ASN"></a><h3>ASN.1  Specifications</h3>

On a contrary to <span class="ncbi_proj">CONNECT</span> library, the ASN.1 data
specifications are maintained within C Toolkit
source structure, and have to be copied over to C++ Toolkit
tree whenever they are changed. There is the same (as for <span class="ncbi_proj">CONNECT</span> library)
<a href="../lxr/source/scripts/internal/c_toolkit/check_sync.sh">safety script</a>,
which keeps "an eye" on those changes, and sends an alert when C++ Toolkit ASN.1
specs go out of sync with their C Toolkit counterparts.

<p>
The full set of tools, which maintain identity of both <span class="ncbi_proj">CONNECT</span> library and
ASN.1 specifications can be found in directory
<a href="../lxr/source/scripts/internal/c_toolkit"><span class="ncbi_dir">scripts/internal/c_toolkit</span></a>.

<p>
However, the internal representations of ASN.1-based objects
differ between the two toolkits.  If you need to convert an object
from one representation to the other, you can use the template class
<a href="../lxr/ident?i=CAsnConverter&d=C"><span class="ncbi_class">CAsnConverter&lt;&gt;</span></a>,
defined in
<a href="../lxr/source/include/ctools/asn_converter.hpp" class="ncbi_file">ctools/asn_converter.hpp</a>.

<p>
<hr>


<a name="ref_RunTimeResources"></a><h2>Run-Time Resources</h2>

Being written for use "as is" in the NCBI C Toolkit and
yet to be in the C++ Toolkit tree, <span class="ncbi_proj">CONNECT</span> library could not employ
directly all the utility objects offered by the C++ Toolkit such as
message logging <a href="../programming_manual/diag.html"><span class="ncbi_class">CNcbiDiag</span></a>,
registry <a href="../programming_manual/registry.html"><span class="ncbi_class">CNcbiRegistry</span></a>, and
MT-locks <a href="threads.html#crwlock"><span class="ncbi_class">CRWLock</span></a>.
All <a href="../lxr/source/include/connect/ncbi_core.h">these objects</a> were replaced
with helper objects coded entirely in C (as tables of function pointers and data).

<p>
On the other hand, throughout the code <span class="ncbi_proj">CONNECT</span> library refers to
predefined objects <span class="ncbi_var">g_CORE_Log</span> (so called <span class="ncbi_term">CORE C logger</span>)
<span class="ncbi_var">g_CORE_Registry</span> (<span class="ncbi_term">CORE C registry</span>), and <span class="ncbi_var">g_CORE_Lock</span>
(<span class="ncbi_term">CORE C MT-lock</span>), which actually are never initialized by the library,
i.e. they are empty objects, which do nothing. It is an application's
resposibility to replace these dummies with real working
logger, registry, and MT-lock. There are two approaches,
one for C and another one for C++ application.

<p>
In a C program <a href="../lxr/source/include/connect/ncbi_util.h"><span class="ncbi_file">connect/ncbi_util.h</span></a>
with calls to <a href="../lxr/ident?i=CORE_SetREG"><span class="ncbi_func">CORE_SetREG()</span></a>,
<a href="../lxr/ident?i=CORE_SetLOG"><span class="ncbi_func">CORE_SetLOG()</span></a>, and
<a href="../lxr/ident?i=CORE_SetLOCK"><span class="ncbi_func">CORE_SetLOCK()</span></a>
can be used to set up the registry, the logger, and
the MT-lock, correspondingly. There are even more convenience routines concerning
<span class="ncbi_term">CORE logger</span>, like <a href="../lxr/ident?i=CORE_SetLOGFILE"><span class="ncbi_func">CORE_SetLOGFILE()</span></a>,
<a href="../lxr/ident?i=CORE_SetLOGFILE_NAME"><span class="ncbi_func">CORE_SetLOGFILE_NAME()</span></a>,
which facilitate redirecting logging messages to either a C stream (<span class="ncbi_type">FILE*</span>) or a named file.

<p>
In a C++ program, yet another additional step is necessary of converting <span class="ncbi_term">native</span> C++ objects,
by calls declared in
<a href="../lxr/source/include/connect/ncbi_core_cxx.hpp"><span class="ncbi_file">connect/ncbi_core_cxx.hpp</span></a>
and as described later in this section, into their C equivalents, so that the C++ objects could be used
where types <a href="../lxr/ident?i=LOG"><span class="ncbi_type">LOG</span></a>, <a href="../lxr/ident?i=REG"><span class="ncbi_type">REG</span></a>
or <a href="../lxr/ident?i=MT_LOCK"><span class="ncbi_type">MT_LOCK</span></a> are expected.


<a name="ref_LOG"></a><h3><span class="ncbi_type">LOG</span> and <span class="ncbi_class">CNcbiDiag</span></h3>

<span class="ncbi_proj">CONNECT</span> library has its own <a href="../lxr/ident?i=LOG">logger</a>, which
has to be set by any of routines declared in
<a href="../lxr/source/include/connect/ncbi_util.h"><span class="ncbi_file">connect/ncbi_util.h</span></a>:
<a href="../lxr/ident?i=CORE_SetLOG"><span class="ncbi_func">CORE_SetLOG()</span></a>,
<a href="../lxr/ident?i=CORE_SetLOGFILE"><span class="ncbi_func">CORE_SetLOGFILE()</span></a> etc.

On the other hand, the interface defined in
<a href="../lxr/source/include/connect/ncbi_core_cxx.hpp"><span class="ncbi_file">connect/ncbi_core_cxx.hpp</span></a>
provides the following C++ function to convert a logging stream of the NCBI C++ Toolkit into a <span class="ncbi_type">LOG</span> object:
<pre class="ncbi_code">
    LOG <a href="../lxr/ident?i=LOG_cxx2c">LOG_cxx2c</a> (void)
</pre>
which creates the <span class="ncbi_type">LOG</span> object on top of the corresponding C++ <span class="ncbi_class">CNcbiDiag</span> object,
and then both C and C++ objects could be manipulated interchangeably, causing exactly the same effect on the underlying
logger. Then, the returned C handle <span class="ncbi_type">LOG</span> can be subsequently used as a <span class="ncbi_term">CORE C logger</span> by means of
<span class="ncbi_func">CORE_SetLOG()</span>, like in the following nested calls: <span class="ncbi_ccode">CORE_SetLOG(LOG_cxx2c());</span>

<p>
<hr>


<a name="ref_REG"></a><h3>REG  and CNcbiRegistry</h3>

<a href="../lxr/source/include/connect/ncbi_core_cxx.hpp"><span class="ncbi_file">connect/ncbi_core_cxx.hpp</span></a>
declares the following C++ function to bind C <span class="ncbi_type">REG</span> object to <span class="ncbi_class">CNcbiRegistry</span>
used in C++ programs built with the use of the NCBI C++ Toolkit:
<pre class="ncbi_code">
    REG <a href="../lxr/ident?i=REG_cxx2c">REG_cxx2c</a> (CNcbiRegistry* reg, bool pass_ownership = false)
</pre>
<p>
Similarly to <span class="ncbi_term">CORE C logger</span> setting, the returned handle can be later used
with <a href="../lxr/ident?i=CORE_SetREG"><span class="ncbi_func">CORE_SetREG()</span></a>
declared in <a href="../lxr/source/include/connect/ncbi_util.h"><span class="ncbi_file">connect/ncbi_util.h</span></a>
to set up the global registry object (<span class="ncbi_term">CORE C registry</span>).

<p>
<hr>


<a name="ref_LOCK"></a><h3>MT_LOCK and CRWLock</h3>

There is a function
<pre class="ncbi_code">
    MT_LOCK <a href="../lxr/ident?i=MT_LOCK_cxx2c">MT_LOCK_cxx2c</a> (CRWLock* lock, bool pass_ownership = false)
</pre>
declared in <a href="../lxr/source/include/connect/ncbi_core_cxx.hpp"><span class="ncbi_file">connect/ncbi_core_cxx.hpp</span></a>,
which converts an object of class <span class="ncbi_class">CRWLock</span> into a C object <span class="ncbi_type">MT_LOCK</span>. The latter can
be used as an argument to <a href="../lxr/ident?i=CORE_SetLOCK"><span class="ncbi_func">CORE_SetLOCK()</span></a> for
setting the global <span class="ncbi_term">CORE C MT-lock</span>, used by a low level code, written in C. Note that passing 0 as the lock pointer
will effectively create a new internal <span class="ncbi_class">CRWLock</span> object, which will then be converted into <span class="ncbi_type">MT_LOCK</span> and
returned. This object gets automatically destroyed when the corresponding <span class="ncbi_type">MT_LOCK</span> is asked to do so.
If the pointer to <span class="ncbi_class">CRWLock</span> is passed non <span class="ncbi_var">NULL</span> then the second argument can specify whether
resulting <span class="ncbi_type">MT_LOCK</span> acquires the ownership of the lock, thus is able to delete the lock when destructing itself.

<p>
<hr>


<a name="ref_ConnectCxx"></a><h3>CONNECT Library in C++ Code</h3>

<a name="ref_SettingLOG"></a><h4>Setting LOG</h4>

To set up the <span class="ncbi_term">CORE C logger</span> to use the same logging format of messages and destination
as used by <span class="ncbi_class">CNcbiDiag</span>, the following sequence of calls may be used:
<pre class="ncbi_code">
    CORE_SetLOG(LOG_cxx2c());
    SetDiagTrace(eDT_Enable);
    SetDiagPostLevel(eDiag_Info);
    SetDiagPostFlag(eDPF_All);
</pre>

<p>
<hr>


<a name="ref_SettingREG"></a><h4>Setting REG</h4>

To set the <span class="ncbi_term">CORE C registry</span> be the same as C++ registry <span class="ncbi_class">CNcbiRegistry</span>, the following
call is necessary:
<pre class="ncbi_code">
    CORE_SetREG(REG_cxx2c(cxxreg, true));
</pre>
here <span class="ncbi_var">cxxreg</span> is a <span class="ncbi_class">CNcbiRegistry</span> registry object created and maintained by a C++ application.

<p>
<hr>


<a name="ref_SettingLOCK"></a><h4>Setting MT-Locking</h4>

To set up a CORE lock, which is used throughout the low level code, including places of
calls of non-reentrant library calls (if no reentrant counterparts were detected during
configure process), one can place the following statement close to the beginning of the
program:
<pre class="ncbi_code">
    CORE_SetLOCK(MT_LOCK_cxx2c());
</pre>

Note that the use of this call is extremely important in a multi-threaded environment.

<p>
<hr>


<a name="ref_CONNECT_Init_Cxx"></a><h4>Convenience call CONNECT_Init()</h4>

Header file <a href="../lxr/source/include/connect/ncbi_core_cxx.hpp" class="ncbi_file">connect/ncbi_core_cxx.hpp</a>
provides convenience call, which sets all shared <span class="ncbi_proj">CONNECT</span>-related resources discussed above for an application
program written within the C++ Toolkit framework (or linked solely against the libraries contained in the
toolkit):
<pre class="ncbi_code">
    void <a href="../lxr/ident?i=CONNECT_Init">CONNECT_Init</a>(<a href="../lxr/ident?i=CNcbiRegistry">CNcbiRegistry</a>* reg = NULL);
</pre>
The call takes only one argument, an optional pointer to a registry, which is used by the application, and
should also be considered by the <span class="ncbi_proj">CONNECT</span> library.
No registry will be used if <span class="ncbi_var">NULL</span> gets passed. The ownership of the registry is passed along.
This fact should be noted by an application doing extensive use of <span class="ncbi_proj">CONNECT</span> stuff in static classes,
i.e. prior to or after main(), because the registry can get deleted before <span class="ncbi_proj">CONNECT</span> library stops
using it. The call also ties <span class="ncbi_term">CORE C logger</span> to <a href="../lxr/ident?i=CNcbiDiag"><span class="ncbi_class">CNcbiDiag</span></a>,
and privately creates <span class="ncbi_term">CORE C MT-lock</span> object (on top of <a href="../lxr/ident?i=CRWLock"><span class="ncbi_class">CRWLock</span></a>)
for internal synchronization inside the library.

<p>
An example on how to use this call could be found in the test program
<a href="../lxr/source/src/connect/test/test_ncbi_conn_stream.cpp"><span class="ncbi_file">test_ncbi_conn_stream.cpp</span></a>.
It shows how to properly setup <span class="ncbi_term">CORE C logger</span>, <span class="ncbi_term">CORE C registry</span> and <span class="ncbi_term">CORE C MT-lock</span> in order
for them to use the same data both in C and C++ parts of both the library and the remaining code of the application.

<p>
Another good source of information is working application examples found in
<a href="../lxr/source/src/app/id1_fetch"><span class="ncbi_dir">src/app/id1_fetch</span></a>.

<p>
<span class="ncbi_note">Note</span> from the examples that the convenience routine does not change logging levels or disable/enable
certain logging properties. If this is desired, the application still has to use separate calls.

<p>
<hr>


<a name="ref_CToolkitDiag"></a><h3>C Toolkit diagnostics redirection</h3>

In a C/C++ program linked against both NCBI C++ and NCBI C
Toolkits the diagnostics messages (if any) generated by either Toolkit are
not necessarily directed through same route, which may result in lost or garbled messages.
To set the diagnostics destination be the same as <span class="ncbi_class">CNcbiDiag</span>'s one, and
thus to guarantee that the messages from both Toolkits will be all stored sequentially and
in the order they were generated, there is a call
<pre class="ncbi_code">
    #include &lt;<a href="../lxr/source/include/ctools/ctools.h">ctools/ctools.h</a>&gt;

    void <a href="../lxr/ident?i=SetupCToolkitErrPost">SetupCToolkitErrPost</a>(void);
</pre>
which is put in a specially designated directory
<a href="../lxr/source/include/ctools" class="ncbi_dir">ctools</a>
providing back links to the C Toolkit from the C++ Toolkit.

<p>
<hr>


<a name="ref_ConnectC"></a><h3>CONNECT Library in C Code</h3>

<span class="ncbi_proj">CONNECT</span> library in C Toolkit has a header
<a href="../../C_DOC/lxr/source/connect/ncbi_core_c.h" class="ncbi_file">connect/ncbi_core_c.h</a>;,
which serves exactly the same purposes that does <span class="ncbi_file">connect/ncbi_core_cxx.hpp</span>
described previously. It defines an API to convert native Toolkit objects, like logger, registry, and MT-lock
into their abstract equivalents, <a href="../../C_DOC/lxr/ident?i=LOG"><span class="ncbi_type">LOG</span></a>,
<a href="../../C_DOC/lxr/ident?i=REG"><span class="ncbi_type">REG</span></a>, and
<a href="../../C_DOC/lxr/ident?i=MT_LOCK"><span class="ncbi_type">MT_LOCK</span></a>,
respectively, which defined in
<a href="../../C_DOC/lxr/source/connect/ncbi_core.h" class="ncbi_file">connect/ncbi_core.h</a>,
and subsequently can used by <span class="ncbi_proj">CONNECT</span> library as <span class="ncbi_term">CORE C</span> objects.

<p>
Briefly, the calls are:
<ul>
<li>
<pre class="ncbi_code">
    LOG <a href="../../C_DOC/lxr/ident?i=LOG_c2c">LOG_c2c</a> (void);
</pre>
Create a logger <span class="ncbi_type">LOG</span> with all messages sent to it rerouted via the error logging facility
used by the C Toolkit.
<p>
<li>
<pre class="ncbi_code">
    REG <a href="../../C_DOC/lxr/ident?i=REG_c2c">REG_c2c</a> (const char* conf_file);
</pre>
Build a registry object <span class="ncbi_type">REG</span> from a named file <span class="ncbi_var">conf_file</span>.
Passing <span class="ncbi_var">NULL</span> as an argument causes the default Toolkit registry file to be searched for and used.
<p>
<li>
<pre class="ncbi_code">
    MT_LOCK <a href="../../C_DOC/lxr/ident?i=MT_LOCK_c2c">MT_LOCK_c2c</a> (<a href="../../C_DOC/lxr/ident?i=TNlmRWlock">TNlmRWlock</a> lock, int/*bool*/ pass_ownership);
</pre>
Build an <span class="ncbi_type">MT_LOCK</span> object on top of <span class="ncbi_type">TNlmRWlock</span> handle. Note that passing <span class="ncbi_var">NULL</span> effectively
creates an internal handle, which is used as an underlying object. Ownership of the original handle can be passed
to the resulting <span class="ncbi_type">MT_LOCK</span> by setting the second argument to a non-zero value. The internally created handle
always has its ownership passed along.
</ul>

Exactly the same way as described in previous section, all objects, resulting
from the above functions, can be used to set up <span class="ncbi_term">CORE C logger</span>, <span class="ncbi_term">CORE C registry</span>, and
<span class="ncbi_term">CORE MT-lock</span> of <span class="ncbi_proj">CONNECT</span> library using the API defined in
<a href="../../C_DOC/lxr/source/connect/ncbi_util.h" class="ncbi_file">connect/ncbi_util.h</a>:
<a href="../../C_DOC/lxr/ident?i=CORE_SetLOG" class="ncbi_func">CORE_SetLOG()</a>,
<a href="../../C_DOC/lxr/ident?i=CORE_SetREG" class="ncbi_func">CORE_SetREG()</a>, and
<a href="../../C_DOC/lxr/ident?i=CORE_SetLOCK" class="ncbi_func">CORE_SetLOCK()</a>, respectively.


<a name="ref_CONNECT_Init_C"></a><h4>Convenience call CONNECT_Init()</h4>

As an alternative to using per-object settings shown in the previous paragraph, the following
"all-in-one" call is provided:
<pre class="ncbi_code">
    void <a href="../../C_DOC/lxr/ident?i=CONNECT_Init">CONNECT_Init</a> (const char* conf_file);
</pre>
This sets <span class="ncbi_term">CORE C logger</span> to go via Toolkit default logging facility, causes
<span class="ncbi_term">CORE C registry</span> to be loaded from the named file (or from the Toolkit's default
file if <span class="ncbi_var">conf_file</span> passed <span class="ncbi_var">NULL</span>), and creates <span class="ncbi_term">CORE C MT-lock</span> on top
of internally created <span class="ncbi_type">TNlmRWlock</span> handle, the ownership of which is passed
to the <span class="ncbi_type">MT_LOCK</span>.

<p>
<span class="ncbi_note">Note</span> again that properties of logging facility is not affected by this call, i.e.
the selection of what gets logged, how, and where, should be controlled by using native C Toolkit's
mechanisms defined in <a href="../../C_DOC/lxr/source/corelib/ncbierr.h" class="ncbi_file">ncbierr.h</a>.


<!--#include virtual="../ssi/navlinks.shtml" -->

<table border=0 width="100%" cellspacing=0>
<tr>
<td align=left>
  <address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Anton Lavrentiev</a></address>
</td>
<!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> -->
<td align=right><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
