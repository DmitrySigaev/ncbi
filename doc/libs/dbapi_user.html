<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->
<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
<!--#set var="TITLE" value="NCBI DBAPI User-Layer Docs" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->
<!--<B><FONT FACE="Arial" SIZE=4><P>DBAPI Interface Overview.</P></B></FONT><P>&nbsp;</P>-->
</head>
<body>

<h1>
NCBI DBAPI User-Layer Reference</h1>

<h2>
Contents</h2>

<ul>
<li>
<a href="#ref_ObjHierarchy">Object Hierarchy</a></li>

<li>
<a href="#ref_Includes">Includes</a></li>

<li>
<a href="#ref_Objects">Objects</a></li>

<li>
<a href="#ref_ObjLifeCycle">Object Life Cycle</a></li>

<li>
<a href="#ref_CVariant">CVariant Type</a></li>

<li>
<a href="#ref_ChooseDriver">Choosing the Driver</a></li>

<li>
<a href="#ref_SrcCnxns">Data Source and Connections</a></li>

<li>
<a href="#ref_MainLoop">Main Loop</a></li>

<li>
<a href="#ref_IOParams">Input and Output Parameters</a></li>

<li>
<a href="#ref_StoredProcs">Stored Procedures</a></li>

<li>
<a href="#ref_Cursors">Cursors</a></li>

<li>
<a href="#ref_Blobs">Updating BLOBs using cursors</a></li>

<li>
<a href="#ref_BulkInsert">Using bulk insert</a></li>
</ul>

<hr><a NAME="ref_ObjHierarchy"></a>
<h3>
Object hierarchy</h3>
<img SRC="dbapi_user.gif" height=464 width=681>
<br>&nbsp;
<p><a NAME="ref_Includes"></a>
<h3>
Includes</h3>
For most purposes it is sufficient to include one file in the user source
file:&nbsp;<span class="ncbi_file">dbapi.hpp</span>.
<blockquote>
<pre class="ncbi_code">#include &lt;dbapi/dbapi.hpp></pre>
</blockquote>
For static linkage the following include file is also necessary:
<blockquote>
<pre class="ncbi_code">#include &lt;dbapi/driver/drivers.hpp></pre>
</blockquote>
<a NAME="ref_Objects"></a>
<h3>
Objects</h3>
All objects are returned by pointers to their respective interfaces. The
null (0) value is valid, meaning that no object was returned.
<br><a NAME="ref_ObjLifeCycle"></a>
<h3>
Object Life Cycle</h3>
In general, any child object is valid only in the scope of its parent object.
This is because most of the objects share the same internal structures.
There is no need to delete every object explicitly, as all created objects
will be deleted upon program exit. Specifically, all objects are derived
from the static CDriverManager object, and will be destroyed when CDriverManager&nbsp;
is destroyed. It is possible to delete any object from the framework and
it is deleted along with all derived objects. For example, when a <tt><a href="../docxx/IConnection.html">IConnection</a></tt>
object is deleted, all derived&nbsp; <tt><a href="../docxx/IStatement.html">IStatement,</a><a href="../docxx/ICallableStatement.html">ICallableStatement</a></tt>&nbsp;
and <tt><a href="../docxx/IResultSet.html">IResultSet</a></tt> objects
will be deleted too.
<br>For each object a <tt>Close()</tt> method is provided. It disposes
of internal resources, required for the proper library cleanup, but leaves
the framework intact. After calling <tt>Close()</tt> the object becomes
invalid. This method may be necessary when the database cleanup and framework
cleanup are performed in different places in the code.
<br><a NAME="ref_CVariant"></a>
<h3>
CVariant type</h3>
The <a href="../docxx/CVariant.html" class="ncbi_class">CVariant</a> type
is used to represent any database data type (except BLOBs). It is an object,
not a pointer, so it behaves like a primitive C++ type. Basic comparison
operators are supported <font face="Courier New">(==, !=, &lt; </font>)
for identical internal types. If types are not identical, <a href="../docxx/CVariantException.html" class="ncbi_class">CVariantException</a>
is thrown. <a href="../docxx/CVariant.html" class="ncbi_class">CVariant</a>
has a set of getters to extract a value of a particular type, e.g.&nbsp;<span class="ncbi_func">GetInt4(),
GetByte(), GetString()</span>, etc. If&nbsp;<span class="ncbi_func">GetString()</span>
is called for a different type, like&nbsp;<span class="ncbi_type">DateTime</span>
or&nbsp;<span class="ncbi_type">integer</span> it tries to convert it to
a string. It it doesn't succeed, <a href="../docxx/CVariantException.html" class="ncbi_class">CVariantException</a>
is thrown.
<br>There is a set of factory methods (static functions) for creating <a href="../docxx/CVariant.html" class="ncbi_class">CVariant</a>
objects of a particular type, such as&nbsp;<span class="ncbi_func">CVariant::BigInt()</span>,<span class="ncbi_func">CVariant::SmallDateTime()</span>,&nbsp;<span class="ncbi_func">CVariant::VarBinary()</span>
etc. For more details please see the comments in <a href="lxr/source/include/dbapi/variant.hpp">variant.hpp</a>
file.
<br><a NAME="ref_ChooseDriver"></a>
<h3>
Choosing the driver</h3>
There are several drivers for working with different SQL servers on different
platforms. The ones presently implemented are "<span class="ncbi_lib">ctlib</span>"
(Sybase), "<span class="ncbi_lib">dblib</span>"(MS SQL, Sybase), "<span class="ncbi_lib">ftds</span>"
(MS SQLcross platform). For static linkage these drivers should be registered
manually; for dynamic linkage this is not necessary. The <a href="../docxx/CDriverManager.html" class="ncbi_class">CDriverManager</a>
object maintains all registered drivers.
<blockquote>
<pre class="ncbi_code">CDriverManager &amp;dm = CDriverManager::GetInstance();
DBAPI_RegisterDriver_CTLIB(dm);
DBAPI_RegisterDriver_DBLIB(dm);</pre>
</blockquote>
<a NAME="ref_SrcCnxns"></a>
<h3>
Data Source and Connections</h3>
The <a href="../docxx/IDataSource.html" class="ncbi_class">IDataSource</a>
interface defines the database platform. To create an object implementing
this interface, use the method&nbsp;<span class="ncbi_func">CreateDs(const
string&amp; driver)</span>. An <a href="../docxx/IDataSource.html" class="ncbi_class">IDataSource</a>
can create objects represented by an <a href="../docxx/IConnection.html" class="ncbi_class">IConnection</a>
interface, which is responsible for the connection to the database. It
is highly recommended to specify the database name as an argument to the<span class="ncbi_func">CreateConnction()</span>
method, or use the&nbsp;<span class="ncbi_func">SetDatabase()</span> method
of a <a href="../docxx/CConnection.html" class="ncbi_class">CConneciton</a>
object instead of using a reqular SQL statement. In the latter case, the
library won't be able to track the current database.
<blockquote>
<pre class="ncbi_code">IDataSource *ds = dm.CreateDs("ctlib");
IConnection *conn = ds->CreateConnection();
conn->Connect("user", "password", "server", "database");
IStatement *stmt = conn->CreateStatement();</pre>
</blockquote>
Every additional call to&nbsp;<span class="ncbi_func"><a href="../docxx/IConnection.html">IConnection</a>::CreateStatement()</span>
results in cloning the connection for each statement. These connections
inherit the same default database, which was specified in the&nbsp;<span class="ncbi_func">Connect()</span>
or&nbsp;<span class="ncbi_func">SetDatabase()</span> method. Thus if the
default database was changed by calling&nbsp;<span class="ncbi_func">SetDatabase()</span>,
all subsequent cloned connections created by&nbsp;<span class="ncbi_func">CreateStatement()</span>
will inherit this particular default database.
<br><a NAME="ref_MainLoop"></a>
<h3>
Main loop</h3>
The library simulates the main result-retrieving loop of the Sybase client
library by using the&nbsp;<span class="ncbi_func"><a href="../docxx/IStatement.html">IStatement</a>::HasMoreResults()</span>
method:
<blockquote>
<pre class="ncbi_code">stmt->Execute("select &agrave;");
while( stmt->HasMoreResults() ) {
&nbsp;&nbsp;&nbsp; if( stmt->HasRows() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IResultSet *rs = stmt->GetResultset();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieve results, if any

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( rs->Next() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int col1 = rs->GetVariant(1).GetInt4();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</pre>
</blockquote>
This method should be called until it returns false, which means that no
more results is available. It returns as soon as a result is ready. The
type of the result can be obtained by calling the&nbsp;<span class="ncbi_func"><a href="../docxx/IResultSet.html">IResultSet</a>::GetResultType()</span>
method. Supported result types are&nbsp;<span class="ncbi_var">eDB_RowResult,
eDB_ParamResult, eDB_ComputeResult, eDB_StatusResult, eDB_CursorResult</span>.
The method<span class="ncbi_func"><a href="../docxx/IStatement.html">IStatement</a>::GetRowCount()</span>
returns the number of updated or deleted rows.
<p>The&nbsp;<span class="ncbi_func"><a href="../docxx/IStatement.html">IStatement</a>::ExecuteUpdate()</span>
method is used for SQL statements that do not return rows:
<blockquote>
<pre class="ncbi_code">stmt->ExecuteUpdate("update...");
int rows = stmt->GetRowCount();</pre>
</blockquote>
The method&nbsp;<span class="ncbi_func"><a href="../docxx/IStatement.html">IStatement</a>::GetResultSet()</span>
returns an <a href="../docxx/IResultSet.html" class="ncbi_class">IResultSet</a>
object. The method&nbsp;<span class="ncbi_func"><a href="../docxx/IResultSet.html">IResultSet</a>::Next()</span>
actually does fetch, so it should be always called first. It returns false
when no more fetch data is available. All column data, except Image and
Text is represented by a single <a href="../docxx/CVariant.html" class="ncbi_class">CVariant</a>
object. The method&nbsp;<span class="ncbi_func"><a href="../docxx/IResultSet.html">IResultSet</a>::GetVariant()</span>
takes one parameter &ucirc; column number. Column numbers start with 1.
<br>&nbsp;
<p><a NAME="ref_IOParams"></a>
<h3>
Input and Output Parameters</h3>
The method&nbsp;<span class="ncbi_func"><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::SetParam(const
CVariant&amp; v, const string&amp; name)</span> is used to pass parameters
to stored procedures and dynamic SQL statements. To ensure the correct
parameter type it is recommended to use <a href="../docxx/CVariant.html" class="ncbi_class">CVariant</a>
type factories (static methods) to create a <a href="../docxx/CVariant.html" class="ncbi_class">CVariant</a>
of the required internal type. There is no internal representation for the BIT parameter type, 
please use TinyInt of Int types with 0 for false and 1 for true respectively.
Here are a few examples:&nbsp;<span class="ncbi_func"><a href="../docxx/CVariant.html">CVariant</a>::Int4(Int4
*p)</span>,&nbsp;<span class="ncbi_func"><a href="../docxx/CVariant.html">CVariant</a>::TinyInt(UInt1
*p)</span>,<span class="ncbi_func"><a href="../docxx/CVariant.html">CVariant</a>::VarChar(const
char *p, size_t len )</span> etc.
<p>There are also corresponding constructors, like&nbsp;<span class="ncbi_func"><a href="../docxx/CVariant.html">CVariant</a>::CVariant(Int4
v)</span>,&nbsp;<span class="ncbi_func"><a href="../docxx/CVariant.html">CVariant</a>::CVariant(const
string&amp; s), ...</span>, but the user must ensure the proper type conversion
in the arguments, and not all internal types can be created
using constructors.
<br>Output parameters are set by the&nbsp;<span class="ncbi_func"><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::SetOutputParam(const
CVariant&amp; v, const string&amp; name)</span> method, where the first
argument is a null <a href="../docxx/CVariant.html" class="ncbi_class">CVariant</a>
of a particular type, e.g.&nbsp;<span class="ncbi_ccode">SetOutputParam(CVariant(eDB_SmallInt),"@arg")</span>.
<p><a NAME="ref_StoredProcs"></a>
<h3>
Stored Procedures</h3>
The <a href="../docxx/ICallableStatement.html" class="ncbi_class">ICallableStatement</a>
object is used for calling stored procedures. Fist get the object itself
by calling&nbsp;<span class="ncbi_func"><a href="../docxx/IConnection.html">IConnection</a>::PrepareCall()</span>.
Then set any parameters. If the parameter name is empty, the calls to&nbsp;<span class="ncbi_func">SetParam()</span>
should be in the exact order of the actual parameters. Retrieve all results
in the main loop. Get the status of the stored procedure using the&nbsp;<span class="ncbi_func"><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::GetReturnStatus()</span>
method.
<blockquote>
<pre class="ncbi_code">ICallableStatement *cstmt = conn->PrepareCall("ProcName");
Uint1 byte = 1;
cstmt->SetParam(CVariant("test"), "@test_input");
cstmt->SetParam(CVariant::TinyInt(&amp;byte), "@byte");
cstmt->SetOutputParam(CVariant(eDB_Int), "@result");

cstmt->Execute();

while(cstmt->HasMoreResults()) {
&nbsp;&nbsp;&nbsp; if( cstmt->HasRows() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IResultSet *rs = cstmt->GetResultSet();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( rs->GetResultType() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case eDB_RowResult:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(rs->Next()) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // retrieve row results

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case eDB_ParamResult:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(rs->Next()) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieve parameter row

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}

// Get status
int status = cstmt->GetReturnStatus();</pre>
</blockquote>
It is also possible to use&nbsp;<span class="ncbi_class"><tt><a href="../docxx/IStatement.html">IStatement</span></a></tt>
interface to call stored procedures using standard SQL language call. The
difference from&nbsp;<span class="ncbi_class"><tt><a href="../docxx/ICallableStatement.html">ICallableStatement</span></a></tt>
is that there is no&nbsp;<span class="ncbi_func"><tt>SetOutputParam()</span></tt>
call. The output parameter is passed as regular&nbsp;<span class="ncbi_func"><tt>SetParam()</span></tt>
call with <i>non null<span class="ncbi_class"></i><tt><a href="../docxx/CVariant.html">CVariant</span></a></tt>
argument. There is no&nbsp;<span class="ncbi_func"><tt>GetReturnStatus()</span></tt>
call in&nbsp;<span class="ncbi_class"><tt><a href="../docxx/IStatement.html">IStatement</span></a></tt>,
so use the result type filter to get it.
<blockquote>
<pre class="ncbi_code">sql = "exec SampleProc @id, @f, @o output";
stmt->SetParam(CVariant(5), "@id");
stmt->SetParam(CVariant::Float(&amp;f), "@f");
stmt->SetParam(CVariant(5), "@o");
stmt->Execute(sql);
&nbsp;
while(stmt->HasMoreResults()) {
&nbsp;&nbsp;&nbsp; IResultSet *rs = stmt->GetResultSet();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; if( rs == 0 )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; switch( rs->GetResultType() ) {
&nbsp;&nbsp;&nbsp; case eDB_ParamResult:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( rs->Next() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NcbiCout &lt;&lt; "Output param: "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rs->GetVariant(1).GetInt4()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp; case eDB_StatusResult:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( rs->Next() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NcbiCout &lt;&lt; "Return status: "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rs->GetVariant(1).GetInt4()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp; case eDB_RowResult:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( rs->Next() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rs->GetVariant(1).GetInt4() == 2121 ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NcbiCout &lt;&lt; rs->GetVariant(2).GetString() &lt;&lt; "|"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rs->GetVariant(3).GetString() &lt;&lt; "|"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rs->GetVariant(4).GetString() &lt;&lt; "|"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rs->GetVariant(5).GetString() &lt;&lt; "|"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rs->GetVariant(6).GetString() &lt;&lt; "|"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rs->GetVariant(7).GetString() &lt;&lt; "|"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NcbiCout &lt;&lt; rs->GetVariant(1).GetInt4() &lt;&lt; "|"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rs->GetVariant(2).GetFloat() &lt;&lt; "|"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; rs->GetVariant("date_val").GetString() &lt;&lt; "|"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp; }
}

stmt->ClearParamList();</pre>
</blockquote>
<a NAME="ref_Cursors"></a>
<br>&nbsp;
<h3>
Cursors</h3>
The library currently supports basic cursor features such as setting parameters
and cursor update and delete operations.
<blockquote>
<pre class="ncbi_code">ICursor *cur = conn->CreateCursor("table_cur",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "select ... for update of ...");
IResultSet *rs = cur->Open();
while(rs->Next()) {
&nbsp;&nbsp;&nbsp; cur->Update(table, sql_statement_for_update);
}
cur->Close();</pre>
</blockquote>
<a NAME="ref_Blobs"></a>
<h3>
Updating BLOBs using cursors</h3>
It is recommended to update BLOBs using cursors, because this is the only
way to work with ODBC driver and no additional connection is open.
<blockquote>
<pre class="ncbi_code">ICursor *blobCur = conn->CreateCursor("test", "select id, blob from BlobSample for update of blob");

IResultSet *blobRs = blobCur->Open();
while(blobRs->Next()) {
&nbsp;&nbsp;&nbsp; ostream&amp; out = blobCur->GetBlobOStream(2, blob.size());
&nbsp;&nbsp;&nbsp; out.write(buf, blob.size());
&nbsp;&nbsp;&nbsp; out.flush();
}</pre>
</blockquote>
Note that <tt>GetBlobOStream()</tt> takes the column number as the first
argument and this call is invalid untill the cursor is open.
<br><a NAME="ref_BulkInsert"></a>
<h3>
Using bulk insert</h3>
Bulk insert is useful when it is necessary to insert big amounts of data.
The&nbsp;<span class="ncbi_func">IConnection::CreateBulkInsert()</span>
takes two parameters, the table name and number of columns. The&nbsp;<span class="ncbi_func">CVariant::Truncate(size_t
len)</span> method truncates the internal buffer of CDB_Text and CDB_Image
object from the end of the buffer. If no paramter specified, it erases
the whole buffer.
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NcbiCout &lt;&lt; "Initializing
BlobSample table..." &lt;&lt; endl;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string im = ......;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IBulkInsert *bi = conn->CreateBulkInsert("BlobSample",
2);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CVariant col1 = CVariant(eDB_Int);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CVariant col2 = CVariant(eDB_Text);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi->Bind(1, &amp;col1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi->Bind(2, &amp;col2);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt;
ROWCOUNT; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
string im = "BLOB data " + NStr::IntToString(i);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
col1 = i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
col2.Truncate();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
col2.Append(im.c_str(), im.size());</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bi->AddRow();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi->Complete();</tt>
<br><tt></tt>&nbsp;<tt></tt>
<p><!--#include virtual="../ssi/navlinks.shtml" --><!-- Begin footer content -->
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td ALIGN=LEFT>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Michael Kholodov</a></address>
</td>

<td><!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> --></td>

<td ALIGN=RIGHT><span class="ncbi_cvs_date">$Date: 2002/12/04 21:35:02
$</span></td>
</tr>
</table>
<!--#include virtual="../ssi/footer.shtml" -->
</body>
</html>
