<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
   <meta name="GENERATOR" content="Mozilla/4.78 [en] (WinNT; U) [Netscape]">
<!--#set var="TITLE" value="NCBI DBAPI User-Layer Docs" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->
<!--<B><FONT FACE="Arial" SIZE=4><P>DBAPI Interface Overview.</P></B></FONT><P>&nbsp;</P>-->
</head>
<body>

<h1>
NCBI DBAPI User-Layer Reference</h1>

<h2>
Contents</h2>

<ul>
<li>
<a href="#ref_ObjHierarchy">Object Hierarchy</a></li>

<li>
<a href="#ref_Includes">Includes</a></li>

<li>
<a href="#ref_Objects">Objects</a></li>

<li>
<a href="#ref_ObjLifeCycle">Object Life Cycle</a></li>

<li>
<a href="#ref_CVariant">CVariant Type</a></li>

<li>
<a href="#ref_ChooseDriver">Choosing the Driver</a></li>

<li>
<a href="#ref_SrcCnxns">Data Source and Connections</a></li>

<li>
<a href="#ref_MainLoop">Main Loop</a></li>

<li>
<a href="#ref_IOParams">Input and Output Parameters</a></li>

<li>
<a href="#ref_StoredProcs">Stored Procedures</a></li>

<li>
<a href="#ref_Cursors">Cursors</a></li>

<li>
<a href="#ref_Libraries">Libraries</a></li>
</ul>

<hr><!-- List of different sections to get indentation of text from heading
     NOTE:  spacing is preserved in PRE blocks, so that is *not* indented here!
	 NOTE:  <blockquote> converts <TAB> to 8 spaces in NS4.78; untabify those regions-->
<dl><a NAME="ref_ObjHierarchy"></a>
<h3>
Object hierarchy</h3>
<img SRC="dbapi_user.gif" height=464 width=681>
<br>&nbsp;
<p><a NAME="ref_Includes"></a>
<h3>
Includes</h3>
For most purposes it is sufficient to include one file in the user source
file: dbapi.hpp.
<pre>#include &lt;dbapi/dbapi.hpp></pre>
For static linkage the following include file is also necessary:
<pre>#include &lt;dbapi/driver/drivers.hpp></pre>
<a NAME="ref_Objects"></a>
<h3>
Objects</h3>
All objects are returned by pointers to their respective interfaces. The
null (0) value is valid, meaning that no object was returned.
<br><a NAME="ref_ObjLifeCycle"></a>
<h3>
Object Life Cycle</h3>
In general, any child object is valid only in the scope of its parent object.
This is because most of the objects share the same internal structures.
There is no need to delete every object explicitly, as all created objects
will be deleted upon program exit. Specifically, all objects are derived
from the static CDriverManager object, and will be destroyed when CDriverManager
is destroyed. Thus it is recommended to reuse the objects such as <tt><a href="../docxx/IStatement.html">IStatement,</a>
<a href="../docxx/ICallableStatement.html">ICallableStatement</a> </tt>or
delete them explicitly, if otherwise is not possible.
<br><a NAME="ref_CVariant"></a>
<h3>
CVariant type</h3>
The <tt><a href="../docxx/CVariant.html">CVariant</a></tt> type is used
to represent any database data type (except BLOBs). It is an object, not
a pointer, so it behaves like a primitive C++ type. Basic comparison operators
are supported <font face="Courier New">(==, !=, &lt; </font>) for identical
internal types. If types are not identical, <tt><a href="../docxx/CVariantException.html">CVariantException</a></tt>
is thrown. <tt><a href="../docxx/CVariant.html">CVariant</a></tt> has a
set of getters to extract a value of a particular type, e.g. <tt>GetInt4(),
GetByte(), GetString()</tt>, etc. If <tt>GetString()</tt> is called for
a different type, like <tt>DateTime</tt> or <tt>integer</tt> it tries to
convert it to a string. It it doesn't succeed, <tt><a href="../docxx/CVariantException.html">CVariantException</a></tt>
is thrown.
<br>There is a set of factory methods (static functions) for creating <tt><a href="../docxx/CVariant.html">CVariant</a></tt>
objects of a particular type, such as <tt><a href="../docxx/CVariant.html">CVariant</a>::BigInt(),
<a href="../docxx/CVariant.html">CVariant</a>::SmallDateTime(),
<a href="../docxx/CVariant.html">CVariant</a>::VarBinary()</tt>, etc. For
more details please see the comments in <a href="lxr/source/include/dbapi/variant.hpp">variant.hpp</a>
file.
<br><a NAME="ref_ChooseDriver"></a>
<h3>
Choosing the driver</h3>
There are several drivers for working with different SQL servers on different
platforms. The ones presently implemented are "<b>ctlib</b>" (Sybase),
"<b>dblib</b>"(MS SQL, Sybase), "<b>ftds</b>" (MS SQLcross platform). For
static linkage these drivers should be registered manually; for dynamic
linkage this is not necessary. The <tt><a href="../docxx/CDriverManager.html">CDriverManager</a></tt>
object maintains all registered drivers.
<blockquote>
<pre>CDriverManager &amp;dm = CDriverManager::GetInstance();
DBAPI_RegisterDriver_CTLIB(dm);
DBAPI_RegisterDriver_DBLIB(dm);

</pre>
</blockquote>
<a NAME="ref_SrcCnxns"></a>
<h3>
Data Source and Connections</h3>
The <tt><a href="../docxx/IDataSource.html">IDataSource</a></tt> interface
defines the database platform. To create an object implementing this interface,
use the method <tt>CreateDs(const string&amp; driver)</tt>. An <tt><a href="../docxx/IDataSource.html">IDataSource</a></tt>
can create objects represented by an <tt><a href="../docxx/IConnection.html">IConnection</a></tt>
interface, which is responsible for the connection to the database. It
is highly recommended to specify the database name as an argument to the
<tt>CreateConnction()</tt>
method, or use the <tt>SetDatabase()</tt> method of a <tt><a href="../docxx/CConnection.html">CConneciton</a></tt>
object instead of using a reqular SQL statement. In the later case, the
library won't be able to track the current database.
<blockquote>
<pre>IDataSource *ds = dm.CreateDs("ctlib");
IConnection *conn = ds->CreateConnection();
conn->Connect("user", "password", "server", "database");
IStatement *stmt = conn->CreateStatement();

</pre>
</blockquote>
Every additional call to <tt><a href="../docxx/IConnection.html">IConnection</a>::CreateStatement()</tt>
results in cloning the connection for each statement. These connections
inherit the same default database, which was specified in the <tt>Connect()</tt>
or <tt>SetDatabase()</tt> method. Thus if the default database was changed
by calling <tt>SetDatabase()</tt>, all subsequent cloned connections created
by <tt>CreateStatement()</tt> will inherit this particular default database.
<br><a NAME="ref_MainLoop"></a>
<h3>
Main loop</h3>
The library simulates the main result-retrieving loop of the Sybase client
library by using the <tt><a href="../docxx/IStatement.html">IStatement</a>::HasMoreResults()</tt>
method:
<blockquote>
<pre>stmt->Execute("select à");
while( stmt->HasMoreResults() ) {
&nbsp;&nbsp;&nbsp; if( stmt->HasRows() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IResultSet *rs = stmt->GetResultset();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieve results, if any

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( rs->Next() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int col1 = rs->GetVariant(1).GetInt4();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</pre>
</blockquote>
This method should be called until it returns false, which means that no
more results is available. It returns as soon as a result is ready. The
type of the result can be obtained by calling the <tt><a href="../docxx/IResultSet.html">IResultSet</a>::GetResultType()</tt>
method. Supported result types are <tt>eRowResult, eParamResult, eComputeResult,
eStatusResult, eCursorResult</tt>. The method <tt><a href="../docxx/IStatement.html">IStatement</a>::GetRowCount()</tt>
returns the number of updated or deleted rows.
<p>The <tt><a href="../docxx/IStatement.html">IStatement</a>::ExecuteUpdate()</tt>
method is used for SQL statements that do not return rows:
<blockquote>
<pre>stmt->ExecuteUpdate("update...");
int rows = stmt->GetRowCount();

</pre>
</blockquote>
The method <tt><a href="../docxx/IStatement.html">IStatement</a>::GetResultSet()</tt>
returns an <tt><a href="../docxx/IResultSet.html">IResultSet</a></tt> object.
The method <tt><a href="../docxx/IResultSet.html">IResultSet</a>::Next()</tt>
actually does fetch, so it should be always called first. It returns false
when no more fetch data is available. All column data, except Image and
Text is represented by a single <tt><a href="../docxx/CVariant.html">CVariant</a></tt>
object. The method <tt><a href="../docxx/IResultSet.html">IResultSet</a>::GetVariant()</tt>
takes one parameter û column number. Column numbers start with 1.
<br>&nbsp;
<p><a NAME="ref_IOParams"></a>
<h3>
Input and Output Parameters</h3>
The method <tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::SetParam(const
CVariant&amp; v, const string&amp; name)</tt> is used to pass parameters
to stored procedures and dynamic SQL statements. To ensure the correct
parameter type it is recommended to use <tt><a href="../docxx/CVariant.html">CVariant</a></tt>
type factories (static methods) to create a <tt><a href="../docxx/CVariant.html">CVariant</a></tt>
of the required internal type. Here are a few examples: <tt><a href="../docxx/CVariant.html">CVariant</a>::Int4(Int4
*p), <a href="../docxx/CVariant.html">CVariant</a>::TinyInt(UInt1 *p),
<a href="../docxx/CVariant.html">CVariant</a>::VarChar(const
char *p, size_t len )</tt> etc.
<p>There are also corresponding constructors, like <tt><a href="../docxx/CVariant.html">CVariant</a>::CVariant(Int4
v), <a href="../docxx/CVariant.html">CVariant</a>::CVariant(const string&amp;
s), ...</tt>, but the user must ensure the proper type conversion in the
arguments, and not all internal types can be created using constructors.
<br>Output parameters are set by the <tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::SetOutputParam(const
CVariant&amp; v, const string&amp; name)</tt> method, where the first argument
is a null <tt><a href="../docxx/CVariant.html">CVariant</a></tt> of a particular
type, e.g. <tt>SetOutputParam(CVariant::SmallInt(0),"@arg")</tt>.<a NAME="ref_StoredProcs"></a>
<h3>
Stored Procedures</h3>
The <tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a></tt>
object is used for calling stored procedures. Fist get the object itself
by calling <tt><a href="../docxx/IConnection.html">IConnection</a>::PrepareCall()</tt>.
Then set any parameters. If the parameter name is empty, the calls to <tt>SetParam()</tt>
should be in the exact order of the actual parameters. Retrieve all results
in the main loop. Get the status of the stored procedure using the <tt><a href="../docxx/ICallableStatement.html">ICallableStatement</a>::GetReturnStatus()</tt>
method.
<blockquote>
<pre>ICallableStatement *cstmt = conn->PrepareCall("ProcName");
Uint1 status = 1;
cstmt->SetParam(CVariant("test"), "@test_input");
cstmt->SetParam(CVariant::TinyInt(&amp;status), "@status");
cstmt->SetOutputParam(CVariant::Int(0), "@result");

cstmt->Execute();

while(cstmt->HasMoreResults()) {
&nbsp;&nbsp;&nbsp; if( cstmt->HasRows() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IResultSet *rs = cstmt->GetResultSet();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( rs->GetResultType() ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case eRowResult:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(rs->Next()) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // retrieve row results

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case eParamResult:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(rs->Next()) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieve parameter row

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}

// Get status
int status = cstmt->GetReturnStatus();

</pre>
</blockquote>
<a NAME="ref_Cursors"></a>
<h3>
Cursors</h3>
The library currently supports basic cursor features such as setting parameters
and cursor update and delete operations.
<blockquote>
<pre>ICursor *cur = conn->CreateCursor("table_cur",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "select ... for update of ...");
IResultSet *rs = cur->Open();
while(rs->Next()) {
&nbsp;&nbsp;&nbsp; cur->Update(table, sql_statement_for_update);
}
cur->Close();

</pre>
</blockquote>
<a NAME="ref_Libraries"></a>
<h3>
Libraries</h3>
The following libraries should be used (the order is significant):
<dl>
<dt>
for <b>ctlib</b> (Sybase):</dt>

<br>&nbsp;
<p>&nbsp;
<p><font face="Courier New">dbapi dbapi_driver_ctlib dbapi_driver</font>
<p>plus corresponding Sybase libraries.
<dt>
for <b>dblib</b> (MS SQL):</dt>

<br>&nbsp;
<p>&nbsp;
<p><font face="Courier New">dbapi dbapi_driver_dblib dbapi_driver</font>
<p>plus Sybase <font face="Courier New">sybdb</font></dl>
</dl>
<!--#include virtual="../ssi/navlinks.shtml" --><!-- Begin footer content -->
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td ALIGN=LEFT>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Michael Kholodov</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>
<!--#include virtual="../ssi/footer.shtml" -->
</body>
</html>
