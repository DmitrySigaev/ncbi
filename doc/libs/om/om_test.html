<!--#set var="TITLE" value="NCBI C++ CGI library" -->
<!--#set var="DOCROOT" value="../.." -->
<!--#include virtual="../../ssi/header.shtml" -->
   
<div align="Center"><br>
   
<h1>Object Manager.</h1>
   
<div align="Left"><a href="#White_box_testing">White box testing.</a>
  <br>
  <a href="#Basic_tests">1.1. Basic tests.</a>
  <br>
 Creating CScope<br>
            Adding Seq_entry to the scope.<br>
            Handling Data loader<br>
  <a href="#Bio_sequence_data_handling">1.2.Bio sequence data handling tests.</a>
  <br>
  <br>
  <a href="#Black_box_testing">Black box testing.</a>
  <br>
  <a href="#Functional_tests">2.1.Functional tests</a>
  <br>
  Modify existing test program<br>
  Modify existing id1_fetch application<br>
 Working with annotations<br>
  Scope isolation (single thread)<br>
 Scope isolation (multiple threads)<br>
 <a href="#Stress_tests">2.2.Stress tests</a>
  <br>
  <a href="#Performance_tests">2.3.Performance tests</a>
  <br>
  <a href="#Recovery_tests">2.4.Recovery tests</a>
  <br>
  <a href="#Mutation_tests">2.5.Mutation tests</a>
  <br>
  <br>
  </div>
   
<div align="Left">  
<h2>Testing.</h2>
        The whole point of testing is to assure software quality. "Quality" 
 is   highly subjective term - it depends on who the customer is and their 
 overall   influence in the scheme of things.Testing involves operation of 
 a software   system under controlled conditions and evaluating the results. 
 The controlled   conditions should include both normal and abnormal conditions. 
 Testing should   intentionally attempt to make things go wrong to determine 
 if things happen   when they shouldn't or things don't happen when they should.<br>
  </div>
  </div>
   
<h2>1.<a name="White_box_testing"></a>
        White box testing.</h2>
        White box testing is based on knowledge of the internal logic of
a  system's    code. Tests are based on coverage of code statements, branches,
 paths, conditions.   Two main parts of  white box testing are unit and integration
 testing. These  are constantly updated and summarized in regression test
programs.<br>
  <br>
   
<h2>2.<a name="Black_box_testing"></a>
        Black box testing.</h2>
        Black box testing is not based on any knowledge of internal design
 or  code.  Tests are based on requirements and functionality. Test cases
include<br>
   
<ul>
       
  <li>functional - based on functional requirements,</li>
       
  <li>stress - testing under unusually heavy loads,</li>
       
  <li>performance - how fast the system reacts to client requests,</li>
       
  <li>recovery - how the system recovers from crashes, hardware failures
etc, and</li>
       
  <li>mutation testing - how the systems handles incorrect and changing input
   data.</li>
   
</ul>
   
<h2>Test cases.</h2>
   
<h3>1.1. <a name="Basic_tests"></a>
        Basic tests.</h3>
        No real bio sequence data.<br>
        Assumptions:        
<ul>
       
  <li>CObjectManager must be created on the heap as a referenced object (in
    CRef container),</li>
       
  <li>CScope object may be created on the stack (as an automatic object),
    on the heap (using operator new) - both as a referenced object or not,</li>
       
  <li>CDataLoader object must be created on the heap as a referenced object
    ,</li>
       
  <li>CSeq_entry object must be created on the heap as a referenced object.</li>
   
</ul>
   
<h4>1.1.1 Creating CScope.</h4>
        Create data loader 1 and register it with the object manager  as
a  non-default    one.<br>
          Create data loader 2 and register it with the object manager  as
 a  default   one.<br>
          Create scope 1 as a referenced object on the heap.<br>
          Add default data loaders to the scope 1 - only data loader 2 is 
added.<br>
          Add data loader 1 to the scope 1 - now scope1 has two data loaders.<br>
          Create scope 2 as an object on the stack.<br>
          Add default data loaders to the scope 2 - only data loader 2 is 
added.<br>
        Create scope 3 on the heap (NOT as a referenced objects).<br>
          Add default data loaders to the scope 3 - only data loader 2 is 
added.<br>
        Delete scope 3 - data loader 2 is alive.<br>
          Both scopes go out of scope - both scopes are deleted, both data
 loaders     are alive.<br>
          Object manager goes out of scope - both data loaders are deleted. 
        
<h4>1.1.2. Adding Seq_entry to the scope.</h4>
        Create 3 scope objects, using three described methods.<br>
        Create seq_entry object.<br>
        Add seq_entry object to all scopes - only one data source must be 
created.<br>
        Delete scope on the heap - data source and seq_entry objects are
alive.<br>
        Remaining scopes go out of scope - data source and seq_entry objects
  are   deleted.        
<h4>1.1.3. Handling Data loader.</h4>
        Create data loader 1.<br>
        Create scope and add default data loaders to it - nothing is added.<br>
        Add data loader 1 to scope (by name) - object manager generates an
 exception    saying that such data loader is unknown.<br>
        Register data loader 1 with object manager as a non-default one.<br>
        Add default data loaders to scope - nothing is added.<br>
        Add data loader 1 to scope - the call succeedes.<br>
        Revoke data loader 1 - the call must fail, which means data loader
 is  in  use.<br>
        Delete scope - data loader 1 is still alive.<br>
        Revoke data loader 1 - the call succeeds, the data loader is deleted.<br>
        Revoke data loader 1 again - object manager generates an exception
 saying    that such data loader was not registered.<br>
   
<h3>1.2 <a name="Bio_sequence_data_handling"></a>
        Bio sequence data handling tests.</h3>
        Artificially created bio sequences.<br>
  This includes existing testobjmgr1.cpp and testobjmgr1_mt.cpp programs.
<br>
   
<h3>   2.1 <a name="Functional_tests"></a>
   Functional tests</h3>
   
<h4>2.1.1 Modify existing test program (<a href="#Bio_sequence_data_handling">
  1.2</a>
  ).</h4>
  2.1.1.1. Modify existing bio sequence data handling test program to work
 with real data from one of NCBI databases. Make sure it gives "reasonable"
 results.<br>
  2.1.1.2. Make test application generate output in <a href="http://www.ncbi.nlm.nih.gov/BLAST/fasta.html">
  FASTA</a>
    format.Compare it with the production FASTA generator.<br>
   
<h4>2.1.2 Modify existing id1_fetch application.</h4>
   Modify existing <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/tools/id1_fetch/id1_fetch.html">
   id1_fetch</a>
    application to use new object manager and data loader. Make sure both 
versions  give identical results:<br>
   2.1.2.1 Using bio sequences from the <a href="http://www.ncbi.nlm.nih.gov/dbEST/">
  Expressed Sequence Tags</a>
   database . This data is reasonably stable (that is highly unlikely to
change  at all), so the test should always give known results.<br>
   2.1.2.2 Using mRNA (<a href="http://www.ncbi.nlm.nih.gov/genome/guide/build.html">
  contig</a>
  ) bio sequences from the <a href="http://www.ncbi.nlm.nih.gov/SNP/">Single
 Nucleotide Polymorphism</a>
   database to include variations. Note: this requires SPLIT server - to
be  able to download data pointed to by an external link.<br>
 
<h4>2.1.3. Working with annotations.</h4>
 2.1.3.1. Same activity in multiple threads.<br>
 2.1.3.2. Slightly different activity in different threads.<br>
   
<h4>2.1.4 Scope isolation (single thread)</h4>
 The tests start with two scopes "looking" at the same data.<br>
 2.1.4.1. Add data to one of scopes. Make sure the data in scopes are now 
different. 
<h4>2.1.5 Scope isolation (multiple threads)</h4>
  These tests start with scopes "looking" at the same data.<br>
  2.1.5.1 Add the same data to different scopes working in parallel threads. 
Make sure the data is added correctly.<br>
  2.1.5.2 Add different data to different scopes working in parallel thread. 
Make sure the data is added correctly.<br>
   
<h3>   2.2 <a name="Stress_tests"></a>
   Stress tests</h3>
  2.2.1. Straightforward run (single thread) though a large set of bio sequences
 (GI - genbank identifiers) to see if the cache gets cleaned and memory consumption
 is reasonable.<br>
  2.2.2. Run through a large set of GIs using several threads, which should
 run through these sets randomly in different directions, sometimes ("not
too often") overlapping.<br>
 2.2.3. Run two threads: one is "slow", another is "fast". The purpose of 
the second thread is to overflow the memory cache.<br>
   
<h3>   2.3 <a name="Performance_tests"></a>
   Performance tests</h3>
How fast does it work? The test should be done on highly splitted data.<br>
2.3.1.Run GenBank formatter (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/tools/id1_fetch/id1_fetch.html">
id1_fetch</a>
) on the same GI several (3-7?) times, then run the same job in our test program
(<a href="#Functional_tests">2.1.2</a>
) in a single and multiple threads on a single and multi-processor computer.
Make sure all threads and all runs produce identical result. What is speed-up
ratio? The test must be done both for simple sequences (<a href="http://www.ncbi.nlm.nih.gov/dbEST/">
EST</a>
) and complex ones (<a href="http://www.ncbi.nlm.nih.gov/SNP/">SNP</a>
).<br>
2.3.2. repeat 2.3.1 with FASTA formatter.<br>
<br>
   
<h3>   2.4 <a name="Recovery_tests"></a>
   Recovery tests</h3>
  2.4.1. ??<br>
   
<h3>   2.5 <a name="Mutation_tests"></a>
   Mutation tests</h3>
  2.5.1. There should be at least two scopes looking at the same bio sequence.
 During the work, the data in the database change. This should be adequately
 reflected in object manager's data.<br>
  2.5.2. Incorrect data? Probably it could be simulated by reading data from
 file.<br>
  <br>
  <br>
  <br>
  <br>
  
 
<!--#include virtual="../../ssi/footer.shtml" -->
