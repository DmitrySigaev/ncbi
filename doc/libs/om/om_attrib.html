<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
                                                                        
                              
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
  <title>Object Manager classes - attributes and operations</title>
    
</head>
 <body>
<div align="Center">
<h1>Object Manager.</h1>
</div>
<h2>Classes - attributes and operations.</h2>
<a href="#Object_manager">Object manager</a>
<br>
<a href="#Scope">Scope</a>
<br>
<a href="#Bioseq_handle">Bioseq handle</a>
<br>
<a href="#Seq_vector">Seq vector</a>
<br>
<a href="#Seq_map">Seq map</a>
<br>
<a href="#Data_loader">Data loader</a>
<br>
<a href="#Description_iterator">Description iterator</a>
<br>
<a href="#Annotation_iterator">Annotation iterator</a>
<br>
<a href="#Feature_iterator">Feature iterator</a>
<br>
<a href="#Graph_data_iterator">Graph data iterator</a>
<br>
<a href="#Alignment_iterator">Alignment iterator</a>
<br>
<br>
<h3><a name="Object_manager"></a>
        Object manager.</h3>
                         Before being able to use any Scopes, client must 
create    and   initialize      Object  Manager (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CObjectManager">
      CObjectManager</a>
      ). Initialization functions include registration    of Data   loaders,
    some  of which may be declared as default ones. All   default Data  
loaders     are added  to a Scope when the latter asks for them.   All Data
loaders     are  named, so Scopes may refer to them by name. Another   kind
of data   object   is  <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_entry">
                         CSeq_entry</a>
                          &#8211; it does not require any data loader, but also 
may   be  registered      with   the Object Manager. Seq.entry may not be 
a default    data object.                       
<h4>    Object methods:</h4>
<code>// register existing data loader.</code><br>
<code>// data loader must be created in the heap (ie using operator new)</code><br>
<code><b>void RegisterDataLoader(CDataLoader&amp; loader, EIsDefault is_default
            = eNonDefault);</b></code><br>
<code>// Revoke previously registered data loader.</code><br>
<code>// Return FALSE if the loader is still in use (by some scope).</code><br>
<code>// Throw an exception if the loader is not registered with this ObjMgr.</code><br>
<b><code>bool RevokeDataLoader(CDataLoader&amp; Loader);</code></b><br>
<b><code>bool RevokeDataLoader(string LoaderName);</code></b><br>
<code>// register top-level seq_entry</code><br>
<b><code>bool RegisterTopLevelSeqEntry(CSeq_entry&amp; TopEntry);</code></b><br>
<br>
<h3><a name="Scope"></a>
        Scope.</h3>
                     Scope (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CScope">
      CScope</a>
      ) is designed to be a lightweight object, which could be  easily  
 created     and destroyed. Scope may even be created on the stack  &#8211; as
an  automatic    object.  Scope is populated with data by adding data loaders 
or  already   created  Seq_entries  to it. Data loader can only be added by
name,  that   is it must  be registered  with the Object Manager beforehand. 
  It is  impossible  to add  a data loader  directly to the scope or remove 
 it. Once  an externally  created  Seq_entry is added to a Scope, it should 
 not be modified  any more.  Safe solution  would  be creating a copy of the
 Seq_entry and storing  it  instead of the original  - this was refused because
 bio sequences may contain  huge amount of data and copying it without a
good  reason is impractical in most cases.<br>
<h4>Object methods:</h4>
<code>// Constructor:</code><br>
<b><code>CScope( CObjectManager&amp; ObjMgr);</code></b><br>
<code>// Add default data loaders and seq_entries from object manager</code><br>
<b><code>bool AddDefaults(void);</code></b><br>
<code>// Add data loader by name (the loader must be known to Object Manager)</code><br>
<b><code>bool AddDataLoader(string LoaderName);</code></b><br>
<code>// Add seq_entry    </code><br>
<b><code>bool AddTopLevelSeqEntry(CSeq_entry&amp; TopEntry);</code></b><br>
<code>// Drop seq_entry    </code><br>
<b><code>bool DropTopLevelSeqEntry(CSeq_entry&amp; TopEntry);</code></b><br>
<code>// Add annotations to a seq-entry (seq or set)</code><br>
<b><code>bool AttachAnnot(const CSeq_entry&amp; entry, CSeq_annot&amp; annot);</code></b><br>
<code>// Construct BioseqHandle</code><br>
<b><code>CBioseqHandle  GetBioseqHandle(const CSeq_id&amp; id);</code></b><br>
<br>
<h3><a name="Bioseq_handle"></a>
        Bioseq handle.</h3>
                  When a client wants to access a bio sequence data, it asks
  the   Scope    for   a Bioseq handle (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBioseq_Handle">
      CBioseq_Handle</a>
      ). Bioseq handle object is responsible for resolving    any internal
   references  in the sequence. It has comparison operators,  which   make 
 sense   only for objects created by the same Scope. It is impossible    
to compare Bioseq   handles created by different Scopes.<br>
<h4>Object methods:</h4>
<code>// public constructors<br>
<b>CBioseq_Handle(const CBioseq_Handle&amp; h);<br>
                CBioseq_Handle&amp; operator= (const CBioseq_Handle&amp;
h);   </b></code><br>
<code>// Comparison</code><br>
<b><code>bool operator== (const CBioseq_Handle&amp; h) const;</code></b><br>
<b><code>bool operator!= (const CBioseq_Handle&amp; h) const;</code></b><br>
<b><code>bool operator&lt; (const CBioseq_Handle&amp; h) const;</code></b><br>
<code>// Validity check<br>
<b>operator bool(void)  const;<br>
               bool operator!(void) const;</b></code><br>
<code>// Get Seq_id</code><br>
<b><code>const CSeq_id* GetSeqId(void)  const;</code></b><br>
<code>// Get the complete bioseq (as loaded by now)</code><br>
<b><code>const CBioseq&amp; GetBioseq(void) const;</code></b><br>
<code>// Get top level seq-entry for a bioseq</code><br>
<b><code>const CSeq_entry&amp; GetTopLevelSeqEntry(void) const;</code></b><br>
<code>// Get bioseq core structure</code><br>
<b><code>TBioseqCore GetBioseqCore(void) const;</code></b><br>
<code>// Get sequence map.</code><br>
<b><code>const CSeqMap&amp; GetSeqMap(void) const;</code></b><br>
<code>// construct SeqVector</code><br>
<b><code>virtual CSeqVector GetSeqVector(bool plus_strand = true);</code></b><br>
<code>// Get sequence's title (used in various flat-file formats.)<br>
<b>virtual string GetTitle(TGetTitleFlags flags = 0);</b></code><br>
<br>
<h3><a name="Seq_vector"></a>
        Seq vector.</h3>
              SeqVector (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeqVector">
      CSeqVector</a>
      ) is a sequence data container. The object may only be constructed
    by  a Bioseq handle. Seq.vector not necessarily contains all the sequence
     data. It rather requests it from all available sources when needed.
In   order    to do so it may access Data loader or other Data sources within
 the same   Scope. It may not access other Scopes.<br>
<h4>Object methods:</h4>
<code> // public constructors<br>
<b>CSeqVector(const CSeqVector&amp; vec);<br>
             CSeqVector&amp; operator= (const CSeqVector&amp; vec);</b><br>
             // size<br>
<b>size_t size(void);</b><br>
              // 0-based array of residues<br>
<b>TResidue operator[] (int pos);</b><br>
              // Target sequence coding.<br>
<b>TCoding GetCoding(void);<br>
              void SetCoding(TCoding coding);</b><br>
              // Set coding to either Iupacaa or Iupacna depending on molecule
   type<br>
<b>void SetIupacCoding(void);</b></code><br>
<br>
<h3><a name="Seq_map"></a>
        Seq map.</h3>
            Seqmap (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeqMap">
      CSeqMap</a>
      ) object gives a general description of the bio sequence data: location 
    and type only without data itself. The object may only be constructed 
 by   a Bioseq handle.<br>
<h4>Object methods:</h4>
<code> // public constructors<br>
<b>CSeqMap(const CSeqMap&amp; another);<br>
            CSeqMap&amp; operator=(const CSeqMap&amp; another);</b><br>
            // size of the map<br>
<b>const size_t size(void) const;</b><br>
            // Get an interval<br>
<b>const CSegmentInfo&amp; operator[](int seg_idx) const;</b></code>
<h4>CSeqMap::CSegmentInfo object methods:</h4>
<code> // public constructors<br>
<b>CSegmentInfo(const CSegmentInfo&amp; seg);<br>
          CSegmentInfo&amp; operator= (const CSegmentInfo&amp; seg);<br>
          bool operator== (const CSegmentInfo&amp; seg) const;<br>
          bool operator&lt;  (const CSegmentInfo&amp; seg) const;</b><br>
        // Sequence interval description <br>
<b>ESegmentType GetType(void) const;<br>
          TSeqPosition GetPosition(void) const;<br>
          TSeqLength   GetLength(void) const;</b></code><br>
<br>
<h3><a name="Data_loader"></a>
        Data loader.<br>
</h3>
<h3><a name="Description_iterator"></a>
        Description iterator.</h3>
      Description iterator (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDesc_CI">
      CDesc_CI</a>
      ) uses Bioseq handle to access the sequence data. It enables to enumerate
  all <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_descr">
    CSeq_descr</a>
     data objects the sequence refers to.<br>
<h4>Object methods:</h4>
<code> // Constructors <br>
<b> CDesc_CI(const CBioseq_Handle&amp; handle);<br>
      CDesc_CI(const CDesc_CI&amp; iter);<br>
      CDesc_CI&amp; operator= (const CDesc_CI&amp; iter);</b><br>
      // Search for data <br>
<b>CDesc_CI&amp; operator++ (void);<br>
      CDesc_CI&amp; operator++ (int);</b><br>
      // Validity check <br>
<b>operator bool (void) const;</b><br>
      // Data access operators <br>
<b>const CSeq_descr&amp; operator*  (void) const;<br>
      const CSeq_descr* operator-&gt; (void) const;</b><br>
</code><br>
<h3><a name="Annotation_iterator"></a>
        Annotation iterator.</h3>
             Any annotation iterator (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CAnnotTypes_CI">
    CAnnotTypes_CI</a>
    ) starts with the following data: sequence location    (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SDKDOCS/SEQLOC.HTML">
         Seq_loc</a>
             ) and a Scope. In turn, Seq_loc refers to a Seq_id. Examining
 all   Data   Sources  in the Scope, iterator object finds all top-level
seq.entries,    which  contain  annotations pointing to the proper Seq_id.
After that the    special  filtering  rules are to be applied:<br>
<br>
<ol>
  <li>If a top-level seq.entry (TSE) contains bio sequence identified by the
Seq_id, include the TSE into the resulting TSE set. If multiple TSEs contain
bio sequence, possibly identified by ID (e.g., different versions of the
same accession, while ID specifies accession only), select the live TSE and
ignore dead entries. If all TSEs selected are dead, report an error - we
cannot decide which one is acceptable. (The latest information about the
ID sequence will always include good annotations for this sequence).</li>
  <li>If multiple TSEs contain bioseqs, possibly identified by ID, and one 
      of these TSEs has been recorded in the Scope's history, select this 
TSE    and  ignore other entries. If more than one TSE can be found in the 
Scope's    history,  report an error. (This means, the user has explicitly 
selected   a dead sequence  for his query).</li>
  <li>If a TSE, containing only references to ID (but no bioseqs identified 
      by ID) is live, include it into the resulting set. (Live TSE always 
contains      information, which may be used to describe the sequence, even 
if the sequence     itself is already dead).</li>
  <li>From dead TSEs not containing the ID bioseq itself select only those 
      found in the scope's history. (Dead TSE means it is not good anymore 
 and    should not be used to describe the ID sequence, no matter live or 
dead.  History  record means the user has explicitly selected the dead TSE 
for his  query).</li>
</ol>
<br>
             The algorithm for selecting TSEs is as follows:<br>
<ol>
  <li>Select all TSEs, containing annotations with references to the ID;</li>
  <li>Find all TSEs from the set selected in (1), containing bioseqs identified 
      by ID;</li>
  <li>Check the scope's history for TSEs found in (2). If there is more than 
      one match - report an error. If there is one match, select it and ignore 
     others, proceed to (5). If there are no matches, proceed to (4).</li>
  <li>Check whether any of the TSEs from the (2) set is live. If there is 
      no live TSE and the set contains multiple dead TSEs, report an error. 
  Otherwise    select the live or the only dead TSE.</li>
  <li>From the set of TSEs found in (1) exclude all TSEs selected in (2).</li>
  <li>From (5) select live TSEs, include all in the resulting set.</li>
  <li>From (5) select dead TSEs. From the resulting set select TSEs contained 
      in the scope's history.</li>
</ol>
    Annotation iterator is a base class for defining other iterators (feature,
  graph and alignment) - it is not used directly.<br>
<h3><a name="Feature_iterator"></a>
        Feature iterator.</h3>
    Feature iterator (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CFeat_CI">
    CFeat_CI</a>
    ) is kind of annotation iterator. It enumerates <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_feat">
    CSeq_feat</a>
     data objects the sequence refers to.<br>
<h4>Object methods:</h4>
<code> // Constructors<br>
<b> CFeat_CI(CScope&amp; scope, const CSeq_loc&amp; loc, SAnnotSelector::TFeatChoice
feat_choice);<br>
 CFeat_CI(const CFeat_CI&amp; iter);<br>
 CFeat_CI&amp; operator= (const CFeat_CI&amp; iter);<br>
</b> // Search for data<br>
<b>CFeat_CI&amp; operator++ (void);<br>
 CFeat_CI&amp; operator++ (int);<br>
</b>    // Validity check<br>
<b>operator bool (void) const;<br>
</b>  // Data access<br>
<b>const CSeq_feat&amp; operator* (void) const;<br>
 const CSeq_feat* operator-&gt; (void) const;<br>
</b></code><br>
<h3><a name="Graph_data_iterator"></a>
        Graph data iterator.</h3>
    Graph data iterator (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CGraph_CI">
    CGraph_CI</a>
     ) is kind of annotation iterator. It enumerates <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_graph">
    CSeq_graph</a>
      data objects the sequence refers to.<br>
<h4>Object methods:</h4>
<code> // Constructors<br>
<b>CGraph_CI(CScope&amp; scope, const CSeq_loc&amp; loc);<br>
  CGraph_CI(const CGraph_CI&amp; iter);<br>
  CGraph_CI&amp; operator= (const CGraph_CI&amp; iter);<br>
</b> // Search for data<br>
<b>CGraph_CI&amp; operator++ (void);<br>
  CGraph_CI&amp; operator++ (int);</b><br>
    // Validity check<br>
<b>operator bool (void) const;</b><br>
  // Data access<br>
<b>const CSeq_graph&amp; operator* (void) const;<br>
  const CSeq_graph* operator-&gt; (void) const;</b></code><br>
<h3><a name="Alignment_iterator"></a>
        Alignment iterator.</h3>
    Alignment iterator (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CAlign_CI">
    CAlign_CI</a>
     ) is kind of annotation iterator. It enumerates <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSeq_align">
    CSeq_align</a>
      data objects the sequence refers to.<br>
<h4>Object methods:</h4>
<code> // Constructors<br>
<b> CAlign_CI(CScope&amp; scope, const CSeq_loc&amp; loc);<br>
    CAlign_CI(const CAlign_CI&amp; iter);<br>
    CAlign_CI&amp; operator= (const CAlign_CI&amp; iter);<br>
</b> // Search for data<br>
<b>CAlign_CI&amp; operator++ (void);<br>
    CAlign_CI&amp; operator++ (int);</b><br>
    // Validity check<br>
<b>operator bool (void) const;</b><br>
    // Data access<br>
<b>const CSeq_align&amp; operator* (void) const;<br>
    const CSeq_align* operator-&gt; (void) const;</b><br>
</code><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
