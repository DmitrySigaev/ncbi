<!--#set var="TITLE" value="Thread manipulation and synchronization" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->


<h2>Thread manipulation and synchronization</h2>
<p>

<ul>
<li><a href=#usingthreads>Using threads</a>
    <ul>
    <li><a href=#cthreadpublic>CThread class public methods</a>
    <li><a href=#cthreadprotected>CThread class protected methods</a>
    <li><a href=#threadlifecycle>Thread life cycle</a>
    <li><a href=#threadref>Referencing thread objects</a>
    </ul>
<li><a href=#synchronization>Synchronization</a>
    <ul>
    <li><a href=#cfastmutex>CFastMutex, CFastMutexGuard</a>
    <li><a href=#cmutex>CMutex, CAutoMutex, CMutexGuard</a>
    <li><a href=#crwlock>CRWLock, CAutoRW, CReadLockGuard, CWriteLockGuard</a>
    </ul>
<li><a href=#tls>Thread local storage (CTls&lt;&gt; class)</a>
</ul>

<p>
This page describes how to add multithreading to your
application and how to use basic synchronization objects.
All classes are defined in
<a href=../lxr/source/include/corelib/ncbithr.hpp class="ncbi_file">include/corelib/ncbithr.hpp</a>
and
<a href=../lxr/source/include/corelib/ncbimtx.hpp class="ncbi_file">include/corelib/ncbimtx.hpp</a>.
<p>


<hr>
<p>


<a name=usingthreads></a>
<h3>Using threads</h3>

<p>
<span class="ncbi_class">CThread</span> class is defined in
<span class="ncbi_file">include/corelib/ncbithr.hpp</span>.
The <span class="ncbi_class">CThread</span> class provides all basic thread
functionality: thread creation, launching,
termination, and cleanup. To create user-defined
thread one needs only to provide the thread's
<span class="ncbi_func">Main()</span> function and, in some cases,
create a new constructor to transfer data to the
thread object, and override <span class="ncbi_func">OnExit()</span>
method for thread-specific data cleanup. To
create a custom thread:
<p>

<ol>
<li>Derive your class from <span class="ncbi_class">CThread</span>, override
<span class="ncbi_func">Main()</span> and, if necessary, <span class="ncbi_func">OnExit()</span>
methods.
<li>Create thread object in your application.
You can do this only with <span class="ncbi_ccode">new</span> operator,
since static or in-stack thread objects are prohibited
(see below). The best way to reference thread objects
is to use <span class="ncbi_type">CRef&lt;CThread&gt;</span> class.
<li>Call <span class="ncbi_func">Run()</span> to start the thread execution.
<li>Call <span class="ncbi_func">Detach()</span> to let the thread
run independently (it will destroy itself on termination then),
or use <span class="ncbi_func">Join()</span> to wait for the thread termination.
</ol>
<p>

The code should look like:
<blockquote>
<pre class="ncbi_code">
#include &lt;corelib/ncbistd.hpp&gt;
#include &lt;corelib/ncbithr.hpp&gt;

USING_NCBI_SCOPE;

class CMyThread : public CThread
{
public:
    CMyThread(int index) : m_Index(index) {}
    virtual void* Main(void);
    virtual void OnExit(void);
private:
    int m_Index;
    int* heap_var;
};


void* CMyThread::Main(void)
{
    cout &lt;&lt; "Thread " &lt;&lt; m_Index &lt;&lt; endl;

    heap_var = new int; // to be destroyed by OnExit()
    *heap_var = 12345;

    int* return_value = new int; // return to the main thread
    *return_value = m_Index;
    return return_value;
}

void CMyThread::OnExit(void)
{
    delete heap_var;
}

int main(void)
{
    CMyThread* thread = new CMyThread(33);
    thread-&gt;Run();
    int* result;
    thread-&gt;Join(reinterpret_cast&lt;void**&gt;(&result));
    cout &lt;&lt; "Returned value: " &lt;&lt; *result &lt;&lt; endl;
    delete result;
    return 0;
}
</pre>
</blockquote>


The above simple application will start one child thread,
passing <span class="ncbi_value">33</span> as the <span class="ncbi_var">index</span> value.
The thread prints <span class="ncbi_output">"Thread 33"</span> message, allocates and
initializes two integer variables, and terminates.
The thread's <span class="ncbi_func">Main()</span> function returns a pointer
to one of the allocated values. This pointer is then passed to
<span class="ncbi_func">Join()</span> method and can be used by another thread.
the other integer allocated by <span class="ncbi_func">Main()</span> is
destroyed by <span class="ncbi_func">OnExit()</span> method.
<p>

It is important not to terminate the program until there are
running threads. Program termination will cause all the running
threads to terminate also. In the above example <span class="ncbi_func">Join()</span>
function is used to wait for the child thread termination.
<p><br>


<a name=cthreadpublic></a>
<h4><a href=../lxr/ident?i=CThread>CThread</a> class public methods</h4>
<p>

<dl>

<dt><b><span class="ncbi_func">CThread(void)</span></b>
<dd>Create the thread object (without running it).

<dt><b><span class="ncbi_func">bool Run(void)</span></b>
<dd>Spawn the new thread, initialize internal <span class="ncbi_class">CThread</span> data
and launch user-provided <span class="ncbi_func">Main()</span>. The method
guarantees that the new thread will start before it returns
to the calling function.

<dt><b><span class="ncbi_func">void Detach(void)</span></b>
<dd>Inform the thread that user does not need to wait for
its termination. Detached thread will
destroy itself after termination. If  <span class="ncbi_func">Detach()</span> is called for
a thread, which has already terminated, it will be scheduled
for destruction immediately. Only one call to  <span class="ncbi_func">Detach()</span>
is allowed for each thread object.

<dt><b><span class="ncbi_func">void Join(void** exit_data)</span></b>
<dd>Wait for the thread termination.  <span class="ncbi_func">Join()</span> will store the
<span class="ncbi_type">void</span> pointer as returned by the user's <span class="ncbi_func">Main()</span>
method, or passed to the <span class="ncbi_func">Exit()</span> function to the
<span class="ncbi_var">exit_data</span>. Then the thread will be scheduled for destruction.
Only one call to <span class="ncbi_func">Join()</span> is allowed for each
thread object. If called more than once, <span class="ncbi_func">Join()</span> will
cause a runtime error.

<dt><b><span class="ncbi_func">static void Exit(void* exit_data)</span></b>
<dd>This function may be called by a thread object itself
to terminate the thread. The thread will be terminated
and, if already detached, scheduled for destruction.
<span class="ncbi_var">exit_data</span> value is transferred to the  <span class="ncbi_func">Join()</span>
function as if it was returned by the <span class="ncbi_func">Main()</span>.
<span class="ncbi_func">Exit()</span> will also call virtual method
<span class="ncbi_func">OnExit()</span> to execute user-provided cleanup code (if any).

<dt><b><span class="ncbi_func">bool Discard(void)</span></b>
<dd>Schedules the thread object for destruction if it
has not been run yet. This function is provided since
there is no other way to delete a thread object without
running it. On success, return <span class="ncbi_value">true</span>.
If the thread has already been run,  <span class="ncbi_func">Discard()</span> do
nothing and return <span class="ncbi_value">false</span>.

<dt><b><span class="ncbi_func">static CThread::TID GetSelf(void)</span></b>
<dd>This method returns a unique thread ID. This ID may
be then used to identify threads, for example, to track the
owner of a shared resource. Since the  main thread
has no associated  <span class="ncbi_class">CThread</span> object, a special value of 0
(zero) is reserved for the main thread ID.

</dl>
<p><br>


<a name=cthreadprotected></a>
<h4><a href=../lxr/ident?i=CThread>CThread</a> class protected methods</h4>
<p>

<dl>
<dt><b><span class="ncbi_func">virtual void* Main(void)</span></b>
<dd> <span class="ncbi_func">Main()</span> is the thread's main function
(just like an application <span class="ncbi_func">main()</span> function).
This method is not defined in the <span class="ncbi_class">CThread</span> class.
It must be provided by derived user-defined class. The return
value is passed to the <span class="ncbi_func">Join()</span> function (and thus
may be used by another thread for some sort of inter-thread
communication).

<dt><b><span class="ncbi_func">virtual void OnExit(void)</span></b>
<dd>This method is called (in the context of the thread) just before
the thread termination to cleanup thread-specific resources.
 <span class="ncbi_func">OnExit()</span> is NOT called by <span class="ncbi_func">Discard()</span>, since the thread
has not been run in this case and there are no thread-specific
data to destroy.

<dt><b><span class="ncbi_func">virtual ~CThread(void)</span></b>
<dd>The destructor is protected to avoid
thread object premature destruction. For this reason,
no thread object can be static or stack-allocated.
It is important to declare any  <span class="ncbi_func">CThread</span> derived
class destructor as <span class="ncbi_keyword">protected</span>.
</dl>
<p><br>



<a name=threadlifecycle></a>
<h4>Thread life cycle</h4>
<p>

The following diagram shows typical thread life
cycle.

<blockquote>
<pre class="ncbi_code_sm">
Parent thread                Child thread                Parent thread                Child thread
    |                                                        |
    |                                                        |
    constructor                                              constructor
    |                                                        |
    |                                                        |
    Run()------------------------                            Run()------------------------
    |                            |                           |                            |
    |                            Main()                      |                            Main()
    Join()                       |                           |                            |
    .                            |                           |                            |
    .                            Exit(), OnExit()            |                            Exit(), OnExit()
    .----------------------------X                           |----------------------------X
    destructor                                               |
    |                                                        Join(), destructor
    |                                                        |
                                                             |


Parent thread                Child thread                Parent thread                Child thread
    |                                                        |
    |                                                        |
    constructor                                              constructor
    |                                                        |
    |                                                        |
    Run()------------------------                            Run()------------------------
    |                            |                           |                            |
    |                            Main()                      |                            Main()
    Detach()                     |                           |                            |
    |                            |                           |                            |
    |                            Exit(), OnExit(),           |                            Exit(), OnExit()
    |                            destructor                  |----------------------------X
    |----------------------------X                           |
    |                                                        Detach(), destructor
    |                                                        |
                                                             |
</pre>
</blockquote>

The diagram demonstrates that thread constructors called from the parent
thread. The child thread is spawned by the <span class="ncbi_func">Run()</span> function only.
Then, the user-provided <span class="ncbi_func">Main()</span> method (containing code created
by user) gets executed. The thread's destructor may be called in the
context of either parent or child thread depending on the state of the thread
at the moment when <span class="ncbi_func">Join()</span> or <span class="ncbi_func">Detach()</span> is called.
<p>

There are two possible ways to terminate a thread. By default,
after user-provided <span class="ncbi_func">Main()</span> function return, the <span class="ncbi_func">Exit()</span> is called
implicitly to terminate the thread. User functions can call
<span class="ncbi_func">CThread::Exit()</span> directly. Since <span class="ncbi_func">Exit()</span> is a static method,
the calling function does not need to be a thread class member or
have a reference to the thread object. <span class="ncbi_func">Exit()</span> will terminate
the thread in which context it is called.
<p>

The  <span class="ncbi_class">CThread</span> destructor is <span class="ncbi_keyword">protected</span>. The same
must be true for any user-defined thread class in order to prohibit
creation of static or automatic thread objects. For the same reason,
a thread object can not be destroyed by explicit <span class="ncbi_ccode">delete</span>.
All threads destroy themselves on termination, detaching,
or joining.
<p>

On thread termination, <span class="ncbi_func">Exit()</span> checks if the thread has been detached
and, if this is true, destroys the thread object. If the thread
has not been detached, the thread object will remain "zombie"
unless detached or joined. Either <span class="ncbi_func">Detach()</span> or <span class="ncbi_func">Join()</span> will
destroy the object if the thread has been terminated. One should
keep in mind, that it is not safe to use the thread object
after a call to <span class="ncbi_func">Join()</span> or <span class="ncbi_func">Detach()</span> since the object may happen
to be destroyed. To avoid this situation, the <span class="ncbi_type">CRef&lt;CThread&gt;</span> can
be used. The thread object will not be destroyed until there is
at least one <span class="ncbi_class">CRef</span> to the object (although it may be terminated
and scheduled for destruction).
<p>

In other words, a thread object will be destroyed when all
of the following conditions are satisfied:
<p>

<ul>
<li>the thread has been run and terminated by an implicit or
explicit call to <span class="ncbi_func">Exit()</span>
<li>the thread has been detached or joined
<li>no <span class="ncbi_class">CRef</span> references the thread object
</ul>
<p>

Which thread will actually destroy a thread object depends on several
conditions. If the thread has been detached before termination,
the <span class="ncbi_func">Exit()</span> method will destroy it, provided there
are no <span class="ncbi_class">CRef</span> references to the object. When joined, the thread
will be destroyed in the context of a joining thread. If
<span class="ncbi_func">Detach()</span> is called after thread termination, it will destroy
the thread in the context of detaching thread. And, finally,
if there are several <span class="ncbi_class">CRef</span> objects referencing the same thread,
it will be destroyed after the last <span class="ncbi_class">CRef</span> release.
<p>

This means that cleaning up thread-specific data can not be
done from the thread destructor. One should override <span class="ncbi_func">OnExit()</span>
method instead. <span class="ncbi_func">OnExit()</span> is guaranteed to be called in the
context of the thread before the thread termination. The destructor
can be used to cleanup non-thread-local data only.
<p>

There is one more possibility to destroy a thread. If a thread has been
created, but does not need to be run, one can use
<span class="ncbi_func">Discard()</span> method to destroy the thread object without
running it. Again, the object will not be destroyed until there
are <span class="ncbi_class">CRef</span>s referencing it.
<p><br>


<a name=threadref></a>
<h4>Referencing thread objects</h4>
<p>

It should be emphasized that regular (C) pointer to a thread object
is not reliable. The thread may terminate at unpredictable
moment, destroying itself. There is no possibility to safely
access thread object after <span class="ncbi_func">Join()</span> using C pointers. The only
solution to this problem is to use  <span class="ncbi_class">CRef</span> class. <span class="ncbi_class">CThread</span>
class provides a mechanism to prevent premature destruction
if there are <span class="ncbi_class">CRef</span> references to the thread object.
<p>


<hr>
<p><br>


<a name=synchronization></a>
<h3>Synchronization</h3>

The following classes implement threads synchronization mechanisms:
<p>

<ul>
<li><span class="ncbi_class">CFastMutex, CFastMutexGuard</span>
<li><span class="ncbi_class">CMutex, CMutexGuard</span>
<li><span class="ncbi_class">CRWLock, CAutoRW, CReadLockGuard, CWriteLockGuard</span>
</ul>
<p><br>



<a name=cfastmutex></a>
<h4><a href=../lxr/ident?i=CFastMutex>CFastMutex</a>,
<a href=../lxr/ident?i=CFastMutexGuard>CFastMutexGuard</a>,
<a href=../lxr/ident?i=DEFINE_STATIC_FAST_MUTEX>DEFINE_STATIC_FAST_MUTEX</a>,
<a href=../lxr/ident?i=DECLARE_CLASS_STATIC_FAST_MUTEX>DECLARE_CLASS_STATIC_FAST_MUTEX</a>,
<a href=../lxr/ident?i=DEFINE_CLASS_STATIC_FAST_MUTEX>DEFINE_CLASS_STATIC_FAST_MUTEX</a></h4>
<p>

<span class="ncbi_class">CFastMutex</span> class is defined in
<a href=../lxr/source/include/corelib/ncbimtx.hpp><span class="ncbi_file">include/corelib/ncbimtx.hpp</span></a>.
This class implements basic mutex behavior with minimum performance overheads.
<span class="ncbi_func">Lock()</span> and <span class="ncbi_func">Unlock()</span>
methods will acquire and release the mutex
for the calling thread. No checks of nesting or unlocking of a
non-acquired mutex are performed. For this reason, <span class="ncbi_class">CFastMutex</span>
should be used only to protect small and simple parts of code.
To guarantee for the mutex release the <span class="ncbi_class">CFastMutexGuard</span> class
may be used. The mutex is locked by the <span class="ncbi_class">CFastMutexGuard</span>
constructor and unlocked by its destructor.
To avoid problems with initialization of static objects on different platforms, special macro definitions are intended to be used to declare static mutexes.
Macro <span class="ncbi_macro">DEFINE_STATIC_FAST_MUTEX(id)</span> will define
static mutex variable with name <span class="ncbi_var">id</span>.
Macro <span class="ncbi_macro">DECLARE_CLASS_STATIC_FAST_MUTEX(id)</span> will declare
static class member of mutex type with name <span class="ncbi_var">id</span>.
Macro <span class="ncbi_macro">DEFINE_CLASS_STATIC_FAST_MUTEX(class, id)</span> will define
static class mutex variable <span class="ncbi_var">class::id</span>.

The example below demonstrates how to protect an integer variable
with the fast mutex:
<p>

<blockquote>
<pre class="ncbi_code">
void ThreadSafe(void)
{
    static int Count = 0;
    DEFINE_STATIC_FAST_MUTEX(CountMutex);
    ...
    {{
        CFastMutexGuard guard(CountMutex);
        Count++;
    }}
    ...
}
</pre>
</blockquote>
<p><br>

<a name=cmutex></a>
<h4><a href=../lxr/ident?i=CMutex>CMutex</a>,
<a href=../lxr/ident?i=CMutexGuard>CMutexGuard</a>,
<a href=../lxr/ident?i=DEFINE_STATIC_MUTEX>DEFINE_STATIC_MUTEX</a>,
<a href=../lxr/ident?i=DECLARE_CLASS_STATIC_MUTEX>DECLARE_CLASS_STATIC_MUTEX</a>,
<a href=../lxr/ident?i=DEFINE_CLASS_STATIC_MUTEX>DEFINE_CLASS_STATIC_MUTEX</a></h4>
<p>

<span class="ncbi_class">CMutex</span> uses the functionality of <span class="ncbi_class">CFastMutex</span>.
It also allows nested locks and performs checks of mutex owner.
This makes <span class="ncbi_class">CMutex</span> somewhat slower than <span class="ncbi_class">CFastMutex</span>,
but capable of protecting complicated code, and safer to use. To guarantee
for a mutex release, <span class="ncbi_class">CMutexGuard</span> can be used.
The mutex is locked by the <span class="ncbi_class">CMutexGuard</span> constructor
and unlocked by its destructor.
Macro <span class="ncbi_macro">DEFINE_STATIC_MUTEX(id)</span> will define
static mutex variable with name <span class="ncbi_var">id</span>.
Macro <span class="ncbi_macro">DECLARE_CLASS_STATIC_MUTEX(id)</span> will declare
static class member of mutex type name <span class="ncbi_var">id</span>.
Macro <span class="ncbi_macro">DEFINE_CLASS_STATIC_MUTEX(class, id)</span> will define
class static mutex variable <span class="ncbi_var">class::id</span>.
The following example demonstrates usage of <span class="ncbi_var">CMutex</span>, including
lock nesting:
<p>


<blockquote>
<pre class="ncbi_code">
static int Count = 0;
DEFINE_STATIC_MUTEX(CountMutex);

void Add2(void)
{
    CMutexGuard guard(CountMutex);
    Count += 2;
    if (Count &lt; 20) {
        Add3();
    }
}

void Add3(void)
{
    CMutexGuard guard(CountMutex);
    Count += 3;
    if (Count &lt; 20) {
        Add2();
    }
}
</pre>
</blockquote>

This example will result in several nested locks of the same mutex
with the guaranteed release of each lock.
<p>

It is important not to unlock the mutex protected by a mutex guard.
<span class="ncbi_class">CFastMutexGuard</span> and <span class="ncbi_class">CMutexGuard</span> both unlock
the associated mutex on destruction. It the mutex is already unlocked
this will cause a runtime error. Instead of unlocking the mutex directly
one can use <span class="ncbi_func">CFastMutexGuard::Release()</span> or
<span class="ncbi_func">CMutexGuard::Release()</span> method. This
methods unlock the mutex and unlink it from the guard.
<p>

In addition to usual <span class="ncbi_func">Lock()</span> and <span class="ncbi_func">Unlock()</span> methods,
the <span class="ncbi_class">CMutex</span> class implements a method to test the mutex state before
locking it. <span class="ncbi_func">TryLock()</span> method attempts to acquire the mutex
for the calling thread and returns <span class="ncbi_value">true</span> on success (this
includes nested locks by the same thread) or <span class="ncbi_value">false</span> if the
mutex has been acquired by another thread. After a successful
<span class="ncbi_func">TryLock()</span> the mutex should be unlocked like after
regular <span class="ncbi_func">Lock()</span>.
<p>


<a name=crwlock></a>
<h4><a href=../lxr/ident?i=CRWLock>CRWLock</a>,
<a href=../lxr/ident?i=CAutoRW>CAutoRW</a>,
<a href=../lxr/ident?i=CReadLockGuard>CReadLockGuard</a>,
<a href=../lxr/ident?i=CWriteLockGuard>CWriteLockGuard</a></h4>
<p>

This class implements sharing a resource between multiple
reading and writing threads. The following rules are used
for locking:
<p>

<ul>
<li>if unlocked, the RWLock can be acquired for either
R-lock or W-lock
<li>if R-locked, the RWLock can be R-locked
by the same thread or other threads
<li>if W-locked, the RWLock can not be acquired by other
threads (a call to <span class="ncbi_func">ReadLock()</span> or <span class="ncbi_func">WriteLock()</span>
by another thread will suspend that thread until the RW-lock release).
<li>R-lock after W-lock by the same thread is allowed but treated
as a nested W-lock
<li>W-lock after R-lock by the same thread results in a runtime error
</ul>
<p>

Like <span class="ncbi_class">CMutex</span>, CRWLock also provides methods for checking its current
state: <span class="ncbi_func">TryReadLock()</span> and <span class="ncbi_func">TryWriteLock()</span>.
Both methods try to acquire the RW-lock, returning <span class="ncbi_value">true</span>
on success (the RW-lock becomes R-locked or W-locked) or
<span class="ncbi_value">false</span> if the RW-lock can not be acquired for the calling thread.
<p>


<hr>
<p>


<a name=tls></a>
<h3>Thread local storage
(<a href=../lxr/ident?i=CTls>CTls&lt;&gt;</a> class)</h3>

The library provides a template class to store
thread specific data: <span class="ncbi_class">CTls&lt;&gt;</span>. This means that each
thread can keep its own data in the same TLS object.
To perform any kind of cleanup one can provide
cleanup function and additional cleanup data when
storing a value in the TLS object.
The following example demonstrates the usage of TLS:
<p>

<blockquote>
<pre class="ncbi_code">
CRef&lt; CTls&lt;int&gt; &gt; tls;

void TlsCleanup(int* p_value, void* /* data */ )
{
    delete p_value;
}

...
void* CMyThread::Main()
{
    int* p_value = new int;
    *p_value = 1;
    tls-&gt;SetValue(p_value, TlsCleanup);
    ...
    p_value = new int;
    *p_value = 2;
    tls-&gt;SetValue(p_value, TlsCleanup);
    ...
    if (*tls-&gt;GetValue() == 2) {
        ...
    }
    ...
}
</pre>
</blockquote>


In the above example the second call to <span class="ncbi_func">SetValue()</span> will cause
the <span class="ncbi_func">TlsCleanup()</span> to deallocate the first integer variable.
To cleanup the last value stored in each TLS, the
<span class="ncbi_func">CThread::Exit()</span> function will automatically call
<span class="ncbi_func">CTls&lt;&gt;::Reset()</span> for
each TLS used by the thread.
<p>

By default, all TLS objects are destroyed on program
termination, since in most cases it is not guaranteed that
a TLS object is not (or will not be) used by a thread.
For the same reason the <span class="ncbi_class">CTls&lt;&gt;</span> destructor is
protected, so that no TLS can be created in the stack memory. The best
way of keeping TLS objects is to use <span class="ncbi_class">CRef</span>.
<p>

Calling <span class="ncbi_func">Discard()</span> will schedule the TLS to be destroyed
as soon as there are no <span class="ncbi_class">CRef</span> references to the object left.
The method should be used with care.
<p>

<!--#include virtual="../ssi/navlinks.shtml" -->

<!-- Begin footer content -->

<table border=0 width="100%" cellspacing=0>
<tr>
<td align=left>
  <address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Aleksey Grichenko</a></address>
</td>
<!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> -->
<td align=right><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
