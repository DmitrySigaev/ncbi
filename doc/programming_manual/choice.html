<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title> Choice objects in the NCBI C++ Toolkit</title>
  </head>
  <body bgcolor = white>
    <h1> Choice objects in the NCBI C++ Toolkit</h1>
<ul>
  <li> <a href="#intro"> Introduction </a>
  <li> <a href="#cppchoice"> C++ choice objects </a>
  <!--li> <a href="#typeinfo"> Type information for choice objects </a-->
</ul>

<a name="intro"> <h3> Introduction </h3>

The <a href="../tools/datatool/datatool.html"> <i>datatool</i></a> program processes the ASN.1
specification files in the <i>src/objects/</i> directories to generate the associated C++ class
definitions. The corresponding program implemented in the C Toolkit, <i>asntool</i>, used the ASN.1
specifications to generate C enums, structs, and functions. In contrast, <i>datatool</i> must generate C++
enums, classes and methods. In addition, for each defined object type, <i>datatool</i> must also
generate the associated <a href="typeinfo.html"> type information</a> method or function. <p>

There is a significant difference in how these two tools implement ASN.1
<i>choice</i> elements.  As an example, we consider the following ASN.1 specification:

<pre><font color="#000080">Object-id ::= CHOICE {
    id INTEGER, 
    str VisibleString }
</pre></font>

The ASN.1 <i>choice</i> element specifies that the corresponding object may be any <i>one</i> of the
listed types. In this case, the possible types are an integer and a string.  The approach used in
<i>asntool</i> was to implement all choice objects as <i>ValNode</i>s, which were in turn defined
as:

<pre><font color="#000080">typedef struct valnode {
    unsigned choice;
    DataVal data;
    struct valnode *next;
} ValNode;
</pre></font>

The <i>DataVal</i> field is a <i>union</i> which may directly store numerical values, or
alternatively, hold a <i>void</i> pointer to a character string or C <i>struct</i>. Thus, to process
a <i>choice</i> element in the C Toolkit, one could first retrieve the <i>choice</i> field to
determine how the data should be interpreted, and subsequently, retrieve the data via the
<i>DataVal</i> field.  In particular, no explicit implementation of individual choice objects was
used, and it was left to functions which manipulate these elements to enforce logical consistency
and error checking for legitimate values. A C <i>struct</i> which included a <i>choice</i> element
as one of its fields merely had to declare that element as type <i>ValNode</i>. This design was
further complicated by the use of a <i>void</i> pointer to store non-primitive types such as
<i>struct</i>s or character strings. <p>

In contrast, the C++ <i>datatool</i> implementation of <i>choice</i> elements defines a class with
built-in, automatic error checking for each <i>choice</i> object. The usage of smart pointers, in
combination with the <i>CObject</i> class hierarchy (and the associated type information methods)
solves many of the problems associated with working with <i>void</i> pointers.
<p>

<a name="cppchoice"> <h3> C++ choice objects</h3>
The classes generated by <i>datatool</i> for <i>choice</i> elements all have the following 
internal structure:
<pre><font color="#000080">class C[AsnChoiceName] : public CObject
{
    typedef CObject Tparent;

public:
    ...					      <font color=red>    // constructors and destructors</font>

    DECLARE_INTERNAL_TYPE_INFO();	      <font color=red>    // declare GetTypeInfo() method</font>

    enum E_Choice {			      <font color=red>    // enumerate the choice variants</font>
        e_not_set,
        e_Xxx,
	...,
    };

    typedef CXxx TXxx;			      <font color=red>    // typedef each variant class</font>
    ...	

    virtual void Reset(void);		      <font color=red>    // reset selection to none</font>

    E_Choice Which(void) const;		      <font color=red>    // return m_choice  </font>

    void Select(E_Choice index,		      <font color=red>    // change the current selection</font>
		EResetVariant reset);

    void CheckSelected(E_Choice index) const; <font color=red>    // throws exception if index != m_choice </font>
    void ThrowInvalidSelection(E_Choice index) const;

    static string SelectionName(E_Choice index);

    bool IsXxx(void) const;		      <font color=red>    // true if m_choice == eXxx</font>
    CXxx& GetXxx(void);
    const CXxx& GetXxx(void) const;
    CXxx& SetXxx(void);
    void SetXxx(const CRef&lt;CXxx>& ref);
    ...

private:

    E_Choice m_choice;			      <font color=red>    // choice state</font>
    union {
        TXxx m_Xxx;
	...
    };
    CObject *m_object;			      <font color=red>    // variant's data</font>
    void DoSelect(E_Choice index);	      <font color=red>    // helper method</font>
    static const char* const sm_SelectionNames[];
};
</pre></font>
For the above ASN.1 specification, <i>datatool</i> generates a class named <i>CObject_id</i>,
which is derived from <a href="cref.html#cobject"><i>CObject</i></a>. For each choice variant in
the specification, an enumerated value (in <i>E_Choice</i>), and an internal <i>typedef</i>
are defined, and a declaration in the <i>union</i> data member is made.
For this example then, we would have:
<pre><font color="#000080">    enum E_Choice {
        e_not_set,
        e_Id,
	e_Str
    };
    ...

    typedef int TId;
    typedef string TStr;
    ...

    union {
        TId m_Id;
        string *m_string;
    };
</pre></font>

In this case both of the choice variants are C++ built-in types. More generally however, the choice
variant types may refer to any type of object. For convenience, we refer to their C++ type names
here as "CXxx", <p>

Two private data members store information about the currently selected choice variant:
<i>m_choice</i> holds the <i>enum</i> value, and <i>m_Xxx</i> holds (or points to) the variant's
data. The choice object's member functions provide access to these two data members. <i>Which()</i>
return's the currently selected variant's <i>E_Choice enum</i> value. Each choice variant has its
own <i>Get()</i> and <i>Set()</i> methods. The <i>GetXxx()</i> methods first call
<i>CheckSelected(e_Xxx)</i>, where an exception will be thrown if <i>e_Xxx != m_choice</i>. Thus, it
is not possible to unknowingly retrieve the incorrect type of choice variant.<p>

Two <i>SetXxx()</i> methods are defined; both use the <i>Select()</i> method, which in turn, uses 
the <i>DoSelect</i> helper method. The latter uses a <i>switch(e_Xxx)</i> statement to initialize
<i>m_Xxx</i> appropriately, sets <i>m_choice</i> to <i>e_Xxx</i>, and returns. <i>SetXxx()</i> with
no arguments calls <i>Select(e_Xxx)</i> and returns <i>m_Xxx</i>. <i>SetXxx(TXxx& value)</i> also
calls <i>Select(e_Xxx)</i> but sets <i>m_Xxx</i> to <i>value</i> before returning. 
<p>

<!--a name="typeinfo"> <h3>Type information for choice objects </h3 -->

<p>
   </body>
<a href="traverse.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<!-- a href=".html"> <i> next</i> </a-->
</html>

	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
