<!--#set var="TITLE" value="Smart Pointers: the CRef Class" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1> Smart Pointers: the <span class="ncbi_class">CObject</span> and <span class="ncbi_class">CRef</span> Classes</h1>

<ul>
  <li> <a href="#autoptr">STL auto_ptrs </a>
  <li> <a href="#cref">The CRef Class </a>
  <li> <a href="#cobject">The CObject Class </a>
  <li> <a href="#exmpl">The CObjectFor class: Using smart pointers for standard types</a>
  <li> <a href="#usage">When to use CRefs and auto_ptrs</a>
  <li> <a href="#pitfalls">CRef Pitfalls</a>
</ul>

<a name="autoptr"></a>
<a href="http://www.cygnus.com/misc/wp/dec96pub/lib-utilities.html#lib.auto.ptr">
 <h3>STL auto_ptrs</h3> </a>
C programmers are well-acquainted with the advantages and pitfalls of using pointers. As is often
the case, the good news is also the bad news:
<ul>
<li> memory can be dynamically allocated as needed, but may not be deallocated as needed, due
      to unanticipated execution paths;
<li> void pointers allow heterogeneous function arguments of different types, but type
      information may not be there when you need it.
</ul>
C++ adds some additional considerations to pointer management: STL containers cannot hold <span class="ncbi_term">
reference</span> objects, so you are left with the choice of using either pointers or <span class="ncbi_term">copies</span>
of objects. Neither choice is attractive, as pointers can cause memory leaks and the copy
constructor may be expensive. </p>

The idea behind a C++ <span class="ncbi_term">smart pointer</span> is to create a wrapper class capable of holding a
pointer.  The wrapper class's constructors and destructors can then handle memory management as
the object goes in and out of scope. The problem with this solution is that it does not handle
multiple pointers to the same resource properly, and it raises the issue of ownership. This is
essentially what the
<a href="../lxr/ident?i=auto_ptr">
<span class="ncbi_class">auto_ptr</span></a> offers, but this strategy is only safe to use when the
resource maps to a single pointer variable.<p>

For example, the following code has two very serious problems:
<pre class="ncbi_code">
    int* ip = new int(5);
    {
        auto_ptr&lt;int&gt; a1(ip);
        auto_ptr&lt;int&gt; a2(ip);
    }
    *ip = 10/(*ip);
</pre>

The first problem occurs inside the block where the two <span class="ncbi_class">auto_ptr</span>s are defined.
Both are referencing the same variable pointed to by yet another C pointer, and
each considers itself to be the owner of that reference. Thus, when the block is exited,
the <span class="ncbi_ccode">delete[]</span> operation is executed twice for the same pointer. <p>

Even if this first problem did not occur - for example if only one <span class="ncbi_class">auto_ptr</span> had been
defined - the second problem occurs when we try to dereference <span class="ncbi_var">ip</span>. The
<span class="ncbi_keyword">delete</span> operation occurring as the block exits has now reset <span class="ncbi_var">*ip</span> to <span class="ncbi_value">0</span>,
so an attempt to divide by zero occurs.
<p><br>

<a name="cref"></a>
<h3>The <a href="../docxx/CRef.html">CRef</a> Class </h3>

These issues are addressed in the NCBI C++ Toolkit by using <span class="ncbi_term">reference-counted</span> smart
pointers: a resource cannot be deallocated until <em>all</em> references to it have ceased to
exist. The implementation of a smart pointer in the NCBI C++ Toolkit is actually divided
between two classes:
<a href="../docxx/CRef.html"> <span class="ncbi_class">CRef</span></a> and
<a href="../docxx/CObject.html">
<span class="ncbi_class">CObject</span></a>. <p>

The <span class="ncbi_class">CRef</span> class essentially provides a pointer interface to a <span class="ncbi_class">CObject</span>, while the
<span class="ncbi_class">CObject</span> actually stores the data and maintains the reference count to it.  The
constructor used to create a new <span class="ncbi_class">CRef</span> pointing to a particular <span class="ncbi_class">CObject</span>
automatically increments the object's reference count. Similarly, the <span class="ncbi_class">CRef</span> destructor
automatically decrements the reference count. In both cases however, the modification of the
reference count is implemented by a member function of the <span class="ncbi_class">CObject</span>.  The <span class="ncbi_class">CRef</span>
class itself does not have direct access to the reference count and contains only a single data
member -- its pointer to a <span class="ncbi_class">CObject</span>. In addition to the <span class="ncbi_class">CRef</span> class's constructors and
destructors, its interface to the <span class="ncbi_class">CObject</span> pointer includes access/mutate functions such as:

<blockquote>
<dl class="ncbi_code">
 <dt>bool Empty()
 <dt>bool NotEmpty()
 <dt>CObject* GetPointer()
 <dt>CObject& GetObject()
 <dt>CObject* Release()
 <dt>void Reset(CObject* newPtr)
 <dt>void Reset(void)
 <dt>operator bool()
 <dt>bool operator!()
 <dt>CRefBase& operator=(const CRefBase& ref)
</dl>
</blockquote>

Both the <span class="ncbi_func">Release()</span> and <span class="ncbi_func">Reset()</span> functions set the <span class="ncbi_class">CRef</span> object's <span class="ncbi_var">m_ptr</span> to
0, thus effectively removing the reference to its <span class="ncbi_class">CObject</span>. There are important distinctions
between these two functions however. The <span class="ncbi_func">Release()</span> method removes the reference without
destroying the object, while the <span class="ncbi_func">Reset()</span> method may lead to the destruction of the
object if there are no other references to it.
<p>
If the <span class="ncbi_class">CObject</span>'s internal reference count is 1 at the time <span class="ncbi_func">Release()</span> is invoked,
that reference count will be decremented to 0, and a pointer to the <span class="ncbi_class">CObject</span> is
returned. The <span class="ncbi_func">Release()</span> method can throw two types of exceptions: (1) a <span class="ncbi_term">null pointer</span> exception if <span class="ncbi_var">m_ptr</span> is already <span class="ncbi_value">0</span>, and (2) an <span class="ncbi_term">Illegal
CObject::ReleaseReference()</span> exception if there are currently other references to that
object. An object must be free of all references (but this one) before it can be
"released". In contrast, the <span class="ncbi_func">Reset(void)</span> function simply resets the <span class="ncbi_class">CRef</span>'s
<span class="ncbi_var">m_ptr</span> to 0, decrements the <span class="ncbi_class">CObject</span>'s reference count, and, if the <span class="ncbi_class">CObject</span>
has no other references and was dynamically allocated, deletes the <span class="ncbi_class">CObject</span>.

<p>
Each member function of the <span class="ncbi_class">CRef</span> class also has a <span class="ncbi_keyword">const</span> implementation that is
invoked when the pointer is to a <span class="ncbi_keyword">const</span> object. In addition, there is also a
<a href="../docxx/CConstRef.html">
<span class="ncbi_class">CConstRef</span></a> class that parallels the <span class="ncbi_class">CRef</span> class.

Both <span class="ncbi_class">CRef</span> and <span class="ncbi_class">CConstRef</span> are implemented as template classes, where the template
argument specifies the type of object which will be pointed to. For example, in the section on <a
href="traverse.html#accessMember">Traversing an ASN.1 Data Structure</a> we examined the structure of the
<span class="ncbi_class">CBiostruc</span> class and found the following type definition

<pre class="ncbi_code">
    typedef list< CRef< ::CBiostruc_id > > TId;
</pre>

As described there, this <span class="ncbi_keyword">typedef</span> defines <span class="ncbi_type">TId</span> to be a list of pointers to
<a href="../docxx/CBiostruc_id.html">
<span class="ncbi_class">CBiostruc_id</span></a> objects. And as you might expect, <span class="ncbi_class">CBiostruc_id</span> is a
specialized subclass of  <span class="ncbi_class">CObject</span>.
<p><br>

<a name="cobject"></a>
<h3> The <a href="../docxx/CObject.html">CObject</a> Class </h3>

The <span class="ncbi_class">CObject</span> class serves as a base class for all objects requiring a reference
count. There is little overhead entailed by deriving a new class from this base
class, and most objects in the NCBI C++ Toolkit are derived from the <span class="ncbi_class">CObject</span> class.
For example,
<a href="../docxx/CNCBINode.html">
<span class="ncbi_class">CNCBINode</span></a> is a direct descendant of <span class="ncbi_class">CObject</span>, and all of the other
<span class="ncbi_interface">HTML</span> classes descend either directly or indirectly from <span class="ncbi_class">CNCBINode</span>. Similarly, all
of the ASN.1 classes defined in the
<a href="../lxr/source/include/objects">
<span class="ncbi_dir">include/objects</span></a> directory, as well as many of the classes defined in the
<a href="../lxr/source/include/serial">
<span class="ncbi_dir">include/serial</span></a> directory are derived either directly or indirectly from the
<span class="ncbi_class">CObject</span> class.<p>

The <span class="ncbi_class">CObject</span> class contains a single private data member, the reference counter, and a
set of member functions which provide an interface to the reference counter. As such, it is
truly a base class which has no stand-alone utility, as it does not even provide allocation
for data values. It is the <span class="ncbi_term">descendant</span> classes, which inherit all the functionality of
the <span class="ncbi_class">CObject</span> class, that provide the necessary richness in representation and
allocation required for the widely diverse set of objects implemented in the NCBI
C++ Toolkit. Nevertheless, it is often necessary to use smart pointers on simple data types,
such as <span class="ncbi_type">int</span>, <span class="ncbi_type">string</span> etc. The <span class="ncbi_class">CObjectFor</span> class, described below, was
designed for this purpose.

<p><br>

<a name="exmpl"></a>
<h3> The <a href="../docxx/CObjectFor.html">CObjectFor</a> class: Using smart pointers for standard types</h3>

The <span class="ncbi_class">CObjectFor</span> class is derived directly from <span class="ncbi_class">CObject</span>, and is implemented as a
template class whose argument specifies the standard type that will be pointed to. In addition to
the reference counter inherited from its parent class, <span class="ncbi_class">CObjectFor</span> has a private
data member of the parameterized type, and a member function <span class="ncbi_func">GetData()</span> to access it.<p>

An example program, <a href="smart_cpp.html"> <span class="ncbi_file">smart.cpp</span></a>, uses the
<a href="../docxx/CRef.html">
<span class="ncbi_class">CRef</span></a> and <a href="../docxx/CObjectFor.html">
<span class="ncbi_class">CObjectFor</span></a> classes, and demonstrates the differences in memory management that arise
using <span class="ncbi_class">auto_ptr</span> and <span class="ncbi_class">CRef</span>.

Using an <span class="ncbi_class">auto_ptr</span> to reference an <span class="ncbi_type">int</span>, the
program tests whether or not the reference is still accessible after an auxilliary <span class="ncbi_class">auto_ptr</span>
which goes out of scope has also been used to reference it. The same sequence is then tested
using <span class="ncbi_class">CRef</span> objects instead. <p>

In the first case, the original auto_ptr, <span class="ncbi_var">orig_ap</span>,
becomes <span class="ncbi_value">NULL</span> at the moment when ownership is transferred to
<span class="ncbi_var">copy_ap</span> by the copy constructor.  Using <span class="ncbi_class">CRef</span> objects however, the reference
contained in the original <span class="ncbi_class">CRef</span> remains accessible (via <span class="ncbi_var">orig</span>) in all blocks where <span class="ncbi_var">orig</span>
is defined. Moreover, the reference itself, i.e. the object pointed to, continues to exist
until <em>all</em> references to it have been removed.

<p><br>

<a name="usage"></a>
<h3>When to use CRefs and auto_ptrs</h3>

There is some overhead in using <span class="ncbi_class">CRef</span> and <span class="ncbi_class">auto_ptr</span>, and these objects should only be used
where needed.  Memory leaks are generally caused as a result of unexpected execution paths. For
example:

<pre class="ncbi_code">
    {
        int *num = new int(5);
        ComplexFunction (num);
        delete num;
        ...
    }
</pre>
If <span class="ncbi_func">ComplexFunction()</span> executes normally, control returns to the block where it was
invoked, and memory is freed by the <span class="ncbi_keyword">delete</span> statement. Unforeseen events however, may
trigger exceptions, causing control to pass elsewhere. In these cases, the <span class="ncbi_keyword">delete</span>
statement may never be reached. The use of a <span class="ncbi_class">CRef</span> or an <span class="ncbi_class">auto_ptr</span> is appropriate
for these situations, as they both guarantee that the object will be destroyed when the
reference goes out of scope. <p>

One situation where they may not be required is when a pointer is embedded inside another
object. If that object's destructor also handles the deallocation of its embedded objects, then
it is sufficient to use a <span class="ncbi_class">CRef</span> on the containing object only.

<p><br>

<a name="pitfalls"></a>
<h3> CRef  Pitfalls</h3>

<h4>Inadvertent Object Destruction</h4>

When the last reference to a <span class="ncbi_class">CRef</span> object goes out of scope or
the <span class="ncbi_class">CRef</span> is otherwise marked for garbage collection, the object to
which the <span class="ncbi_class">CRef</span> points is also destroyed.  This  feature
helps to prevent memory leaks, but it also requires care in the use of
<span class="ncbi_class">CRef</span>s within methods and functions.

<pre class="ncbi_code">
    class CMy : public CObject
    {
    .....
    };

    void f(CMy* a)
    {
        CRef<CMy> b = a;
        return;
    }

    CMy* a = new CMy();
    f(a);
    <em>// the object "a" is now destroyed!</em>
</pre>

In this example the function <span class="ncbi_func">f()</span> establishes a local <span class="ncbi_class">CRef</span> to the
<span class="ncbi_class">CMy</span> object <span class="ncbi_var">a</span>.
 On exitting <span class="ncbi_func">f()</span> the <span class="ncbi_class">CRef</span> <span class="ncbi_var">b</span>
is destroyed, including the implied destruction of the <span class="ncbi_class">CMy</span> objects <span class="ncbi_var">a</span>.
To avoid this behavior, pass a <span class="ncbi_class">CRef</span> to the function <span class="ncbi_func">f()</span> instead of
a normal pointer variable:

<pre class="ncbi_code">
    CRef<CMy> a = new CMy();
    f(a);
    <em>// the CMy object pointed to by "a" is not  destroyed!</em>
</pre>

<p>
<hr>
<a href="exceptions.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<!--a href="typeinfo.html"> <i> next</i> </a -->

<!--#include virtual="../ssi/navlinks.shtml" -->

     <table border=0 width="100%" cellspacing=0>
        <tr>
          <td><address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
          <!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> -->
          <td align=right><span class="ncbi_cvs_date">$Date$</span></td>
     </table>

<!--#include virtual="../ssi/footer.shtml" -->
