<!--#set var="TITLE" value="User-defined type information" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>User-defined type information</h1>

<ul>
<li>
<a href="#introduction">Introduction</a></li>

<li>
<a href="#macros">Installing a <span class="ncbi_func">GetTypeInfo()</span> function: the <span class="ncbi_macro">BEGIN_/END_</span>
macros</a></li>

<li>
<a href="#addm">Specifying internal structure and class inheritance: the
<span class="ncbi_macro">ADD_</span> macros</a></li>
</ul>
<p><br>

<a NAME="introduction"></a>
<h3>Introduction</h3>

Object type information, as it is used in the NCBI C++ Toolkit, is defined
in the section on <a href="typeinfo.html">Runtime Object Type Information</a>.
As described there, all of the classes and constructs defined in the serial
<span class="ncbi_dir">include</span> and <span class="ncbi_dir">src</span> directories have a static implementation
of a <span class="ncbi_func">GetTypeInfo()</span> function that yields a <a href="typeinfo.html#ctypeinfo" class="ncbi_class">CTypeInfo</a>
for the object of interest. In this section, we describe how type information
can also be generated and accessed for user-defined types. We begin with
a review of some of the basic notions introduced in the previous discussion.
<p>The type information for a class is stored outside any instances of
that class, in a statically created <a href="typeinfo.html#ctypeinfo" class="ncbi_class">CTypeInfo</a>
object. A class's type information includes the class layout, inheritance
relations, external alias, and various other attributes that are independent
of specific instances. In addition, the type information object provides
an interface to the class's data members.
<p> Limited type information is also available for primitive data
types, enumerations, containers, and pointers. The type information for
a primitive type specifies that it is an <span class="ncbi_type">int, float,</span> or
<span class="ncbi_type">char</span>,
etc., and whether or not that element is signed. Enumerations are a special
kind of primitive type, whose type information specifies its enumeration
values and named elements. Type information for containers can specify
both the type of container and the type of elements. The type information
for a pointer provides convenient methods of access to the type information
for the type pointed to.
<p> For all types, the type information is encoded in a static <span class="ncbi_class">CTypeInfo</span>
object, which is then accessed by all instances of a given type using a
<a href="../lxr/ident?i=GetTypeInfo" class="ncbi_func">GetTypeInfo()</a>
function. For class types, this function is implemented as a static
method for the class. For non class types, <span class="ncbi_func">GetTypeInfoXxx()</span> is implemented
as a static global function, where <i>Xxx</i><!--NCBI_MARK--> is a unique suffix generated
from the type's name. With the first invocation of <span class="ncbi_func">GetTypeInfo()</span>
for a given type, the static <span class="ncbi_class">CTypeInfo</span> object is created, which
then persists (local to the function <span class="ncbi_func">GetTypeInfo()</span>) throughout execution.
Subsequent calls to <span class="ncbi_func">GetTypeInfo()</span> simply return a pointer to this
statically created local object.
<p>In order to make type information about <span class="ncbi_term">user-defined</span> classes
accessible to your application, the user-defined classes must also implement
a static <span class="ncbi_func">GetTypeInfo()</span> method. A set of preprocessor <a href="#macros">macros</a>
is available, which greatly simplifies this effort. A pre-requisite to
using these macros however, is that the class definition must include the
following line:

<a NAME="cdcl"></a>
<blockquote>
<pre class="ncbi_code">
DECLARE_INTERNAL_TYPE_INFO();</pre></blockquote>

This pre-processor macro will generate the following in-line statement
in the class definition:

<blockquote>
<pre class="ncbi_code">
static const NCBI_NS_NCBI::CTypeInfo* GetTypeInfo(void);</pre></blockquote>

As with class objects, there must be some means of declaring the type information
function for an enumeration prior to using the macros which implement that
function. Given an enumeration named <span class="ncbi_type">EMyEnum</span>,
<span class="ncbi_ccode">DECLARE_ENUM_INFO(EMyEnum)</span>
will generate the following declaration:

<blockquote>
<pre class="ncbi_code">
const CEnumeratedTypeValues* GetTypeInfo_enum_EMyEnum(void);</pre></blockquote>

The <span class="ncbi_macro">DECLARE_ENUM_INFO()</span> macro should appear in the header file where
the enumeration is defined, immediately following the definition. The <span class="ncbi_macro">DECLARE_INTERNAL_ENUM_INFO</span>
macro is intended for usage with internal class definitions, as in:

<blockquote>
<pre class="ncbi_code">
class ClassWithEnum {
    enum EMyEnum {
        ...
    };

    DECLARE_INTERNAL_ENUM_INFO(EMyEnum);
    ...
};
</pre></blockquote>

The C++ Toolkit also allows one to provide type information for legacy
C style <span class="ncbi_keyword">struct</span> and
<span class="ncbi_term">choice</span> elements defined in the C Toolkit.
The mechanisms used to implement this are mentioned but not described in
detail here, as it is not likely that newly-defined types will be in these
categories.
<p><br>


<a NAME="macros"></a>
<h3>Installing a GetTypeInfo() function: the BEGIN_/END_macros</h3>

Several pre-processor macros are available for the installation of the
<span class="ncbi_func">GetTypeInfo()</span> functions for different types. Table 1 lists six <span class="ncbi_macro">BEGIN_NAMED_*_INFO</span>
macros, along with a description of the type of object each can be applied
to and its expected arguments. Each macro in Table 1 has a corresponding
<span class="ncbi_macro">END_*_INFO</span> macro definition.
<p> The first four macros in Table 1 apply to C++ objects. The <span class="ncbi_macro">DECLARE_INTERNAL_TYPE_INFO()</span>
macro <em>must</em> appear in the class definition's public section. These
macros take two
<span class="ncbi_type">string</span> arguments:
<ul>
<li>
an external alias for the type, and</li>

<li>
the internal C++ symbolic class name.</li>
</ul>
<a NAME="alias"></a>The external alias is required for serializable objects
whose external name differs from the internal C++ class name. For example,
the external object names specified in the ASN.1 modules (in
<span class="ncbi_dir">src/objects</span>)
are prefixed with the letter "C" in the corresponding C++ class names (e.g.,
<i>Bioseq</i><!--NCBI_MARK-->
versus <span class="ncbi_class">CBioseq</span>). Each of the "named" macros in Table 1 has a corresponding
"unnamed" macro which accepts the (unquoted) symbolic class name as one
of its arguments, and generates a call to the corresponding "named" macro
using a quoted string. For example,
<span class="ncbi_macro">BEGIN_CLASS_INFO</span> is defined
as:
<blockquote>
<pre class="ncbi_code">
#define BEGIN_CLASS_INFO(ClassName) \
    BEGIN_NAMED_CLASS_INFO(#ClassName, ClassName)
</pre></blockquote>

The next two macros implement global, uniquely named functions which provide
access to type information for C++ enumerations; the resulting functions
are named <span class="ncbi_ccode">GetTypeInfo_enum_[EnumName]</span>. The <span class="ncbi_macro">DECLARE_ENUM_INFO()</span>
or <span class="ncbi_macro">DECLARE_ENUM_INFO_IN()</span> macro should be used in these cases to
declare the <span class="ncbi_func">GetTypeInfo*()</span> functions.
<p>The usage of these six macros generally takes the following form:

<blockquote>
<pre class="ncbi_code">
BEGIN_*_INFO(ClassName)
{
    ADD_*(MemberName);
    ADD_*(memberName);
    ...
}
END_*_INFO
</pre></blockquote>

That is, the <span class="ncbi_macro">BEGIN/END</span> macros are used to generate the function's
signature and enclosing block, and various <span class="ncbi_macro">ADD_*</span> macros are applied
to add information about internal members and class relations.
<table BORDER WIDTH="100%" cellspacing=0>
<tr>
<th>Macro name</th>

<th>Used for</th>

<th>Arguments</th>
</tr>

<tr>
<td><a href="#class">BEGIN_NAMED_CLASS_INFO</a></td>

<td>Non-abstract class object</td>

<td>ClassAlias, ClassName</td>
</tr>

<tr>
<td><a href="#abstr">BEGIN_NAMED_ABSTRACT_CLASS_INFO</a></td>

<td>Abstract class object</td>

<td>ClassAlias, ClassName</td>
</tr>

<tr>
<td><a href="#derive">BEGIN_NAMED_DERIVED_CLASS_INFO</a></td>

<td>Derived subclass object</td>

<td>ClassAlias, ClassName, BaseClassName</td>
</tr>

<tr>
<td><a href="#choice">BEGIN_NAMED_CHOICE_INFO</a></td>

<td>C++ class choice object</td>

<td>ClassAlias, ClassName</td>
</tr>

<tr>
<td><a href="#enum">BEGIN_NAMED_ENUM_INFO</a></td>

<td>Enum object</td>

<td>EnumAlias, EnumName, IsInteger</td>
</tr>

<tr>
<td><a href="#enum_in">BEGIN_NAMED_ENUM_IN_INFO</a></td>

<td>internal Enum object</td>

<td>EnumAlias, CppContext, EnumName, IsInteger</td>
</tr>

<caption ALIGN=BOTTOM>Table 1</caption>
</table>

<ul>
<li>
<a NAME="class"></a>
<a href="../lxr/ident?i=BEGIN_NAMED_CLASS_INFO" class="ncbi_macro">BEGIN_NAMED_CLASS_INFO(ClassAlias,
ClassName)</a></li>

<br><a href="../lxr/ident?i=BEGIN_CLASS_INFO" class="ncbi_macro">BEGIN_CLASS_INFO(ClassName)</a>
<br>These macros should be used on classes that do not contain any pure
virtual functions. For example, the <span class="ncbi_func">GetTypeInfo()</span> method for the
<a href="iterators.html#CPerson" class="ncbi_class">CPerson</a> class (used in the
chapter on iterators) can be implemented as:

<blockquote>
<pre class="ncbi_code">
BEGIN_NAMED_CLASS_INFO("CPerson", CPerson)
{
    ADD_NAMED_STD_MEMBER("m_Name", m_Name);
    ADD_NAMED_STD_MEMBER("m_Addr", m_Addr);
    ADD_NAMED_MEMBER("m_NextDoor", m_NextDoor, POINTER, (CLASS, (CPerson)));
}
END_CLASS_INFO
</pre>
</blockquote>

or, equivalently, as:

<blockquote>
<pre class="ncbi_code">
BEGIN_CLASS_INFO(CPerson)
{
    ADD_STD_MEMBER(m_Name);
    ADD_STD_MEMBER(m_Addr);
    ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)));
}
END_CLASS_INFO
</pre></blockquote>

Here, the <span class="ncbi_class">CPerson</span> class has two <span class="ncbi_class">string</span>
data members, <span class="ncbi_var">m_Name</span> and
<span class="ncbi_var">m_Addr</span>, as well as a pointer to
an object of the same type (<span class="ncbi_type">CPerson*</span>). All built-in C++ types such
as <span class="ncbi_type">int, float, string</span> etc., use the <span class="ncbi_macro">ADD_NAMED_STD_MEMBER</span>
or <span class="ncbi_macro">ADD_STD_MEMBER</span> macros. These and other macros used to add members
are defined in <a href="#addm">Table 2</a>.
<li>
<a NAME="abstr"></a>
<a href="../lxr/ident?i=BEGIN_NAMED_ABSTRACT_CLASS_INFO" class="ncbi_macro">BEGIN_NAMED_ABSTRACT_CLASS_INFO(ClassAlias, ClassName)</a></li>

<br><a href="../lxr/ident?i=BEGIN_ABSTRACT_CLASS_INFO" class="ncbi_macro">BEGIN_ABSTRACT_CLASS_INFO(ClassName)</a>
<br>These macros must be used on abstract base classes
which contain pure virtual functions. Because these abstract classes cannot
be instantiated, special handling is required in order to install their
static <span class="ncbi_func">GetTypeInfo()</span> methods.
<p>For example, suppose the classes <span class="ncbi_class">CA</span> and
<span class="ncbi_class">CB</span> are derived from an abstract base class,
<span class="ncbi_class">CBase</span>. In order
to be able to apply a <a href="iterators.html#typeIt" class="ncbi_class">CTypeIterator</a>&lt;CBase>
that will visit all objects of type <span class="ncbi_class">CA</span> and
<span class="ncbi_class">CB</span>, we must implement
the <span class="ncbi_func">GetTypeInfo()</span> method on that abstract class. The
<span class="ncbi_macro">ABSTRACT_CLASS_INFO</span>
macros do this for us:

<blockquote>
<pre class="ncbi_code">
BEGIN_ABSTRACT_CLASS_INFO(CBase)
{
    // ... data member definitions for abstract base class

    ADD_SUB_CLASS (CA);
    ADD_SUB_CLASS (CB);
}
END_ABSTRACT_CLASS_INFO
</pre></blockquote>

The <a href="../lxr/ident?i=ADD_SUB_CLASS" class="ncbi_macro">ADD_SUB_CLASS</a>
macro provides the class inheritance information for all objects - its
usage is <em>not</em> restricted to abstract classes. However, each class
listed as a subclass by these macros must also use the DERIVED_CLASS macros
defined below. Failure to define these hierarchical relations in the
<span class="ncbi_func">GetTypeInfo()</span>
macros will not lead to compile-time errors, but the iterator will
<e,>not</em> recognize these objects as instances of the parent class.
<li>
<a NAME="derive"></a>
<a href="../lxr/ident?i=BEGIN_NAMED_DERIVED_CLASS_INFO" class="ncbi_macro">BEGIN_NAMED_DERIVED_CLASS_INFO(ClassAlias, ClassName, BaseClassName)</a></li>

<br><a href="../lxr/ident?i=BEGIN_DERIVED_CLASS_INFO" class="ncbi_macro">BEGIN_DERIVED_CLASS_INFO(ClassName, BaseClassName)</a>
<br>These macros should be used on derived subclasses
whose parent classes also have the
<span class="ncbi_func">GetTypeInfo()</span> method implemented.
Data members inherited from parent classes should not be included in the
derived class type information.

<blockquote>
<pre class="ncbi_code">
BEGIN_DERIVED_CLASS_INFO(CA, CBase)
{
    // ... data members in CA not inherited from CBase
}
END_DERIVED_CLASS_INFO

BEGIN_DERIVED_CLASS_INFO(CB, CBase)
{
    // ... data members in CB not inherited from CBase
}
END_DERIVED_CLASS_INFO
</pre></blockquote>

<span class="ncbi_note">NOTE:</span>The type information
for classes derived directly from <span class="ncbi_class">CObject</span> does
<em>not</em> however,
follow this protocol. In this special case, although the class is derived
from <span class="ncbi_class">CObject</span>, you should <em>not</em> use the <span class="ncbi_macro">DERIVED_CLASS</span>
macros to implement
<span class="ncbi_func">GetTypeInfo()</span>, but instead use the usual <span class="ncbi_macro">BEGIN_CLASS_INFO</span>
macro. <span class="ncbi_class">CObject</span>'s have a slightly different interface to their type
information (see <a href="../lxr/ident?i=CObjectGetTypeInfo" class="ncbi_class">CObjectGetTypeInfo</a>),
and apply these macros differently.
<li>
<a NAME="choice">
</a><a href="../lxr/ident?i=BEGIN_NAMED_CHOICE_INFO class="ncbi_macro"">BEGIN_NAMED_CHOICE_INFO(ClassAlias, ClassName)</a></li>

<br><a href="../lxr/ident?i=BEGIN_CHOICE_INFO" class="ncbi_macro">BEGIN_CHOICE_INFO(ClassName)</a>
<br>These macros install <span class="ncbi_func">GetTypeInfo()</span> for
C++ <span class="ncbi_term">choice</span> objects, which are implemented as C++ classes.
See <a href="choice.html"">Choice objects in the C++ Toolkit</a> for a description of C++ <span class="ncbi_term">choice</span>
objects. Each of the choice variants occurs as a data member in the class,
and the macros used to add choice variants (<a href="../lxr/ident?i=ADD_NAMED_CHOICE_VARIANT" class="ncbi_macro">ADD_NAMED_*_CHOICE_VARIANT</a>)
are used similarly to those which add data members to classes (see discussion
of the <a href="#addm" class="ncbi_macro">ADD*</a> macros below).
<li>
<a NAME="enum"></a>
<a href="../lxr/ident?i=BEGIN_NAMED_ENUM_INFO" class="ncbi_macro">BEGIN_NAMED_ENUM_INFO(EnumAlias,
EnumName, IsInteger)</a></li>

<br><a href="../lxr/ident?i=BEGIN_ENUM_INFO" class="ncbi_macro">BEGIN_ENUM_INFO(EnumName,
IsInteger)</a>
<br>In addition to the two arguments used by the
<span class="ncbi_macro">BEGIN_*_INFO</span> macros for classes, a Boolean argument (<span class="ncbi_func">IsInteger</span>)
indicates whether or not the enumeration includes arbitrary integer values
or only those explicitly specified.
<p>Example usage:


<blockquote>
<pre class="ncbi_code">
// hpp file:
enum EMyEnum {
    eZero = 0,
    eOne,
    eTwo,
    eTen = 10
};

// cpp file:
BEGIN_ENUM_INFO(EMyEnum, false)
{
    ADD_ENUM_VALUE("zero", eZero);
    ADD_ENUM_VALUE("one", eOne);
    ADD_ENUM_VALUE("two", eTwo);
    ADD_ENUM_VALUE("ten", eTen);
}
END_ENUM_INFO
</pre></blockquote>

Enumerated values are specified with the <span class="ncbi_macro">ADD_ENUM_VALUE</span>
macro. As a result of executing the above macro, a global function named
<span class="ncbi_func">GetTypeInfo_enum_EMyEnum()</span> will be implemented.
<br> 
<br> 
<li>
<a NAME="enum_in"></a>
<a href="../lxr/ident?i=BEGIN_NAMED_ENUM_IN_INFO" class="ncbi_macro">BEGIN_NAMED_ENUM_IN_INFO(EnumAlias, CppContext, EnumName, IsInteger)</li>

<br><a href="../lxr/ident?i=BEGIN_ENUM_IN_INFO" class="ncbi_macro">BEGIN_ENUM_IN_INFO(CppContext,
EnumName, IsInteger)</a>
<br>These macros also implement the type information
functions for C++ enumerations --but in this case, the enumeration is defined
outside the scope where the macro is applied, so a <span class="ncbi_term">context</span> argument
is required. This new argument, <span class="ncbi_func">CppContext</span>, specifies the C++ class
name or external namespace where the enumeration is defined.
<p>The <span class="ncbi_func">CppContext</span> argument should be
postfixed with the scope operator (::). For example, if
<span class="ncbi_type">EMyEnum</span>
is itself defined in <span class="ncbi_class">CMyClass</span>, then we would use the following macros
in the
<span class="ncbi_file">*.cpp</span> file:

<blockquote>
<pre class="ncbi_code">
BEGIN_ENUM_IN_INFO(CMyClass::, EMyEnum, false)
{
    ADD_ENUM_VALUE("zero", eZero);
    ADD_ENUM_VALUE("one", eOne);
    ADD_ENUM_VALUE("two", eTwo);
    ADD_ENUM_VALUE("ten", eTen);
}
END_ENUM_IN_INFO
</pre></blockquote>
</ul>

Again, when using the above macros to install type
information, the corresponding class definitions
<em>must</em> include a declaration of the static class member function <span class="ncbi_func">GetTypeInfo()</span> in
the class's public section. The <span class="ncbi_macro">DECLARE_INTERNAL_TYPE_INFO()</span> macro
is provided to ensure that the declaration of this method is correct. Similarly,
the <span class="ncbi_macro">DECLARE_INTERNAL_ENUM_INFO</span> and
<span class="ncbi_macro">DECLARE_ENUM_INFO</span> macros
should be used in the header files where enumerations are defined. The
<span class="ncbi_macro">DECLARE_ASN_TYPE_INFO</span> and <span class="ncbi_macro">DECLARE_ASN_CHOICE_INFO</span> macros
can be used to declare the type information functions for C-style structs
and choice nodes.
<p><br>

<a NAME="addm"></a>
<h3>Specifying internal structure and class inheritance: the ADD_ macros</h3>

Information about internal class structure and inheritance
is specified using the <span class="ncbi_macro">ADD_*</span> macros. Again, each macro has both
a "named" and "unnamed" implementation. The arguments to all of the ADD_NAMED_*
macros begin with the external alias and C++ name of the item to be added.
<p>The ADD_* macros that take <em>only</em> an alias
and a name require that the type being added must be either a built-in
type or a type defined by the name argument. When adding a
<span class="ncbi_class">CRef</span>
data member to a class or choice object however, the class referenced by
the <span class="ncbi_class">CRef</span> must be made explicit with the <span class="ncbi_var">RefClass</span> argument,
which is the C++ class name for the type pointed to.
<p>Similarly, when adding an enumerated data member
to a class, the enumeration itself must be explicitly named. For example,
if class <span class="ncbi_class">CMyClass</span> contains a data member <span class="ncbi_var">m_MyEnumVal</span> of type
<span class="ncbi_type">EMyEnum</span>, then the BEGIN_NAMED_CLASS_INFO macro for <span class="ncbi_class">CMyClass</span>
should contain the statement:

<blockquote>
<pre class="ncbi_code">
ADD_ENUM_MEMBER (m_MyEnumVal, EMyEnum);
</pre>
</blockquote>

<p>or, equivalently:

<blockquote>
<pre class="ncbi_code">
ADD_NAMED_ENUM_MEMBER ("m_MyEnumVal", m_MyEnumVal, EMyEnum);
</pre>
</blockquote>

<p>or, to define a "custom" (non-default) external
alias:

<blockquote>
<pre class="ncbi_code">
ADD_NAMED_ENUM_MEMBER ("m_CustomAlias", m_MyEnumVal, EMyEnum);
</pre>
</blockquote>

<p>Here, <span class="ncbi_type">EMyEnum</span> is defined in the same namespace
and scope as <span class="ncbi_class">CMyClass</span>. Alternatively, if the enumeration is defined
in a different class or namespace (and therefore, then the <span class="ncbi_macro">ADD_ENUM_IN_MEMBER</span> macro must be used:

<blockquote>
<pre class="ncbi_code">
ADD_ENUM_IN_MEMBER (m_MyEnumVal, COtherClassName::, EMyEnum);
</pre>
</blockquote>

<p>In this example, <span class="ncbi_type">EMyEnum</span> is defined in
a class named <span class="ncbi_class">COtherClassName</span>. The
<span class="ncbi_func">CppContext</span> argument (defined
here as <span class="ncbi_class">COtherClassName::</span>) acts as a scope operator, and can also
be used to specify an alternative namespace. The ADD_NAMED_ENUM_CHOICE_VARIANT
and ADD_NAMED_ENUM_IN_CHOICE_VARIANT macros are used similarly to provide
information about enumerated choice options. The <span class="ncbi_macro">ADD_ENUM_VALUE</span>
macro is used to add enumerated values to the enumeration itself, as demonstrated
in the above example of the <a href="#enum">BEGIN_NAMED_ENUM_INFO</a> macro.
<br> 
<br> 
<table BORDER WIDTH="100%" cellspacing=0>
<tr>
<th>Macro name</th>

<th>Usage</th>

<th>Arguments</th>
</tr>

<tr>
<td>ADD_NAMED_STD_MEMBER </td>

<td>Add a standard data member to a class</td>

<td>MemberAlias, MemberName</td>
</tr>

<tr>
<td>ADD_NAMED_CLASS_MEMBER </td>

<td>Add an internal class member to a class</td>

<td>MemberAlias, MemberName</td>
</tr>

<tr>
<td>ADD_NAMED_SUB_CLASS </td>

<td>Add a derived subclass to a class</td>

<td>SubClassAlias, SubClassName</td>
</tr>

<tr>
<td>ADD_NAMED_REF_MEMBER </td>

<td>Add a <span class="ncbi_class">CRef</span> data member to a class</td>

<td>MemberAlias, MemberName, RefClass</td>
</tr>

<tr>
<td>ADD_NAMED_ENUM_MEMBER </td>

<td>Add an enumerated data member to a class</td>

<td>MemberAlias, MemberName, EnumName</td>
</tr>

<tr>
<td>ADD_NAMED_ENUM_IN_MEMBER </td>

<td>Add an externally defined enumerated data member to a class</td>

<td>MemberAlias, MemberName, CppContext, EnumName</td>
</tr>

<tr>
<td>ADD_NAMED_MEMBER </td>

<td>Add a data member of the type specified by <span class="ncbi_var">TypeMacro</span> to a class</td>

<td>MemberAlias, MemberName, TypeMacro, TypeMacroArgs</td>
</tr>

<tr>
<td>ADD_NAMED_STD_CHOICE_VARIANT</td>

<td>Add a standard variant type to a C++ choice object</td>

<td>VariantAlias, VariantName</td>
</tr>

<tr>
<td>ADD_NAMED_REF_CHOICE_VARIANT</td>

<td>Add a <span class="ncbi_class">CRef</span> variant to a C++ choice object</td>

<td>VariantAlias, VariantName, RefClass</td>
</tr>

<tr>
<td>ADD_NAMED_ENUM_CHOICE_VARIANT</td>

<td>Add an enumeration variant to a C++ choice object</td>

<td>VariantAlias, VariantName, EnumName</td>
</tr>

<tr>
<td>ADD_NAMED_ENUM_IN_CHOICE_VARIANT</td>

<td>Add an enumeration variant to a C++ choice object </td>

<td>VariantAlias, VariantName, CppContext, EnumName</td>
</tr>

<tr>
<td>ADD_NAMED_CHOICE_VARIANT </td>

<td>Add a variant of the type specified by <span class="ncbi_var">TypeMacro</span> to a C++ choice
object</td>

<td>VariantAlias, VariantName, TypeMacro, TypeMacroArgs </td>
</tr>

<tr>
<td>ADD_ENUM_VALUE</td>

<td>Add a named enumeration value to an <span class="ncbi_keyword">enum</span></td>

<td>EnumValName, Value </td>
</tr>

<caption ALIGN=BOTTOM>Table 2</caption>
</table>
<p>
The most complex macros by far are those which use the <span class="ncbi_type">TypeMacro</span>
and <span class="ncbi_var">TypeMacroArgs</span> arguments:
<span class="ncbi_macro">ADD(_NAMED)_MEMBER</span> and <span class="ncbi_macro">ADD(_NAMED)_CHOICE_VARIANT</span>.
These macros are more open-ended and allow for more complex specifications.
We have already seen one example of using a macro of this type, in the
implementation of the
<span class="ncbi_func">GetTypeInfo()</span> method for <span class="ncbi_class">CPerson</span>:

<blockquote>
<pre class="ncbi_code">
ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)));
</pre>
</blockquote>

<p>The <span class="ncbi_macro">ADD_MEMBER</span> and <span class="ncbi_macro">ADD_CHOICE_VARIANT</span> macros always take
at least two arguments:
<ol>
<li>
the internal member (variant) name</li>

<li>
the definition of the member's (variant's) type</li>
</ol>
Depending on the (second) <span class="ncbi_var">TypeMacro</span> argument, additional arguments
may or may not be needed. In this example, the <span class="ncbi_var">TypeMacro</span> is <i>POINTER</i><!--NCBI_MARK-->,
which <em>does require</em> additional arguments. The <span class="ncbi_var">TypeMacroArgs</span>
here specify that <span class="ncbi_var">m_NextDoor</span> is a pointer to a class type
whose C++ name is <span class="ncbi_class">CPerson</span>.
<p> More generally, the remaining arguments depend on the value of
<span class="ncbi_var">TypeMacro</span>, as these parameters complete the type definition. The
possible strings which can occur as <span class="ncbi_var">TypeMacro</span>, along with the additional
arguments required for that type, are given in Table 3.
<br> 
<br> 
<center><table BORDER=1 cellspacing=0>
<tr>
<th>TypeMacro</th>

<th>TypeMacroArgs </th>
</tr>

<tr>
<td>CLASS </td>

<td>(ClassName) </td>
</tr>

<tr>
<td>STD </td>

<td>(C++ type) </td>
</tr>

<tr>
<td>StringStore </td>

<td>() </td>
</tr>

<tr>
<td>null </td>

<td>() </td>
</tr>

<tr>
<td>ENUM </td>

<td>(EnumType, EnumName) </td>
</tr>

<tr>
<td>POINTER </td>

<td>(Type,Args) </td>
</tr>

<tr>
<td>STL_multiset </td>

<td>(Type,Args) </td>
</tr>

<tr>
<td>STL_set </td>

<td>(Type,Args) </td>
</tr>

<tr>
<td>STL_multimap </td>

<td>(KeyType,KeyArgs,ValueType,ValueArgs) </td>
</tr>

<tr>
<td>STL_map </td>

<td>(KeyType,KeyArgs,ValueType,ValueArgs) </td>
</tr>

<tr>
<td>STL_list </td>

<td>(Type,Args) </td>
</tr>

<tr>
<td>STL_list_set </td>

<td>(Type,Args) </td>
</tr>

<tr>
<td>STL_vector </td>

<td>(Type,Args) </td>
</tr>

<tr>
<td>STL_CHAR_vector </td>

<td>(C++ Char type) </td>
</tr>

<tr>
<td>STL_auto_ptr </td>

<td>(Type,Args)</td>
</tr>

<tr>
<td>CHOICE </td>

<td>(Type,Args) </td>
</tr>

<caption ALIGN=BOTTOM>Table 3</caption>
</table></center>

<p>The <span class="ncbi_macro">ADD_MEMBER</span> macro generates a call to the corresponding <span class="ncbi_macro">ADD_NAMED_MEMBER</span>
macro as follows:

<blockquote>
<pre class="ncbi_code">
#define ADD_MEMBER(MemberName,TypeMacro,TypeMacroArgs) \
    ADD_NAMED_MEMBER(#MemberName,MemberName,TypeMacro,TypeMacroArgs)
</pre></blockquote>

Some examples of using the ADD_MEMBER macro are:
<blockquote>
<pre class="ncbi_code">
ADD_MEMBER(m_X);
ADD_MEMBER(m_A, STL_auto_ptr, (CLASS, (ClassName)));
ADD_MEMBER(m_B, STL_CHAR_vector, (char));
ADD_MEMBER(m_C, STL_vector, (STD, (int)));
ADD_MEMBER(m_D, STL_list, (CLASS, (ClassName)));
ADD_MEMBER(m_E, STL_list, (POINTER, (CLASS, (ClassName))));
ADD_MEMBER(m_F, STL_map, (STD, (long), STD, (string)));
</pre></blockquote>

Similarly, the <span class="ncbi_macro">ADD_CHOICE_VARIANT</span> macro generates a call to the
corresponding <span class="ncbi_macro">ADD_NAMED_CHOICE_VARIANT</span> macro. These macros add type
information for the <a href="choice.html"> choice object's variants.</a>

<p>
<a href="typeinfo.html"><i>previous</i></a>&nbsp;&nbsp;
<i><a href="../index.html">up&nbsp;</a></i><!--NCBI_MARK-->&nbsp;&nbsp;
<a href="iterators.html"><i>next</i></a>&nbsp;&nbsp;


<!--#include virtual="../ssi/navlinks.shtml" -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> --></td>

<td ALIGN=RIGHT><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
