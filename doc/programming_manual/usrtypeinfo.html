<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
    <title>User-defined type information</title>
  </head>
  <body bgcolor = white>
    <h1> User-defined type information </h1>

  	      <ul>
	        <li><a href="#introduction"> Introduction</a> 
	        <li><a href="#macros"> Installing a <i>GetTypeInfo()</i> function: the <i>BEGIN_/END_</i> macros </a>
	        <li><a href="#addm"> Specifying internal structure and class inheritance: the <i>ADD_</i> macros</a>
	      </ul>

<a name ="introduction"> <h3>Introduction</h3> 

Object type information, as it is used in the NCBI C++ Toolkit, is defined in the section on <a
href="typeinfo.html"> <i>Runtime Object Type Information</i></a>. As described there, all of the
classes and constructs defined in the serial <i>include</i> and <i>src</i> directories have a static
implementation of a <i>GetTypeInfo()</i> function that yields a <a href="typeinfo.html#ctypeinfo">
<i>CTypeInfo</i></a> for the object of interest.  In this section, we describe how type information
can also be generated and accessed for user-defined types. We begin with a review of some of the
basic notions intoduced in the previous discussion.
<p>

The type information for a class is stored outside any instances of that class, in a statically
created <a href="typeinfo.html#ctypeinfo"> <i>CTypeInfo</i></a> object.  A <i>class</i>'s type
information includes the class layout, inheritance relations, external alias, and various other
attributes that are independent of specific instances. In addition, the type information object
provides an interface to the class's data members.<p>

Limited type information is also available for primitive data types, enumerations, containers, and
pointers. The type information for a primitive type specifies that it is an <i>int, float,</i> or
<i>char</i>, etc., and whether or not that element is signed. Enumerations are a special kind of
primitive type, whose type information specifies its enumeration values and named elements. Type
information for containers can specify both the type of container and the type of elements. The type
information for a pointer provides convenient methods of access to the type information for the
type pointed to.<p>

For all types, the type information is encoded in a static <i>CTypeInfo</i> object, which is
then accessed by all instances of a given type using a 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=GetTypeInfo">
<i>GetTypeInfo()</i></a> function. For <i>class</i> types, this function is implemented as a static
method for the class. For non class types, <i>GetTypeInfoXxx()</i> is implemented as a static global
function, where <i>Xxx</i> is a unique suffix generated from the type's name. With the first
invocation of <i>GetTypeInfo()</i> for a given type, the static <i>CTypeInfo</i> object is created,
which then persists (local to the function <i>GetTypeInfo()</i>) throughout execution. Subsequent
calls to <i>GetTypeInfo()</i> simply return a pointer to this statically created local object. <p>

In order to make type information about <i>user-defined</i> classes accessible to your application,
the user-defined classes must also implement a static <i>GetTypeInfo()</i> method. A set of
preprocessor <a href="#macros"> macros</a> is available, which greatly simplifies this effort. A
pre-requisite to using these macros however, is that the class definition must include the following
line:<p>
<a name="cdcl">
<center><pre>DECLARE_INTERNAL_TYPE_INFO();
</pre></center>
This pre-processor macro will generate the following in-line statement in the class definition:

<center><pre>static const NCBI_NS_NCBI::CTypeInfo* GetTypeInfo(void);
</pre></center>

As with class objects, there must be some means of declaring the type
information function for an enumeration prior to using the macros which implement that function. 
Given an enumeration named <i>EMyEnum</i>,

<center><i>DECLARE_ENUM_INFO(EMyEnum)
</i></center> 

will generate the following declaration:

<p><center><pre>const CEnumeratedTypeValues* GetTypeInfo_enum_EMyEnum(void);</pre></center><p>

The <i>DECLARE_ENUM_INFO()</i> macro should appear in the header file where the enumeration is
defined, immediately following the definition. The <i>DECLARE_INTERNAL_ENUM_INFO</i> macro is
intended for usage with internal class definitions, as in:

<pre>
	class ClassWithEnum {
	    enum EMyEnum {
	        ...
            };
	    DECLARE_INTERNAL_ENUM_INFO(EMyEnum);
	    ...
	};
</pre>

The C++ Toolkit also allows one to provide type information for legacy C style <i>struct</i> and
<i>choice</i> elements defined in the C Toolkit. The mechanisms used to implement this are mentioned
but not described in detail here, as it is not likely that newly-defined types will be in
these categories. 

<a name="macros"><h3> Installing a <i>GetTypeInfo()</i> function: the <i>BEGIN_/END_</i> macros </h3>

Several pre-processor macros are available for the installation of the <i>GetTypeInfo()</i> functions
for different types.  Table 1 lists six <i>BEGIN_NAMED_*_INFO</i> macros, along with a description
of the type of object each can be applied to and its expected arguments. Each macro in Table 1 has 
a corresponding <i>END_*_INFO</i> macro definition.<p>

The first four macros in Table 1 apply to C++ objects. The <i>DECLARE_INTERNAL_TYPE_INFO()</i> macro
<strong>must</strong> appear in the class definition's public section. These macros take two
<i>string</i> arguments:
<ul>
<li> an external alias for the type, and 
<li> the internal C++ symbolic class name. 
</ul>

<a name="alias">
The external alias is required for serializable objects whose external name differs from the
internal C++ class name. For example, the external object names specified in the ASN.1 modules (in
<i>src/objects</i>) are prefixed with the letter "C" in the corresponding C++ class names (e.g.,
<i>Bioseq</i> versus <i>CBioseq</i>).  Each of the "named" macros in Table 1 has a corresponding
"unnamed" macro which accepts the (unquoted) symbolic class name as one of its arguments, and
generates a call to the corresponding "named" macro using a quoted string.  For example,
<i>BEGIN_CLASS_INFO</i> is defined as:

<font color = "#000080"> <pre>
#define BEGIN_CLASS_INFO(ClassName) \
    BEGIN_NAMED_CLASS_INFO(#ClassName, ClassName)
</pre></font>

<p>
The next two macros implement global, uniquely named functions which provide access to type
information for C++ enumerations; the resulting functions are named <i>GetTypeInfo_enum_[EnumName]</i>.
The <i>DECLARE_ENUM_INFO()</i> or <i>DECLARE_ENUM_INFO_IN()</i> macro should be used in these cases
to declare the <i>GetTypeInfo*()</i> functions.<p>

The usage of these six macros generally takes the following form:
<font color = "#808080"><pre>
     BEGIN_*_INFO(ClassName)
     {
         ADD_*(MemberName);
         ADD_*(memberName);
         ...
     }
     END_*_INFO
</pre></font>

That is, the <i>BEGIN/END</i> macros are used to generate the function's signature and enclosing
block, and various <i>ADD_*</i> macros are applied to add information about internal members and
class relations. <p>

<table BORDER WIDTH="100%"><caption ALIGN=BOTTOM> Table 1</caption>
<tr><th>Macro name</th>			    <th>Used for</th>            <th>Arguments</th>   </tr>

<tr><td><a href="#class">  BEGIN_NAMED_CLASS_INFO</a></td>
					    <td>Non-abstract class object</td>      <td>ClassAlias, ClassName</td> </tr>


<tr><td><a href="#abstr">  BEGIN_NAMED_ABSTRACT_CLASS_INFO</a></td>
					    <td>Abstract class object</td>	    <td>ClassAlias, ClassName</td> </tr>

<tr><td><a href="#derive"> BEGIN_NAMED_DERIVED_CLASS_INFO</a></td> 
					    <td>Derived subclass object</td>	    <td>ClassAlias, ClassName, BaseClassName</td> </tr>

<tr><td><a href="#choice"> BEGIN_NAMED_CHOICE_INFO</a></td>
					    <td>C++ class choice object</td>        <td>ClassAlias, ClassName</td> </tr>

<tr><td><a href="#enum">   BEGIN_NAMED_ENUM_INFO</a></td>
					    <td>Enum object</td>		    <td>EnumAlias, EnumName, IsInteger</td> </tr>

<tr><td><a href="#enum_in"> BEGIN_NAMED_ENUM_IN_INFO</a></td>
					    <td>internal Enum object</td>	    <td>EnumAlias, CppContext, EnumName, IsInteger</td> </tr>
</table>
<p>

<ul>
<li> <a name=class>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_CLASS_INFO">
<i>BEGIN_NAMED_CLASS_INFO(ClassAlias, ClassName)</i></a><br>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_CLASS_INFO">
<i>BEGIN_CLASS_INFO(ClassName)</i></a> <br>

These macros should be used on classes that do not contain any pure virtual functions. For example,
the <i>GetTypeInfo()</i> method for the <a href="iterators.html#CPerson"><i>CPerson</i></a> class
(used in the chapter on iterators) can be implemented as:

<font color = "#000080"> <pre>
BEGIN_NAMED_CLASS_INFO("CPerson", CPerson)
{
    ADD_NAMED_STD_MEMBER("m_Name", m_Name);
    ADD_NAMED_STD_MEMBER("m_Addr", m_Addr);
    ADD_NAMED_MEMBER("m_NextDoor", m_NextDoor, POINTER, (CLASS, (CPerson)));
}
END_CLASS_INFO
</pre><font color = black>

or, equivalently, as:

<font color = "#000080"> <pre>
BEGIN_CLASS_INFO(CPerson)
{
    ADD_STD_MEMBER(m_Name);
    ADD_STD_MEMBER(m_Addr);
    ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)));
}
END_CLASS_INFO
</pre><font color = black>

Here, the <i>CPerson</i> class has two <i>string</i> data members, <i>m_Name</i> and
<i>m_Addr</i>, as well as a pointer to an object of the same type (<i>CPerson*</i>).
All built-in C++ types such as <i>int, float, string</i> etc., use the <i>ADD_NAMED_STD_MEMBER</i>
or <i>ADD_STD_MEMBER</i> macros. These and other macros used to add members are defined in 
<a href="#addm"> Table 2</a>. <p>

<li><a name=abstr>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_ABSTRACT_CLASS_INFO">
<i>BEGIN_NAMED_ABSTRACT_CLASS_INFO(ClassAlias, ClassName)</i></a> <br>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_ABSTRACT_CLASS_INFO">
<i>BEGIN_ABSTRACT_CLASS_INFO(ClassName)</i></a> <br>

These macros must be used on abstract base classes which contain pure virtual functions. Because
these abstract classes cannot be instantiated, special handling is required in order to install
their static <i>GetTypeInfo()</i> methods. <p>

For example, suppose the classes <i>CA</i> and <i>CB</i> are derived from an abstract base class,
<i>CBase</i>.  In order to be able to apply a <a href="iterators.html#typeIt">
<i>CTypeIterator</i></a><i>&lt;CBase></i> that will visit all objects of type <i>CA</i> and
<i>CB</i>, we must implement the <i>GetTypeInfo()</i> method on that abstract class. The
<i>ABSTRACT_CLASS_INFO</i> macros do this for us:

<font color = "#000080"> <pre>
BEGIN_ABSTRACT_CLASS_INFO(CBase)
{
  // ... data member definitions for abstract base class

  ADD_SUB_CLASS (CA);
  ADD_SUB_CLASS (CB);
}
END_ABSTRACT_CLASS_INFO
</pre></font>
The <a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=ADD_SUB_CLASS">
<i>ADD_SUB_CLASS</i></a> macro provides the class inheritance information for all objects -
its usage is <i>not</i> restricted to abstract classes. However, each class listed as a
subclass by these macros must also use the DERIVED_CLASS
macros defined below. Failure to define these hierarchical relations in the
<i>GetTypeInfo()</i> macros will not lead to compile-time errors, but the iterator will
<i>not</i> recognize these objects as instances of the parent class.
<p>

<li><a name=derive>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_DERIVED_CLASS_INFO">
<i>BEGIN_NAMED_DERIVED_CLASS_INFO(ClassAlias, ClassName, BaseClassName)</i></a><br> 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_DERIVED_CLASS_INFO">
<i>BEGIN_DERIVED_CLASS_INFO(ClassName, BaseClassName)</i></a><br> 

These macros should be used on derived subclasses whose parent classes also have the
<i>GetTypeInfo()</i> method implemented. Data members inherited from parent classes should not be
included in the derived class type information.

<font color = "#000080"> <pre>
BEGIN_DERIVED_CLASS_INFO(CA, CBase)
{
  // ... data members in CA not inherited from CBase
}
END_DERIVED_CLASS_INFO

BEGIN_DERIVED_CLASS_INFO(CB, CBase)
{
  // ... data members in CB not inherited from CBase
}
END_DERIVED_CLASS_INFO
</pre></font>

<font color=red> NOTE:</font> The type information for classes derived directly from <i>CObject</i> does
<i>not</i> however, follow this protocol. In this special case, although the class is derived
from <i>CObject</i>, you should <i>not</i> use the <i>DERIVED_CLASS</i> macros to implement
<i>GetTypeInfo()</i>, but instead use the usual <i>BEGIN_CLASS_INFO</i> macro. <i>CObject</i>'s
have a slightly different interface to their type information (see <a
href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=CObjectGetTypeInfo">
<i>CObjectGetTypeInfo</i></a>), and apply these macros differently. <p>

<li><a name=choice>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_CHOICE_INFO">
<i>BEGIN_NAMED_CHOICE_INFO(ClassAlias, ClassName)</i></a><br>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_CHOICE_INFO">
<i>BEGIN_CHOICE_INFO(ClassName)</i></a><br>

These macros install <i>GetTypeInfo()</i> for C++ <i>choice</i> objects, which are implemented as
C++ classes.  See <a href="choice.html"> <i>Choice objects in the C++ Toolkit</i></a> for a
description of C++ <i>choice</i> objects. Each of the choice variants occurs as a data member in the
class, and the macros used to add choice variants (<a
href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=ADD_NAMED_CHOICE_VARIANT">
<i>ADD_NAMED_*_CHOICE_VARIANT</i></a>) are used similarly to those which add data members to classes (see
discussion of the <a href ="#addm"> <i>ADD*</i></a> macros below).
<p>

<li><a name=enum>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_ENUM_INFO">
<i>BEGIN_NAMED_ENUM_INFO(EnumAlias, EnumName, IsInteger)</i></a><br>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_ENUM_INFO">
<i>BEGIN_ENUM_INFO(EnumName, IsInteger)</i></a><br>

In addition to the two arguments used by the <i>BEGIN_*_INFO</i> macros for classes, a Boolean
argument (<i>IsInteger</i>) indicates whether or not the enumeration includes arbitrary integer
values or only those explicitly specified.

<p>
Example usage:
<font color = "#000080"> <pre>
// hpp file:
enum EMyEnum {
	eZero = 0,
	eOne,
	eTwo,
	eTen = 10
};

// cpp file:
BEGIN_ENUM_INFO(EMyEnum, false)
{
	ADD_ENUM_VALUE("zero", eZero);
	ADD_ENUM_VALUE("one", eOne);
	ADD_ENUM_VALUE("two", eTwo);
	ADD_ENUM_VALUE("ten", eTen);
}
END_ENUM_INFO
</pre></font>

Enumerated values are specified with the <i>ADD_ENUM_VALUE</i> macro.  As a result of
executing the above macro, a global function named <i>GetTypeInfo_enum_EMyEnum()</i> will be
implemented.<p>

<li><a name=enum_in>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_ENUM_IN_INFO">
<i>BEGIN_NAMED_ENUM_IN_INFO(EnumAlias, CppContext, EnumName, IsInteger)</i></a><br>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_ENUM_IN_INFO">
<i>BEGIN_ENUM_IN_INFO(CppContext, EnumName, IsInteger)</i></a><br>

These macros also implement the type information functions for C++ enumerations --but in this case,
the enumeration is defined outside the scope where the macro is applied, so a <i>context</i>
argument is required.  This new argument, <i>CppContext</i>, specifies the C++ class name or
external namespace where the enumeration is defined.<p>

The <i>CppContext</i> argument should be postfixed with the scope operator (::). For example, if
<i>EMyEnum</i> is itself defined in <i>CMyClass</i>, then we would use the following macros in the
<i>*.cpp</i> file:

<font color = "#000080"> <pre>
BEGIN_ENUM_IN_INFO(CMyClass::, EMyEnum, false)
{
	ADD_ENUM_VALUE("zero", eZero);
	ADD_ENUM_VALUE("one", eOne);
	ADD_ENUM_VALUE("two", eTwo);
	ADD_ENUM_VALUE("ten", eTen);
}
END_ENUM_IN_INFO
</pre></font>

</ul>

Again, when using the above macros to install type information, the corresponding class definitions
<i>must</i> include a declaration of the static class member function <i>GetTypeInfo()</i> in the
class's public section. The <i>DECLARE_INTERNAL_TYPE_INFO()</i> macro is provided to ensure that 
the declaration of this method is correct.
Similarly, the <i>DECLARE_INTERNAL_ENUM_INFO</i> and
<i>DECLARE_ENUM_INFO</i> macros should be used in the header files where enumerations are
defined. The <i>DECLARE_ASN_TYPE_INFO</i> and <i>DECLARE_ASN_CHOICE_INFO</i> macros can be used to
declare the type information functions for C-style structs and choice nodes.
<p>

<a name="addm">
<h3> Specifying internal structure and class inheritance: the <i>ADD_</i> macros </h3>

Information about internal class structure and inheritance is specified using the <i>ADD_*</i>
macros. Again, each macro has both a "named" and "unnamed" implementation. The arguments to all of
the ADD_NAMED_* macros begin with the external alias and C++ name of the item to be added. <p>

The ADD_* macros that take <i>only</i> an alias and a name require that the <i>type</i> being
added must be either a built-in type or a type defined by the name argument. When adding a
<i>CRef</i> data member to a class or choice object however, the class referenced by the <i>CRef</i>
must be made explicit with the <i>RefClass</i> argument, which is the C++ class name for
the type pointed to. <p>

Similarly, when adding an enumerated data member to a class, the enumeration itself must be
explictly named. For example, if class <i>CMyClass</i> contains a data member <i>m_MyEnumVal</i> of
type <i>EMyEnum</i>, then the BEGIN_NAMED_CLASS_INFO macro for <i>CMyClass</i> should contain the statement:

<p><center>ADD_ENUM_MEMBER (m_MyEnumVal, EMyEnum);</center><p>

or, equivalently:

<p><center>ADD_NAMED_ENUM_MEMBER ("m_MyEnumVal", m_MyEnumVal, EMyEnum);</center><p>

or, to define a "custom" (non-default) external alias:

<p><center>ADD_NAMED_ENUM_MEMBER ("m_CustomAlias", m_MyEnumVal, EMyEnum);</center><p>

Here, <i>EMyEnum</i> is defined in the same namespace and scope as <i>CMyClass</i>. Alternatively,
if the enumeration is defined in a different class or namespace (and therefore, then the
ADD_ENUM_IN_MEMBER macro must be used:

<p><center>ADD_ENUM_IN_MEMBER (m_MyEnumVal, COtherClassName::, EMyEnum);</center><p>

In this example, <i>EMyEnum</i> is defined in a class named <i>COtherClassName</i>. The
<i>CppContext</i> argument (defined here as <i>COtherClassName::</i>) acts as a scope operator, and
can also be used to specify an alternative namespace. The ADD_NAMED_ENUM_CHOICE_VARIANT and
ADD_NAMED_ENUM_IN_CHOICE_VARIANT macros are used similarly to provide information about enumerated
choice options. The <i>ADD_ENUM_VALUE</i> macro is used to add enumerated values to the enumeration
itself, as demonstrated in the above example of the <a href="#enum"> BEGIN_NAMED_ENUM_INFO</a>
macro.<p>



<table ALIGN=TOP BORDER WIDTH="100%"><caption ALIGN=BOTTOM> Table 2</caption>
<tr><th>Macro name</th>			    <th>Usage</th>            <th>Arguments</th>   </tr>

<tr><td> ADD_NAMED_STD_MEMBER </td>
    <td> Add a standard data member to a class</td>    <td>MemberAlias, MemberName</td> </tr>

<tr><td> ADD_NAMED_CLASS_MEMBER </td>
    <td> Add an internal class member to a class</td>  <td>MemberAlias, MemberName</td> </tr>

<tr><td> ADD_NAMED_SUB_CLASS </td> 
    <td> Add a derived subclass to a class</td> <td>SubClassAlias, SubClassName</td> </tr>

<tr><td> ADD_NAMED_REF_MEMBER </td> 
    <td> Add a <i>CRef</i> data member to a class</td> <td>MemberAlias, MemberName, RefClass</td> </tr>

<tr><td> ADD_NAMED_ENUM_MEMBER </td> 
    <td> Add an enumerated data member to a class</td> <td>MemberAlias, MemberName, EnumName</td> </tr>

<tr><td> ADD_NAMED_ENUM_IN_MEMBER </td> 
    <td> Add an externally defined enumerated data member to a class</td> <td>MemberAlias, MemberName, CppContext, EnumName</td> </tr>

<tr><td> ADD_NAMED_MEMBER </td>
    <td> Add a data member of the type specified by <i>TypeMacro</i> to a class</td>    
    <td>MemberAlias, MemberName, TypeMacro, TypeMacroArgs </td></tr>

<tr><td> ADD_NAMED_STD_CHOICE_VARIANT</td>
    <td> Add a standard variant type to a C++ choice object </td><td> VariantAlias, VariantName</td></tr>

<tr><td> ADD_NAMED_REF_CHOICE_VARIANT
</td><td> Add a <i>CRef</i> variant to a C++ choice object </td><td> VariantAlias, VariantName, RefClass</td></tr>

<tr><td> ADD_NAMED_ENUM_CHOICE_VARIANT </td>
    <td> Add an enumeration variant to a C++ choice object </td><td> VariantAlias, VariantName, EnumName</td> </tr>

<tr><td> ADD_NAMED_ENUM_IN_CHOICE_VARIANT </td>
    <td> Add an enumeration variant to a C++ choice object </td><td> VariantAlias, VariantName, CppContext, EnumName</td> </tr>

<tr><td> ADD_NAMED_CHOICE_VARIANT </td> 
    <td> Add a variant of the type specified by <i>TypeMacro</i> to a C++ choice object</td>
    <td>VariantAlias, VariantName, TypeMacro, TypeMacroArgs </td></tr>

<tr><td> ADD_ENUM_VALUE
</td><td> Add a named enumeration value to an <i>enum</i> 
</td><td> EnumValName, Value

</table>

The most complex macros by far are those which use the <i>TypeMacro</i> and <i>TypeMacroArgs</i> arguments:
<i>ADD(_NAMED)_MEMBER</i> and <i>ADD(_NAMED)_CHOICE_VARIANT</i>.
These macros are more open-ended and allow for more complex specifications. We
have already seen one example of using a macro of this type, in the implementation of the
<i>GetTypeInfo()</i> method for <i>CPerson</i>:<p>

<center> ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson))); </center><p>

The <i>ADD_MEMBER</i> and <i>ADD_CHOICE_VARIANT</i>  macros always take at least two arguments: 
<ol>
<li> the internal member (variant) name
<li> the definition of the member's (variant's) type
</ol>

Depending on the (second) <i>TypeMacro</i> argument, additional arguments may or may
not be needed.  In this example, the <i>TypeMacro</i> is <i>POINTER</i>, which <i>does</i>
require additional arguments. The <i>TypeMacroArgs</i> here specify that <i>m_NextDoor</i>
is a pointer to a <i>class</i> type whose C++ name is <i>CPerson</i>.<p>

More generally, the remaining arguments depend on the value of <i>TypeMacro</i>, as these
parameters complete the type definition. The possible strings which can occur as <i>TypeMacro</i>,
along with the additional arguments required for that type, are given in Table 3.<p>

<center><table border=.5 width=500 cellspacing=1>
  <caption ALIGN=BOTTOM> Table 3</caption>
  <tr>
	 <th>TypeMacro</th>
	 <th>TypeMacroArgs </th>
  </tr>

  <tr>	 <td> CLASS </td>	 <td> (ClassName) </td>  </tr>
  <tr>	 <td> STD   </td>        <td> (C++ type) </td>  </tr>
  <tr>	 <td> StringStore </td>  <td> ()     </td>  </tr>
  <tr> 	 <td> null </td>         <td> ()     </td>  </tr>
  <tr>	 <td> ENUM </td>         <td> (EnumType, EnumName) </td>  </tr> 
  <tr>	 <td> POINTER </td>      <td> (Type,Args) </td>  </tr> 
  <tr>	 <td> STL_multiset </td> <td> (Type,Args) </td>  </tr> 
  <tr>	 <td> STL_set </td>      <td> (Type,Args) </td>  </tr> 
  <tr>	 <td> STL_multimap </td> <td> (KeyType,KeyArgs,ValueType,ValueArgs) </td>  </tr> 
  <tr>	 <td> STL_map </td>      <td> (KeyType,KeyArgs,ValueType,ValueArgs) </td>  </tr> 
  <tr>	 <td> STL_list </td>     <td> (Type,Args) </td>  </tr> 
  <tr>	 <td> STL_list_set </td> <td> (Type,Args) </td>  </tr>
  <tr>	 <td> STL_vector </td>   <td> (Type,Args) </td>  </tr>
  <tr>	 <td> STL_CHAR_vector </td> <td> (C++ Char type) </td>  </tr>
  <tr>	 <td> STL_auto_ptr </td>   <td> (Type,Args)</td>  </tr>
  <tr>	 <td> CHOICE </td>         <td> (Type,Args) </td>  </tr> 

</table></center>
<p>

The <i>ADD_MEMBER</i> macro generates a call to the corresponding <i>ADD_NAMED_MEMBER</i> macro as follows:

<font color = "#000080"> <pre>
#define ADD_MEMBER(MemberName,TypeMacro,TypeMacroArgs) \
     ADD_NAMED_MEMBER(#MemberName,MemberName,TypeMacro,TypeMacroArgs)
</pre></font>
Some examples of using the ADD_MEMBER macro are:
<font color = "#000080"> <pre>
   ADD_MEMBER(m_X);
   ADD_MEMBER(m_A, STL_auto_ptr, (CLASS, (ClassName)));
   ADD_MEMBER(m_B, STL_CHAR_vector, (char));
   ADD_MEMBER(m_C, STL_vector, (STD, (int)));
   ADD_MEMBER(m_D, STL_list, (CLASS, (ClassName)));
   ADD_MEMBER(m_E, STL_list, (POINTER, (CLASS, (ClassName))));
   ADD_MEMBER(m_F, STL_map, (STD, (long), STD, (string)));
</pre></font>

Similarly, the <i>ADD_CHOICE_VARIANT</i> macro generates a call to the corresponding <i>ADD_NAMED_CHOICE_VARIANT</i> macro.
These macros add type information for the <a href="choice.html"><i>choice</i> object's variants.

<p>

   </body>
<!--a href=".html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;<-->
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="methods.html"> <i> next</i> </a>
</html>

	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
