<!--#set var="TITLE" value="Exception handling in the NCBI C++ Toolkit" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->

<a href="../lxr/source/include/corelib/ncbiexpt.hpp"><h1>Exception handling </a> in the NCBI C++ Toolkit</h1>

<ul>
  <li><a href="#NcbiException">NCBI C++ exceptions</a>
    <ul>
    <li><a href="#Requirements">Requirements</a></li>
    <li><a href="#Architecture">Architecture</a></li>
    <li><a href="#Implementation">Implementation</a>
      <ul>
        <li><a href="#CException">CException</a></li>
        <li><a href="#DerivedExceptions">Derived exceptions</a></li>
        <li><a href="#ReportingExceptions">Reporting an exception</a></li>
        <li><a href="#CExceptionReporter">CExceptionReporter</a></li>
        <li><a href="#ErrorCodes">Choosing and analyzing error codes</a></li>
      </ul>
    <li><a href="#Examples">Examples</a></li>
      <ul>
        <li><a href="#ThrowingExample">Throwing an exception</a></li>
        <li><a href="#ReportingExample">Reporting an exception</a></li>
      </ul>
    </ul>
  </li>
  <li> <a href="#errno">The CErrnoException Class</a>
  <li> <a href="#parse">The CParseException Class</a>
  <li> <a href="#macro">Macros for standard C++ exception handling</a>
  <li> <a href="#tracex">Exception Tracing </a>
  <li> <a href="../libs/err_msg.html#ref_Exception">Reference Manual pages</a>
</ul>
<p><br>


<a name="NcbiException"></a>
<h3>NCBI C++ exceptions</h3>

<p>
C++ exceptions is a standard mechanism of communicating abnormal or
unexpected events to a higher execution context. By throwing an exception
a piece of code says it was unable to complete the task and it is
up to others to decide what to do next.
</p>
<p>
What the standard mechanism lacks is backlog,
history of unfinished tasks and its consequences. Say for instance,
a program tries to load some data from a database. An exception occurs,
which says a connection to some port could not be created -- so what?
How meaningfull is it? What did the program try to do? Where did the request
for the connection come from?
</p>
<p>
Another problem is analyzing and handling exceptions in a program.
When an exception is caught,
what is known for sure is only that something bad has happened -- but
what exactly? The standard exception has only type (exception class)
and a text message. The latter probably makes sense for a human, but not for
a program. The former does not seem to be clear enough.
</p>

<p><br>

<a name="#Requirements"></a>
<h4>Requirements</h4>
<ul>
  <li>
  Exception should contain information about where exactly has it
  been thrown -- for a human.
  </li>
  <li>
  Exception should have a numeric id -- for a program.
  </li>
  <li>
  It should be possible to create a stack of exceptions -- to accumulate
  a backlog of events (unfinished jobs) which caused the problem. Still, for a client,
  it should look like a single exception. That is, a client should be able
  to ignore completely the compound structure of the exception being thrown
  and still get some meaningful information.
  </li>
  <li>
  The system should provide for the ability to analyze the exception backlog
  and possibly print information about each exception separately.
  </li>
  <li>
  It should be possible to report the exception data into an arbitrary
  output channel and possibly format it differently for each channel.
  </li>
</ul>

<p><br>

<a name="Architecture"></a>
<h4>Architecture</h4>
<p>
Each subsystem (library) has its own type of exceptions. It may have several types,
if necessary, but all of them should be derived from a single base class (which in turn is
derived from a system-wide base class). So, the type of an exception uniquely
identifies the library which produced it.
</p>
<p>
Each exception has a numeric id, which is unique throughout the subsystem.
Such an id gives an unambiguous description of the problem occurred.
Each id is associated with a text message. Strictly speaking, there is only
one message associated with a given id, so there is no need to include the
message in the exception itself -- it could be taken from an external source.
Still, we suggest using the message -- it serves as an additional comment.
Also, it does not restrict us from using an external source of messages
in the future.
</p>
<p>
Each exception has information about location where it has been thrown -- file
name and line number.
</p>
<p>
Exception can have a reference to the "lower level" one, which makes it possible
to analyze the backlog. Naturally, such a backlog cannot be created automatically -
it is a developer's responsibility. The system only provides the mechanism,
it does not solve problems by itself. Developer is supposed to catch exceptions
in proper places and re-throw them with the backlog information added.
</p>
<p>
Exception's constructor mandatory parameters include location information,
exception id and a message. Such constructor is to be used at the lower level, 
when the exception is thrown initially. At higher levels we need a constructor,
which would accept the exception from the lower level as one of its
parameters.
</p>
<p>
NCBI exception has a sophisticated reporting mechanism -- the standard
<span class="ncbi_func">exception::what()</span> function is definitely not enough. There are three
groups of reporting mechanisms:
</p>
<ul>
  <li>exception formats its data by itself and either returns the result as
  a string or puts it into an output stream;</li>
  <li>client provides an external exception data formatter;</li>
  <li>NCBI standard diagnostic mechanism is used.</li>
</ul>

<p><br>

<a name="Implementation"></a>
<h4>Implementation</h4>

<a name="CException"></a>
<h5>CException</h5>
<p>
There is a single system-wide exception base class --
<a href="../lxr/ident?i=CException&d=C" class="ncbi_class">CException</a>.
Each subsystem <em>must</em> implement its own type of exceptions, which must be
be derived from this class. The class defines basic requirements of an exception
construction, backlog and reporting mechanisms.
</p>
<p>
Constructor includes location information, exception id and a message.
Each exception class defines its own error codes. So, the error code "by itself"
is meaningless -- one should also know the the exception class, which produced it.
<pre class="ncbi_code">
    // When throwing an exception initially, "prev_exception" must be 0
    CException(const char* file, int line,
               const CException* prev_exception, 
               EErrCode err_code,const string& message) throw();
</pre>
</p>

<p>
To make it easier to throw/re-throw an exception, the following macros are defined:
<pre class="ncbi_code">
    NCBI_THROW(exception_class,err_code,message)
    NCBI_RETHROW(prev_exception,exception_class,err_code,message)
    NCBI_RETHROW_SAME(prev_exception,message)
</pre>
The last one (<span class="ncbi_macro">NCBI_RETHROW_SAME</span>) re-throws
the same exception with backlog information added. 
</p>

<p>
The class has numerous reporting methods (the contents of reports is defined by
<a href="diag.html#PostFlags">diagnostics post flags</a>):
<pre class="ncbi_code">
    // Standard report (includes full backlog)
    virtual const char* what(void) const throw();

    // Report the exception using "reporter";
    // if "reporter" is not specified (passed 0), then use the default reporter
    // (as set with CExceptionReporter::SetDefault)
    void Report(const char* file, int line,
                const string&amp; title, CExceptionReporter* reporter = 0,
                TDiagPostFlags flags = eDPF_Trace) const;

    // Report as a string
    // this exception only, no backlog attached
    string ReportThis(TDiagPostFlags flags = eDPF_Trace) const;
    // including full backlog
    string ReportAll (TDiagPostFlags flags = eDPF_Trace) const;

    // Report "standard" attributes (file, line, type, err.code, user message)
    // into the "out" stream (this exception only, no backlog)
    void ReportStd(ostream&amp; out, TDiagPostFlags flags = eDPF_Trace) const;

    // Report "non-standard" attributes (those of derived class)
    // into the "out" stream
    virtual void ReportExtra(ostream&amp; out) const;

    // If _enabled_, then calling what() or ReportAll() would
    // also report exception to the default exception reporter.
    // Return the previous state of the flag.
    static bool EnableBackgroundReporting(bool enable);
</pre>
Also, the following macro is defined:
<pre class="ncbi_code">
    NCBI_REPORT_EXCEPTION(title,e)
</pre>
Finally, the following data access functions help to analyze exception
from a program:
<pre class="ncbi_code">
    // Return class name as a string
    virtual const char* GetType(void) const;
    // Interpretation of error code (as text)
    virtual const char* GetErrCodeString(void) const;
    const string&amp; GetFile(void)    const;
    int           GetLine(void)    const;
    EErrCode      GetErrCode(void) const;
    const string&amp; GetMsg(void)     const;
    // Get "previous" exception from the backlog
    const CException* GetPredecessor(void) const;
</pre>
</p>


<a name="DerivedExceptions"></a>
<h5>Derived exceptions</h5>
<p>
The only requirement for a derived exception is to define error codes
as well as its textual representation. Implementation of several other
functions (e.g. constructors) are, in general case,
pretty straightforward -- so we put it into a macro definition.
Please note, this macro can only be used when the derived class has
no additional data members.
Here is an example of an exception declaration:
<blockquote>
<pre class="ncbi_code">
class CSubsystemException : public CException
{
public:
    enum EErrCode {
        eType1,
        eType2
    };
    virtual const char* GetErrCodeString(void) const
    {
        switch (GetErrCode()) {
        case eType1: return "eType1";
        case eType2: return "eType2";
        default:     return CException::GetErrCodeString();
        }
    }
    NCBI_EXCEPTION_DEFAULT(CSubsystemException,CException);
};
</pre></blockquote>
In case the derived exception has data members not found in the base class,
it should also impelement its own <span class="ncbi_func">ReportExtra</span> method -- to report
this non-standard data.
</p>



<a name="ReportingExceptions"></a>
<h5>Reporting an exception</h5>
<p>
There are several way to report an NCBI C++ exception:
<ol>
  <li>
An exception is capable of formatting its own data, returning a string
(or a pointer to a string buffer). Each exception report occupies one line.
Still, since an exception may contain a backlog of previously thrown
exceptions, the resulting report could contain several lines of text -
one for each exception thrown. The report normally contains information
about location from which the exception has been thrown, text representation
of the exception class and error code, and a description of the error.
The content of the report is defined by
<a href="diag.html#PostFlags">diagnostics post flags</a>.
The following methods generate reports of this type:
<pre class="ncbi_code">
    // Standard report (includes full backlog)
    virtual const char* what(void) const throw();
    // Report as a string
    // this exception only, no backlog attached
    string ReportThis(TDiagPostFlags flags = eDPF_Trace) const;
    // including full backlog
    string ReportAll (TDiagPostFlags flags = eDPF_Trace) const;
</pre>
Functions <span class="ncbi_func">what()</span> and <span class="ncbi_func">ReportAll()</span> may also generate a
<span class="ncbi_term">background</span> report - the one generated by a default exception reporter.
This feature can be disabled by calling the static method
<pre class="ncbi_code">
    CException::EnableBackgroundReporting(false);
</pre>
  </li>
  <li>
Client can provide its own
<a href="#CExceptionReporter">exception reporter</a>.
An object of this class may either use exception data access functions to
create its own reports, or redirect reports into its own output channel(s).
While it is possible to specify the reporter in the <span class="ncbi_func">CException::Report()</span>
function, it seems to be better to install the reporter as a default one instead,
using
<pre class="ncbi_code">
    CExceptionReporter::SetDefault(const CExceptionReporter* handler);
</pre>
static function, and use the standard <span class="ncbi_macro">NCBI_REPORT_EXCEPTION</span> macro in the program.
  </li>
  <li>
Still another way to report an exception is to use the standard
<a href="diag.html">diagnostic</a> mechanism provided by NCBI C++ toolkit.
In this case the code to generate the report would look like this:
<pre class="ncbi_code">
    try {
        ...
    } catch (CException&amp; e) {
        ERR_POST("your message here" << e);
    }
</pre>
  </li>
</ol>
</p>



<a name="CExceptionReporter"></a>
<h5>CExceptionReporter</h5>
<p>
One of possible ways to report an exception is to use an external "reporter".
Reporter is an object that formats exception data and sends it to its own output
channel. Client can install its own, custom exception reporter (this is not
required though -- in case the default was not set,
the standard NCBI diagnostic mechanism is used).<br />
<span class="ncbi_class">CExceptionReporter</span> is an abstract class, which defines reporter interface:
<pre class="ncbi_code">
    // Default reporter
    static  void SetDefault(CExceptionReporter* handler);
    static  const CExceptionReporter* GetDefault(void);

    // Enable/disable using default reporter
    // Return previous state of this flag
    static  bool EnableDefault( bool enable);

    // Report exception using default reporter
    static void ReportDefault(const char* file, int line,
                              const string&amp; title, const CException&amp; ex,
                              TDiagPostFlags flags = eDPF_Trace);

    // Report exception with _this_ reporter
    virtual void Report(const char* file, int line,
                        const string&amp; title, const CException&amp; ex,
                        TDiagPostFlags flags = eDPF_Trace) const = 0;
</pre>
</p>


<a name="ErrorCodes"></a>
<h5>Choosing and analyzing error codes</h5>
<p>
Choosing and interpreting error codes can potentially create some problems.
The matter of fact is that each exception class has its own error codes, as well as
their interpretation. Enumerated values are stored internally (in a program)
as numbers. So, same number can be interpreted incorrectly,
as soon as we somehow misinterpret the exception class.
<br />
Say for instance, there is an exception class, which is derived from
<a href="#DerivedExceptions" class="ncbi_class">CSubsystemException</a> -- let us call
it <span class="ncbi_class">CSupersystemException</span> -- which also defines two error codes:
<span class="ncbi_var">eSuper1</span> and <span class="ncbi_var">eSuper2</span>:
<blockquote>
<pre class="ncbi_code">
class CSupersystemException : public CSubsystemException
{
public:
    enum EErrCode {
        eSuper1,
        eSuper2
    };
    virtual const char* GetErrCodeString(void) const
    {
        switch (GetErrCode()) {
        case eSuper1: return "eSuper1";
        case eSuper2: return "eSuper2";
        default:      return CException::GetErrCodeString();
        }
    }
    NCBI_EXCEPTION_DEFAULT(CSupersystemException, CSubsystemException);
};
</pre></blockquote>

Now, suppose an exception <span class="ncbi_class">CSupersystemException</span> has been thrown
somewhere. On a higher level it has been caught as <span class="ncbi_class">CSubsystemException</span>.
It is easy to see that the error code returned by this object would be
completely meaningless: the error code of <span class="ncbi_class">CSupersystemException</span>
cannot be interpreted in terms of <span class="ncbi_class">CSubsystemException</span>.
<br />
One reasonable solution seems to be isolating error codes of different
exception classes  -- by assigning different numeric values to them
(there is only one person, who can do this -- a developer).
Apparently, such isolation should only be done within each branch of
derivatives only.
<br />
Another solution is to make sure that the exception in question does 
belong to the desired class, not to any intermediate ones. Template
function <a href="../lxr/ident?i=UppermostCast" class="ncbi_func">UppermostCast()</a>
does the trick. It utilizes the runtime information and dynamic cast conversion:
<pre class="ncbi_code">
    try {
        ...
        NCBI_THROW(CSupersystemException,eSuper1,"your message here");
        ...
    }
    catch (CSubsystemException&amp; e) {
        // call to UppermostCast&lt;CSubsystemException&gt;(e) would return 0 here!
        // which means that "e" was actually the object of a different class
        const CSupersystemException *p = UppermostCast&lt;CSupersystemException&gt;(e);
        if (p) {
            switch (p->GetErrCode()) {
            case CSupersystemException::eSuper1:
                ...
                break;
            case CSupersystemException::eSuper2:
                ...
                break;
            default:
                ...
                break;
            }
        }
        NCBI_RETHROW_SAME(e,"your message here");
    }
</pre>
Finally, the runtime information makes it possible to do it even better.
Since <span class="ncbi_func">GetErrCode</span> function is non-virtual, it might check the
type of the object, for which it has been called, against the type of
the class to which it belong. If these two do not match, the
function returns <span class="ncbi_term">invalid</span> error code. Such code only means that the caller
did not know the correct type of the exception, and the function is unable
to interpret it.
</p>

<p><br>

<a name="Examples"></a>
<h4>Examples</h4>

<a name="ThrowingExample"></a>
<h5>Throwing an exception</h5>
<p>
It is worth to remind: the system only provides a mechanism to create a backlog
of unfinished tasks, it does not create it automatically. It is up to
developer to catch exceptions and re-throw them with the backlog information added.
Here is an example of throwing
<a href="#DerivedExceptions" class="ncbi_class">CSubsystemException</a> exception:
<pre class="ncbi_code">
    ... // your code
    NCBI_THROW(CSubsystemException,eType1,"your message here");
    ...
</pre>
The code that catches, and possibly re-throws the exception might look like this:
<pre class="ncbi_code">
    try {
        ... // your code
    } catch (CSubsystemException&amp; e) {
        if (e.GetErrCode() == CSubsystemException::eType2) {
            ...
        } else {
            NCBI_RETHROW(e,CSubsystemException,eType1,"your message here")
        }
    } catch (CException&amp; e) {
        NCBI_RETHROW(e,CException,eUnknown,"your message here")
    }
</pre>
</p>

<a name="ReportingExample"></a>
<h5>Reporting an exception</h5>
<p>
There is a
<a href="#ReportingExceptions">number of ways</a>
to report <span class="ncbi_class">CException</span>, for example:
<pre class="ncbi_code">
    try {
        ... // your code
    } catch (CSubsystemException&amp; e) {
        NCBI_REPORT_EXCEPTION("your message here",e);
        ERR_POST(e);
        cerr << e.ReportAll();
        cerr << e.what();
        e.Report(__FILE__,__LINE__,"your message here");
    }
</pre>
We suggest using <span class="ncbi_macro">NCBI_REPORT_EXCEPTION(title,e)</span> macro
(which is equivalent to calling
<span class="ncbi_ccode">e.Report(__FILE__,__LINE__,title)</span>) -
it redirects the output into standard diagnostic channels
and is highly configurable.
</p>

<p>&nbsp;</p>

<a name="errno"></a>
<a href="../docxx/CErrnoException.html"><h3>The CErrnoException Class</h3></a>
<p>
The <span class="ncbi_class">CErrnoException</span> class is derived from <span class="ncbi_class">CException</span>, and in addition to the
description string, has an <span class="ncbi_type">int</span> data member called <span class="ncbi_var">m_Errno</span>.
The constructor itself automatically adds information about the most recent error state as
obtained via the global system variable <span class="ncbi_var">errno</span>. The <span class="ncbi_class">CErrnoException</span>
has only one <a href="#ErrorCodes">error core</a> - <span class="ncbi_var">eErrno</span>. To analyze the
actual reason of the exception one should use <span class="ncbi_func">GetErrno()</span> data access function:
<pre class="ncbi_code">
    int GetErrno(void) const;
</pre>
To throw a CErrnoException, the standard <span class="ncbi_macro">NCBI_THROW</span> macro can be used:
<pre class="ncbi_code">
    NCBI_THROW(CErrnoException,eErrno,"Your message here");
</pre>
</p>

<p>&nbsp;</p>

<a name="parse"></a>
<a href="../docxx/CParseException.html"><h3>The CParseException Class</h3></a>
<p>
The <span class="ncbi_class">CParseException</span> class is derived from <span class="ncbi_class">CException</span>,
and includes an additional <span class="ncbi_type">int</span> data member, in this case called <span class="ncbi_var">m_Pos</span>.
This class was specifically defined to support complex parsing tasks,
and its constructor requires that positional information be supplied along with the
description message. This makes it impossible to use the standard
<span class="ncbi_macro">NCBI_THROW</span> macro to throw it, so we defined two additional macros:
<pre class="ncbi_code">
    // To throw exceptions with one more parameter (e.g. CParseException)
    #define NCBI_THROW2(exception_class, err_code, message, extra)
    #define NCBI_RETHROW2(prev_exception,exception_class,err_code,message,extra) \
</pre>
</p>


<p>&nbsp;</p>


<a name="macro"></a>
<h3> Macros for standard C++ exception handling</h3>

The C++ <span class="ncbi_func">throw()</span> statement provides a mechanism for specifying the types of exceptions that
may be thrown by a function. Functions that do <em>not</em> include a <span class="ncbi_func">throw()</span> statement in
their declaration can throw any type of exception, but where the <span class="ncbi_func">throw()</span> statement <em>is</em>
used, undeclared exception types that are thrown will cause <span class="ncbi_func">std::unexpected()</span> to be raised.
Various compilers handle these events differently, and the first two macros listed below,
(<span class="ncbi_macro">THROWS(())</span>, <span class="ncbi_macro">THROWS_NONE</span>, are provided to support platform-independent exception specifications.<p>

<table border=1 cellspacing=1>
  <caption></caption>
  <tr>
     <th>Macro</th>
     <th>C++ Equivalent </th>
     <th>Synopsis </th>
  </tr>

  <tr>
     <td><span class="ncbi_macro">THROWS((types))</span></td>
    <td><span class="ncbi_ccode"> throw(types)</span></td>
     <td> Defines the type of exceptions thrown by the given function. <span class="ncbi_var">types</span> may be a single
     object type or a comma delimited list.</td>
  </tr>

  <tr>
     <td><span class="ncbi_macro"> THROWS_NONE</span></td>
    <td><span class="ncbi_ccode"> throw()</span></td>
     <td> Specifies that the given function throws no exceptions.     </td>
  </tr>

  <tr>
     <td><span class="ncbi_macro">STD_CATCH(message)</span></td>
     <td><span class="ncbi_ccode">catch(std::exception)</span></td>
     <td> Provides uniform handling of all exceptions derived from <span class="ncbi_class">std::exception</span>. </td>
  </tr>

  <tr>
     <td><span class="ncbi_macro">STD_CATCH_ALL(message)</span></td>
     <td><span class="ncbi_ccode">catch(...)</span></td>
     <td> Applies <span class="ncbi_macro">STD_CATCH()</span> to <span class="ncbi_class">std::exception</span> derived objects;
     catches non-standard exceptions and generates an "Unknown exception" message.
    </td>
  </tr>
</table>
<p>

The <span class="ncbi_macro"> catch</span> macros provide uniform, routine exception handling with minimal effort from the
programmer.  We provide a convenient <span class="ncbi_macro">STD_CATCH()</span> macro to print formatted messages to the
application's <a href="diag.html" class="ncbi_term">diagnostic stream</a>. For example, if <span class="ncbi_func">F()</span>
throws an exception of the form:
<pre class="ncbi_code">
    throw std::runtime_error(throw-msg)
</pre>

then
<pre class="ncbi_code">
    try {F();}
    STD_CATCH(catch-msg);
</pre>
will generate a message of the form:

<pre class="ncbi_output">
    Error: [catch-msg] Exception: throw-msg
</pre>

In this example, the generated message starts with the Error tag, as that is the
<a href="diag.html#severity">severity level</a> for the default diagnostic stream.  User-defined
classes that are derived from <span class="ncbi_class">std::exception</span> will be treated uniformly in the same
manner. The <span class="ncbi_keyword">throw</span> clause in this case creates a new instance of
<span class="ncbi_class">std::runtime_error</span> whose data member <span class="ncbi_var">desc</span> is initialized to
<span class="ncbi_var">throw-msg</span>. When the exception is then caught, the exception's member function
<span class="ncbi_func">what()</span> can be used to retrieve that message.<p>

The <span class="ncbi_macro">STD_CATCH_ALL</span> macro catches all exceptions. If however, the exception
caught is <em>not</em> derived from <span class="ncbi_class">std::exception</span>, then the <span class="ncbi_keyword">catch</span> clause cannot
assume that <span class="ncbi_func">what()</span> has been defined for this object, and a default message is generated:

<pre class="ncbi_output">
    Error: [catch-msg] Exception: Unknown exception
</pre>

<p>&nbsp;</p>

<a name="tracex"></a>
<h3> Exception Tracing </h3>

Knowing exactly where an exception first occurs can be very useful for debugging purposes.
<a href="#CException"><span class="ncbi_class">CException</span></a>
class has this functionality built in, so it is highly recommended to use exceptions derived
from it. In addition to this a set of
<span class="ncbi_macro">THROW*_TRACE()</span> macros defined in the NCBI C++ Toolkit combine
exception handling with <a href="diag.html#trace">trace</a> mechanisms to provide such information.
<p>

The most commonly used of these macros, <span class="ncbi_ccode">THROW1_TRACE(class_name, init_arg)</span>, instantiates
an exception object of type <span class="ncbi_var">class_name</span> using
<span class="ncbi_var">init_arg</span> to initialize it. The definition of this
macro is:

<pre class="ncbi_code">
    #define THROW1_TRACE(class_name, init_arg) \
        throw NCBI_NS_NCBI::DbgPrint(__FILE__, __LINE__, class_name(init_arg), #class_name)
</pre>

From the <span class="ncbi_func">throw()</span> statement here, we see that the object actually being thrown by this macro
is the value returned by <a href="../lxr/ident?i=DbgPrint">DbgPrint</a>().
<span class="ncbi_func">DbgPrint()</span> in turn calls
<a href="../lxr/ident?i=DbgPrint"><span class="ncbi_func">DoDbgPrint</span></a>().
The latter is an overloaded function that simply creates a diagnostic stream and writes the file name,
line number, and the exception's <span class="ncbi_func">what()</span> message to that stream. The exception object
(which is of type <span class="ncbi_var">class_name</span>) is then the value returned by <span class="ncbi_func">DbgPrint()</span>.<p>

More generally, three sets of <span class="ncbi_macro">THROW*_TRACE</span> macros are defined:

<ul>
 <li><span class="ncbi_macro"> THROW0_TRACE(exception_object) </span>
 <li><span class="ncbi_macro"> THROW0p_TRACE(exception_object) </span>
 <li><span class="ncbi_macro"> THROW0np_TRACE(exception_object) </span>
 <br><br>
 <li><span class="ncbi_macro"> THROW1_TRACE(exception_class, exception_arg) </span>
 <li><span class="ncbi_macro"> THROW1p_TRACE(exception_class, exception_arg)</span>
 <li><span class="ncbi_macro"> THROW1np_TRACE(exception_class, exception_arg) </span>
<br><br>
 <li><span class="ncbi_macro"> THROW_TRACE(exception_class, exception_args) </span>
 <li><span class="ncbi_macro"> THROWp_TRACE(exception_class, exception_args) </span>
 <li><span class="ncbi_macro"> THROWnp_TRACE(exception_class, exception_args) </span>
</ul>

The first three macros (<span class="ncbi_macro">THROW0*_TRACE</span>) take a single argument, which may be a newly
constructed exception, as in:
<pre class="ncbi_code">
    THROW0_TRACE(runtime_error("message"))
</pre>
or simply a <span class="ncbi_term">printable</span> object to be thrown, as in:
<pre class="ncbi_code">
    THROW0_TRACE("print this message")
</pre>

The <span class="ncbi_macro">THROW0_TRACE</span> macro accepts either an exception object or a string as the argument to be
thrown. The <span class="ncbi_macro">THROW0p_TRACE</span> macro generalizes this functionality by accepting any
<span class="ncbi_term">printable</span> object, such as <span class="ncbi_ccode">complex(1,3)</span>, as its single argument.  Any object with a
defined output operator is, of course, printable.  The third macro generalizes this one step
further, and accepts aggregate arguments such as <span class="ncbi_type">vector&lt;T&gt;</span>, where <span class="ncbi_var">T</span> is a printable
object.  Note that in cases where the object to be thrown is not a <span class="ncbi_class">std::exception</span>,
you will need to use <span class="ncbi_macro">STD_CATCH_ALL</span> or a custom catch to catch the thrown object. <p>

The remaining six macros accept two arguments: an "exception" class name and an initialization
argument, where both arguments are also passed to the trace message.  The class argument need not actually
be derived from <span class="ncbi_class">std::exception</span>, as the pre-processor simply uses the class name to construct
a new object of that type using the initialization argument.

All of the <span class="ncbi_macro">THROW1*_TRACE</span> macros assume that there is a single initialization argument.  As in
the first three macros, <span class="ncbi_macro">THROW1_TRACE()</span>, <span class="ncbi_macro">THROW1p_TRACE()</span> and <span class="ncbi_macro">THROW1np_TRACE()</span>
specialize in different types of printable objects, ranging from exceptions and numeric and
character types, to aggregate and container types. <p>

The last three macros parallel the previous two sets of macros in their specializations, and
may be applied where the exception object's constructor takes multiple arguments. (See also the
discussion of <a href="../libs/err_msg.html#ref_Exception">Exception handling</a> in the Reference Manual).
<p>

It is also possible to specify that execution should abort immediately when an exception occurs. By
default, this feature is not activated, but the
<a href="../lxr/ident?i=SetThrowTraceAbort">
<span class="ncbi_func">SetThrowTraceAbort()</span> </a> function can be used to activate it. Alternatively, you can turn it
on for the entire application by setting either the <span class="ncbi_env">$ABORT_ON_THROW</span> environment variable, or
the application's registry <span class="ncbi_reg_var">ABORT_ON_THROW</span>  entry (in the <span class="ncbi_reg">[DEBUG]</span> section) to an arbitrary non-empty value.


<p>
<a href="diag.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="cref.html"> <i> next</i> </a>

<!--#include virtual="../ssi/navlinks.shtml" -->

     <table border=0 width="100%" cellspacing=0>
        <tr>
          <td><address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
          <!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> -->
          <td align=right><span class="ncbi_cvs_date">$Date$</span></td>
     </table>

<!--#include virtual="../ssi/footer.shtml" -->
