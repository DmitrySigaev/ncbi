<!--#set var="TITLE" value="NCBI Application" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->


<h2>Writing a Simple Application.</h2>


<div>
<ul>
  <li>
    <a href="#using">Basic classes of NCBI C++ toolkit.</a></li>
  <li>
    <a href="#creating">Creating a simple application.</a>
	<ul>
	  <li><a href="#creating_unix">UNIX systems.</a></li>
	  <li><a href="#creating_ms">MS Windows.</a></li>
	  <li><a href="#whatis">What is in there.</a></li>
	</ul>
  </li>
  <li>
    <a href="#inside">Inside the NCBI Application class.</a></li>
</ul>
</div>



<a name="using"></a>
<h3>Basic classes of NCBI C++ toolkit.</h3>
<p>
Five fundamental classes form the foundation of the C++ Toolkit:
<ul>
  <li>
    class <a href="#CNcbiApplication">CNcbiApplication</a></li>
  <li>
    class <a href="#CNcbiArguments">CNcbiArguments</a>
	(see also <a href="argdescr.html">CArgDescriptions, CArgs, ...</a>)</li>
  <li>
    class <a href="#CNcbiEnvironment">CNcbiEnvironment</a></li>
  <li>
    class <a href="#CNcbiRegistry">CNcbiRegistry</a></li>
  <li>
    class <a href="#CNcbiDiag">CNcbiDiag</a></li>
</ul>
</p>


<a name="CNcbiApplication"></a>
<p>
<i><a href="../docxx/CNcbiApplication.html">CNcbiApplication</a></i>
is an abstract class used to define the basic functionality and behavior
of an NCBI application. Since this application class effectively supersedes
the <i>C</i>-style <i>main()</i> function, minimally, it must provide the
same functionality, i.e.
<ul>
  <li>
    A mechanism to execute the actual application</li>
  <li>
    A data structure for holding program command-line arguments ("argv")</li>
  <li>
    A data structure for holding environment variables</li>
</ul>
In addition, the application class provides the same features previously
implemented in the C Toolkit, namely:
<ul>
  <li>
    Mechanisms for specifying where, when, and how errors should be reported</li>
  <li>
    Methods for reading, accessing, modifying, and writing information in the
    application's registry (configuration) file</li>
  <li>
    Methods to describe, and then automatically parse, validate and access
    program command-line arguments, and to generate the<i>USAGE</i> message</li>
</ul>
The mechanism to execute the application is provided by <i>CNcbiApplication</i>'s
member function <i>Run()</i> - which you must write your own implementation
of. The <i>Run()</i> function will be automatically invoked by <i>CNcbiApplication::AppMain()</i>,
after it has initialized its
<i>CNcbiArguments, CNcbiEnvironment, CNcbiRegistry</i>,
and <i>CNcbiDiag</i> data members.
</p>


<a name="CNcbiArguments"></a>
<p>
<i><a href="../docxx/CNcbiArguments.html">CNcbiArguments</a></i>
class provides a data structure for holding the application's command-line
arguments, along with methods for accessing and modifying these. Access
to the argument values is implemented using the built-in <i>[ ]</i> operator.
For example, the first argument in <i>argv</i> (following the program
name) can be retrieved using the
<i>CNcbiApplication::GetArguments()</i>
method:
<br />
<pre>string arg1_value = GetArguments()[1];</pre>
Here,
<i>GetArguments()</i> returns the <i>CNcbiArguments</i> object,
whose argument values can then be retrieved using the <i>[ ]</i> operator.
Four additional <i>CNcbiArgument</i> member functions support retrieval
and modification of the program name (initially <i>argv</i>[0]). A helper
class, described in <i><a href="argdescr.html">Parsing, validating, and
accessing command line arguments</a></i>, supports the generation of
<i>USAGE</i>
messages and the imposition of constraints on the values of the input arguments.
<br /><br />
When using C++ Toolkit on Mac OS you can specify command-line arguments in a separate 
file with the name of your executable and ".args" extension. Each argument should be on a separate line.
<br /><br />
Example:
<br />
<table border=1 CELLPADDING=5 CELLSPACING=1>
  <tr>
    <th>Command-line parameters</th>
    <th>File Content</th>
  </tr>
  <tr>
    <td>
-gi "Integer" (GI id of the Seq-Entry to examine)<br /><br />

OPTIONAL ARGUMENTS:<br />
 -h (Print this USAGE message;  ignore other arguments)<br />
 -reconstruct (Reconstruct title)<br />
 -accession (Prepend accession)<br />
 -organism (Append organism name)
    </td>
    <td>
-gi<br />
10200<br />
-reconstruct<br />
-accession<br />
-organism<br />
    </td>
  </tr>
</table>

Please note:
<ul>
<li>File must contain Macintosh-style line breaks</li>
<li>No extra spaces are allowed after argument ("-accession" and not "-accession ")</li>
<li>Arguments must be followed by an empty terminating line.</li>
</ul>
</p>


<a name="CNcbiEnvironment"></a>
<p>
<i><a href="../docxx/CNcbiEnvironment.html">CNcbiEnvironment</a></i>
class provides a data structure for storing, accessing, and modifying the
environment variables accessed by the C library routine <i>getenv()</i>.
For example, to retrieve the value of environment variable <b>PATH</b>:
<br>
<pre>string arg1_value = GetEnvironment().Get("PATH");</pre>
</p>



<a name="CNcbiRegistry"></a>
<p>
<i><a href="registry.html">CNcbiRegistry</a></i>
class is used to load, access, modify and store runtime information read
from a configuration file. Previously, these files were by convention named
<i>.*rc</i>
files on
<i>UNIX
</i>systems. The convention for all platforms now is to
name such files
<i>*.ini</i> (where * is by default the application name).
</p>




<a name="CNcbiDiag"></a>
<p>
<i><a href="diag.html">CNcbiDiag</a></i> class
implements much of the functionality of the NCBI C Toolkit error processing
mechanisms. Each instance of <i>CNcbiDiag</i> has a private buffer to handle
a <i>single</i> message, along with private severity level and post flags
and their associated get/set methods. A CNcbiDiag object has the look and
feel of an output stream; its member functions and friends include output
operators <i>>></i> and format manipulators. The default is to post errors
to <i>stderr</i>, with the action determined by the severity level of the
message, however user can provide another stream to post to, or create
an arbitrary callback to do the job, or just ignore all diagnostics. See
also <i><a href="diag.html">Diagnostic Streams </a></i>in this manual,
as well as the discussion in the Reference Manual section on 
<i><a href="../libs/err_msg.html#ref_Message">message posting</a></i>.
</p>


<a name="creating"></a>
<h3>Creating a simple application.</h3>

<a name="creating_unix"></a>
<h4>UNIX systems.</h4>
<p>
Using <tt><a href="outside_tree.html">new_project.sh</a></tt> shell script,
create a new project <i>sample</i> in the folder <i>sample</i>:
  <pre>
  $NCBI/c++/scripts/new_project.sh <i>sample</i> app
  </pre>
This will create:
<ol>
  <li>the project folder - <i>sample</i>,</li>
  <li>the source file - <i>sample</i>.cpp,</li>
  <li>the makefile - Makefile.<i>sample</i>_app.</li>
</ol>
Then build the project and run the application:
  <pre>
  cd <i>sample</i>
  make -f Makefile.<i>sample</i>_app
  ./<i>sample</i>
  </pre>
</p>


<a name="creating_ms"></a>
<h4>MS Windows.</h4>
<p>
<ol>
  <li>In Microsoft Visual Studio create a new project/workspace:
  choose <tt>Win32 Console Application</tt>, then <tt>Empty project</tt>.
  </li>
  <li>
  Copy the sample
  <a href="../lxr/source/src/app/sample/basic/basic_sample.cpp">source file</a>
  into the project directory, rename it, then add to the project.
  </li>
  <li>
  Modify the project settings:
    <ul>
	  <li>Enable Run-time type information (in <tt>C/C++ - C++ language</tt>),
	  </li>
	  <li>Disable using precompiled headers (in <tt>C/C++ - Precompiled headers</tt>),
	  </li>
	  <li>Add additional include directory (in <tt>C/C++ - Preprocessor</tt>).
	  Here, at NCBI, it could be <tt>\\Dizzy\public\cxx\include</tt>,
      that is, the "root" of all includes,
	  </li>
	  <li>Add additional library path (<tt>Link-Input</tt>).
      Here, at NCBI it could be <tt>\\Dizzy\public\cxx\Debug</tt>. Please note,
	  this library path is configuration-dependent, that is it must be
	  different for each configuration you are going to build the project in,
	  </li>
	  <li>Remove all standard libraries in <tt>Link-Input-Object/library modules</tt>,
	  </li>
	  <li>Add <tt>xncbi.lib</tt> NCBI library to the project.
	  </li>
	</ul>
  </li>
  <li>Build the project and run the application.
  </li>
</ol>
</p>


<a name="whatis"></a>
<h4>What is in there.</h4>
<p>
In the
<a href="../lxr/source/src/app/sample/basic/basic_sample.cpp">sample application</a>
above:
<ol>
  <li>There is an application class derived from <var>CNcbiApplication</var>, which overrides
    purely virtual function <var>Run()</var>, and also initialization (<var>Init()</var>)
    and cleanup (<var>Exit()</var>) functions:
    <pre>
    class CSampleApplication : public CNcbiApplication
    {
    private:
        virtual void Init(void);
        virtual int  Run(void);
        virtual void Exit(void);
    };
	</pre>
  </li>
  <li>Program's main function creates an object of the application class and calls
  its <var>AppMain()</var> function:
	<pre>
    int main(int argc, const char* argv[])
    {
        CSampleApplication theApp;
        // Execute main application function
        theApp.AppMain(argc, argv, 0, eDS_Default, 0);
    }
	</pre>
  </li>
  <li>Application's initialization function creates
  <a href="argdescr.html">argument descriptions object</a>,
  which describes the expected command line arguments and the usage context:
	<pre>
    void CSampleApplication::Init(void)
    {
        // Create command-line argument descriptions
        auto_ptr&lt;CArgDescriptions&gt; arg_desc(new CArgDescriptions);
        // Specify USAGE context
        arg_desc->SetUsageContext(GetArguments().GetProgramBasename(),
                                  "CArgDescriptions demo program");
        ...
        // Setup arg.descriptions for this application
        SetupArgDescriptions(arg_desc.release());
    }
	</pre>
  </li>
  <li>Application's <var>Run()</var> function prints those arguments into
  the standard output stream, or in a file.</li>
</ol>

More realistic examples of applications, which utilize NCBI C++ toolkit
can be found <a href="../examples.html">here</a>.
</p>



<a NAME="inside"></a>
<h3>Inside the NCBI Application class.</h3>
<p>
Here is a somewhat simplified view of the application's class definition:
<pre>
class CNcbiApplication
{
public:
   int AppMain(int argc, const char **argv, const char **envp,
               EAppDiagStream diag, const char* config, const string&amp; name);

    virtual void Init(void);     // initialization
    virtual int  Run(void) = 0;  // main loop
    virtual void Exit(void);     // cleanup (on the application exit)

    // Get the application's cached command-line arguments
    const CNcbiArguments&amp; GetArguments(void) const;

    // Get cmd.-line arguments parsed according to the arg descriptions set by
    // SetArgDescriptions(). Throw exception if no descriptions have been set.
    const CArgs&amp; GetArgs(void) const;

    // Get the application's cached environment
    const CNcbiEnvironment&amp; GetEnvironment(void) const;

    // Get the application's cached configuration parameters
    const CNcbiRegistry&amp; GetConfig(void) const;

protected:
   virtual bool SetupDiag_AppSpecific(void);
   virtual bool LoadConfig(CNcbiRegistry&amp; reg, const string* conf);
   .............
};
</pre>

The protected virtual function <i>SetupDiag_AppSpecific()</i>
can be redefined to setup error posting specific for your application.
<i>SetupDiag_AppSpecific()</i>
will be called inside <i>AppMain()</i> by default if the error posting
has not been setup already. Also, if you pass
<b>diag</b>=<i>eDS_AppSpecific</i>
to <i>AppMain()</i>, then <i>SetupDiag_AppSpecific()</i> will be called
for sure, regardless of the error posting setup that was active before
the <i>AppMain()</i> call.
<p>The protected virtual function <i>LoadConfig()
</i>reads
the program's <i>.ini </i>configuration file to load the application's
parameters into the registry. The default implementation of <i>LoadConfig()</i>
expects to find a configuration file named
<i>progname.ini</i>, and will
generate a warning to the user if no such file is found.
</p>

<a NAME="appmain"></a>
<p>
The <i>AppMain() </i>function is also inherited
from the parent class. Although this function accepts up to six arguments,
this example passes only the first two, with missing values supplied by
defaults. The remaining four arguments specify:
<ul>
  <li>
    (#3) a NULL-terminated array of '\0'-terminated
    character strings from which the environment variables can be read</li>
  <li>
    (#4) how to setup a diagnostic stream for message posting</li>
  <li>
    (#5) the name of a <i>.ini</i> configuration
    file (will use program name with suffix <i>.ini</i> by default)</li>
  <li>
    (#6) a program name (to be used in lieu of <i>argv[0]</i>)</li>
</ul>
In order to avoid the display of a warning message when no configuration file is present, the
<i>.ini</i>
file should be explicitly specified as <i>NULL (zero)</i>, as in:
<pre>AppMain (argc, argv, envp, diag_stream, 0, progname);</pre>
</p>

<p>
<i>AppMain() </i>begins by resetting the internal
data members with the actual values provided by the arguments of <i>main()</i>.
Once these internal data structures have been loaded, <i>AppMain() </i>calls
the virtual functions <i>Init(), Run(), </i>and <i>Exit() </i>in succession
to execute the application.
</p>

<p>
The <i>Init() </i>and <i>Exit() </i>virtual functions
are provided as places for developers to add their own methods for specific
applications. As this example does not require any additional initialization/termination,
these two functions are empty.
The <i>Run() </i>method prints out the message defined in <i>justApp.cpp</i> and exits.
</p>
<p>
As shown above, source files which utilize
the <i>CNcbiApplication</i> class must
<i>#include</i> the header file
where that class is defined, <i>corelib/ncbiapp.hpp</i>, in the
<b><i>include/</i></b>
directory. This header file in turn includes <i>corelib/ncbistd.hpp</i>,
which should <i>always</i> be <i>#include</i>'d.
</p>

<i><a href="../index.html">up&nbsp;</a></i> <i><a href="argdescr.html">next&nbsp;</a></i>


<!--#include virtual="../ssi/navlinks.shtml" -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>

<tr>
<td>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Denis Vakatov</a></address>
</td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
