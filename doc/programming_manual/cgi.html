<!--#set var="TITLE" value="Developing CGI applications" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->

<h1>Developing CGI applications</h1>

<ul>
  <li> <a href="#overview"> Overview of the CGI classes </a>
  <li> <a href="#ccgiapp"> The CCgiApplication class </a>
  <li> <a href="#cncbires"> The CNcbiResource and CNcbiCommand classes </a>
  <li> <a href="#ccgireq"> The CCgiRequest class </a>
  <li> <a href="#ccgires"> The CCgiResponse class </a>
  <li> <a href="#ccgicoo"> The CCgiCookie class </a>
  <li> <a href="#cookies"> The CCgiCookies class </a>
  <li> <a href="#ccgictx"> The CCgiContext class </a>
  <li> <a href="#xmpl"> Example code using the CGI classes </a>
  <li> <a href="#cgireg"> CGI Registry configuration </a>  
</ul>

Although CGI programs are generally run as web applications with HTML interfaces, this section of
the Programming Manual places emphasis on the CGI side of things, omitting HTML details of the
implementation where possible. Similarly, the section on <a href="webpgs.html">Generating web
pages</a> focuses largely on the usage of HTML components independent of CGI details. The two
branches of the NCBI C++ Toolkit hierarchy are all but independent of one another - with but one
explicit hook between them: the constructors for HTML <a href="webpgs.html#page"> page</a>
components accept a <span class="ncbi_class">CCgiApplication</span> as an optional argument. This <span class="ncbi_class">CCgiApplication</span>
argument provides the HTML page component with access to all of the CGI objects used in the
application. <p>

Further discussion of combining a CGI application with the HTML classes can be found in the section
on <a href="htmlcgi.html">An example web-based CGI application</a>. The focus in this chapter is on
the CGI classes only.  For additional information about the CGI classes, the reader is also referred
to the discussion of
<a href="../libs/cgi.html">NCBI C++ CGI Classes</a> in the Reference Manual.
<p><br>

<a name="overview"></a><h3> Overview of the CGI classes </h3>
Figure 1 illustrates the layered design of the CGI classes.
<br><br>
<center><img SRC="cgi.gif"><br><br>Figure 1</center><br>

This design is best described by starting with a consideration of the capabilities
one might need to implement a CGI program, including:

<ul>
  <li> A way to retrieve and store the current values of environment variables
  <li> A means of retrieving and interpreting the client's query request string
  <li> Mechanisms to service and respond to the requested query
  <li> Methods and data structures to obtain, store, modify, and send cookies
  <li> A way to set/reset the context of the application (for Fast-CGI)
</ul>

The <span class="ncbi_class">CCgiContext</span> class unifies these diverse capabilities under one aggregate
structure. As their names suggest, the <span class="ncbi_class">CCgiRequest</span> class receives and parses the
request, and the <span class="ncbi_class">CCgiResponse</span> class outputs the response on
an output stream. All incoming <span class="ncbi_class">CCgiCookie</span>s are also parsed and stored by the
<span class="ncbi_class">CCgiRequest</span> object, and the outgoing cookies are sent along with the response
by the <span class="ncbi_class">CCgiResponse</span> object. The request is actually processed by the application's
<span class="ncbi_class">CNcbiResource</span>.  The list of <span class="ncbi_class">CNcbiCommand</span>s stored with that resource object are
scanned to find a matching command, which is then executed. <p>

The <span class="ncbi_class">CCgiContext</span> object, which is a <span class="ncbi_keyword">friend</span> to the <span class="ncbi_class">CCgiApplication</span>
class, orchestrates this sequence of events in coordination with the application
object. The same application may be run in many different contexts, but the
<span class="ncbi_term">resource</span> and defined set of <span class="ncbi_term">commands</span> are invariant. What changes with each
context is the request and its associated response.
<p>

The <span class="ncbi_class">CCgiApplication</span> class is a specialization of <span class="ncbi_class">CNcbiApplication</span>.  Figure 2
illustrates the adaptation of the <span class="ncbi_func">Init()</span> and <span class="ncbi_func">Run()</span> member functions inherited from the
<span class="ncbi_class">CNCbiApplication</span> class to the requirements of CGI programming. Although the application is
<span class="ncbi_term">contained</span> in the context, it is the application which creates and initializes each context in
which it participates. The program arguments and environmental variables are passed along to the
context, where they will be stored, thus freeing the application to be restarted in a new context,
as in Fast-CGI.
<br>
<center><img SRC="cgirun.gif"><br>Figure 2</center><p>

The application's <span class="ncbi_func">ProcessRequest</span> member function is an abstract function that
must be implemented for each application project. In most cases, this
function will access the query and the environment variables via the <span class="ncbi_class">CCgiContext</span>,
using <span class="ncbi_func">ctx.GetRequest()</span> and <span class="ncbi_func">ctx.GetConfig()</span>. The application may then
service the request using its resource's <span class="ncbi_func">HandleRequest()</span> method. The context's
response object can then be used to send an appropriate response. <p>

These classes are described in more detail below, along with abbreviated synopses of the
class definitions. These are included here to provide a conceptual framework and are not
intended as reference materials. For example, constructor and destructor declarations that
operate on void arguments, and <span class="ncbi_keyword">const</span> methods that duplicate 
non-const declarations are generally not included here. Certain virtual functions and data members
that have no meaning outside of a web application are also omitted. For complete
definitions, refer to the header files via the source browsers.
<p><br>

<a name="ccgiapp"></a>
<a href="../docxx/CCgiApplication.html">
<h3> The CCgiApplication class </h3></a>
As mentioned, the <span class="ncbi_class">CCgiApplication </span> class implements its own version of
<a href="../lxr/ident?i=Init">
<span class="ncbi_func">Init()</span></a>, where it instantiates a <a href="#cncbires"><span class="ncbi_class">CNcbiResource</span></a> object using
<span class="ncbi_func">LoadResource()</span>.
<a href="../lxr/ident?i=Run">
<span class="ncbi_func">Run()</span></a> is no longer a pure virtual
function in this subclass, and its implementation now calls <span class="ncbi_func">CreateContext(),
ProcessRequest()</span>, and <span class="ncbi_func">CCgiContext::GetResponse()</span>. The <span class="ncbi_class">CCgiApplication</span>
class does <em>not</em> have
a <span class="ncbi_class">CCgiContext</span> data member, since the application object can participate in multiple
<span class="ncbi_class">CCgiContext</span>s. Instead, a local variable in each <span class="ncbi_func">Run()</span> invocation stores a pointer to the
context created there. The <span class="ncbi_func">LoadServerContext()</span> member function is used in web applications such
as the <a href="../tools.html#ref_TableTools" class="ncbi_app">query</a> program, where it is necessary
to store more complex run-time data with the context object. The <span class="ncbi_class">CCgiServerContext</span>
object returned by this function is stored as a data member of a <span class="ncbi_class">CCgiContext</span>, and is
application-specific.

<blockquote>
<pre class="ncbi_code">
class CCgiApplication : public CNcbiApplication
{
    friend class CCgiContext;

public:

    void Init(void);
    void Exit(void);
    int Run(void);

    CNcbiResource& GetResource(void);
    virtual int ProcessRequest(CCgiContext&) = 0;
    CNcbiResource* LoadResource(void);
    virtual CCgiServerContext* LoadServerContext(CCgiContext& context);

    bool RunFastCGI(unsigned def_iter=3);

protected:

    CCgiContext* CreateContext(CNcbiArguments*, CNcbiEnvironment*,
                               CNcbiIstream*, CNcbiOstream*);

private:
    auto_ptr&lt;CNcbiResource> m_resource;
};
</pre></blockquote>

If the program was <em>not</em> compiled as a Fast-CGI application (or the environment does
not support Fast-CGI), then
<a href="../lxr/ident?i=RunFastCGI" class="ncbi_func"> RunFastCGI()</a> will return <span class="ncbi_value">false</span>. Otherwise, a "Fast-CGI loop" will be
iterated over <span class="ncbi_var">def_iter</span> times, with the initialization methods and
<span class="ncbi_func">ProcessRequest()</span> function being executed on each iteration. The value returned by
<span class="ncbi_func">RunFastCGI()</span> in this case is <span class="ncbi_value">true</span>.  <span class="ncbi_func">Run()</span> first calls <span class="ncbi_func">
RunFastCGI()</span>, and if that returns <span class="ncbi_value">false</span>, the application is run as a plain CGI
program.
<p><br>

<a name="cncbires"></a>
<a href="../docxx/CNcbiResource.html">
<h3> The CNcbiResource</a> and
<a href="../docxx/CNcbiCommand.html">
CNcbiCommand</a> classes </h3>

The resource class is at the heart of the application, and it is here that the program's
functionality is defined. The single argument to the resource class's constructor is a <a
href="applic.html#CNcbiRegistry"><span class="ncbi_class">CNcbiRegistry</span></a> object, which defines data
paths, resources, and possibly environmental variables for the application. This
information is stored in the resource class's data member, <span class="ncbi_var">m_config</span>. The only other
data member is a
<a href="../lxr/ident?i=TCmdList">
<span class="ncbi_type">TCmdList</span></a> (a list of <span class="ncbi_class">CNcbiCommand</span>s) called <span class="ncbi_var">m_cmd</span>.

<blockquote>
<pre class="ncbi_code">
class CNcbiResource
{
public:

    CNcbiResource(CNcbiRegistry& config);

    CNcbiRegistry&    GetConfig(void);
    const TCmdList&   GetCmdList(void) const;
    virtual CNcbiCommand* GetDefaultCommand(void) const = 0;
    virtual const CNcbiResPresentation* GetPresentation(void) const;

    void AddCommand(CNcbiCommand* command);
    virtual void HandleRequest(CCgiContext& ctx);

protected:

    CNcbiRegistry& m_config;
    TCmdList m_cmd;
};CNcbiDbPresentatio
</pre></blockquote>

The <span class="ncbi_func">AddCommand()</span> method is used when a resource is being initialized, to add
commands to the command list.  Given a <span class="ncbi_class">CCgiRequest</span> object defined in a particular context <span class="ncbi_var">ctx</span>,
<a href="../lxr/ident?i=HandleRequest">
<span class="ncbi_ccode">HandleRequest(ctx)</span></a> compares entries in the context's request to
commands in <span class="ncbi_var">m_cmd</span>. The first command in <span class="ncbi_var">m_cmd</span> which matches an entry in the request is then executed (see below),
and the request is considered "handled". If desired, a default command can
be installed which will execute when no matching command is found. The default
command is defined by implementing the pure virtual function <span class="ncbi_func">GetDefaultCommand()</span>.
The <a href="../docxx/CNcbiResPresentation.html">
<span class="ncbi_class">CNcbiResPresentation</span></a> class is an abstract base class, and the member function,
<span class="ncbi_func">GetPresentation()</span>, returns 0. It is provided as a hook for implementing interfaces
between information resources (e.g. databases) and CGI applications.

<blockquote>
<pre class="ncbi_code">
class CNcbiCommand
{
public:

    CNcbiCommand(CNcbiResource& resource);

    virtual CNcbiCommand* Clone(void) const = 0;
    virtual string GetName() const = 0;
    virtual void Execute(CCgiContext& ctx) = 0;
    virtual bool IsRequested(const CCgiContext& ctx) const;

protected:

    virtual string GetEntry() const = 0;
    CNcbiResource& GetResource() const { return m_resource; }

private:

    CNcbiResource& m_resource;
};
</pre></blockquote>

<span class="ncbi_class">CNcbiCommand</span> is an abstract base class: its only data member is a reference to the
resource it belongs to, and most of its methods - with the exception of
<span class="ncbi_func">GetResource()</span> and <span class="ncbi_func">IsRequested()</span> - are pure virtual functions.
<span class="ncbi_func">IsRequested()</span> examines the <span class="ncbi_value">key=value</span> entries stored with the context's
request object. When an entry is found where <span class="ncbi_ccode">key==GetEntry()</span> and
<span class="ncbi_ccode">value==GetName()</span>, <span class="ncbi_func">IsRequested()</span> returns <span class="ncbi_value">true</span>.
<p>

The resource's <span class="ncbi_func">HandleRequest()</span> method iterates over its command list, calling
<span class="ncbi_func">CNcbiCommand::IsRequested()</span> until the first match between a command and a request
entry is found.  When <span class="ncbi_func">IsRequested()</span> returns <span class="ncbi_value">true</span>, the command is <span class="ncbi_term">cloned</span>,
and the cloned command is then <span class="ncbi_term">executed</span>.  Both the <span class="ncbi_func">Execute()</span> and <span class="ncbi_func">Clone()</span>
methods are pure virtual functions which must be implemented by the user.
<p><br>

<a name="ccgireq"></a>
<a href="../docxx/CCgiRequest.html">
<h3> The CCgiRequest class </h3></a>

The <span class="ncbi_class">CCgiRequest</span> class serves as an interface between the user's query and the CGI
program. Arguments to the constructor include a <span class="ncbi_class">CNcbiArguments</span> object, a
<span class="ncbi_class">CNcbiEnvironment</span> object, and a <span class="ncbi_class">CNcbiIstream</span> object. The class
constructors do little other than invoke <span class="ncbi_func">CCgiRequest::x_Init()</span>, where
the actual initialization takes place. <p>

<span class="ncbi_func">x_Init()</span> begins by examining the environment argument, and if it is <span class="ncbi_value">NULL</span>,
<span class="ncbi_var">m_OwnEnv</span> (an auto_ptr) is reset to a dummy environment. Otherwise,
<span class="ncbi_var">m_OwnEnv</span> is reset to the passed environment, making the request object the
effective owner of that environment. The environment is then used to cache network
information as "gettable" properties. Cached properties include:

<ul>
  <li> server properties such as the server name, gateway interface, and server port
  <li> client properties (the remote host and remote address)
  <li> client data properties (content type and content length of the request)
  <li> request properties including the request method, query string, and path information
  <li> authentication information such as the remote user and remote identity
  <li> standard HTTP properties (from the HTTP header)
</ul>
These properties are keyed to an enumeration named
<a href="../docxx/ECgiProp.html">
<span class="ncbi_type">ECgiProp</span></a>, and can be retrieved using the request object's <span class="ncbi_func">GetProperty()</span>
member function.  For example, <span class="ncbi_ccode">GetProperty(eCgi_HttpCookie)</span> is used to access
cookies from the HTTP Header, and <span class="ncbi_ccode">GetProperty(eCgi_RequestMethod)</span> is used to
determine where the query string should be read from. <p>

<span class="ncbi_note">NOTE:</span>

Setting <span class="ncbi_env">$QUERY_STRING</span> without also setting <span class="ncbi_env">$REQUEST_METHOD</span> will result in a
failure by <span class="ncbi_func">x_init()</span> to read the input query.

<span class="ncbi_func">x_init()</span> first looks for the definition of <span class="ncbi_env">$REQUEST_METHOD</span>, and
depending on if it is <span class="ncbi_interface">GET</span> or <span class="ncbi_interface">POST</span>, reads the query from the environment or the
input stream respectively.

If the environment does not define <span class="ncbi_env">$REQUEST_METHOD</span>, then <span class="ncbi_func">x_Init()</span> will
try to read the query string from the command line only.

<blockquote>
<pre class="ncbi_code">
class CCgiRequest {
public:

    CCgiRequest(const CNcbiArguments*, const CNcbiEnvironment*,
        CNcbiIstream*, TFlags);

    static const string& GetPropertyName(ECgiProp prop);
    const string& GetProperty(ECgiProp prop) const;
    size_t GetContentLength(void) const;
    const CCgiCookies& GetCookies(void) const;
    const TCgiEntries& GetEntries(void) const;
    static SIZE_TYPE ParseEntries(const string& str, TCgiEntries& entries);

private:

    void x_Init(const CNcbiArguments*, const CNcbiEnvironment*,
        CNcbiIstream*, TFlags);

    const CNcbiEnvironment*    m_Env;
    auto_ptr&lt;CNcbiEnvironment> m_OwnEnv;
    TCgiEntries m_Entries;
    CCgiCookies m_Cookies;
};
</pre></blockquote>

This abbreviated definition of the <span class="ncbi_class">CCgiRequest</span> class highlights its primary
functionalities:
<ol>
<li> to parse and store the <span class="ncbi_value">&lt;key=value></span> pairs contained
in the query string (stored in <span class="ncbi_var">m_Entries</span>)
<li> to parse and store the cookies contained in the HTTP header (stored in
<span class="ncbi_var">m_Cookies</span>)
</ol>
As implied by the "T" prefix,
<a href="../lxr/ident?i=TCgiEntries">
<span class="ncbi_type">TCgiEntries</span></a> is a type defintion, and defines <span class="ncbi_var">m_Entries</span> to be an STL
multimap of <span class="ncbi_value">&lt;string,string></span> pairs. The <span class="ncbi_class">CCgiCookies</span> class (described <a href="#cookies">below</a>) contains an STL set of <a
href="#ccgicoo"><span class="ncbi_class">CCgiCookie</span></a>, and implements an interface to this set.
<p><br>

<a name="ccgires"></a>
<a href="../docxx/CCgiResponse.html">
<h3> The CCgiResponse class </h3></a>

The <span class="ncbi_class">CCgiResponse</span> class provides an interface to the program's output
stream (usually <span class="ncbi_var">cout</span>) - which is the sole argument to the constructor for <span class="ncbi_class">CCgiResponse</span>.
The output stream can be accessed by the program using <span class="ncbi_func">CCgiResponse::GetOutput()</span>, which
returns a pointer to the output stream, or, using <span class="ncbi_func">CCgiResponse::out()</span>, which returns
a reference to that stream. <p>

In addition to implementing controlled access to the output stream, the primary function
of the response class is to generate appropriate HTML headers that will precede the rest
of the response. For example, a typical sequence in the implementation of a particular
command's execute function might be:

<blockquote>
<pre class="ncbi_code">
MyCommand::Execute(CCgiContext& ctx)
{
    // ... generate the output and store it in MyOutput

    ctx.GetResponse().WriteHeader();
    ctx.GetResponse().out() << MyOutput;
    ctx.GetResponse.out() << "&lt;/body>&lt/html>" << endl;
    ctx.GetResponse.Flush();
}
</pre></blockquote>

Any cookies that are to be sent with the response are included in the headers
generated by the response object.<p>

Two member functions are provided for outputting HTML headers: <span class="ncbi_func">WriteHeader()</span>
and <span class="ncbi_func">WriteHeader(CNcbiOstream&)</span>. The second of these is for writing
to a specified stream other than the default stream stored with the response object.
Thus, <span class="ncbi_ccode">WriteHeader(out())</span> is equivalent to <span class="ncbi_ccode">WriteHeader()</span>. <p>

The <span class="ncbi_func">WriteHeader()</span> function begins by invoking <span class="ncbi_func">IsRawCgi()</span> to
see if the application is a
<a href="http://absolut.banki.hu/~asoka/www.mcp.com/818640000/0-7897/0-7897-0740-3/ch4.htm#NonParsedHeaders">
<span class="ncbi_term">non-parsed header</span></a> program. If so, then the
first header put on the output stream is an HTTP status line, taken from the
private static data member, <span class="ncbi_var">sm_HTTPStatusDefault</span>. Next, unless the content
type has been set by the user (using <span class="ncbi_func">SetContentType()</span>), a default content
line is written, using <span class="ncbi_var">sm_ContentTypeDefault</span>. Any cookies stored in
<span class="ncbi_var">m_Cookies</span> are then written, followed by any additional headers stored
with the request in <span class="ncbi_var">m_HeaderValues</span>. Finally, a new line is written
to separate the body from the headers.

<blockquote>
<pre class="ncbi_code">
class CCgiResponse {
public:

    CCgiResponse(CNcbiOstream* out = 0);

    void SetRawCgi(bool raw);
    bool IsRawCgi(void) const;
    void SetHeaderValue(const string& name, const string& value);
    void SetHeaderValue(const string& name, const tm& value);
    void RemoveHeaderValue(const string& name);
    void SetContentType(const string &type);
    string GetHeaderValue(const string& name) const;
    bool HaveHeaderValue(const string& name) const;
    string GetContentType(void) const;

    CCgiCookies& Cookies(void);             // Get cookies set
    CNcbiOstream* SetOutput(CNcbiOstream* out); // Set default output stream
    CNcbiOstream* GetOutput(void) const;        // Query output stream
    CNcbiOstream& out(void) const;              // Conversion to ostream
                                                // to enable <<
    void Flush() const;

    CNcbiOstream& WriteHeader(void) const;      // Write HTTP response header
    CNcbiOstream& WriteHeader(CNcbiOstream& out) const;

protected:

    typedef map&lt;string, string> TMap;
    static const string sm_ContentTypeName;
    static const string sm_ContentTypeDefault;
    static const string sm_HTTPStatusDefault;
    bool m_RawCgi;
    CCgiCookies m_Cookies;
    TMap m_HeaderValues;       // Additional header lines in alphabetical order
    CNcbiOstream* m_Output;    // Default output stream
};
</pre></blockquote>
<p><br>

<a name="ccgicoo"></a>
<a href="../docxx/CCgiCookie.html">
<h3> The CCgiCookie class </h3></a>

The traditional means of maintaining state information when servicing a multi-step request
has been to include <span class="ncbi_type">hidden</span> input elements in the query strings passed to subsequent
URLs. The newer preferred method uses
<a href="http://home.netscape.com/newsref/std/cookie_spec.html">
HTTP cookies</a>, which
provide the server access to client-side state information stored with the client.
The cookie is a text string consisting of four key=value pairs:

<ul>
  <li> name (required)
  <li> expires (optional)
  <li> domain (optional)
  <li> path (optional)
</ul>

The <span class="ncbi_class">CCgiCookie</span> class provides means of creating, modifying,
and sending cookies. The constructor requires at least two arguments, specifying the
<span class="ncbi_term">name</span> and <span class="ncbi_term">value</span> of the cookie, along with the optional <span class="ncbi_var">domain</span> and
<span class="ncbi_var">path</span> arguments. Format errors in the arguments to the constructor (see <a href="#appendix">Appendix</a>) will cause the invalid argument to be thrown.
The <span class="ncbi_func">CCgiCookie::Write(CNcbiOstream&)</span> member function creates a <span class="ncbi_value">Set-Cookie</span>
directive using its private data members, and places the resulting string on the specified
output stream:

<blockquote>
<pre class="ncbi_output">
Set-Cookie: <span class="ncbi_var">m_Name</span>=<span class="ncbi_var">m_Value</span>; expires=<span class="ncbi_var">m_Expires</span>; path=<span class="ncbi_var">m_Path</span>;
domain=<span class="ncbi_var">m_Domain</span>; <span class="ncbi_var">m_Secure</span>
</pre></blockquote>

<p>As with the constructor, and in compliance with the proposed standard
(<a href="ftp://ftp.isi.edu/in-notes/rfc2109.txt">RFC 2109</a>), only the
name and value are mandatory in the directive.

<blockquote>
<pre class="ncbi_code">
class CCgiCookie {
public:

    CCgiCookie(const string& name, const string& value,
               const string& domain = NcbiEmptyString,
               const string& path   = NcbiEmptyString);

    const string& GetName(void) const;

    CNcbiOstream& Write(CNcbiOstream& os) const;

    void Reset(void);
    void CopyAttributes(const CCgiCookie& cookie);
    void SetValue  (const string& str);
    void SetDomain (const string& str);
    void SetPath   (const string& str);
    void SetExpDate(const tm& exp_date);
    void SetSecure (bool secure);

    const string& GetValue  (void) const;
    const string& GetDomain (void) const;
    const string& GetPath   (void) const;
    string        GetExpDate(void) const;
    bool GetExpDate(tm* exp_date) const;
    bool GetSecure(void)          const;

    bool operator&lt;(const CCgiCookie& cookie) const;
    typedef const CCgiCookie* TCPtr;
    struct PLessCPtr {
        bool operator() (const TCPtr& c1, const TCPtr& c2) const {
            return (*c1 < *c2);
        }
    };

private:
    string m_Name;
    string m_Value;
    string m_Domain;
    string m_Path;
    tm     m_Expires;
    bool   m_Secure;
};
</pre></blockquote>


With the exception of <span class="ncbi_var">m_Name</span>, all of the cookie's data members can be reset using
the <span class="ncbi_func">SetXxx(), Reset()</span>, and <span class="ncbi_func">CopyAttributes()</span> member functions; <span class="ncbi_var">m_Name</span> is
non-mutable. As with the constructor, format errors in the arguments to these functions
will cause the invalid argument to be thrown. By default, <span class="ncbi_var">m_Secure</span> is
<span class="ncbi_value">false</span>. The <span class="ncbi_func">GetXxx()</span> methods return the stored value for that attribute or,
if no value has been set, a reference to <span class="ncbi_class">NcbiEmptyString</span>. <span class="ncbi_ccode">GetExpDate(tm*)</span>
returns <span class="ncbi_value">false</span> if no expiration date was previously set. Otherwise, <span class="ncbi_var">tm</span> is
reset to <span class="ncbi_var">m_Expire</span>, and <span class="ncbi_value">true</span> is returned.
<p><br>

<a name="cookies"></a>
<a href="../docxx/CCgiCookies.html">
<h3> The CCgiCookies class </h3></a>

The <span class="ncbi_class">CCgiCookies</span> class provides an interface to an STL set of <span class="ncbi_class">CCgiCookie</span>s
(<span class="ncbi_var">m_Cookies</span>). Each cookie in the set is uniquely identified by its name, domain, and
path values, and is stored in ascending order using the <span class="ncbi_type">CCgiCookie::PLessCPtr</span>
struct.  Two constructors are provided, allowing the user to initialize <span class="ncbi_var">m_Cookies</span>
to either an empty set or a set of <span class="ncbi_var">N</span> new cookies created from the string
"name1=value1; name2=value2; ...; nameN=valuenN".
Many of the operations on a <span class="ncbi_class">CCgiCookies</span> object involve iterating over the set,
and the class's type definitions support these activities by
providing built-in iterators and a typedef for the set, <span class="ncbi_type">TSet</span>. <p>

The <span class="ncbi_func">Add()</span> methods provide a variety of options for creating and adding new cookies to the set.
As with the constructor, a single string of name-value pairs may be used to create and add <span class="ncbi_var">N</span>
cookies to the set at once. Previously created cookies can also be added to the set individually or
as sets. Similarly, the <span class="ncbi_func">Remove()</span> methods allow individual cookies or sets of cookies (in the
specified range) to be removed. All of the remove functions destroy the removed cookies when
<span class="ncbi_ccode">destroy==true</span>. <span class="ncbi_func">CCgiCookies::Write(CNcbiOstream&)</span> iteratively invokes the <span class="ncbi_func">CCgiCookie::Write()</span>
on each element.

<blockquote>
<pre class="ncbi_code">
class CCgiCookies {
public:
    typedef set&lt;CCgiCookie*, CCgiCookie::PLessCPtr>  TSet;
    typedef TSet::iterator         TIter;
    typedef TSet::const_iterator   TCIter;
    typedef pair&lt;TIter,  TIter>    TRange;
    typedef pair&lt;TCIter, TCIter>   TCRange;

    CCgiCookies(void);           // create empty set of cookies
    CCgiCookies(const string& str);
    // str = "name1=value1; name2=value2; ..."

    bool Empty(void) const;

    CCgiCookie* Add(const string& name, const string& value,
                    const string& domain = NcbiEmptyString,
                    const string& path   = NcbiEmptyString);

    CCgiCookie* Add(const CCgiCookie& cookie);
    void Add(const CCgiCookies& cookies);
    void Add(const string& str);
    // "name1=value1; name2=value2; ..."

    CCgiCookie* Find(const string& name, const string& domain, const string& path);
    CCgiCookie* Find(const string& name, TRange*  range=0);

    bool Remove(CCgiCookie* cookie, bool destroy=true);
    size_t Remove(TRange& range, bool destroy=true);
    size_t Remove(const string& name, bool destroy=true);
    void Clear(void);

    CNcbiOstream& Write(CNcbiOstream& os) const;

private:
    TSet m_Cookies;
};
</pre></blockquote>
<p><br>

<a name="ccgictx"></a>
<a href="../docxx/CCgiContext.html">
<h3> The CCgiContext class </h3></a> As depicted in <a href="#overview"> Figure 1</a>, a
<span class="ncbi_class">CCgiContext</span> object contains an application object, a request object, and a response
object, corresponding to its data members <span class="ncbi_var">m_app, m_request</span>, and
<span class="ncbi_var">m_response</span>. Additional data members include a string encoding the URL for the context
(<span class="ncbi_var">m_selfURL</span>), a message buffer (<span class="ncbi_var">m_lmsg</span>), and a <span class="ncbi_class">CCgiServerContext</span>. These
last three data members are only used in complex web applications such as the <a
href="../tools.html#ref_TableTools" class="ncbi_app">query</a> program, where it is necessary to store
more complex run-time data with the context object.  The message buffer is essentially an STL
list of string objects whose class definition
(<a href="../lxr/ident?i=CCtxMsgString"><span class="ncbi_class">CCtxMsgString</span></a>)
includes a <span class="ncbi_func">Write()</span> output function. <span class="ncbi_func">GetServCtx()</span> returns <span class="ncbi_var">m_srvCtx</span> if it
has been defined and otherwise, calls the application's
<span class="ncbi_func">CCgiApplication::LoadServerContext()</span> to obtain it.

<blockquote>
<pre class="ncbi_code">
class CCgiContext
{
public:
    CCgiContext(CCgiApplication&        app,
                const CNcbiArguments*   args = 0,
                const CNcbiEnvironment* env  = 0,
                CNcbiIstream*           inp  = 0,
                CNcbiOstream*           out  = 0);

    const CCgiApplication& GetApp(void) const;
    CNcbiRegistry&     GetConfig(void);
    CCgiRequest&       GetRequest(void);
    CCgiResponse&      GetResponse(void);
    const string&      GetSelfURL(void) const;
    CNcbiResource&     GetResource(void);
    CCgiServerContext&     GetServCtx(void);

    CNcbiOstream& PrintMsg(CNcbiOstream& os);   // output all msgs in m_lmsg to os
    void PutMsg(const string& msg);     // add message to m_lmsg
    void PutMsg(CCtxMsg* msg);          // add message to m_lmsg
    bool EmptyMsg(void);            // true iff m_lmsg is empty
    void ClearMsg(void);            // delete all messages in m_lmsg

    string GetRequestValue(const string& name) const;
    void AddRequestValue(const string& name, const string& value);
    void RemoveRequestValues(const string& name);
    void ReplaceRequestValue(const string& name, const string& value);

private:

    CCgiApplication&      m_app;
    auto_ptr&lt;CCgiRequest> m_request;
    CCgiResponse      m_response;
    mutable string    m_selfURL;
    list&lt;CCtxMsg*>        m_lmsg;        // message buffer

    auto_ptr&lt;CCgiServerContext> m_srvCtx;
    // defined by CCgiApplication::LoadServerContext()

    friend class CCgiApplication;
};
</pre></blockquote>
<p><br>

<a name=xmpl></a><h3>Example code using the CGI classes</h3>
The <a href="../tools.html#ref_TableTools"> <span class="ncbi_app">hello</span></a> program demonstrates a
simple application that combines the NCBI C++ Toolkit's CGI and HTML classes.
<a href="cgi_cpp.html"><span class="ncbi_file">justcgi.cpp</span></a> is an adaptation of
that program, stripped of all HTML references with additional request-processing added.
<p>
The application defines two classes of commands:<p>

<table border=1 width=400 cellspacing=1>
  <caption></caption>
  <tr><th>class</th><th><span class="ncbi_func">GetEntry()</span></th><th><span class="ncbi_func">GetName()</span></th> </tr>
  <tr><td> CHelloBasicCommand </td> <td> cmd1 </td> <td> init </td> </tr>
  <tr><td> CHelloReplyCommand </td> <td> cmd2 </td> <td> reply </td> </tr>
</table>
<p>
Executing <pre class="ncbi_cmd">./cgi 'cmd1=init&cmd2=reply'</pre> 
results in execution of only <span class="ncbi_var">cmd1</span>,
as does executing 
<pre class="ncbi_cmd">./cgi 'cmd2=reply&cmd1=init'</pre>
The commands are matched in the
order that they are registered with the resource - not according to the order in which
they occur in the request. The assumption is that only the first entry (if any) in the query
actually specifies a command, and that the remaining entries provide optional arguments
to that command.
The <a href="make_cgi.html"> Makefile</a> for this example links
to both the <span class="ncbi_proj">xncbi</span> and <span class="ncbi_proj">xcgi</span> libraries.
Additional examples using the CGI classes can be found in
<a href="../lxr/source/src/cgi/test/" class="ncbi_dir">src/cgi/test</a>.
<p><br>

<a name="cgireg"></a><h3>CGI Registry configuration</h3>
<p>Application registry defines CGI related configuration settings, 
in the <span class="ncbi_reg">[CGI]</span> section.</p>


<table border=1 width=550 cellspacing=1>
  <caption></caption>
  <tr><th>Field</th><th>Value(s)</th><th>Action</th> </tr>

  <tr>
	<td><span class="ncbi_reg_var">TimeStamp</span></td> 
	<td>true | false</td>
	<td>"true" - log start time, finish time and total elapsed time
	</td>
  </tr>
  <tr>
	<td><span class="ncbi_reg_var">PrintEnv</span></td> 
	<td>all | {comma separated list of environment variables}</td>
	<td> "all" - log all environment variables<br>
		 instead of "all" can be list of variables to be logged
	</td>
  </tr>
  <tr>
	<td><span class="ncbi_reg_var">Log</span></td> 
	<td>OnError | OnDebug | On </td>
	<td>"On" - enable logging <br> 
	    "OnDebug" - enables logging if program compiled in debug mode<br>
		"OnError" - enables logging if CGI fails for some reason<br>
	</td>
  </tr>
  <tr>
	<td><span class="ncbi_reg_var">StatLog</span></td> 
	<td>true | false</td>
	<td>"true" - enable statistical logging <br> 
	</td>
  </tr>
  <tr>
	<td><span class="ncbi_reg_var">LogArgs</span></td> 
	<td>{comma separated list of CGI request variables}</td>
	<td>If defined all variables will appear in the statistics log files 
	in form of key='value' pairs where key is the variable name.
	<pre class="ncbi_code"> Example: LogArgs = param1,param2 </pre>
	Here param1 and param2 are names of the 
	In addition it is possible to specify alternative aliases for variable 
	names. Aliases are used in case we want param1 to appear in the log file 
	under some different name (say 'alias').
	<br>
	<pre class="ncbi_code"> Example: LogParams = param1=alias,param2</pre>
	<br>
	The rationale for aliasing can be saving space in log files, 
	resolving names ambuiguities or improving log files readabilty.
	</td>
  </tr>
  <tr>
	<td><span class="ncbi_reg_var">TimeStatCutOff</span></td> 
	<td>number of cut-off seconds</td>
	<td>Used with <span class="ncbi_reg_var">StatLog</span>. 
	Used NOT to log statistics if CGI request took less than specified number 
	of seconds. No effect if set to 0.
	<br> 
	</td>
  </tr>
  <tr>
	<td><span class="ncbi_reg_var">RequestErrBufSize</span></td> 
	<td>Size of CGI request error buffer</td>
	<td>This parameter works only when CGI request fails trying to parse
        the request string. In this case error message includes portion
        of the original request string. (By default it is first 256 characters).
        By setting this parameter you can disable printing buffer 
        diagnostics (value 0) or set value different than 256. 
	<br><br> 

        Example:<br>
	<pre class="ncbi_code">[CGI]<br>RequestErrBufSize = 1024</pre>
	</td>
  </tr>

  <tr>
	<td><span class="ncbi_reg_var">DiagPrefixEnv</span></td> 
	<td>Name of environment variable</td>
	<td>The value of specified environment variable will be added (as prefix)
       to all diagnostic messages isued during the HTTP request processing. 
	<br><br> 

        Example:<br>
	<pre class="ncbi_code">[CGI]<br>DiagPrefixEnv = PROXIED_IP</pre>
	</td>
  </tr>

</table>

<p>Fast CGI settings.<span class="ncbi_reg">[FastCGI]</span> section.</p>

<table border=1 width=550 cellspacing=1>
  <caption></caption>
  <tr><th>Field</th><th>Value(s)</th><th>Action</th> </tr>

  <tr>
	<td><span class="ncbi_reg_var">StopIfFailed</span></td> 
	<td>true | false</td>
	<td>"true" - stop Fast CGI application in case of an error
	</td>
  </tr>

  <tr>
	<td><span class="ncbi_reg_var">PrintIterNo</span></td> 
	<td>true | false</td>
	<td>"true" - log FastCGI iteration(call) number
	</td>
  </tr>

  <tr>
	<td><span class="ncbi_reg_var">Debug</span></td> 
	<td>true | false</td>
	<td>"true" - logs fast CGI debug information into the output context
	</td>
  </tr>

  <tr>
	<td><span class="ncbi_reg_var">StandaloneServer</span></td> 
	<td>Unix domain socket (named pipe for WinNT), or a colon followed by a port number</td>
	<td>Run FastCGI as a standalone server on the local port, without
       Web server.<br>
       You can also use environment variable
       <span class="ncbi_env_var">$FCGI_STANDALONE_SERVER</span>.
	<br><br> 

        Example:<br>
	<pre class="ncbi_code">[FastCGI]<br>StandaloneServer = :5000</pre>
        or:
	<pre class="ncbi_code">[FastCGI]<br>StandaloneServer = /tmp/fcgi/mysocket</pre>
	</td>
  </tr>


</table>


<p>CGI load balancing settings.<span class="ncbi_reg">[CGI-LB]</span> section.</p>

<table border=1 width=550 cellspacing=1>
  <caption></caption>
  <tr><th>Field</th><th>Value(s)</th><th>Action</th> </tr>

  <tr>
	<td><span class="ncbi_reg_var">Name</span></td> 
	<td>Cookie name</td>
	<td>Name of the load balancing cookie in the HTTP response
	</td>
  </tr>

  <tr>
	<td><span class="ncbi_reg_var">LifeSpan</span></td> 
	<td>Cookie life span in seconds</td>
	<td>Cookie expiration period in seconds
	</td>
  </tr>

  <tr>
	<td><span class="ncbi_reg_var">Domain</span></td> 
	<td>Internet domain</td>
	<td>For NCBI services should be "ncbi.nlm.nih.gov"
	</td>
  </tr>

  <tr>
	<td><span class="ncbi_reg_var">Path</span></td> 
	<td>Cookie path</td>
	<td>"/" for most cases
	</td>
  </tr>

  <tr>
	<td><span class="ncbi_reg_var">Secure</span></td> 
	<td>true | false</td>
	<td>Cookie security mode
	</td>
  </tr>

  <tr>
	<td><span class="ncbi_reg_var">Host</span></td> 
	<td>Host IP address</td>
	<td>This becomes the value of the cookie. 
	When registry value is not defined, application tries to identify the host 
	value automatically. In this case application should be initialized using 
	CCgiApplication::SetCafService function.	
	</td>
  </tr>

</table>


<a name=appendix></a><h3>Appendix</h3>
<h4> Restrictions on arguments to the <span class="ncbi_class">CCgiCookie</span> constructor </h4>
<table border=1 width=550 cellspacing=1>
  <caption></caption>
  <tr><th>Field</th><th>Restrictions</th> </tr>
  <tr><td> name (required)  </td> <td> no spaces; must be printable ASCII; cannot contain = , or ; </tr>
  <tr><td> value (required) </td> <td> no spaces; must be printable ASCII; cannot contain , or ; </tr>
  <tr><td> domain (optional)</td> <td> no spaces; must be printable ASCII; cannot contain , or ; </tr>
  <tr><td> path  (optional) </td> <td> case-sensitive </tr>

</table>
<p>

<a href="exceptions.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="webpgs.html"> <i> next</i> </a>


<!--#include virtual="../ssi/navlinks.shtml" -->

     <table border=0 width="100%" cellspacing=0>
        <tr>
          <td><address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
          <!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> -->
          <td align=right><span class="ncbi_cvs_date">$Date$</span></td>
     </table>

<!--#include virtual="../ssi/footer.shtml" -->
