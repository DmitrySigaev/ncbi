<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
    <title>Class Type Information</title>
  </head>
  <body bgcolor = white>
    <h1> Class Type Information </h1>

  	      <ul>
	        <li>The <a href="#ctypeinfo"> <i>CTypeInfo</i></a> class
	        <li>The <a href="#cobjinfo"> <i>CObjectInfo</i></a> class
	        <li>The <a href="#objstrs"> <i>CObject[IO]Stream</i></a> classes
	        <li>The <a href="#iterators"> C++ Type-specific Iterators</a>
	        <li><a href="#macros"> Preprocessor macros for specifying type information </a>
	      </ul>

Type information about an object is necessary in three contexts: (1) when processing serialized
data, where information about an encoded object's internal structure is needed, (2) when
reading from a flat (non-serialized) data file, where class member names must be readily
available, and (3) when using a generalized <a href="iterators.html"> type iterator</a> to
traverse the data members of a structured object.  The usage of type information to process
serialized data is described in the sections <a href="asn.html"> Processing serial data</a> and
<a href="traverse.html"> Traversing a serialized data structure</a>. C++ object type iterators
are described in <a href="iterators.html"> The NCBI C++ Toolkit Iterators</a> section.<p>

The type information for a class is stored outside any instances of that class, in a statically
created <i>CTypeInfo</i> object. The <i>CTypeInfo</i> object is then accessed by all instances
of the class via the <a
href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=GetTypeInfo">
<i>GetTypeInfo()</i></a> class method. With the first invocation of <i>GetTypeInfo()</i> (for a
given class), a static <a href="#ctypeinfo"><i>CTypeInfo</i></a> object is created, which is
local to the function <i>GetTypeInfo()</i>. Subsequent calls to <i>GetTypeInfo()</i> simply
return a pointer to this statically created local object. Because <i>GetTypeInfo()</i> is
itself a static class method, a single invocation initializes the <i>CTypeInfo</i> object for
all instances of that class.<p>

All of the classes defined in the C++ Toolkit's <i>objects</i> directory have a static
<i>GetTypeInfo()</i> member function. In order to make type information about user-defined
classes accessible to your application, these classes must also implement a static
<i>GetTypeInfo()</i> method. A set of preprocessor <a href="#macros"> macros</a> are available which greatly
simplify this effort. A prerequisite to using these macros however, is that the class definition must
include the following line:<p>
<center><pre>static const CTypeInfo* GetTypeInfo(void);
</pre></center>

Only C++ <i>class</i> and <i>struct</i> objects can have static methods however, and additional
mechanisms must be used to implement "type information" for other entities, such as C++ <i>enum</i>s
as well as C style <i>struct</i> and <i>choice</i> elements defined in legacy libraries. These mechanisms
are also defined in the section on preprocessor macros. 

<a name="ctypeinfo"> <h3> The
<a href="../docxx/CTypeInfo.html"> <i>CTypeInfo</i></a> class </h3>
This is the base class for all type information storage and mechanisms. The class contains a
single data member, <i>m_Name</i>, which stores the class name for the object. A large number
of member functions - many of which are pure virtual functions at this level - provide
information about data members, class type, subclass types, superclass types, and size.  
For example, <i>CTypeInfo::EndOf(object)</i> adds the address of <i>object</i> to the value
returned by <i>CTypeInfo::GetSize()</i>, to define the address where the object
terminates. This is used by the object <a href="iterators.html"> type iterators</a> to define
their termination conditions. <p>

The subclasses derived from this base class include 
<a href="../docxx/CPrimitiveTypeInfo.html"> <i>CPrimitiveTypeInfo</i></a>, 
<a href="../docxx/CPointerTypeInfo.html"> <i>CPointerTypeInfo</i></a>,
<a href="../docxx/CContainerTypeInfo.html"> <i>CContainerTypeInfo</i></a>, and
<a href="../docxx/CClassTypeInfoBase.html"> <i>CClassTypeInfoBase</i></a>.
These subclasses contain additional data members and member functions, such as
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=AddMember"> <i>AddMember()</i></a> and
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=AddSubClass"> <i>AddSubClass()</i></a>,
which accomodate the different features required for different data types. The <a href="#macros"> macros</a> described
below provide interfaces to these <i>CTypeInfo</i> subclasses and their methods for adding class type information.
<p>

Type information is often needed when the object itself has been passed anonymously,
or as an instance of a more abstract parent class. In this case, it is not possible to invoke the
<i>GetTypeInfo()</i> method directly, as the object's specific type is unknown. Using a static cast
operation to enable the member function is also unsafe, as it may open the door to
incorrectly associating an object's pointer with the wrong type information.  For these
reasons, the <i>CTypeInfo</i> class is intended for internal usage only, and it is the
<a href="#cobjinfo"> <i>CObjectInfo</i></a> class which provides the user interface to object
type information.

<a name="cobjinfo"> <h3> The 
<a href="../docxx/CObjectInfo.html"> <i>CObjectInfo</i></a> class </h3>

Let us suppose that we would like to have a generic function which can populate an object 
using data read from a flat file. For example, we might like to have:

<center><pre>int LoadObject (CObject& myObj, CNcbiIStream& is); </pre></center>

where <i>myObj</i> is an instance of some subclass of <i>CObject</i>. Assuming that the text in the
file is of the form:
<pre>MemberName: value
MemberName: value
MemberName: value
:
</pre>
we would like to find the corresponding data member in <i>myObj</i> for each <i>MemberName</i>, and set
the data member's value accordingly. Unfortunately, <i>myObj</i> cannot directly supply any useful
type information, as the member names we seek are for a specific subclass of <i>CObject</i>. The solution to
this problem is to pass a <i>CObjectInfo</i> to the function instead of a <i>CObject</i>. Specifically,
we create <i>myObj</i> as an instance of the desired type, and then use <i>ObjectInfo(myObj</i>) to obtain an
instance of <i>CObjectInfo</i> for <i>myObj</i>. Our new definition of <i>LoadObject()</i> might then be:

<center><pre>int LoadObject (CObjectInfo *info, CNcbiIStream& is); </pre></center>

The <i>CObjectInfo</i> object (<i>info</i>) will contain pointers to <i>myObj</i> as well as to its associated
<i>CTypeInfo</i> object. Using the interface to <i>CObjectInfo</i>, we can access <i>myObj</i> as
<i>info->GetObjectPtr()</i>. Each line in the file can then be processed as follows:

<font color="#000080"><pre>
     string myName, myValue;
     int MemIndex;

     while (!is.eof()) {

         is >> myName >> myValue;

         MemIndex = info->FindMember(RemoveDelimiter(myName, ':'));

         if (MemIndex != -1) {

	     info->GetClassMember(MemIndex)->SetPrimitiveValueString (myValue);

         }

         else {
            // generate an error message and exit
         }
     }
</pre></font>

The <i>GetClassMember()</i> method also returns a <i>CObjectInfo</i> object, in this case, for the data member. 
Accordingly, we use <i>CObjectInfo</i>'s class interface to set the value of this member.

<a name="objstrs"> <h3> The 
<a href="../docxx/CObjectIStream"> <i>CObjectIStream</i></a> and
<a href="../docxx/CObjectOStream"> <i>CObjectOStream</i></a> classes</h3>

Both of these classes are derived from the <a
href="../docxx/CObjectStack"> <i>CObjectStack</i></a>
class. As implied by this class name, the object stream classes use a stack data structure
to support the parsing of serialized objects. Reading and writing serial data objects is
described in the section on <a href="asn.html#example1"> Processing serial data</a>, where the
program <a href="xml2asn_cpp.html"><i>xml2asn.cpp</i></a> demonstrated the usage of both
<i>CObjectIStream</i> and <i>CObjectOStream</i>. Here, we reconsider these objects briefly
with respect to how type information is used in combination with I/O streams to handle serial data. <p>

Each of the <i>open</i> statements in <a href="xml2asn_cpp.html"><i>xml2asn.cpp</i></a> specifies a filename and an 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=ESerialDataFormat">
<i>ESerialDataFormat</i></a>, e.g.:

<font color = "#000080"><pre>
  auto_ptr<CObjectIStream> xml_in(CObjectIStream::Open("1001.xml", eSerial_Xml));
</pre></font>

This statement causes a 
<a href="../docxx/CObjectIStreamXml.html"> 
<i>CObjectIStreamXml</i></a> object to be opened on the file named "1001.xml". No information 
is yet provided as to what <i>type</i> of object(s) may be encoded in the file - only the
syntax used in the encoding is currently known. Similarly, the two statements which
create output streams specify only that the output formats will be ASN.1 text and ASN.1 binary. <p>

It is not until the input and output operators are applied to these streams, in conjunction with the 
<i>CBiostruc bs</i>, that the object-specific type information comes into play. The statement
<i>*xml_in >> bs </i> indirectly invokes the <i>Read()</i> template function, which is defined as:
<font color = "#000080"><pre>
template&lt;typename T> CObjectIStream& Read(CObjectIStream& in, T& object)
{
    Read(in, &object, GetTypeRef(&object));
    return in;
}
</pre></font>
This, in turn, accesses the class type information associated with the object, <i>bs</i>. Here,
<i>GetTypeRef()</i> is ensured to return the correct type information. Similarly, the output
operators, when applied to the <i>CObjectOstream</i> objects in conjunction with the 
<i>bs</i>, will invoke the <i>Write()</i> template function:

<font color = "#000080"><pre>
template&lt;typename T> CObjectOStream& Write(CObjectOStream& out, T& object)
{
    Write(out, &object, GetTypeRef(&object));
    return out;
}
</pre></font>

The type information
defines what tag names and value types should be encountered on the stream, while the <i>CObject[IO]Stream</i>
subclasses specialize the specific syntax (such as field delimiters) for each format. The stream objects
use internal stack data structures to keep track of nested "frames" in the data stream. <p>

<a name="macros"><h3> Preprocessor Macros for implementing the <i>GetTypeInfo()</i> member function</h3>
All of the classes defined in the <i>include/objects</i> directory of the C++ tree have the
static <i>GetTypeInfo()</i> member function defined. Accordingly, all of the resulting objects can 
be used with the ASN.1 and XML input and output object streams described above. In order to apply 
these object streams to user-defined classes however, it is also necessary to implement the 
static <i>GetTypeInfo()</i> member function for these objects.<p>

A number of pre-processor macros are defined in 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/serial/serialimpl.hpp"> 
<i>serialimpl.hpp</i></a> to support this type of activity. 
Several pairs of <i>BEGIN/END</i> macros 
implement the <i>GetTypeInfo()</i> method for different types of objects. 
Each of the <i>BEGIN_NAMED_xxx_INFO</i> macros listed in Table 1 has a corresponding 
<i>END_xxx_INFO</i> macro definition.<p>

Most of these macros take two <i>string</i> arguments: (1) an external alias for the object, and (2) the
internal C++ symbolic class name. The alias is required for serial objects whose external
name differs from the internal C++ class name. For example, the external object names specified
in the ASN.1 modules (in <i>src/objects</i>) are prefixed with the letter "C" in 
the corresponding C++ class names (e.g., <i>Bioseq</i> versus <i>CBioseq</i>).  Each of the "named"
macros in Table 1 has a corresponding "unnamed" macro which accepts the (unquoted) symbolic
class name as one of its arguments, and generates a call to the corresponding "named" macro using
a quoted string.  For example, <i>BEGIN_CLASS_INFO</i> is defined as:

<font color = "#000080"> <pre>
#define BEGIN_CLASS_INFO(ClassName) BEGIN_NAMED_CLASS_INFO(#ClassName, ClassName)
</pre></font>

Internal information about non-object entities, including <i>enum</i>s and C style structs
(such as those defined in the C Toolkit), can also be accessed.  Because it is not possible to
install methods <i>per se</i> for these entities, two helper functions,
<i>GetTypeInfo_struct_()</i> and <i>GetEnumInfo_()</i> are used in conjunction with the macros
in Table 1 to install global functions.  Note also that because a C++ <i>struct</i> is actually
a C++ <i>class</i> with no private or protected members, the CLASS_INFO macros should be used
for these objects - <i>not</i> the ASN_STRUCT_INFO macros.
<p>

<table BORDER WIDTH="100%"><caption ALIGN=BOTTOM> Table 1</caption>
<tr><th>Macro name</th>			    <th>Class type used for</th>            <th>Arguments</th>   </tr>

<tr><td><a href="#class">  BEGIN_NAMED_CLASS_INFO</a></td>
					    <td>Non-abstract class object</td>      <td>ClassAlias, ClassName</td> </tr>


<tr><td><a href="#abstr">  BEGIN_NAMED_ABSTRACT_CLASS_INFO</a></td>
					    <td>Abstract class object</td>	    <td>ClassAlias, ClassName</td> </tr>

<tr><td><a href="#derive"> BEGIN_NAMED_DERIVED_CLASS_INFO</a></td> 
					    <td>Derived subclass object</td>	    <td>ClassAlias, ClassName, BaseClassName</td> </tr>

<tr><td><a href="#choice"> BEGIN_NAMED_CHOICE_INFO</a></td>
					    <td>C++ class choice object</td>        <td>ClassAlias, ClassName</td> </tr>

<tr><td><a href="#achoice"> BEGIN_NAMED_ASN_CHOICE_INFO</a></td>
					    <td>(old style) C choice object  </td>  <td>ChoiceAlias, ChoiceName</td> </tr>

<tr><td><a href="#asnstr"> BEGIN_NAMED_ASN_STRUCT_INFO</a></td>
					    <td>(old style) C Struct object</td>    <td>StructAlias, StructName</td> </tr>

<tr><td><a href="#enum">   BEGIN_NAMED_ENUM_INFO</a></td>
					    <td>Enum object</td>		    <td>EnumAlias, InfoName, EnumName, IsInteger</td> </tr>
</table>
<p>

<ul>
<li> <a name=class>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_CLASS_INFO">
<i>BEGIN_NAMED_CLASS_INFO</i></a> should be used on classes that
do not contain any pure virtual functions. For example, the 
<i>GetTypeInfo()</i> method for the <a href="iterators.html#CPerson"><i>CPerson</i></a> class can be
implemented as:
<font color = "#000080"> <pre>
BEGIN_NAMED_CLASS_INFO("CPerson", CPerson)
{
    ADD_NAMED_STD_MEMBER("m_name", m_name);
    ADD_NAMED_STD_MEMBER("m_addr", m_addr);
    ADD_NAMED_MEMBER("m_next_door", m_next_door, POINTER, (CLASS, (CPerson)));
}
END_CLASS_INFO
</pre><font color = black>
The macros used to add members here are defined in <a href="#addm"> Table 2</a>. <p>

<li><a name=abstr>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_ABSTRACT_CLASS_INFO">
<i>BEGIN_NAMED_ABSTRACT_CLASS_INFO</i></a> must be used on
abstract base classes which contain pure virtual functions. Because these abstract classes cannot
be instantiated, special handling is required in order to install their static <i>GetTypeInfo()</i>
methods. <p>

For example, suppose the classes <i>CA</i> and <i>CB</i> are derived from an abstract base
class, <i>CBase</i>.  In order to apply a <a href="iterators.html#typeIt">
<i>CTypeIterator</i></a><i>&lt;CBase></i> that will visit
all objects of type <i>CA</i> and <i>CB</i>, we must be able to implement the
<i>GetTypeInfo()</i> method on that abstract class. The <i>ABSTRACT_CLASS_INFO</i> macros do
this for us:

<font color = "#000080"> <pre>
BEGIN_NAMED_ABSTRACT_CLASS_INFO("CBase", CBase)
{
  // ... data member definitions for abstract base class

  ADD_NAMED_SUB_CLASS ("CA", CA);
  ADD_NAMED_SUB_CLASS ("CB", CB);
}
END_ABSTRACT_CLASS_INFO
</pre></font>
The <a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=ADD_NAMED_SUB_CLASS">
<i>ADD_NAMED_SUB_CLASS</i></a> macro provides the class inheritance information for all objects -
its usage is <i>not</i> restricted to abstract classes. However, each class listed as a
subclass by these macros must also use the DERIVED_CLASS
macros defined below. Failure to define these hierarchical relations in the
<i>GetTypeInfo()</i> macros will not lead to compile-time errors, but the iterator will
<i>not</i> recognize these objects as instances of the parent class.
<p>
<li><a name=derive>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_DERIVED_CLASS_INFO">
<i>BEGIN_NAMED_DERIVED_CLASS_INFO</i></a> should be used on derived subclasses whose parent classes also
have the <i>GetTypeInfo()</i> method implemented. Data members inherited from parent classes should
not be included in the derived class type information. 

<font color = "#000080"> <pre>
BEGIN_NAMED_DERIVED_CLASS_INFO("CA", CA, CBASE)
{
  // ... data members in CA not inherited from CBase
}
END_DERIVED_CLASS_INFO
</pre></font>

<font color=red> NOTE:</font> The type information for classes derived from <i>CObject</i> does
<i>not</i> however, follow this protocol. In this special case, although the class is derived
from <i>CObject</i>, you should <i>not</i> use the <i>DERIVED_CLASS</i> macros to implement
<i>GetTypeInfo()</i>, but instead use the usual <i>BEGIN_CLASS_INFO</i> macro. <i>CObject</i>'s
have a slightly different interface to their type information (see <a
href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=CObjectGetTypeInfo">
<i>CObjectGetTypeInfo</i></a>), and apply these macros differently. <p>

<li><a name=choice>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_CHOICE_INFO">
<i>BEGIN_NAMED_CHOICE_INFO</i></a> installs <i>GetTypeInfo()</i> for C++ <i>choice</i> objects, 
which are implemented as C++ classes; each of the choice types is identified as an internally
enumerated type. The <i>Which()</i> and <i>Select()</i> methods provide the interface to the
currently selected option, and a private data member, <i>m_object</i> is a <i>CObject*</i> 
pointer to the selected option's internal representation.<p>

The arguments to the macro are the external class alias and the internal C++ class name for the
choice object.  The <i>ADD_NAMED_*_CHOICE_VARIANT</i> macros are used to add the enumerated
type options to the choice object's type information.
 <p>

<li><a name=achoice>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_ASN_CHOICE_INFO">
<i>BEGIN_NAMED_ASN_CHOICE_INFO</i></a> installs the corresponding global <i>GetTypeInfo_struct()_</i> 
function for old C style ASN.1 <i>choice</i> nodes (implemented as <i>valnode</i>s). Arguments
to the macro are the external choice alias and the internal name for the choice node in the C
Toolkit libraries. As a result of executing the macro, a global function named
<i>GetTypeInfo_struct_ChoiceName</i> will be implemented. The <i>ADD_ASN_CHOICE_VARIANT</i>
macros are used to add types to the choice object.
<p>

<li><a name=asnstr>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_ASN_STRUCT_INFO">
<i>BEGIN_NAMED_ASN_STRUCT_INFO</i></a> should be
used to implement the <i>GetTypeInfo_struct()_</i> function for C style <i>struct</i>s. 
User-defined C++ <i>struct</i>s should <i>not</i> use this macro; it is provided 
only for the implementation of type information functions for legacy code structures. 
As a result of executing this macro, a global function named 
<i>GetTypeInfo_struct_StructName</i> will be implemented. 
Members are added to the <i>struct</i> using the same <i>ADD_*</i> macros used
for class objects. <p>

<li><a name=enum>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_NAMED_ENUM_INFO">
<i>BEGIN_NAMED_ENUM_INFO(Name, Method, Enum, IsInteger)</i></a> takes 4 arguments: 

<ol><li> <i>EnumAlias</i> - the external alias for the enum object
    <li> <i>InfoName</i> - the function name to be used when installing the type information function
    <li> <i>EnumName</i> - the internal C++ name for the enum object
    <li> <i>IsInteger</i> - a Boolean value of <i>true</i> or <i>false</i> indicating whether or not 
    the enumeration includes arbitrary integer values or only those specified in the enumeration.

</ol><p>
Example usage:
<font color = "#000080"> <pre>
// hpp file:
enum EMyEnum {
	eZero = 0,
	eOne,
	eTwo,
	eTen = 10
};

// cpp file:
BEGIN_NAMED_ENUM_INFO("MyEnum", GetEnumInfo_EMyEnum, EMyEnum, false)
{
	ADD_ENUM_VALUE("zero", eZero);
	ADD_ENUM_VALUE("one", eOne);
	ADD_ENUM_VALUE("two", eTwo);
	ADD_ENUM_VALUE("ten", eTen);
}
END_ENUM_INFO
</pre></font>
Like  the C style <i>struct</i> types, <i>enum</i> types can not install <i>GetTypeInfo()</i>
methods, but instead, must implement global, uniquely named functions which can provide type 
information. The "type information" for an <i>enum</i> however, is simply a list of its named
enumerated values. <p>

As a result of executing this macro, a global function named <i>InfoName</i> will be implemented. 
Enumerated values should be specified using the <i>ADD_ENUM_VALUE</i> macro.
</ul>

When using the above macros to install type information, the corresponding class
definitions must include a declaration of the static class member function <i>GetTypeInfo()</i>
in the class's public section. In summary, you never actually <i>write</i> the code for the
<i>GetTypeInfo()</i> methods, but simply declare the static method in the class definitions,
and use the <i>BEGIN/END_xxx_INFO</i> macros to implement them.

<p>
<a name="addm"><h4> The ADD_* macros</h4> 

Type information about individual data members, subclasses, and possible values and types (as
in <i>enum</i> and <i>choice</i> objects) is added to the <i>GetTypeInfo()</i> and global
functions using the <i>ADD_*</i> macros in Table 2. As with the <i>BEGIN_*_INFO</i> macros,
each of the <i>ADD_*</i> macros has both "named" and "unnamed" implementations. Again, the 
named macros must be used in cases where the internal C++ name differs from an external
alias for the entity. <p>

The ADD_* macros vary considerably in their complexity and their resulting flexibility.  Table
2 lists the simpler (and therefore, less flexible) <i>ADD_*</i> macro names, along with their
usage and arguments. Most of these macros take the external alias and internal C++ names of the
data member or subclass to be added, as arguments. The term "standard" is used here to refer to
built-in C++ types such as <i>int</i>, <i>float</i>, <i>string</i> etc. For the first five
ADD_* macros, the <i>type</i> of member being added is defined either by the internal C++ name
or a primitive type.
<p>

When adding a <i>CRef</i> data member or choice option however, the class referenced by the
<i>CRef</i> must be made explicit with the <i>RefClass</i> argument, which is the internal C++
class name. Enumeration type data members and choice options also require additional explicit
information: <i>EnumType</i> specifes whether or not the enumeration includes arbitrary integer
values. The <i>ADD_ENUM_VALUE</i> macro, as used in the above <a href="#enum"> example</a>,
specifies the legitimate values of the enumeration.  <p>

<table BORDER WIDTH="100%"><caption ALIGN=BOTTOM> Table 2</caption>
<tr><th>Macro name</th>			    <th>Usage</th>            <th>Arguments</th>   </tr>

<tr><td> ADD_NAMED_STD_MEMBER </td>
    <td> Add a standard data member to a class</td>    <td>MemberAlias, MemberName</td> </tr>

<tr><td> ADD_NAMED_CLASS_MEMBER </td>
    <td> Add an internal class member to a class</td>  <td>InternalClassAlias, InternalClassName</td> </tr>

<tr><td> ADD_NAMED_SUB_CLASS </td> 
    <td> Add a derived subclass to a class</td> <td>SubClassAlias, SubClassName</td> </tr>

<tr><td> ADD_NAMED_STD_CHOICE_VARIANT</td>
    <td> Add a standard option type to a C++ choice object </td><td> ChoiceOptionAlias, ChoiceOptionName</td></tr>

<tr><td> ADD_ASN_CHOICE_STD_VARIANT
</td><td> Add a standard option type to an ASN choice object </td><td> ChoiceOptionAlias, ChoiceOptionName</td></tr>

<tr><td> ADD_NAMED_REF_MEMBER </td> 
    <td> Add a <i>CRef</i> data member to a class</td> <td>MemberAlias, MemberName, RefClass</td> </tr>

<tr><td> ADD_NAMED_REF_CHOICE_VARIANT
</td><td> Add a <i>CRef</i> to a C++ choice object </td><td> ChoiceOptionAlias, ChoiceOptionName, RefClass</td></tr>

<tr><td> ADD_NAMED_ENUM_MEMBER </td> 
    <td> Add an <i>enum</i> data member to a class</td> <td>EnumAlias, EnumName, EnumType</td> </tr>

<tr><td> ADD_NAMED_ENUM_CHOICE_VARIANT </td>
    <td> Add an <i>enum</i> type to a C++ choice object </td><td> EnumAlias, EnumName, EnumType</td> </tr>

<tr><td> ADD_ENUM_VALUE
</td><td> Add a named enumeration value to an <i>enum</i> 
</td><td> EnumValName, Value
</td></tr>

</table>

The ADD_MEMBER macro is more open-ended, allowing
for more complex specifications. Again, <i>Name</i> is the data member's identifier in the
class definition.  The value of <i>Args</i> depends on the value of the <i>Type</i>
argument, where <i>Type</i> is one of the following:<p>

<table border=.5 width=600 cellspacing=1>
  <caption></caption>
  <tr>
	 <th>Type</th>
	 <th>Args </th>
  </tr>

  <tr>	 <td> CLASS </td>	 <td> (Name) </td>  </tr>
  <tr>	 <td> STD   </td>        <td> (Name) </td>  </tr>
  <tr>	 <td> StringStore </td>  <td> ()     </td>  </tr>
   <tr>	 <td> null </td>         <td> ()     </td>  </tr>
  <tr>	 <td> ENUM </td>         <td> (Type, Name) </td>  </tr> 
  <tr>	 <td> POINTER </td>      <td> (Type,Args) </td>  </tr> 
  <tr>	 <td> STL_multiset </td> <td> (Type,Args) </td>  </tr> 
  <tr>	 <td> STL_set </td>      <td> (Type,Args) </td>  </tr> 
  <tr>	 <td> STL_multimap </td> <td> (KeyType,KeyArgs,ValueType,ValueArgs) </td>  </tr> 
  <tr>	 <td> STL_map </td>      <td> (KeyType,KeyArgs,ValueType,ValueArgs) </td>  </tr> 
  <tr>	 <td> STL_list </td>     <td> (Type,Args) </td>  </tr> 
  <tr>	 <td> STL_list_set </td> <td> (Type,Args) </td>  </tr>
  <tr>	 <td> STL_vector </td>   <td> (Type,Args) </td>  </tr>
  <tr>	 <td> STL_CHAR_vector </td> <td> (Type) </td>  </tr>
  <tr>	 <td> STL_auto_ptr </td>   <td> (Type,Args)</td>  </tr>
  <tr>	 <td> CHOICE </td>         <td> (Type,Args) </td>  </tr> 
  <tr>	 <td> CHOICE_POINTER </td> <td> (Type,Args) </td>  </tr> 
  <tr>	 <td> CHOICE_STL_auto_ptr </td> <td> (Type,Args) </td>  </tr> 

</table>
<p>

Some examples of using the ADD_MEMBER macros:
<font color = "#000080"> <pre>
   ADD_MEMBER(m_a, STL_auto_ptr, (CLASS, (CA)));
   ADD_MEMBER(m_x, STL_CHAR_vector, (char))
   ADD_MEMBER(m_x, STL_vector, (STD, (char))
   ADD_MEMBER(m_x, STL_list, (CLASS, (name))
   ADD_MEMBER(m_x, STL_list, (POINTER, (CLASS, (name)))
   ADD_MEMBER(m_x, STL_map, (STD, (long), STD, (string)));
</pre></font>
...Add discussion of ADD_ENUM_M. 
<p>
 ADD_NAMED_SUB_CLASS(ClassAlias, ClassName)
 ADD_ENUM_VALUE (Name, Value) enumInfo->AddValue(Name, enumValue = Value)
<p>

   </body>
<a href="exceptions.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<!-- a href="newpage.html"> <i> next</i> </a-->
</html>

	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
