<!--#set var="TITLE" value="Processing Serial Data" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>Processing Serial Data</h1>

<ul>
  <li> <a href="#headersandlibs"> Accessing the object header files and serialization libraries </a>
  <li> <a href="#example1"> Reading and writing serial data: An Example Application </a>
  <li> <a href="#includes"> Determining which header files to include</a>
  <li> <a href="#linklibs"> Determining which libraries to link to</a>
</ul>

Although this discussion focuses on ASN.1 and XML formatted data, the data structures and tools
described here have been designed to (potentially) support any formalized serial data
specification.  Many of the tools and objects have open-ended abstract or template
implementations that can be instantiated differently to fit various specifications. <p>

<a name="headersandlibs"></a>
<h3> Accessing the object header files and serialization libraries </h3>

Reading and writing serialized data is implemented by an integrated set of streams, filters,
and object types. An application that reads encoded data files will require the object header
files and libraries which define how these serial streams of data should be loaded into
memory. This entails <span class="ncbi_ccode">#include</span> statements in your source files, as well as the associated
library specifications in your makefiles.  The object header and implementation files are
located in the
<a href="../lxr/source/include/objects/">
<span class="ncbi_dir">include/objects</span></a> and
<a href="../lxr/source/src/objects/">
<span class="ncbi_dir">src/objects</span></a> subtrees of the C++ tree,
respectively. The header and implementation files for serialized streams and type
information are in the
<a href="../lxr/source/include/serial/">
<span class="ncbi_dir">include/serial</span></a> and
<a href="../lxr/source/src/serial/">
<span class="ncbi_dir">src/serial</span></a> directories.
<p>

If you have checked out the <span class="ncbi_dir"> objects</span> directories, but not explicitly run the
<a href="../tools/datatool/datatool.html">
<span class="ncbi_app">datatool</span></a> code generator, then you will find that your <span class="ncbi_dir">include/objects</span>
subdirectories are (almost) empty, and the source subdirectories contain only makefiles and
ASN.1 specifications. These makefiles and ASN.1 specifications can be used to build your own
copies of the objects' header and implementation files, using <span class="ncbi_cmd">make all_r</span> (if you
configured using the <span class="ncbi_conf_flag">--with-objects</span> flag), or running datatool explicitly.<p>

However, building your own local copies of these header and implementation files is neither
necessary nor recommended, as it is simpler to use the pre-generated header files and prebuilt
libraries.  The pre-built header and implementation files can be found in <span class="ncbi_dir">
$NCBI/c++/include/objects/</span> and <span class="ncbi_dir">$NCBI/c++/src/objects/</span>, respectively.  Assuming your
makefile defines an include path to <span class="ncbi_dir">$NCBI/c++/include</span>, selected object header files such
as
<a href="../lxr/source/include/objects/general/Date.hpp" class="ncbi_file">Date.hpp</a>, can be included as:
<pre class="ncbi_code">
    #include <objects/general/Date.hpp>
</pre>

This header file (along with its implementations in the accompanying <span class="ncbi_dir">src</span> directory) was
generated by <a href="../tools/datatool/datatool.html" class="ncbi_app">datatool</a> using the specifications from
<a href="../lxr/source/src/objects/general/general.asn" class="ncbi_file">src/objects/general/general.asn</a>. In order to use the classes defined in the <span class="ncbi_dir">objects</span>
directories, your source code should begin with the statements:
<pre class="ncbi_code">
    USING_NCBI_SCOPE;
    using namespace objects;
</pre>

All of the objects' header and implementation files are generated by <span class="ncbi_app">datatool</span>, as specified
in the ASN.1 specification files. The resulting object definitions however, are not in any
way dependent on ASN.1 format, as they simply specify the in-memory representation of the defined
data types. Accordingly, the objects themselves can be used to read, interpret, and write any
type of serialized data. Format specializations on the input stream are implemented via
<a href="../docxx/CObjectIStream.html">
<span class="ncbi_class">CObjectIStream</span></a> objects, which extract the required tags and values from the input data
according to the format specified. Similarly, Format specializations on an output stream are implemented via
<a href="../docxx/CObjectOStream.html">
<span class="ncbi_class">CObjectOStream</span></a> objects.

<a name="example1"></a>
<h3> Reading and writing serial data </h3>

Let's consider a program <a href="xml2asn_cpp.html"> <span class="ncbi_file">xml2asn.cpp</span></a> that translates an
XML data file containing an object of type
<a href="../lxr/source/src/objects/mmdb1/mmdb1.asn">Biostruc</a>, to ASN.1 text and binary formats.

In <span class="ncbi_func">main()</span>, we begin by initializing the diagnostic stream to write errors to a local
file called <span class="ncbi_file">xml2asn.log</span>. (Exception handling, program tracing, and error logging are
described in the <a href="diag.html">Diagnostic Streams</a> section).<p>

An instance of the <span class="ncbi_class">CTestAsn</span> class is then created, and its member function
<span class="ncbi_func">AppMain()</span> is invoked. This function in turn calls <span class="ncbi_func">CTestAsn::Run()</span>.  The first
three lines of code there define the XML input and ASN.1 output streams, using <a
href="cref.html"> <span class="ncbi_class">auto_ptr</span></a>s, to ensure automatic destruction of these objects.<p>

Each stream is associated with data serialization mechanisms appropriate to the
<a href="../lxr/ident?i=ESerialDataFormat">
<span class="ncbi_type">ESerialDataFormat</span></a> provided to the constructor:

<pre class="ncbi_code">
    enum ESerialDataFormat {
        eSerial_None       = 0,
        eSerial_AsnText    = 1,   // open ASN.1 text format
        eSerial_AsnBinary  = 2,   // open ASN.1 binary format
        eSerial_Xml        = 3    // open XML format (not supported yet)
    };
</pre>

<span class="ncbi_class">CObjectIStream</span> and <span class="ncbi_class">CObjectOStream</span> are base classes which provide generic
interfaces between the specific type information of a serializable object and an I/O
stream. The object stream classes that will actually be instantiated by this application,
<a href="../docxx/CObjectIStreamXml.html">
<span class="ncbi_class">CObjectIStreamXml</span></a>,
<a href="../docxx/CObjectOStreamAsn.html">
<span class="ncbi_class">CObjectOStreamAsn</span></a>, and
<a href="../docxx/CObjectOStreamAsnBinary.html">
<span class="ncbi_class">CObjectOStreamAsnBinary</span></a>,
are descendants of these base classes.
<p>

Finally, a variable for the object type that will be generated from the input stream (in this case a
<a href="../docxx/CBiostruc.html" class="ncbi_class">CBiostruc</a>) is defined, and the
<span class="ncbi_class">CObject[I/O]Stream</span> operators "<<" and ">>" are used to read and write the serialized data to
and from the object. (Note that it is <em>not</em> possible to simply "pass the data through", from
the input stream to the output stream, using a construct like: <span class="ncbi_ccode">*inObject >> *outObject</span>). The
<span class="ncbi_class">CObject[I/O]Stream</span>s know nothing about the structure of the specific object - they have
knowledge only of the serialization format (text ASN, binary ASN, XML, etc.). In contrast, the <a
href="../docxx/CBiostruc.html"> <span class="ncbi_class">CBiostruc</span></a> knows nothing about I/O and serialization
formats, but it contains explicit type information about itself.  Thus, the
<span class="ncbi_class">CObject[I/O]Stream</span>s can apply their specialized serialization methods to the data members of
<span class="ncbi_class">CBiostruc</span> using the <a href="typeinfo.html#ctypeinfo"><span class="ncbi_term">type information</span></a> associated with
that object's class.

<a name="includes"></a>
<h3>Determining Which Header Files to Include </h3>

As always, we include the <span class="ncbi_proj">corelib</span> header files, <span class="ncbi_file">ncbistd.hpp</span> and <span class="ncbi_file">ncbiapp.hpp</span>.
In addition, the <span class="ncbi_proj">serial</span> header files that define the generic <span class="ncbi_class">CObject[IO]Stream</span>
objects are included, along with <span class="ncbi_file">serial.hpp</span>, which defines generalized serialization
mechanisms. Finally, we need to include the header file for the object type we will be using.<p>

There are two source browsers that can be used to locate the appropriate header file for a
particular object type. All class names in the NCBI C++ Toolkit begin with the letter
"C". Using the <a href="../docxx/HIER.html"> class
hierarchy browser</a>, we find <span class="ncbi_class">CBiostruc</span>, derived from <span class="ncbi_class">CBiostruc_Base</span>, which is
in turn derived from <span class="ncbi_class">CObject</span>. Following the <span class="ncbi_url">CBiostruc</span> link, we can then use the
<span class="ncbi_menu">locate</span> button to move to the LXR source code navigator, and there, find the name
of the header file. In this case, we find
<a href="../lxr/source/include/objects/mmdb1/Biostruc.hpp">
<span class="ncbi_file">CBiostruc.hpp</span></a> is located in
<span class="ncbi_dir">include/objects/mmdb1</span>.  Alternatively, if we know the name of the C++ class, the source
code navigator's <a href="../lxr/ident">
identifier search</a> tool can be used directly. In summary, the
following <span class="ncbi_ccode">#include</span> statements appear at the top of <a href="xml2asn_cpp.html"><span class="ncbi_file">xml2asn.cpp</span></a>:

<pre class="ncbi_code">
    #include <corelib/ncbistd.hpp>
    #include <corelib/ncbiapp.hpp>
    #include <serial/serial.hpp>
    #include <serial/objistr.hpp>
    #include <serial/objostr.hpp>
    #include <objects/mmdb1/Biostruc.hpp>
</pre>

<a name="linklibs"></a>
<h3>Determining Which Libraries to Link To </h3>
Determining which libraries must be linked to requires a bit more work and may involve
some trial and error. The list of available libraries currently includes:<p>
<table border=0 cellpadding=3>
<tr><td>access  <td>medlars <td>ncbimime  <td>seq      <td>seqloc  <td>xconnect </tr>
<tr><td>biblio  <td>medline <td>objprt    <td>seqalign <td>seqres  <td>xfcgi </tr>
<tr><td>cdd     <td>mmdb1   <td>proj      <td>seqblock <td>seqset  <td>xhtml </tr>
<tr><td>featdef <td>mmdb2   <td>pub       <td>seqcode  <td>submit  <td>xncbi </tr>
<tr><td>general <td>mmdb3   <td>pubmed    <td>seqfeat  <td>xcgi    <td>xser </tr>
</table><p>

It should be clear that we will need to link to the core library,
<a href="../libs.html#ref_TableXNCBI"><span class="ncbi_proj">xncbi</span></a>, as
well as to the serial library,
<a href="../libs.html#ref_TableXSERIAL">
<span class="ncbi_proj">xser</span></a>. In addition, we will need to link to whatever object libraries are
entailed by using a
<a href="../docxx/CBiostruc.html" class="ncbi_class">CBiostruc</a> object. Minimally, one would
expect to link to the <span class="ncbi_proj">mmdb</span> libraries. This in itself is insufficient however,
as the <span class="ncbi_class">CBiostruc</span> class embeds other types of objects, including PubMed citations,
features, and sequences, which in turn embed additional objects such as
<a href="../docxx/CDate.html" class="ncbi_class">Date</a>.
The makefile for <span class="ncbi_file">xml2asn.cpp</span>, <a href="make_xml2asn.html"> <span class="ncbi_file">Makefile.xml2asn.app</span></a> lists
the libraries required for linking in the make variable <span class="ncbi_make_var">LIB</span>.
<p>

See also the example program,
<a href="../lxr/source/src/objects/asn2asn/asn2asn.cpp">
<span class="ncbi_file">asn2asn.cpp</span></a> which demonstrates more generalized translation of <span class="ncbi_type">Seq-entry</span> and
<span class="ncbi_type">Bioseq-set</span> (defined in
<a href="../lxr/source/src/objects/seqset/seqset.asn" class="ncbi_file">seqset.asn</a>).

<p>

<a href="objstream.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="choice.html"> <i> next </i> </a>


<!--#include virtual="../ssi/navlinks.shtml" -->

     <table border=0 width="100%" cellspacing=0>
        <tr>
          <td><address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
          <!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> -->
          <td align=right><span class="ncbi_cvs_date">$Date$</span></td>
     </table>

<!--#include virtual="../ssi/footer.shtml" -->
