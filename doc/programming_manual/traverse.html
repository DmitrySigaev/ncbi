<!--#set var="TITLE" value="Traversing a Data Structure" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>Traversing a Data Structure</h1>

<ul>
<li>
<a href="#locateClass">Locating the Class Definitions</a></li>

<li>
<a href="#accessMember">Accessing and Referencing Data Members</a></li>

<li>
<a href="#example">Traversing a Biostruc</a></li>

<li>
<a href="#iterate">Iterating Over Containers</a></li>
</ul>
<p><br>

<a NAME="locateClass"></a>
<h3>Locating the Class Definitions</h3>

In general, traversing through a class object requires that you first become
familiar with the internal class structure and member access functions
for that object.  In this section we consider how you can access this
information in the source files, and apply it.  The example provided
here involves a <span class="ncbi_type">Biostruc</span> type which is implemented by class <a href="/home/zimmerma/internal/c++/doc/docxx/CBiostruc.html" class="ncbi_class">CBiostruc</a>, and
its base (parent) class, <a href="/home/zimmerma/internal/c++/doc/docxx/CBiostruc_Base.html"><span class="ncbi_class">CBiostruc_Base</span>.</a>
<p>The first question is: how do I locate the class definitions implementing
the object to be traversed? There are now two source browsers which you
can use. To obtain a synopsis of the class, you can search the <a href="../docxx/index.html">index
</a>or
the <a href="../docxx/HIER.html">class hierarchy </a>of the <i>Doc++</i>
browser and follow a link to the class. For example, a synopsis of the
<a href="../docxx/CBiostruc.html" class="ncbi_class">CBiostruc</a>
class is readily available. From this page, you can also access the relevant
source files archived by the <i>LXR</i><!--NCBI_MARK--> browser, by following the
<a href="../lxr/ident?i=CBiostruc">Locate CBiostruc</a> link.
Alternatively, you may want to access the <i>LXR</i><!--NCBI_MARK-->
engine directly by using the <a href="../lxr/ident?i=CBiostruc">Identifier
search</a> tool.
<p>Because we wish to determine which headers to include, the synopsis
displayed by the <a href="../lxr/ident?i=CBiostruc">Identifier
search </a> tool is most useful. There we find a single header file,
<a href="../lxr/source/include/objects/mmdb1/Biostruc.hpp" class="ncbi_file">Biostruc.hpp</a>,
listed as defining the class. Accordingly, this is the header file we must include.
The <span class="ncbi_class">CBiostruc</span> class inherits from the <span class="ncbi_class">CBiostruc_Base</span> class
however, and we will need to consult that file as well to understand the
internal structure of the <span class="ncbi_class">CBiostruc</span> class. Following a link to the
parent class from the class hierarchy browser, we find the definition of
the <a href="../docxx/CBiostruc_Base.html" class="ncbi_class">CBiostruc_Base</a> class.
<p>This is where we must look for the definitions and access functions
we will be using. However, it is the <span class="ncbi_term" >derived user class</span> (<span class="ncbi_class">CBiostruc</span>)
whose header should be
<span class="ncbi_ccode">#include</span>'d in your source files, and which
should be instantiated by your local program variable.  For a more
general discussion of the relationship between the base parent objects
and their derived user classes, see <a href="objects.html#base">Working
with the serializable object classes.</a>
<p><br>

<a NAME="accessMember"></a>
<h3>Accessing and Referencing Data Members</h3>

Omitting some of the low-level details of the base class, we find the <span class="ncbi_class">CBiostruc_Base</span>
class has essentially the following structure:

<blockquote>
<pre class="ncbi_code">
class CBiostruc_Base : public CObject
{
public:
    // type definitions 
    typedef list&lt; CRef&lt;CBiostruc_id> > TId;
    typedef list&lt; CRef&lt;CBiostruc_descr> > TDescr;
    typedef list&lt; CRef&lt;CBiostruc_feature_set> > TFeatures;
    typedef list&lt; CRef&lt;CBiostruc_model> > TModel;
    typedef CBiostruc_graph TChemical_graph;

    // Get() members 
    const TId&amp; GetId(void) const;
    const TDescr&amp; GetDescr(void) const;
    const TChemical_graph&amp; GetChemical_graph(void) const;
    const TFeatures&amp; GetFeatures(void) const;
    const TModel&amp; GetModel(void) const;

    // Set() members
    TId&amp; SetId(void);
    TDescr&amp; SetDescr(void);
    TChemical_graph&amp; SetChemical_graph(void);
    TFeatures&amp; SetFeatures(void);
    TModel&amp; SetModel(void);

private:
    TId m_Id;
    TDescr m_Descr;
    TChemical_graph m_Chemical_graph;
    TFeatures m_Features;
    TModel m_Model;
};</pre></blockquote>

With the exception of the structure's chemical graph,
each of the class's private data members is actually a <span class="ncbi_class">list</span> of references
(pointers), as specified by the type definitions. For example, <span class="ncbi_type">TId</span>
is a list of <a href="cref.html#cref" class="ncbi_class">CRef</a> objects, where each
<span class="ncbi_class">CRef</span>
object points to a <a href="../docxx/CBiostruc_id.html" class="ncbi_class">CBiostruc_id</a>.
The <span class="ncbi_class">CRef</span> class is a type of smart pointer used to hold a
pointer to a reference-counted object. The dereferencing operator, when applied
to a (dereferenced) iterator pointing to an element of <span class="ncbi_type">CBiostruc::TId</span>,
e.g. <span class="ncbi_ccode">**CRef_i</span>, will return a <span class="ncbi_class">CBiostruc_id</span>. Thus, the call
to <span class="ncbi_func">GetId()</span> returns a list which must then be iterated over and dereferenced
to get the individual <span class="ncbi_class">CBiostruc_id</span> objects. In contrast, the function
<span class="ncbi_func">GetChemicalGraph()</span>
returns the object directly, as it does not involve a <span class="ncbi_class">list</span> or a
<span class="ncbi_class">CRef</span>.
<p>The <span class="ncbi_func">GetXxx()</span> and <span class="ncbi_func">SetXxx()</span> member
functions define the user interface to the class, providing methods to
access and modify ("mutate") private data. In addition, most classes, including
<span class="ncbi_class">CBiostruc</span>,
have <span class="ncbi_func">IsSetXxx()</span> and <span class="ncbi_func">ResetXxx()</span> methods to validate and clear
the data members, respectively.
<p><br>

<a NAME="example"></a>
<h3>Traversing a Biostruc</h3>
The program <a href="traverse_cpp.html" class="ncbi_file">traverseBS.cpp</a>
demonstrates how one might load a serial data file and iterate over the
components of the resulting object. This example reads from a text ASN.1
Biostruc file and stores the information into a <span class="ncbi_class">CBiostruc</span> object
in memory. The overloaded <span class="ncbi_func">Visit()</span> function is then used to recursively
examine the object
<span class="ncbi_ccode">CBiostruc bs</span> and its components.
<p><a href="traverse_cpp.html#visitBS" class="ncbi_ccode">Visit(bs)</a>
simply calls <span class="ncbi_func">Visit()</span> on each of the
<span class="ncbi_class">CBiostruc</span> data members,
which are accessed using <span class="ncbi_ccode">bs.GetXxx()</span>. The information needed to
write each of these functions - the data member types and member function
signatures - is contained in the respective header files. For example,
looking at
<a href="../lxr/source/include/objects/mmdb1/Biostruc_.hpp#L65" class="ncbi_file">Biostruc_.hpp</a>,
we learn that the structure's descriptor list can be accessed using <span class="ncbi_func">GetDescr()</span>,
and that the type returned is a list of pointers to descriptors:

<blockquote>
<pre class="ncbi_code">
typedef list&lt; CRef&lt;CBiostruc_descr> > TDescr;
const TDescr&amp; GetDescr(void) const;
</pre>
</blockquote>

Consulting the base class for <a href="../lxr/source/include/objects/mmdb1/Biostruc_descr_.hpp#L62" class="ncbi_class">CBiostruc_desc</a>
in turn, we learn that this class has a <span class="ncbi_term">choice state</span> defining the
type of value stored there as well as the method that should be used to
access that value. This leads to an implementation of <a href="traverse_cpp.html#visitDscr">Visit(CBiostruc::TDescr DescrList)</a> that uses an iterator over its list argument and a switch
statement over the current descriptor's choice state.
<p><br>


<a NAME="iterate"></a>
<h3>Iterating Over Containers</h3>

Most of the <span class="ncbi_func">Visit()</span> functions implemented
here rely on standard STL iterators to walk through a list of objects.
The general syntax for using an iterator is:

<blockquote>
<pre class="ncbi_code">
ContainerType ContainerName;

for (ContainerType::IteratorType i = ContainerName.begin();
    i != ContainerName.end(); ++i) {

    ObjectType ObjectName = *i;
    // ...
}
</pre></blockquote>

Dereferencing the iterator is required, as the iterator
behaves like a pointer that traverses consecutive elements of the container.
For example, to iterate over the list of descriptors in the <i>Biostruc</i><!--NCBI_MARK-->,
we use a container of type <span class="ncbi_type">CBiostruc::TDescr</span>, and an iterator of
type
<span class="ncbi_ccode">const_iterator</span> to ensure that the data is not mutated in the
body of the loop. Because the descriptor list contains pointers
(<a href="cref.html#cref" class="ncbi_class">CRefs</a>)
to objects, we will actually need to dereference <em>twice</em> to get to
the objects themselves.

<blockquote>
<pre class="ncbi_code">
for (CBiostruc::TDescr::const_iterator i = descList.begin();
     i != descList.end(); ++i) {

    const CBiostruc_descr&amp; thisDescr = **i;
    // ...
}
</pre></blockquote>

In traversing the descriptor list in this example,
we handled each type of descriptor with an explicit <span class="ncbi_keyword">case</span> statement.
In fact, however, we really only visit those descriptors whose types have
string representations: <span class="ncbi_type">TName, TPdb_comment</span>, and
<span class="ncbi_type">TOther_comment</span>.
The other two descriptor types, <span class="ncbi_type">THistory</span> and
<span class="ncbi_type">TAttribute</span>,
are objects that are "visited" recursively, but the associated visit functions
are not actually implemented (see <a href="traverse_hpp.html" class="ncbi_file">traverseBS.hpp</a>).
<p>The NCBI C++ Toolkit provides a rich and powerful
<a href="iterators.html">set
of iterators</a> for various application needs. An alternative to using
the above <span class="ncbi_ccode">switch</span> statement to visit elements of the descriptor list
would have been to use an NCBI <a href="iterators.html#stdType" class="ncbi_class">CStdTypeIterator</a>
that only visits strings. For example, we could implement the Visit function
on a <span class="ncbi_type">CBiostruc::TDescr</span> as follows:

<blockquote>
<pre class="ncbi_code">
void Visit (const CBiostruc::TDescr&amp; descList)
{
    for (CBiostruc::TDescr::const_iterator i1 = descList.begin();
        i1 != descList.end(); ++i1) {

        for (CStdTypeConstIterator&lt;string> i = ConstBegin(**i1); i; ++i) {
            cout &lt;&lt; *i &lt;&lt; endl;
        }
    }
}
</pre></blockquote>

In this example, the iterator will skip over all but the string data members.
<p>The <span class="ncbi_class">CStdTypeIterator</span> is one of several
iterators which makes use of an object's <span class="ncbi_term">type information</span> to implement
the desired functionality. We began this section by positing that the traversal
of an object requires an a priori knowledge of that object's internal
structure.  This is not strictly true however, if type information
for the object is also available. An object's type information specifies
the class layout, inheritance relations, data member names, and various
other attributes such as size, which are independent of specific instances.
All of the C++ type iterators described in <a href="iterators.html">The
NCBI C++ Toolkit Iterators</a> section utilize type information, which
is the topic of the next section: <a href="typeinfo.html">Runtime Object
Type Information</a>.

<p><i><a href="../index.html">up</a></i><!--NCBI_MARK-->&nbsp;&nbsp;&nbsp;
<i><a href="typeinfo.html">next</a></i><!--NCBI_MARK--><!--i><a href=".html">next&nbsp;</a></i-->
<p>


<!--#include virtual="../ssi/navlinks.shtml" -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> --></td>

<td ALIGN=RIGHT><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
