<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <title> Traversing a Data Structure. </title>
</head>
<body bgcolor="#FFFFFF">

<h1>
Traversing a Data Structure</h1>

<ul>
<li>
<a href="#locateClass">Locating the Class Definitions</a></li>

<li>
<a href="#accessMember">Accessing and Referencing Data Members</a></li>

<li>
<a href="#example">Traversing a Biostruc</a></li>

<li>
<a href="#iterate">Iterating Over Containers</a></li>
</ul>
<a NAME="locateClass"></a>
<h3>
Locating the Class Definitions</h3>
In order to traverse a serial data object, you must first become familiar
with the class structures and access functions which implement the object.
The example provided here involves a Biostruc type which is implemented
by class <i>CBiostruc.</i>
<p>The first question is: how do I locate the class definitions implementing
the object to be traversed? There are now two source browsers which you
can use. To obtain a synopsis of the class, you can search the <a href="../docxx/index.html">index
</a>or the <a href="../docxx/HIER.html">class hierarchy </a>of the <i>Doc++</i>
browser and follow a link to the class. For example, a synopsis of the
<i><a href="../docxx/CBiostruc.html">CBiostruc</a></i>
class is readily available. From this page, you can also access the relevant
source files archived by the <i>LXR</i> browser, by following the <i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=CBiostruc">Locate
CBiostruc</a></i> link. Alternatively, you may want to access the <i>LXR</i>
engine directly by using the <i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=CBiostruc">Identifier
search</a></i> tool.
<p>Because we wish to determine which headers to include, the synopsis
displayed by the <i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=CBiostruc">Identifier
search </a></i>tool is most useful. There we find a single header file,
<i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/objects/mmdb1/Biostruc.hpp">Biostruc.hpp
</a></i>listed as defining the class. Accordingly, this is the header file
we must include. The <i>CBiostruc</i> class inherits from the <i>CBiostruc_Base</i>
class however, and we will need to consult that file as well to understand
the internal structure of the <i>CBiostruc</i> class. Following a link
to the parent class from the class hierarchy browser, we find the definition
of the <i><a href="../docxx/CBiostruc_Base.html">CBiostruc_Base</a></i>
class.
<p>This is where we must look for the definitions and access functions
we will be using. However, it is the <i>derived</i> class (defined in <i>CBiostruc.hpp</i>)
whose header should be
<i>#include</i>'d in your source files, and which
should be instantiated by your local program variable. The deriveded class
header file will include the base header file for you.
<p>More generally, the base (auto-generated) classes should <i>never</i>
be instantiated or accessed directly in an application. The relation between
these two files and the classes they define reflects a <a href="objects.html#base">general
design</a> used in developing the object libraries: the base class files
are generated by <i><a href="../tools/datatool/datatool.html">datatool</a></i>
according to the ASN.1 specifications in the <i>src/objects</i> directories;
the inherited class files (i.e., the <i><a href="objects.html#base">user</a></i>
classes) are intended for developers who are extending these classes to
support features above and beyond the ASN.1 specifications.&nbsp;
<p><a NAME="accessMember"></a>
<h3>
Accessing and Referencing Data Members</h3>
Omitting some of the low-level details of the base class, we find the <i>CBiostruc_Base</i>
class has essentially the following structure:
<pre><font color="#000080">class CBiostruc_Base : public CObject
{
public:
&nbsp;&nbsp;&nbsp; // type definitions&nbsp;
&nbsp;&nbsp;&nbsp; typedef list&lt; CRef&lt;CBiostruc_id> > TId;
&nbsp;&nbsp;&nbsp; typedef list&lt; CRef&lt;CBiostruc_descr> > TDescr;
&nbsp;&nbsp;&nbsp; typedef list&lt; CRef&lt;CBiostruc_feature_set> > TFeatures;
&nbsp;&nbsp;&nbsp; typedef list&lt; CRef&lt;CBiostruc_model> > TModel;
&nbsp;&nbsp;&nbsp; typedef CBiostruc_graph TChemical_graph;

&nbsp;&nbsp;&nbsp; // Get() members&nbsp;
&nbsp;&nbsp;&nbsp; const TId&amp; GetId(void) const;
&nbsp;&nbsp;&nbsp; const TDescr&amp; GetDescr(void) const;
&nbsp;&nbsp;&nbsp; const TChemical_graph&amp; GetChemical_graph(void) const;
&nbsp;&nbsp;&nbsp; const TFeatures&amp; GetFeatures(void) const;
&nbsp;&nbsp;&nbsp; const TModel&amp; GetModel(void) const;

&nbsp;&nbsp;&nbsp; // Set() members
&nbsp;&nbsp;&nbsp; TId&amp; SetId(void);
&nbsp;&nbsp;&nbsp; TDescr&amp; SetDescr(void);
&nbsp;&nbsp;&nbsp; TChemical_graph&amp; SetChemical_graph(void);
&nbsp;&nbsp;&nbsp; TFeatures&amp; SetFeatures(void);
&nbsp;&nbsp;&nbsp; TModel&amp; SetModel(void);

private:
&nbsp;&nbsp;&nbsp; TId m_Id;
&nbsp;&nbsp;&nbsp; TDescr m_Descr;
&nbsp;&nbsp;&nbsp; TChemical_graph m_Chemical_graph;
&nbsp;&nbsp;&nbsp; TFeatures m_Features;
&nbsp;&nbsp;&nbsp; TModel m_Model;
};</font></pre>
<font color="#000000">With the exception of the structure's chemical graph,
each of the class's private data members is actually a <i>list</i> of references
(pointers), as specified by the type definitions. For example, <i>TId</i>
is a list of <i><a href="cref.html#cref">CRef</a></i> objects, where each
<i>CRef</i> object points to a <i><a href="../docxx/CBiostruc_id.html">CBiostruc_id</a></i>.
The <i>CRef</i></font><font color="#000080"> </font><font color="#000000">class</font><font color="#000080">
i</font><font color="#000000">s a type of smart pointer used to hold a
pointer to a reference-counted object. The derefencing operator, when applied
to a (dereferenced) iterator pointing to an <i>element</i> of <i>CBiostruc::TId</i>,
e.g. <i>**CRef_i</i>, will return a <i>CBiostruc_id</i>. Thus, the call
to <i>GetId()</i> returns a list which must then be iterated over and dereferenced
to get the individual <i>CBiostruc_id</i> objects. In contrast, the function
<i>GetChemicalGraph()</i> returns the object directly, as it does not involve
a list or a <i>CRef</i>.</font>
<p><font color="#000080">I</font><font color="#000000">n general, all objects
in the NCBI libraries will have a similar structure: a set of private data
members and a set of <i>GetXxx()</i> and <i>SetXxx()</i> member functions
to access and modify ("mutate") these data. In addition, most classes,
including <i>CBiostruc</i>, have <i>IsSetXxx()</i> and <i>ResetXxx()</i>
methods to validate and clear the data members respectively</font><font color="#000080">.&nbsp;</font><a NAME="example"></a>
<h3>
<font color="#000080">Traversing a Biostruc</font></h3>
<font color="#000000">The program <i><a href="traverse_cpp.html">traverseBS.cpp</a></i>
demonstrates how one might load a serial data file and iterate over the
components of the resulting object. This example reads from a text ASN.1
Biostruc file and stores the information into a <i>CBiostruc</i> object
in memory. The overloaded <i>Visit()</i> function is then used to recursively
examine the object
<i>CBiostruc bs</i> and its components.</font><font color="#000000"></font>
<p><font color="#000000">&nbsp;<i><a href="traverse_cpp.html#visitBS">Visit(bs)</a></i>
simply calls <i>Visit()</i> on each of the
<i>CBiostruc</i> data members,
and the data members are accessed using <i>bs.GetXxx()</i>. The information
needed to write each of these functions - the data member types and member
function signatures - is contained in the respective header files. For
example, looking at
<i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/objects/mmdb1/Biostruc_.hpp#L65">Biostruc_.hpp</a></i>,
we learn that the structure's descriptor list can be accessed using <i>GetDescr()</i>,
and that the type returned is a list of pointers to descriptors:</font>
<pre><font color="#000080">&nbsp;&nbsp;&nbsp;&nbsp; typedef list&lt; CRef&lt;CBiostruc_descr> > TDescr;
&nbsp;&nbsp;&nbsp;&nbsp; const TDescr&amp; GetDescr(void) const;</font></pre>
<font color="#000000">Consulting the base class for <i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/objects/mmdb1/Biostruc_descr_.hpp#L62">CBiostruc_desc</a></i>
in turn, we learn that this class has a <i>choice state</i> defining the
type of value stored there as well as the method that should be used to
access that value. This leads to an implementation of <i><a href="traverse_cpp.html#visitDscr">Visit(CBiostruc::TDescr
DescrList)</a></i> that uses an iterator over its list argument and a switch
statement over the current descriptor's choice state.&nbsp;</font><a NAME="iterate"></a>
<h3>
<font color="#000000">Iterating Over Containers</font></h3>
<font color="#000000">Most of the <i>Visit()</i> functions implemented
here rely on standard STL iterators to walk through a list of objects.
The general syntax for using an iterator is:</font>
<pre><font color="#000080">&nbsp; ContainerType ContainerName;

&nbsp; for (ContainerType::IteratorType i = ContainerName.begin();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i != ContainerName.end(); ++i) {

&nbsp;&nbsp;&nbsp; ObjectType ObjectName = *i;
&nbsp;&nbsp;&nbsp; // ...
&nbsp; }</font></pre>
<font color="#000000">Dereferencing the iterator is required, as the iterator
is essentially a pointer that traverses consecutive elements of the container.
For example, to iterate over the list of descriptors in the Biostruc, we
use a container of type <i>CBiostruc::TDescr</i>, and an iterator of type
<i>const_iterator</i> to ensure that the data is not mutated in the body
of the loop. Because the descriptor list contains pointers (<i><a href="cref.html#cref">CRefs</a></i>)
to objects, we will actually need to dereference <i>twice</i> to get to
the objects themselves.</font>
<pre><font color="#000080">&nbsp; for (CBiostruc::TDescr::const_iterator i = descList.begin();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i != descList.end(); ++i) {

&nbsp;&nbsp;&nbsp; const CBiostruc_descr&amp; thisDescr = **i;
&nbsp;&nbsp;&nbsp; // ...
&nbsp; }</font></pre>
<font color="#000000">In traversing the descriptor list in this example,
we handled each type of descriptor with an explicit <i>case</i> statement.
In fact, however, we really only visit those descriptors whose types have
string representations: <i>TName, TPdb_comment</i>, and
<i>TOther_comment</i>.
The other two descriptor types, <i>THistory</i> and
<i>TAttribute</i>,
are objects that are "visited" recursively, but the associated visit functions
are not actually implemented (see <i><a href="traverse_hpp.html">traverseBS.hpp</a></i>).</font>
<p><font color="#000000">The NCBI C++ Toolkit provides a rich and powerful
set of iterators for various application needs. An alternative to using
the above <i>switch</i> statement to visit elements of the descriptor list
would have been to use an NCBI <i>type</i> iterator that only visits strings.
For example, we could implement the Visit function on a <i>CBiostruc::TDescr</i>
as follows:</font>
<pre><font color="#000080">void Visit (const CBiostruc::TDescr&amp; descList) {&nbsp;

&nbsp;&nbsp;&nbsp; for (CBiostruc::TDescr::const_iterator i1 = descList.begin();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i1 != descList.end(); ++i1) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (CStdTypeConstIterator&lt;string> i = ConstBegin(**i1); i; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; *i &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</font></pre>
<font color="#000000">In this example, the iterator will skip over all
but the string data members. For a complete discussion of the iterator
classes available in the NCBI C++ Toolkit, see <i><a href="iterators.html">The
NCBI C++ Toolkit Iterators</a></i>.</font>
<p>

<a href="iterators.html"><i>previous</i>&nbsp;</a>&nbsp;&nbsp;
<i><a href="../index.html">up&nbsp;</a></i>&nbsp;&nbsp; 
<!--i><a href=".html">next&nbsp;</a></i-->
<p><hr>
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>

</body>
</html>
