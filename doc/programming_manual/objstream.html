<!--#set var="TITLE" value="CObject[IO]Streams" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>
<span class="ncbi_class">CObject[IO]Streams</span></h1>

<ul>
<li>
<a href="#intro">Format Specific Streams: The <span class="ncbi_class">CObject[IO]Stream</span>
classes</a></li>

<li>
<a href="#objistr">The <span class="ncbi_class">CObjectIStream</span></a> classes</li>

<li>
<a href="#objostr">The <span class="ncbi_class">CObjectOStream</span></a> classes</li>

<li>
<a href="#objcopy">The <span class="ncbi_class">CObjectStreamCopier</span></a> classes</li>

<li>
<a href="#cback">Type-specific IO routines</a></li>

<li>
<a href="#readhooks">The <span class="ncbi_term">Read</span> hook classes</a></li>

<li>
<a href="#writehooks">The <span class="ncbi_term">Write</span> hook classes</a></li>

<li>
<a href="#copyhooks">The <span class="ncbi_term">Copy</span> hook classes</a></li>

<li>
<a href="#hookguard">The <span class="ncbi_class">CObjectHookGuard</span> class</a></li>

<li>
<a href="#blocks">The <span class="ncbi_term">ByteBlock</span> and <span class="ncbi_term">CharBlock</span> classes</a></li>
</ul>
<p><br>

<a NAME="intro"></a>
<h3>Format Specific Streams: The <span class="ncbi_class">CObject[IO]Stream</span> classes</h3>

The reading and writing of serialized data objects entails satisfying two
independent sets of constraints and specifications: (1) <span class="ncbi_term">format-specific</span>
parsing and encoding schemes, and (2)
<span class="ncbi_term">object-specific</span> internal structures
and rules of composition. The NCBI C++ Toolkit implements serial IO processes
by combining a set of <span class="ncbi_term">object stream</span> classes with an independently
defined set of
<span class="ncbi_term">data object</span> classes. These classes are implemented
in the <span class="ncbi_dir">serial</span> and <span class="ncbi_dir">objects</span> directories respectively.
<p>The base classes for the object stream classes are <a href="../docxx/CObjectIStream.html" class="ncbi_class">CObjectIStream</a>
and <a href="../docxx/CObjectOStream.html" class="ncbi_class">CObjectOStream</a>.
Each of these base classes has derived subclasses which specialize in different
formats, including XML, binary ASN.1, and text ASN.1. A simple example
program, <a href="xml2asn_cpp.html" class="ncbi_file">xml2asn.cpp</a>, described in
the chapter on <a href="asn.html#example1">Processing serial data</a>,
uses these object stream classes in conjunction with a <span class="ncbi_class">CBiostruct</span>
object to translate a file from XML encoding to ASN.1 formats. In this
chapter, we consider in more detail the class definitions for object streams,
and how the <a href="typeinfo.html#ctypeinfo">type information</a> associated
with the data is used to implement serial input and output.
<p>Each object stream specializes in a serial data format and a direction
(in/out). It is not until the input and output operators are applied to
these streams, in conjunction with a specified serializable object, that
the object-specific type information comes into play. For example, if <span class="ncbi_var">instr</span>
is a
<span class="ncbi_class">CObjectIStream</span>, the statement: <span class="ncbi_ccode">instr >> myObject</span> invokes
a <span class="ncbi_func">Read()</span> method associated with the input stream, whose sole argument
is a <a href="typeinfo.html#cobjinfo" class="ncbi_class">CObjectInfo</a> for <span class="ncbi_var">myObject</span>.
<p>Similarly, the output operators, when applied to a <span class="ncbi_class">CObjectOstream</span>
in conjunction with a serializable object, will invoke a <span class="ncbi_func">Write()</span>
method on the output stream which accesses the object's type information.
The object's type information defines what tag names and value types should
be encountered on the stream, while the <span class="ncbi_class">CObject[IO]Stream</span> subclasses
specialize the data serialization format.
<p>The input and output operators (<span class="ncbi_ccode">&lt;&lt;</span> and
<span class="ncbi_ccode">&gt;&gt;</span>) are declared in
<a href=../lxr/source/include/serial/serial.hpp>serial/serial.hpp</a> header.

<p><br>

<a NAME="objistr"></a>
<h3>The <a href="../docxx/CObjectIStream.html" class="ncbi_class">CObjectIStream</a> classes</h3>

<span class="ncbi_class">CObjectIStream</span> is a virtual base class for the <a href="../docxx/CObjectIStreamXml.html" class="ncbi_class">CObjectIStreamXml</a>,
<a href="../docxx/CObjectIStreamAsn.html" class="ncbi_class">CObjectIStreamAsn</a>,
and <a href="../docxx/CObjectIStreamAsnBinary.html" class="ncbi_class">CObjectIStreamAsnBinary</a>
classes. As such, it has no public constructors, and its user interface
includes the following methods:
<ul>
<li>
<a href="#open class="ncbi_func"">Open()</a></li>

<li>
<a href="#close" class="ncbi_func">Close()</a></li>

<li>
<a href="#getdata" class="ncbi_func">GetDataFormat()</a></li>

<li>
<a href="#readheader" class="ncbi_func">ReadFileHeader()</a></li>

<li>
<a href="#read" class="ncbi_func">Read()</a></li>

<li>
<a href="#readobj" class="ncbi_func">ReadObject()</a></li>

<li>
<a href="#readsep" class="ncbi_func">ReadSeparateObject()</a></li>

<li>
<a href="#skip" class="ncbi_func">Skip()</a></li>

<li>
<a href="#skipobj" class="ncbi_func">SkipObject()</a></li>
</ul>
<a NAME="open"></a>There are several <span class="ncbi_func">Open()</span> methods; most of these
are static class methods that return a pointer to a newly created <span class="ncbi_class">CObjectIStream</span>.
Typically, these methods are used with an
<span class="ncbi_class">auto_ptr</span>, as in:

<blockquote>
<pre class="ncbi_code">
auto_ptr&lt;CObjectIStream> xml_in(CObjectIStream::Open(filename, eSerial_Xml));
</pre>
</blockquote>

Here, an XML format is specified by the enumerated value <span class="ncbi_var">eSerial_Xml</span>,
defined in
<a href="../lxr/ident?i=ESerialDataFormat" class="ncbi_type">ESerialDataFormat</a>.
Because these methods are static, they can be used to create a new instance
of a <span class="ncbi_class">CObjectIStream</span> subclass, and open it with one statement.
In this example, a <a href="../docxx/CObjectIStreamXml.html" class="ncbi_class">CObjectIStreamXml</a>
is created and opened on the file <span class="ncbi_var">filename</span>.
<p>An additional non-static <span class="ncbi_func">Open()</span> method is provided, which can
only be invoked as a member function of a previously instantiated object
stream (whose format type is of course, implicit to its class). This method
takes a <span class="ncbi_class">CNcbiIstream</span> and a Boolean argument, specifying whether
or not the
<span class="ncbi_class">CNcbiIstream</span> should also be closed when the object stream
is closed:

<blockquote>
<pre class="ncbi_code">
void Open(CNcbiIstream&amp; inStream, bool deleteInStream = false);
</pre>
</blockquote>

<p><a NAME="close"></a><a NAME="getdata"></a><a NAME="readheader"></a>The
next three methods have the following definitions. <span class="ncbi_func">Close()</span> closes
the stream. <span class="ncbi_func">GetDataFormat()</span> returns the enumerated <span class="ncbi_type">ESerialDataFormat</span>
for the stream. <span class="ncbi_func">ReadFileHeader()</span> reads the first line from the file,
and returns it in a string. This might be used for example, in the following
context:

<blockquote>
<pre class="ncbi_code">
auto_ptr&lt;CObjectIStream> in(CObjectIStream::Open(fname, eSerial_AsnText));
string type = in.ReadFileHeader();

if (type.compare("Seq-entry") == 0) {
    CSeq_entry seqent;
    in->Read(ObjectInfo(seqent), eNoFileHeader);
    // ...
}

else if (type.compare("Bioseq-set") == 0) {
    CBioseq_set seqset;
    in->Read(ObjectInfo(seqset), eNoFileHeader);
    // ...
}
// ...
</pre>
</blockquote>

The <span class="ncbi_func">ReadFileHeader()</span> method for the base <span class="ncbi_class">CObjectIStream</span> class
returns an empty string. Only those stream classes which specialize in
ASN.1 text or XML formats have actual implementations for this method.
<p><a NAME="read"></a>Several <span class="ncbi_func">Read*()</span> methods are provided for usage
in different contexts.
<span class="ncbi_func">CObjectIStream::Read()</span> should be used for
reading a top-level "root" object from a data file. For convenience, the
input operator <span class="ncbi_ccode">>></span>, as described above, indirectly invokes this method
on the input stream, using a <a href="typeinfo.html#cobjinfo" class="ncbi_class">CObjectTypeInfo</a>
object derived from <span class="ncbi_var">myObject</span>. By default, the <span class="ncbi_func">Read()</span> method first calls
<span class="ncbi_func">ReadFileHeader()</span>, and then calls <span class="ncbi_func">ReadObject()</span>.
Accordingly, calls to <span class="ncbi_func">Read()</span> which follow the usage of <span class="ncbi_func">ReadFileHeader()</span> <em>must</em> include the optional
<span class="ncbi_var">eNoFileHeader</span> argument.
<p><a NAME="readobj"></a><a NAME="readsep"></a>Most data objects also contain
embedded objects, and the default behavior of <span class="ncbi_func">Read()</span> is to load
the top-level object, along with all of its contained subobjects into memory.
In some cases this may require significant memory allocation, and it may
be only the top-level object which is needed by the application. The next
two methods, <a href="../lxr/ident?i=ReadObject" class="ncbi_func">ReadObject()</a> and
<a href="../lxr/ident?i=ReadSeparateObject" class="ncbi_func">ReadSeparateObject()</a>,
can be used to load subobjects as either persistent data members of the
root object or as temporary local objects. In contrast to <span class="ncbi_func">Read()</span>,
these methods assume that there is not a file header on the stream.
<p>As a result of executing <span class="ncbi_ccode">ReadObject(member)</span>, the newly
created subobject will be instantiated as a member of its parent object.
In contrast, <span class="ncbi_ccode">ReadSeparateObject(local)</span>, instantiates the subobject
in the local temporary variable only, and the corresponding data member
in the parent object is set to an appropriate <span class="ncbi_value">null</span> representation
for that data type. In this case, an attempt to reference that subobject
after exiting the scope where it was created generates an error.
<p><a NAME="skip"></a><a NAME="skipobj"></a>The <span class="ncbi_func">Skip()</span> and <span class="ncbi_func">SkipObject()</span>
methods allow entire top-level objects and subobjects to be "skipped".
In this case the input is still read from the stream and validated, but
no object representation for that data is generated. Instead, the data
is stored in a delay buffer associated with the object input stream,
where it can be accessed as needed. <span class="ncbi_func">Skip()</span> should only be applied
to top-level objects. As with the <span class="ncbi_func">Read()</span> method, the optional
<span class="ncbi_type">ENoFileHeader</span>
argument can be included if the file header has already been extracted
from the data stream. <span class="ncbi_ccode">SkipObject(member)</span> may be applied to subobjects
of the root object.
<p>All of the <span class="ncbi_func">Read</span> and <span class="ncbi_func">Skip</span> methods are like wrapper functions,
which define what activities take place immediately before and after the
data is actually read. How and when the data is then loaded into memory
is determined by the object itself. Each of the above methods ultimately
calls <span class="ncbi_ccode">objTypeInfo->ReadData()</span> or <span class="ncbi_ccode">objTypeInfo->SkipData()</span>,
where
<span class="ncbi_var">objTypeInto</span> is the static type information object associated
with the data object. This scheme allows the user to install type-specific
read, write, and copy hooks, which are described below. For example, the
default behavior of loading all subobjects of the top-level object can
be modified by installing appropriate read hooks which use the <span class="ncbi_func">ReadSeparateObject()</span>
and <span class="ncbi_func">SkipObject()</span> methods where needed.

<p><br>


<a NAME="objostr"></a>
<h3>The  <a href="../docxx/CObjectOStream.html" class="ncbi_class">CObjectOStream</a> classes</h3>

The output object stream classes mirror the <span class="ncbi_class">CObjectIStream</span> classes.
The <span class="ncbi_class" class="ncbi_class">CObjectOStream</span> base class is used to derive the <a href="../docxx/CObjectOStreamXml.html">CObjectOStreamXml</a>,
<a href="../docxx/CObjectOStreamAsn.html" class="ncbi_class">CObjectOStreamAsn</a>,
and <a href="../docxx/CObjectOStreamAsnBinary.html" class="ncbi_class">CObjectOStreamAsnBinary</a>
classes. There are no public constructors, and the user interface includes
the following methods:
<ul>
<li>
<span class="ncbi_func">Open()</span></li>

<li>
<span class="ncbi_func">Close()</span></li>

<li>
<span class="ncbi_func">GetDataFormat()</span></li>

<li>
<span class="ncbi_func">WriteFileHeader()</span></li>

<li>
<span class="ncbi_func">Write()</span></li>

<li>
<span class="ncbi_func">WriteObject()</span></li>

<li>
<span class="ncbi_func">WriteSeparateObject()</span></li>

<li>
<span class="ncbi_func">Flush()</span></li>

<li>
<span class="ncbi_func">FlushBuffer()</span></li>
</ul>
Again, there are several <span class="ncbi_func">Open()</span> methods, which are static class
methods that return a pointer to a newly created <span class="ncbi_class">CObjectOstream</span>:

<blockquote>
<pre class="ncbi_code">
static CObjectOStream* Open(const string&amp; fileName, ESerialDataFormat format);
static CObjectOStream* Open(ESerialDataFormat format,
                            const string&amp; fileName, unsigned openFlags = 0);
static CObjectOStream* Open(ESerialDataFormat format,
                            CNcbiOstream&amp; os, bool deleteOutStream = false);
</pre>
</blockquote>
The <span class="ncbi_func">Write*()</span> methods correspond to the
<span class="ncbi_func">Read*()</span> methods defined for the input streams.
<span class="ncbi_func">Write()</span> first calls <span class="ncbi_func">WriteFileHeader()</span>,
and then calls <span class="ncbi_func">WriteObject()</span>.
<span class="ncbi_func">WriteSeparateObject()</span> can be
used to write a temporary object (and all of its children) to the output
stream. It is also possible to install type-specific <span class="ncbi_term">write</span> hooks.
Like the
<span class="ncbi_func">Read()</span> methods, these <span class="ncbi_func">Write()</span> methods serve as wrapper
functions that define what occurs immediately before and after the data
is actually written.
<p><br>


<a NAME="objcopy"></a>
<h3>The <a href="../docxx/CObjectStreamCopier.html" class="ncbi_class">CObjectStreamCopier</a> classes</h3>

The <span class="ncbi_class">CObjectStreamCopier</span> class is neither an input nor an output
stream class, but a helper class, which allows one to "pass data through"
without storing the intermediate objects in memory. Its sole constructor
is:

<blockquote>
<pre class="ncbi_code">
CObjectStreamCopier(CObjectIStream&amp; in, CObjectOStream&amp; out);
</pre>
</blockquote>

<p>and its most important method is the <span class="ncbi_func">Copy(CObjectTypeInfo&amp;)</span>
method, which, given an object's description, reads that object from the
input stream and writes it to the output stream. The serial formats of
both the input and output object streams are implicit, and thus the translation
between two different formats is performed automatically.
<p>In keeping with the <span class="ncbi_func">Read</span>
and <span class="ncbi_func">Write</span> methods of the
<span class="ncbi_class">CObjectIStream</span>
and
<span class="ncbi_class">CObjectOStream</span> classes, the <span class="ncbi_func">Copy</span> method takes an optional
<span class="ncbi_type">ENoFileHeader</span> argument, to indicate that the file header is not
available in the input and should not be generated on the output. The <span class="ncbi_func">CopyObject()</span>
method corresponds to the <span class="ncbi_func">ReadObject()</span> and
<span class="ncbi_func">WriteObject()</span>
methods.
<p>As an example, consider how the <span class="ncbi_func">Run()</span> method in <a href="xml2asn_cpp.html" class="ncbi_file">xml2asn.cpp</a>
might be implemented differently using the <span class="ncbi_class">CObjectStreamCopier </span>class:

<blockquote>
<pre class="ncbi_code">
int CTestAsn::Run() {
    auto_ptr&lt;CObjectIStream&gt;
        xml_in(CObjectIStream::Open("1001.xml", eSerial_Xml));
    auto_ptr&lt;CObjectOStream&gt;
        txt_out(CObjectOStream::Open("1001.asntxt", eSerial_AsnText));
    CObjectStreamCopier txt_copier(*xml_in, *txt_out);
    txt_copier.Copy(CBiostruc::GetTypeInfo());
    auto_ptr&lt;CObjectOStream&gt;
        bin_out(CObjectOStream::Open("1001.asnbin", eSerial_AsnBinary));
    CObjectStreamCopier bin_copier(*xml_in, *bin_out);
    bin_copier.Copy(CBiostruc::GetTypeInfo());
    return 0;
}
</pre>
</blockquote>

<p>It is also possible to install type-specific <span class="ncbi_func">Copy</span> hooks. Like
the <span class="ncbi_func">Read</span> and <span class="ncbi_func">Write</span> methods, the <span class="ncbi_func">Copy</span> methods serve
as wrapper functions that define what occurs immediately before and after
the data is actually copied.
<p><br>


<a NAME="cback"></a>
<h3>Type-specific I/O routines</h3>

Much of the functionality needed to read and write serializable objects
may be type-specific yet application-driven. Because the specializations
may vary with the application, it does not make sense to implement fixed
methods, yet we would like to achieve a similar kind of object-specific
behavior.
<p>To address these needs, the C++ Toolkit provides hook mechanisms, whereby
the needed functionality can be installed with the object's static class
<a href="typeinfo.html#ctypeinfo">type information</a> object. Such hooks
can be installed <em>globally</em>, where they will be applied on <em>all</em>
streams where these events occur, or <em>locally</em>, where they will only
be applied to a selected stream.
<p>For any given object and specific stream, at most one read hook and
one write hook is "active". If <span class="ncbi_var">myObject</span> has a locally installed
read hook as well as a global read hook, then the locally installed hook
will override the global hook when a read occurs on the "local" stream.
Read events on all of the other "non-local" streams will of course, trigger
the globally installed hook. Designating multiple read/write hooks (both
local and global) for a selected object does not generate an error. Older
or less specific hooks are simply overridden by the more specific or most
recently installed hook.
<p><br>


<a NAME="readhooks"></a>
<h3>The <span class="ncbi_term">Read</span> hook classes</h3>

All of the different contexts in which an object might be encountered on
an input stream can be reduced to three cases:
<ol>
<li>
as a stand-alone object</li>

<li>
as a data member of a containing object</li>

<li>
as a variant of a <span class="ncbi_term">choice</span> object</li>

</ol>
Hooks can be installed for each of these contexts, depending
on the desired level of specificity. Corresponding to these contexts, three
abstract base classes provide the foundations for deriving new <span class="ncbi_term">Read</span>
hooks:
<ul>
<li>
<span class="ncbi_class">CReadObjectHook</span></li>

<li>
<span class="ncbi_class">CReadClassMemberHook</span></li>

<li>
<span class="ncbi_class">CReadChoiceVariantHook</span></li>
</ul>
Each of these base hook classes exists only to define a pure virtual
<span class="ncbi_func">Read</span> method, which can then be implemented
(in a derived subclass) to install the desired type of read hook. If the goal is to apply the new
<span class="ncbi_func">Read</span>
method in all contexts, then the new hook should be derived from
the <span class="ncbi_class">CReadObjectHook</span> class, and registered with the object's static
type information object. For example, to install a new
<span class="ncbi_class">CReadObjectHook</span>
for a
<span class="ncbi_class">CBioseq</span>, one might use:

<blockquote>
<pre class="ncbi_code">
CBioseq::GetTypeInfo()->SetGlobalReadObjectHook(myReadBioseqHook);
</pre>
</blockquote>

Another way of installing hooks of any type (read/write/copy, object/member/variant)
is provided by <span class="ncbi_class">CObjectHookGuard</span> class described below.
<p>
Alternatively, if the desired behavior is to trigger the specialized
<span class="ncbi_func">Read</span>
method only when the object occurs as a data member of a particular containing
class, then the new hook should be derived from the <span class="ncbi_class">CReadClassMemberHook</span>,
and registered with that member's type information object:

<blockquote>
<pre class="ncbi_code">
CBioseq::GetTypeInfo()->FindMember("Seq-inst")
    ->SetGlobalReadClassMemberHook(myReadSeqinstHook);
</pre></blockquote>

Similarly, one can install a read hook that will only be triggered when
the object occurs as a choice variant:
<blockquote>
<pre class="ncbi_code">
CSeq_entry::GetTypeInfo()->FindVariant("Bioseq")
    ->SetGlobalReadChoiceVariantHook(myReadBioseqHook);
</pre>
</blockquote>

The new hook classes for these examples should be derived from <span class="ncbi_class">CReadObjectHook</span>,
<span class="ncbi_class">CReadClassMemberHook</span>,
and <span class="ncbi_class">CReadChoiceVariantHook</span>, respectively. In the first case, all
occurrences of <span class="ncbi_class">CBioseq</span> on any input stream will trigger the new
<span class="ncbi_func">Read</span>
method. In contrast, the last case installs this new <span class="ncbi_func">Read</span> method
to be triggered only when the <span class="ncbi_class">CBioseq</span> occurs as a choice variant
in a <span class="ncbi_class">CSeq_entry</span> object.
<p>All of the virtual <span class="ncbi_func">Read</span> methods take two arguments: a <span class="ncbi_class">CObjectIStream</span>
and a reference to a <a href="typeinfo.html#objinfo" class="ncbi_class">CObjectInfo</a>.
For example, the <span class="ncbi_class">CReadObjectHook</span> class declares the <span class="ncbi_func">ReadObject()</span>
method as:

<blockquote>
<pre class="ncbi_code">
virtual void ReadObject(CObjectIStream&amp; in,
                        const CObjectInfo&amp; object) = 0;
</pre>
</blockquote>
The <span class="ncbi_func">ReadClassMember</span> and <span class="ncbi_func">ReadChoiceVariant</span> hooks differ from
the <span class="ncbi_func">ReadObject</span> hook class, in that the second argument to the virtual
<span class="ncbi_func">Read</span>
method is an iterator, pointing to the object type information for a data
member or choice variant respectively.
<p>In summary, to install a read hook for an object type:
<ol>
<li>
derive a new class from the appropriate hook class:</li>

<ul>
<li>
if the target object occurs in any context, use the <span class="ncbi_class">CReadObjectHook</span>
class.</li>

<li>
if the target object occurs as a data member, use the <span class="ncbi_class">CReadClassMemberHook</span>
class.</li>

<li>
if the target object occurs as a choice variant, use the <span class="ncbi_class" class="ncbi_class">CReadChoiceVariant
Hook</span> class.</li>
</ul>

<li>
implement the virtual <span class="ncbi_func">Read</span> method for the new class.</li>

<li>
install the hook, using the <span class="ncbi_func">SetGlobalReadHook()</span> or <span class="ncbi_func">SetLocalReadHook()</span>
method defined in</li>

<ul>
<li>
<span class="ncbi_class">CObjectTypeInfo</span> for a <span class="ncbi_class">CReadObjectHook</span></li>

<li>
<span class="ncbi_class">CMemberInfo</span> for a <span class="ncbi_class">CReadClassMemberHook</span></li>

<li>
<span class="ncbi_class">CVariantInfo</span> for a <span class="ncbi_class">CReadChoiceVariantHook</span></li>
</ul>
or use <span class="ncbi_class">CObjectHookGuard</span> class to install any of these hooks.
</ol>
In many cases you will need to read the hooked object and do
some special processing, or to skip the entire object. To simplify
object reading or skipping all base hook classes have DefaultRead()
and DefaultSkip() methods taking the same arguments as the user
provided ReadXXXX() methods. Thus, to read a bioseq object from a hook:

<blockquote>
<pre class="ncbi_code">
void CMyReadObjectHook::ReadObject(CObjectIStream& in, const CObjectInfo& object)
{
    DefaultRead(in, object);
    // Do some user-defined processing of the bioseq
}
</pre>
</blockquote>

Note that from a choice variant hook you can not skip stream data -- this could leave the
choice object in an uninitialized state. For this reason the CReadChoiceVariantHook class
has no DefaultSkip() method.
<p>
For a good example of using a <span class="ncbi_class">CReadClassMemberHook</span> object, see the
<a href="../lxr/source/src/objects/asn2asn/asn2asn.cpp" class="ncbi_file">asn2asn.cpp</a> and
<a href="../lxr/source/src/serial/test/testserial.cpp" class="ncbi_file">testserial.cpp</a>
demo programs.
<p><br>


<a NAME="writehooks"></a>
<h3>The <span class="ncbi_term">Write</span> hook classes</h3>

The <span class="ncbi_term">Write</span> hook classes parallel the <span class="ncbi_term">Read</span> hook classes, and
again, we have three base classes:
<ul>
<li>
<span class="ncbi_class">CWriteObjectHook</span></li>

<li>
<span class="ncbi_class">CWriteClassMemberHook</span></li>

<li>
<span class="ncbi_class">CWriteChoiceVariantHook</span></li>
</ul>
These classes define the pure virtual methods:

<blockquote>
<pre class="ncbi_code">
CWriteObjectHook::WriteObject(CObjectOStream&amp;,
                              const CConstObjectInfo&amp; object) = 0;

CWriteClassMemberHook::WriteClassMember(CObjectOStream&amp;,
                                        const CConstObjectInfoMI&amp; member) = 0;

CWriteChoiceVariantHook::WriteChoiceVariant(CObjectOStream&amp;,
                                            const CConstObjectInfoCV&amp; variant) = 0;
</pre>
</blockquote>

Like the read hooks, your derived write hooks can be installed by invoking
the
<span class="ncbi_func">SetGlobalWriteObjectHook()</span> or <span class="ncbi_func">SetLocalWriteObjectHook()</span>
methods for the appropriate type information objects. Corresponding to
the examples for read hooks then, we would have:

<blockquote>
<pre class="ncbi_code">
CBioseq::GetTypeInfo()->SetGlobalWriteObjectHook(myWriteBioseqHook);

CBioseq::GetTypeInfo()->FindMember("Seq-inst")
    ->SetGlobalWriteClassMemberHook(myWriteSeqinstHook);

CSeq_entry::GetTypeInfo()->FindVariant("Bioseq")
    ->SetGlobalWriteChoiceVariantHook(myWriteBioseqHook);
</pre>
</blockquote>

<span class="ncbi_class">CObjectHookGuard</span> class provides is a simple way to install write hooks.
<p>
The <a href="../lxr/source/src/objects/asn2asn/asn2asn.cpp" class="ncbi_file">asn2asn.cpp</a> and
<a href="../lxr/source/src/serial/test/testserial.cpp" class="ncbi_file">testserial.cpp</a>
demo programs also demonstrate the usage of the <span class="ncbi_class">CWriteClassMemberHook</span>
class.
<p><br>


<a NAME="copyhooks"></a>
<h3>The <span class="ncbi_term">Copy</span> hook classes</h3>


As with the <span class="ncbi_term">Read</span> and <span class="ncbi_term">Write</span>
hook classes, there are three base classes which define the following
<span class="ncbi_term">Copy</span> methods:

<blockquote>
<pre class="ncbi_code">
CCopyObjectHook::CopyObject(CObjectStreamCopier&amp; copier,
                            const CObjectTypeInfo&amp; object) = 0;

CCopyClassMemberHook::CopyClassMember(CObjectStreamCopier&amp; copier,
                                      const CObjectTypeInfoMI&amp; member) = 0;

CCopyChoiceVariantHook::CopyChoiceVariant(CObjectStreamCopier&amp;,
                                          const CObjectTypeInfoCV&amp; variant) = 0;
</pre>
</blockquote>

Newly derived copy hooks can be installed by invoking the <span class="ncbi_func">SetGlobalCopyObjectHook()</span>
or
<span class="ncbi_func">SetLocalCopyObjectHook()</span> methods for the appropriate type information
objects. The other way of installing hooks is described below in the <span class="ncbi_class">CObjectHookGuard</span>
section.
<p>To do default copying of an object in the overloaded hook method
each of the base copy hook classes has <span class="ncbi_func">DefaultCopy()</span> method.
<p><br>


<a NAME="hookguard"></a>
<h3>The <span class="ncbi_class">CObjectHookGuard</span> class</h3>

To simplify hooks usage <span class="ncbi_class">CObjectHookGuard</span> class may be used.
It's a template class: the template parameter is the class to be
hooked (in case of member or choice variant hooks it's the parent
class of the member).

<p>
The CObjectHookGuard class has several constructors for installing
different hook types. The last argument to all constructors is
a stream pointer. By default the pointer is NULL and the hook is
intalled as a global one. To make the hook stream-local pass the
stream to the guard constructor.

<ul>
<li>
Object read/write hooks:

<blockquote>
<pre class="ncbi_code">
CObjectHookGuard(CReadObjectHook& hook, CObjectIStream* in = 0);
CObjectHookGuard(CWriteObjectHook& hook, CObjectOStream* out = 0);
</pre>
</blockquote>
</li>

<li>
Class member read/write hooks:
<blockquote>
<pre class="ncbi_code">
CObjectHookGuard(string id, CReadClassMemberHook& hook, CObjectIStream* in = 0);
CObjectHookGuard(string id, CWriteClassMemberHook& hook, CObjectOStream* out = 0);
</pre>
</blockquote>

The string "id" argument is the name of the member in ASN.1 specification
for generated classes.
</li>

<li>
Choice variant read/write hooks:
<blockquote>
<pre class="ncbi_code">
CObjectHookGuard(string id, CReadChoiceVariantHook& hook, CObjectIStream* in = 0);
CObjectHookGuard(string id, CWriteChoiceVariantHook& hook, CObjectOStream* out = 0);
</pre>
</blockquote>
The string "id" argument is the name of the variant in ASN.1 specification
for generated classes.
</li>

</ul>

The guard's destructor will uninstall the hook. Since all hook classes are derived
from CObject and stored as CRef<>-s, the hooks are destroyed automatically when
uninstalled. For this reason it's recommended to create hook objects on heap.
<p><br>


<a NAME="blocks"></a>
<h3>The <span class="ncbi_class">ByteBlock</span> and <span class="ncbi_class">CharBlock</span> classes</h3>

<span class="ncbi_class">CObject[IO]Stream::ByteBlock</span> class may be used for non-standard processing
of an OCTET STRING data, e.g. from a read/write hooks. The
<span class="ncbi_class">CObject[IO]Stream::CharBlock</span> class has almost the same functionality,
but may be used for VisibleString data processing.
<p>

An example of using ByteBlock or CharBlock classes is generating
data on-the-fly in a write hook. To use block classes:
<ol>
<li>Initialize the block variable with an i/o stream and, in case of
output stream, the length of the block.</li>

<li>Use Read()/Write() functions to process block data</li>

<li>Close the block with the End() function</li>
</ol>

Below is an example of using <span class="ncbi_class">CObjectOStream::ByteBlock</span>
in an object write hook for non-standard data processing. Note, that ByteBlock
and CharBlock classes read/write data only. You should also provide
some code for writing class' and members' tags.
<p>

Since OCTET STRING and VisibleString in the NCBI C++ Toolkit are
implemented as <span class="ncbi_class">vector&lt;char&gt;</span> and <span class="ncbi_class">string</span> classes, which have
no serailization type info, you can not install a read or write hook
for these classes. The example also demonstrates how to process
members of these types using the contaning class hook.
Another example of using CharBlock with write hooks can be found in
<a href="../lxr/source/src/serial/test/testserial.cpp" class="ncbi_class">testserial.cpp</a>
application.

<blockquote>
<pre class="ncbi_code">
void CWriteMyObjectHook::WriteObject(CObjectOStream&amp; out,
                                     const CConstObjectInfo&amp; object)
{
    const CMyObject&amp; obj = *reinterpret_cast&lt;const CMyObject*&gt;
        (object.GetObjectPtr());
    if ( NothingToProcess(obj) ) {
        // No special processing - use default write method
        DefaultWrite(out, object);
        return;
    }

    // Write object open tag
    out.BeginClass(object.GetClassTypeInfo());
    // Iterate object members
    for (CConstObjectInfo::CMemberIterator member =
        object.BeginMembers(); member; ++member) {

        if ( NeedProcessing(member) ) {
            // Write the special member manually
            out.BeginClassMember(member.GetMemberInfo()-&gt;GetId());
            // Start byte block, specify output stream and block size
            size_t length = GetRealDataLength(member);
            CObjectOStream::ByteBlock bb(out, length);
            // Processing and output
            for (int i = 0; i &lt; length; ) {
                char* buf;
                int buf_size;
                // Assuming ProcessData() generates the data from "member",
                // starting from position "i" and stores the data to "buf"
                ProcessData(member, i, &amp;buf_size, &amp;buf);
                i += buf_size;
                bb.Write(buf, buf_size);
            }
        }
        // Close the byte block
        bb.End();
        // Close the member
        out.EndClassMember();
    }
    else {
        // Default writer for members without special processing
        if ( member.IsSet() )
            out.WriteClassMember(member);
    }
    // Close the object
    out.EndClass();
}
</pre>
</blockquote>

<p><i><a href="../index.html">up</a></i><!--NCBI_MARK--> <a href="asn.html"><i>next</i></a>


<!--#include virtual="../ssi/navlinks.shtml" -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i><!--NCBI_MARK--></td> --></td>

<td ALIGN=RIGHT><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>
<!-- NOTES:

- Skip(TTypeInfo)
- CopyObject(TTypeInfo, CObjectStreamCopier&);

- omitted versions of Read*, Skip* that use TTypeInfo args in the descrip
-->

<!--#include virtual="../ssi/footer.shtml" -->
