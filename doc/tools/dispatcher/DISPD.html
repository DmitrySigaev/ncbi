<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body>
<b>$Date$ $Revision$</b>

<center>
<h1>
<b><font size=+2>DISPD Service Mapper Protocol</font></b></h1></center>

<p>DISPD.CGI is a CGI HTTP-compliant program, the purpose of which
is to map a requested service name to an actual server location. This mapping
is called <i>dispatching</i>. Optionally DISPD.CGI can also pass data between
the client, requested the mapping, and the server, which implements the
service, and was found as a result of <i>dispatching</i>. This combined
mode is called <i>connection</i>. The client may choose either of these
modes if there is no special requirement on data transfer (e.g. firewall
connection). In some cases, however, the requested connection mode implicitly
limits the request to be a <i>dispatching</i>-only request, and actual
data flow between the client and the server occurs separately at a later stage.

<p>The protocol is designed as an extension to HTTP/1.0 and is coded in the
HTTP header parts of the packets. The request (both <i>dispatching</i>,
and <i>connection</i>) is done by sending an HTTP-packet to DISPD.CGI with
a query line of the form:

<blockquote><tt><font color="#3333FF">dispd.cgi?service=<i>&lt;name></i></font></tt></blockquote>

which can be followed by parameters (if applicable) to be passed to the
service. The parameters take form of one or more of the following construct:

<blockquote><tt><font color="#3333FF">&amp;<i>&lt;param></i>[=<i>&lt;value></i>]</font></tt></blockquote>

where square brackets are used to denote an optional value part of the
parameter.

<p>In the case of a <i>connection </i>request, the request body can contain
data to be passed to the first found server, connection to which is
automatically initiated by DISPD.GCI after <i>dispatching</i>. On a contrary,
in case of a <i>dispatching</i> request, the body is completely ignored
(connection dropped) after the header has been read, which may confuse
an unprepared client.

<p>
<i>Dispatching</i> is done via LBSM Daemon (<tt>lbsmd</tt>), which has
to run on the same host where DISPD.CGI runs. DISPD.CGI never
dispatches to the services marked as <i>local</i> (by means of
<tt>L=yes</tt> in configuration of LBSMD). Otherwise, the result
of dispatching is exactly what the client would get from service
mapping API if run locally (see Service Mapping API in the NCBI C++ Toolkit
documentation). Explicitly specifying its capabilities, the client
can narrow the server search; for example, by choosing
<a href="#Browsers">stateless</a> servers only.

<p>
In the client request to the DISPD.CGI, the following additional
HTTP tags are recognized:

<ul>
  <tt><font color="#3333FF">Accepted-Server-Types:
  <i>&lt;list></i></font></tt>
  <br>where <tt><i>&lt;list></i></tt> can include
  one or more of the following keywords, separated by spaces:
  <ul>
    <li><tt><font color="#3333FF">NCBID</font></tt></li>
    <li><tt><font color="#3333FF">STANDALONE</font></tt></li>
    <li><tt><font color="#3333FF">HTTP</font></tt></li>
    <li><tt><font color="#3333FF">HTTP_GET</font></tt></li>
    <li><tt><font color="#3333FF">HTTP_POST</font></tt></li>
    <br>which describe server types, the client is capable to handle. Note
    that some server types can be ignored if not compatible with the current
    <a href="#Client-Mode">client mode</a>.
    <br>
    Default is <i>any</i>, and in case of <i>connection</i> request,
    the dispatcher will accomodate an actual found server with the
    connection mode, which the client requested, by relaying data
    appropriately, and in a way suitable for the server.
  </ul>

  <p>
  <a NAME="Client-Mode"></a><tt><font color="#3333FF">Client-Mode:
  <i>&lt;mode></i></font></tt>
  <br>where <tt><i>&lt;mode></i></tt> can be one of the following:
  <ul>
    <li><tt><font color="#3333FF">STATELESS_ONLY</font></tt></li>
    <li><tt><font color="#3333FF">STATEFUL_CAPABLE</font></tt></li>
  </ul>
  <tt>STATELESS_ONLY</tt> specifies that the client is not capable of
  doing full-duplex data exchange with the server (e.g. in a dedicated
  connection).<br>
  <tt>STATEFUL_CAPABLE</tt> should be used by the clients, which are
  capable of holding an open connection to the server. This keyword
  serves as a hint to dispatcher to try to open a direct TCP channel
  between the client and a server, thus reducing the network usage overhead.
  <br>
  Default is <tt>STATELESS_ONLY</tt> in order to support Web-browsers.

  <p>
  <tt><font color="#3333FF">Dispatch-Mode:
  <i>&lt;mode></i></font></tt>
  <br>where <tt><i>&lt;mode></i></tt> can be one of the following:
  <ul>
    <li><tt><font color="#3333FF">INFORMATION_ONLY</font></tt></li>
    <li><tt><font color="#3333FF">STATEFUL_INCLUSIVE</font></tt></li>
    <li><tt><font color="#3333FF">NO_INFORMATION</font></tt></li>
  </ul>
  <tt>INFORMATION_ONLY</tt> specifies that the current request is a
  <i>dispatching</i> request, and no data and/or connection establishment
  with the server required at this stage. That is the dispatcher returns
  the list of available server specifications (if any), corresponding
  to requested service, and in accordance with client mode and data
  relaying (see below).<br>
  <tt>NO_INFORMATION</tt> is used to disable sending the above
  mentioned dispatching information back to the client.
  This keyword is reserved for use by the dispatcher itself and
  should not be used by a side application.<br>
  <tt>STATEFUL_CAPABLE</tt> tells the dispatcher that the
  current request is a <i>connection</i> request, and as soon it is
  going over HTTP, it is considered stateless, thus the dispatching
  would otherwise only supply stateless servers. This keyword modify this
  default behavior, and dispatching information sent back along with
  server reply (resulting from data exchange) should include stateful
  servers as well, thus allowing the client to change the connection
  mode later and go to a dedicated connection.
  <br>
  Default is <i>connection</i> request, and as it is going over HTTP,
  it is stateless at the same time. This is to support calls to
  NCBI services from Web-browsers.

  <p>
  <tt><font color="#3333FF">Relay-Mode:
  <i>&lt;mode></i></font></tt>
  <br>where <tt><i>&lt;mode></i></tt> can be one of the following:
  <ul>
    <li><a NAME="FIREWALL"></a><tt><font color="#3333FF">FIREWALL</font></tt></li>
    <li><tt><font color="#3333FF">DIRECT</font></tt></li>
  </ul>
  <tt>FIREWALL</tt> requests a firewall connection, that is the
  client is sitting behind a firewall, and is not able to connect
  to an arbitrary port.
  If this is a <i>connection</i> request (as per Dispatch-Mode tag),
  then the data exchange could happen in 2 different ways:
  in case of stateless client, the data are relayed by DISPD.CGI itself.
  In case of stateful request the actual
  connection must be re-established with the NCBI
  firewall daemon, connection point of which is sent out in reply as a
  <tt><font color="#3333FF"><a href="#Connection-Info">Connection-Info</a></font></tt>
  tag value. No other data transfer occurs between the client and DISPD.CGI,
  but in the re-established firewalled connection.<br>
  <tt>DIRECT</tt> specifies that the client is capable to communicate
  to a server by its own. In case of stateful connection, Connection-Info
  returned would contain a point, where the server is running, and
  this point is <i>not</i> a firewall daemon port, but direct server port.
  In case of stateless connection, again, the data could be passed
  by DISPD.CGI, in case of <i>connection</i> request.
  <br>
  Default is <tt>DIRECT</tt>, which also supports connections from
  Web-browsers.
</ul>

<a NAME="Browsers"></a>
If neither of the tags are found in the HTTP header, the request is considered
as <i>connection</i> request, for stateless-only and direct client,
that is the first found server is run, and parameters (if any) and other data
(e.g. from the request body) are passed for processing. The backward data flow
is wrapped to HTTP-compliant reply and sent back to the client.
Note that in this mode, if the server found is a standalone server,
i.e. running on some listening port, the data are
accepted from it until the reply ends, and then wrapped to HTTP-reply;
thus, there is no real full-duplex data exchange as it could be with a
dedicated connection to the standalone server.
This case is the only for use by Web-browsers,
which are unaware of HTTP extensions, described here.

<p>
Dispatcher tries to determine whether the request is coming a from Web-browser,
or from an application (a SERVICE connector, for instance) by analyzing
HTTP header. In case of a Web-browser, the data path could be chosen
more expensive but more robust, including connection retries if required,
while with an application, dispatcher could return an error and the retry
has to be done by the application, not the dispatcher.

<p>Another tag, which dispatcher is aware of, is <br>
<tt><font color="#3333FF">Skip-Info-<i>n</i>: <i>&lt;server info></i></font></tt>
<br>
A number of <i>&lt;server info></i> strings can be passed to DISPD.CGI to
ignore the servers from being considered as potential mapping targets
(in case the client knows the listed servers do not work, or not appropriate);
<tt>Skip-Info</tt> tags are enumerated by numerical consequent suffices
(<i>n</i>), starting from 1. These tags are optional and should only be used
if the client believes that the certain servers do not match the search
criteria, or otherwise the client may end up with an unsuccessful mapping.

<p>
In response to the client DISPD.CGI can produce the following HTTP tags:
<ul>
  <p>
  <a NAME="Connection-Info"></a><tt><font color="#3333FF">Connection-Info:
<i>&lt;host>
&lt;port> &lt;ticket></i></font></tt>
<p><i><tt>&nbsp;&nbsp;&nbsp; </tt></i>the tag value gives the host (in
a dotted notation) and the port number (decimal value) to identify the machine
the server is running on (if the server was specifically started due to
the client request), the ticket value (hexadecimal value) represents the
ticket (4-byte value), which must be passed to the server (as a binary
value) in the very beginning of the data stream. If the server was not
run by the dispatcher, this HTTP tag does not appear in the reply.
<p><tt><font color="#3333FF">Server-Info-<i>n</i>: <i>&lt;server info></i></font></tt>
<p><i><tt>&nbsp;&nbsp;&nbsp; </tt></i>the tag(s) (enumerated increasingly
by suffix <i>n</i>, starting from 1) give a list of servers, where the
requested service is available. The list can have up to 5 entries. However,
there only one entry generated, if the service was requested in the <a href="#FIREWALL">firewall</a>
mode.
<p><tt><font color="#3333FF">Request-Failed: <i>&lt;reason></i></font></tt>
<p><i><tt>&nbsp;&nbsp;&nbsp; </tt></i>the tag (if present) means mapping
failure with an explanation in the tag value.
<br>&nbsp;</ul>

<li>
In case of stateless connections to NCBID servers (that is non HTTP-compliant
servers, which made so by intermediate NCBID.CGI HTTP-compliant gateway
program) the data flow resembles the way that the DISPD.CGI deals with
standalone servers in <a href="#Browsers">stateless</a> mode.</li>

<br>&nbsp;
<li>
NCBID.CGI program chooses the mode of <i>connection</i> from another additional
HTTP tag</li>

<ul>&nbsp;
<br><tt><font color="#3333FF">Connection-Mode: <i>&lt;mode></i></font></tt>
<p><i><tt>&nbsp;&nbsp;&nbsp; </tt></i>where <i>&lt;mode> </i>is one of
the following:
<ul>
<li>
<tt><font color="#3333FF">Stateful</font></tt></li>

<li>
<tt><font color="#3333FF">Stateless</font></tt></li>

<p><br>The tag can be absent, meaning stateless mode of connection (useful
when connecting from the Internet browsers). This tag gets generated automatically
by DISPD.CGI when forwarding to an NCBID-server in <i>connection</i> request.</ul>
</ul>
</ul>

</body>
</html>
