/*  $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors: Anatoliy Kuznetsov
 *
 * File Description:
 *	  Query parser entry point. 
 *    Glues together code generated by BISON, lexical tokenizer, 
 *    error processing, etc.
 *
 */

#include <ncbi_pch.hpp>
#include <corelib/ncbimtx.hpp>
#include <util/qparse/query_parse.hpp>
#include <util/resource_pool.hpp>


USING_NCBI_SCOPE;

/* extern "C" */ static int yyerror (const char *s);
/* extern "C" */ static int yylex (CQueryParseTree::TNode** lvalp, void* param);

BEGIN_NCBI_SCOPE



/// Query tree garbage collection functor.
///
/// Finds nodes in the query tree and removes them from the 
/// memory pool. All lost nodes are deleted by the pool object.
///
/// @internal
/// @ingroup QParser
///
class CQueryTreeCleanPoolFunc
{
public:
	typedef CResourcePool<CQueryParseTree::TNode, CFastMutex> TNodePool;
	
public: 
    CQueryTreeCleanPoolFunc(TNodePool& mem_pool)
    : m_Pool(mem_pool)
    {}
  
    ETreeTraverseCode 
    operator()(CQueryParseTree::TNode& tr, int delta)
    {
        if (delta == 0 || delta == 1) {
            m_Pool.Forget(&tr);
        }
        return eTreeTraverse;
    }
private:
    TNodePool&  m_Pool;
};

/// Class passed to Lex/Bison (yylex/yyparse) functions.
/// Works as a glue to pass all the information 
/// (both parsed stream and output syntactic tree)
///
/// @internal
/// @ingroup QParser
///
class CQueryParserEnv
{
public:
	typedef CResourcePool<CQueryParseTree::TNode, CFastMutex> TNodePool;

public:
    CQueryParserEnv(const char* query_str)
    : m_Query(query_str),
      m_Ptr(query_str),
      m_QueryClause(0),
	  m_Verbose(false)
    {
		m_QueryLen = ::strlen(m_Query);
	}

    ~CQueryParserEnv()
    {
        if (m_QueryClause) {
            // Sync the memory pool not to delete the in-tree nodes
            CQueryTreeCleanPoolFunc func(m_NodePool);
            TreeDepthFirstTraverse(*m_QueryClause, func);

            delete m_QueryClause;
        }
    }

    const char*  GetQueryBuffer() const { return m_Query; }
    const char*  GetBufPtr() const { return m_Ptr; }
	const char*  GetBufEnd() const { return m_Query + m_QueryLen; }
    void SetBufPtr(const char* ptr) { m_Ptr = ptr; }

    int GetChar()
    {
        int r = *m_Ptr++;
        return r;
    }

    /// Skip number of characters
    void Skip(int num)
    {
        m_Ptr += num;
    }

    void UnGetChar() { --m_Ptr; }

    void AttachQueryClause(CQueryParseTree::TNode* qc)
    {
        m_QueryClause = qc;
    }

    CQueryParseTree::TNode* GetQueryClause() { return m_QueryClause; }

    /// Return query clause.
    ///
    /// Caller is responsible for deleteion
	///
    CQueryParseTree::TNode* DetachQueryClause() 
    { 
        if (m_QueryClause) {
            // Sync the memory pool
            CQueryTreeCleanPoolFunc func(m_NodePool);
            TreeDepthFirstTraverse(*m_QueryClause, func);

            CQueryParseTree::TNode* qc = m_QueryClause;
            m_QueryClause = 0;

            return qc; 
        }
        return 0;
    }

    void AddNodeToPool(CQueryParseTree::TNode* qnode)
    {
        m_NodePool.Put(qnode);
    }

    TNodePool& GetPool()
    {
        return m_NodePool;
    }
	
	bool IsVerbose() const { return m_Verbose; }
	void SetVerbose(bool verbose=true) { m_Verbose = verbose; }

private:
    const char*    m_Query;   ///< Request buffer. (Source for the scanner)
	unsigned       m_QueryLen;///< Query length
    const char*    m_Ptr;     ///< Current position in the request buffer

    /// Query clause tree. This is the result of the statement parsing.
	CQueryParseTree::TNode*                 m_QueryClause;
    /// Memory pool of query clause tree nodes. 
    /// Used to avoid memory leaks when BISON shifts stack and calls
    /// yyerror (or othewise throws a C++ exception)
    TNodePool m_NodePool;
	/// Debug trace when parsing
	bool      m_Verbose;
};




END_NCBI_SCOPE

#include "query_parser_bison.tab.c"
#include "lexer.inc"

/// Called by yyparse on error 
static
int yyerror (const char *s) 
{
//    BDB_THROW(eQuerySyntaxError, s);
    return 1;
}


BEGIN_NCBI_SCOPE

#if 0
void BDB_ParseQuery(const char* query_str, CBDB_Query* query)
{
    CBDB_QueryParserEnvironment env(query_str);
    /*int res = */ yyparse((void*) &env);
    CBDB_Query::TQueryClause* qc = env.GetQueryClause();

    if (qc) {
        qc = env.DetachQueryClause();
        query->SetQueryClause(qc);
    } else {

        // Check if we have only one token node created by the tokenizer
        // means it's just a single word request (legal)

        CResourcePool<CBDB_Query::TQueryClause>& pool = env.GetPool();
        CResourcePool<CBDB_Query::TQueryClause>::TPoolList& vec = 
                                                        pool.GetFreeList();

        // the only node in pool
        if (vec.size() == 1) {
            CBDB_Query::TQueryClause* qcl = vec[0];
            query->SetQueryClause(qcl);
            pool.ForgetAll();
        }
    }
}
#endif

END_NCBI_SCOPE

/*
 * ===========================================================================
 * $Log$
 * Revision 1.1  2007/01/10 16:14:01  kuznets
 * initial revision
 *
 *
 * ==========================================================================
 */



