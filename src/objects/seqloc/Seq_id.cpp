/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqloc.asn'.
 */

// standard includes

// generated includes
#include <ncbi_pch.hpp>
#include <corelib/ncbiutil.hpp>
#include <corelib/ncbiapp.hpp>
#include <util/line_reader.hpp>
#include <util/static_map.hpp>
#include <serial/serialimpl.hpp>

#include <objects/seq/Bioseq.hpp>
#include <objects/seq/Seq_inst.hpp>

#include <objects/seqloc/Seq_id.hpp>
#include <objects/seqloc/Textseq_id.hpp>
#include <objects/seqloc/Giimport_id.hpp>
#include <objects/seqloc/Patent_seq_id.hpp>
#include <objects/seqloc/PDB_seq_id.hpp>

#include <objects/biblio/Id_pat.hpp>

#include <objects/general/Object_id.hpp>
#include <objects/general/Dbtag.hpp>
#include <objects/general/Date.hpp>
#include <objects/general/Date_std.hpp>

// generated classes

BEGIN_NCBI_SCOPE
BEGIN_objects_SCOPE // namespace ncbi::objects::


// constructor
CSeq_id::CSeq_id(void)
{
    return;
}

// destructor
CSeq_id::~CSeq_id(void)
{
    return;
}


static void s_SplitVersion(const string& acc_in, string& acc, int& ver)
{
    string verstr;
    NStr::SplitInTwo(acc_in, ".", acc, verstr);
    if (verstr.empty()) {
        ver = 0;
    } else {
        ver = NStr::StringToNumeric(verstr);
        if (ver <= 0) {
            NCBI_THROW(CSeqIdException, eFormat,
                       "Version embedded in accession " + acc_in
                       + " is not a positive integer");
        }
    }
}


const CTextseq_id* CSeq_id::GetTextseq_Id(void) const
{
    switch ( Which() ) {
    case e_Genbank:
        return &GetGenbank();
    case e_Embl:
        return &GetEmbl();
    case e_Ddbj:
        return &GetDdbj();
    case e_Pir:
        return &GetPir();
    case e_Swissprot:
        return &GetSwissprot();
    case e_Other:
        return &GetOther();
    case e_Prf:
        return &GetPrf();
    case e_Tpg:
        return &GetTpg();
    case e_Tpe:
        return &GetTpe();
    case e_Tpd:
        return &GetTpd();
    case e_Gpipe:
        return &GetGpipe();
    default:
        return 0;
    }
}


inline
void x_Assign(CObject_id& dst, const CObject_id& src)
{
    switch ( src.Which() ) {
    case CObject_id::e_not_set:
        dst.Reset();
        return;
    case CObject_id::e_Id:
        dst.SetId(src.GetId());
        return;
    case CObject_id::e_Str:
        dst.SetStr(src.GetStr());
        return;
    default:
        NCBI_THROW(CSeqIdException, eFormat, "invalid Object-id variant");
    }
}


inline
void x_Assign(CGiimport_id& dst, const CGiimport_id& src)
{
    dst.SetId(src.GetId());
    if ( src.IsSetDb() ) {
        dst.SetDb(src.GetDb());
    }
    else {
        dst.ResetDb();
    }
    if ( src.IsSetRelease() ) {
        dst.SetRelease(src.GetRelease());
    }
    else {
        dst.ResetRelease();
    }
}


inline
void x_Assign(CTextseq_id& dst, const CTextseq_id& src)
{
    if ( src.IsSetName() ) {
        dst.SetName(src.GetName());
    }
    else {
        dst.ResetName();
    }
    if ( src.IsSetAccession() ) {
        dst.SetAccession(src.GetAccession());
    }
    else {
        dst.ResetAccession();
    }
    if ( src.IsSetRelease() ) {
        dst.SetRelease(src.GetRelease());
    }
    else {
        dst.ResetRelease();
    }
    if ( src.IsSetVersion() ) {
        dst.SetVersion(src.GetVersion());
    }
    else {
        dst.ResetVersion();
    }
}


inline
void x_Assign(CDbtag& dst, const CDbtag& src)
{
    dst.SetDb(src.GetDb());
    x_Assign(dst.SetTag(), src.GetTag());
}


inline
void x_Assign(CPatent_seq_id& dst, const CPatent_seq_id& src)
{
    dst.SetSeqid(src.GetSeqid());
    dst.SetCit().Assign(src.GetCit());
}


inline
void x_Assign(CDate& dst, const CDate& src)
{
    dst.Assign(src);
}


inline
void x_Assign(CPDB_seq_id& dst, const CPDB_seq_id& src)
{
    dst.SetMol().Set(src.GetMol());
    if ( src.IsSetChain() ) {
        dst.SetChain(src.GetChain());
    }
    else {
        dst.ResetChain();
    }
    if ( src.IsSetRel() ) {
        dst.SetRel().Assign(src.GetRel());
    }
    else {
        dst.ResetRel();
    }
}


void CSeq_id::Assign(const CSerialObject& obj, ESerialRecursionMode how)
{
    if ( GetTypeInfo() == obj.GetThisTypeInfo() ) {
        const CSeq_id& id = static_cast<const CSeq_id&>(obj);
        switch ( id.Which() ) {
        case e_not_set:
            Reset();
            return;
        case e_Local:
            x_Assign(SetLocal(), id.GetLocal());
            return;
        case e_Gibbsq:
            SetGibbsq(id.GetGibbsq());
            return;
        case e_Gibbmt:
            SetGibbmt(id.GetGibbmt());
            return;
        case e_Giim:
            x_Assign(SetGiim(), id.GetGiim());
            return;
        case e_Pir:
            x_Assign(SetPir(), id.GetPir());
            return;
        case e_Swissprot:
            x_Assign(SetSwissprot(), id.GetSwissprot());
            return;
        case e_Patent:
            x_Assign(SetPatent(), id.GetPatent());
            return;
        case e_Other:
            x_Assign(SetOther(), id.GetOther());
            return;
        case e_General:
            x_Assign(SetGeneral(), id.GetGeneral());
            return;
        case e_Gi:
            SetGi(id.GetGi());
            return;
        case e_Prf:
            x_Assign(SetPrf(), id.GetPrf());
            return;
        case e_Pdb:
            x_Assign(SetPdb(), id.GetPdb());
            return;
        case e_Genbank:
            x_Assign(SetGenbank(), id.GetGenbank());
            return;
        case e_Embl:
            x_Assign(SetEmbl(), id.GetEmbl());
            return;
        case e_Ddbj:
            x_Assign(SetDdbj(), id.GetDdbj());
            return;
        case e_Tpg:
            x_Assign(SetTpg(), id.GetTpg());
            return;
        case e_Tpe:
            x_Assign(SetTpe(), id.GetTpe());
            return;
        case e_Tpd:
            x_Assign(SetTpd(), id.GetTpd());
            return;
        case e_Gpipe:
            x_Assign(SetGpipe(), id.GetGpipe());
            return;
        }
    }
    CSerialObject::Assign(obj, how);
}


// Compare() - are SeqIds equivalent?
CSeq_id::E_SIC CSeq_id::Compare(const CSeq_id& sid2) const
{
    if ( Which() != sid2.Which() ) { // Only one case where this will work
        const CTextseq_id *tsip1 = GetTextseq_Id();
        if ( !tsip1 )
            return e_DIFF;

        const CTextseq_id *tsip2 = sid2.GetTextseq_Id();
        if ( !tsip2 )
            return e_DIFF;

        if ( tsip1->Match(*tsip2) ) // id Textseq_id match
            return e_YES;
        else
            return e_NO;
    }

    switch ( Which() ) { // Now we only need to know one
    case e_Local:
        return GetLocal().Match(sid2.GetLocal()) ? e_YES : e_NO;
    case e_Gibbsq:
        return GetGibbsq() == sid2.GetGibbsq() ? e_YES : e_NO;
    case e_Gibbmt:
        return GetGibbmt() == sid2.GetGibbmt() ? e_YES : e_NO;
    case e_Giim:
        return GetGiim().GetId() == sid2.GetGiim().GetId() ? e_YES : e_NO;
    case e_Pir:
        return GetPir().Match(sid2.GetPir()) ? e_YES : e_NO;
    case e_Swissprot:
        return GetSwissprot().Match(sid2.GetSwissprot()) ? e_YES : e_NO;
    case e_Patent:
        return GetPatent().Match(sid2.GetPatent()) ? e_YES : e_NO;
    case e_Other:
        return GetOther().Match(sid2.GetOther()) ? e_YES : e_NO;
    case e_General:
        return GetGeneral().Match(sid2.GetGeneral()) ? e_YES : e_NO;
    case e_Gi:
        return GetGi() == sid2.GetGi() ? e_YES : e_NO;
    case e_Prf:
        return GetPrf().Match(sid2.GetPrf()) ? e_YES : e_NO;
    case e_Pdb:
        return GetPdb().Match(sid2.GetPdb()) ? e_YES : e_NO;
    case e_Genbank:
        return GetGenbank().Match(sid2.GetGenbank()) ? e_YES : e_NO;
    case e_Embl:
        return GetEmbl().Match(sid2.GetEmbl()) ? e_YES : e_NO;
    case e_Ddbj:
        return GetDdbj().Match(sid2.GetDdbj()) ? e_YES : e_NO;
    case e_Tpg:
        return GetTpg().Match(sid2.GetTpg()) ? e_YES : e_NO;
    case e_Tpe:
        return GetTpe().Match(sid2.GetTpe()) ? e_YES : e_NO;
    case e_Tpd:
        return GetTpd().Match(sid2.GetTpd()) ? e_YES : e_NO;
    case e_Gpipe:
        return GetGpipe().Match(sid2.GetGpipe()) ? e_YES : e_NO;
    default:
        return e_error;
    }
}


int CSeq_id::CompareOrdered(const CSeq_id& sid2) const
{
    int ret = Which() - sid2.Which();
    if ( ret != 0 ) {
        return ret;
    }
    const CTextseq_id *tsip1 = GetTextseq_Id();
    const CTextseq_id *tsip2 = sid2.GetTextseq_Id();
    if ( tsip1 && tsip2 ) {
        return tsip1->Compare(*tsip2);
    }
    switch ( Which() ) { // Now we only need to know one
    case e_Local:
        return GetLocal().Compare(sid2.GetLocal());
    case e_Gibbsq:
        return GetGibbsq() - sid2.GetGibbsq();
    case e_Gibbmt:
        return GetGibbmt() - sid2.GetGibbmt();
    case e_Giim:
        return GetGiim().GetId() - sid2.GetGiim().GetId();
    case e_Patent:
        return GetPatent().Compare(sid2.GetPatent());
    case e_General:
        return GetGeneral().Compare(sid2.GetGeneral());
    case e_Gi:
        return GetGi() - sid2.GetGi();
    case e_Pdb:
        return 0;
    default:
        return this == &sid2? 0: this < &sid2? -1: 1;
    }
}

typedef pair<const char*, CSeq_id::E_Choice> TChoiceMapEntry;
// used for binary searching; must be in order.
static const TChoiceMapEntry sc_ChoiceArray[] = {
    TChoiceMapEntry("???",          CSeq_id::e_not_set),
    TChoiceMapEntry("bbm",          CSeq_id::e_Gibbmt),
    TChoiceMapEntry("bbs",          CSeq_id::e_Gibbsq),
    TChoiceMapEntry("dbj",          CSeq_id::e_Ddbj),
    TChoiceMapEntry("ddbj",         CSeq_id::e_Ddbj),
    TChoiceMapEntry("emb",          CSeq_id::e_Embl),
    TChoiceMapEntry("embl",         CSeq_id::e_Embl),
    TChoiceMapEntry("gb",           CSeq_id::e_Genbank),
    TChoiceMapEntry("genbank",      CSeq_id::e_Genbank),
    TChoiceMapEntry("general",      CSeq_id::e_General),
    TChoiceMapEntry("gi",           CSeq_id::e_Gi),
    TChoiceMapEntry("gibbmt",       CSeq_id::e_Gibbmt),
    TChoiceMapEntry("gibbsq",       CSeq_id::e_Gibbsq),
    TChoiceMapEntry("giim",         CSeq_id::e_Giim),
    TChoiceMapEntry("gim",          CSeq_id::e_Giim),
    TChoiceMapEntry("gnl",          CSeq_id::e_General),
    TChoiceMapEntry("gpipe",        CSeq_id::e_Gpipe),
    TChoiceMapEntry("gpp",          CSeq_id::e_Gpipe),
    TChoiceMapEntry("lcl",          CSeq_id::e_Local),
    TChoiceMapEntry("local",        CSeq_id::e_Local),
    TChoiceMapEntry("not_set",      CSeq_id::e_not_set),
    TChoiceMapEntry("oth",          CSeq_id::e_Other), // deprecated vs. ref
    TChoiceMapEntry("other",        CSeq_id::e_Other),
    TChoiceMapEntry("pat",          CSeq_id::e_Patent),
    TChoiceMapEntry("patent",       CSeq_id::e_Patent),
    TChoiceMapEntry("pdb",          CSeq_id::e_Pdb),
    TChoiceMapEntry("pgp",          CSeq_id::e_Patent),
    TChoiceMapEntry("pir",          CSeq_id::e_Pir),
    TChoiceMapEntry("prf",          CSeq_id::e_Prf),
    TChoiceMapEntry("ref",          CSeq_id::e_Other),
    TChoiceMapEntry("sp",           CSeq_id::e_Swissprot),
    TChoiceMapEntry("swissprot",    CSeq_id::e_Swissprot),
    TChoiceMapEntry("tpd",          CSeq_id::e_Tpd),
    TChoiceMapEntry("tpe",          CSeq_id::e_Tpe),
    TChoiceMapEntry("tpg",          CSeq_id::e_Tpg)
};
typedef CStaticArrayMap<const char*, CSeq_id::E_Choice, PNocase_CStr> TChoiceMap;
static const TChoiceMap sc_ChoiceMap(sc_ChoiceArray, sizeof(sc_ChoiceArray));


static const char* const s_TextId[CSeq_id::e_MaxChoice+1] =
{   // FASTA_LONG formats
    "???" , // not-set = ???
    "lcl",  // local = lcl|integer or string
    "bbs",  // gibbsq = bbs|integer
    "bbm",  // gibbmt = bbm|integer
    "gim",  // giim = gim|integer
    "gb",   // genbank = gb|accession|locus
    "emb",  // embl = emb|accession|locus
    "pir",  // pir = pir|accession|name
    "sp",   // swissprot = sp|accession|name
    "pat",  // patent = pat|country|patent number (string)|seq number (integer)
            //     *OR* pgp|country|application number|seq number
    "ref",  // other = ref|accession|name|release - changed from oth to ref
    "gnl",  // general = gnl|database(string)|id (string or number)
    "gi",   // gi = gi|integer
    "dbj",  // ddbj = dbj|accession|locus
    "prf",  // prf = prf|accession|name
    "pdb",  // pdb = pdb|entry name (string)|chain id (char)
    "tpg",  // tpg = tpg|accession|name
    "tpe",  // tpe = tpe|accession|name
    "tpd",  // tpd = tpd|accession|name
    "gpp"   // gpipe = gpp|accession|name
    ""  // Placeholder for end of list
};

CSeq_id::E_Choice CSeq_id::WhichInverseSeqId(const char* SeqIdCode)
{
    TChoiceMap::const_iterator it = sc_ChoiceMap.find(SeqIdCode);
    if (it == sc_ChoiceMap.end()) {
        return e_not_set;
    } else {
        return it->second;
    }
}


typedef pair<const char*, CSeq_id::EAccessionInfo> TAccInfoMapEntry;
// used for binary searching; must be in order.
static const TAccInfoMapEntry sc_AccInfoArray[] = {
    TAccInfoMapEntry("ambiguous_nuc",           CSeq_id::eAcc_ambiguous_nuc),
    TAccInfoMapEntry("ddbj_con",                CSeq_id::eAcc_ddbj_con),
    TAccInfoMapEntry("ddbj_dirsub",             CSeq_id::eAcc_ddbj_dirsub),
    TAccInfoMapEntry("ddbj_est",                CSeq_id::eAcc_ddbj_est),
    TAccInfoMapEntry("ddbj_genome",             CSeq_id::eAcc_ddbj_genome),
    TAccInfoMapEntry("ddbj_gss",                CSeq_id::eAcc_ddbj_gss),
    TAccInfoMapEntry("ddbj_htgs",               CSeq_id::eAcc_ddbj_htgs),
    TAccInfoMapEntry("ddbj_other_nuc",          CSeq_id::eAcc_ddbj_other_nuc),
    TAccInfoMapEntry("ddbj_patent",             CSeq_id::eAcc_ddbj_patent),
    TAccInfoMapEntry("ddbj_prot",               CSeq_id::eAcc_ddbj_prot),
    TAccInfoMapEntry("ddbj_tpa_nuc",            CSeq_id::eAcc_ddbj_tpa_nuc),
    TAccInfoMapEntry("ddbj_tpa_prot",           CSeq_id::eAcc_ddbj_tpa_prot),
    TAccInfoMapEntry("ddbj_wgs_nuc",            CSeq_id::eAcc_ddbj_wgs_nuc),
    TAccInfoMapEntry("ddbj_wgs_prot",           CSeq_id::eAcc_ddbj_wgs_prot),
    TAccInfoMapEntry("embl_con",                CSeq_id::eAcc_embl_con),
    TAccInfoMapEntry("embl_ddbj",               CSeq_id::eAcc_embl_ddbj),
    TAccInfoMapEntry("embl_dirsub",             CSeq_id::eAcc_embl_dirsub),
    TAccInfoMapEntry("embl_est",                CSeq_id::eAcc_embl_est),
    TAccInfoMapEntry("embl_genome",             CSeq_id::eAcc_embl_genome),
    TAccInfoMapEntry("embl_htgs",               CSeq_id::eAcc_embl_htgs),
    TAccInfoMapEntry("embl_other_nuc",          CSeq_id::eAcc_embl_other_nuc),
    TAccInfoMapEntry("embl_patent",             CSeq_id::eAcc_embl_patent),
    TAccInfoMapEntry("embl_prot",               CSeq_id::eAcc_embl_prot),
    TAccInfoMapEntry("embl_tpa_nuc",            CSeq_id::eAcc_embl_tpa_nuc),
    TAccInfoMapEntry("embl_tpa_prot",           CSeq_id::eAcc_embl_tpa_prot),
    TAccInfoMapEntry("embl_wgs_nuc",            CSeq_id::eAcc_embl_wgs_nuc),
    TAccInfoMapEntry("embl_wgs_prot",           CSeq_id::eAcc_embl_wgs_prot),
    TAccInfoMapEntry("gb_backbone",             CSeq_id::eAcc_gb_backbone),
    TAccInfoMapEntry("gb_cdna",                 CSeq_id::eAcc_gb_cdna),
    TAccInfoMapEntry("gb_con",                  CSeq_id::eAcc_gb_con),
    TAccInfoMapEntry("gb_ddbj",                 CSeq_id::eAcc_gb_ddbj),
    TAccInfoMapEntry("gb_dirsub",               CSeq_id::eAcc_gb_dirsub),
    TAccInfoMapEntry("gb_embl",                 CSeq_id::eAcc_gb_embl),
    TAccInfoMapEntry("gb_embl_ddbj",            CSeq_id::eAcc_gb_embl_ddbj),
    TAccInfoMapEntry("gb_est",                  CSeq_id::eAcc_gb_est),
    TAccInfoMapEntry("gb_genome",               CSeq_id::eAcc_gb_genome),
    TAccInfoMapEntry("gb_gsdb",                 CSeq_id::eAcc_gb_gsdb),
    TAccInfoMapEntry("gb_gss",                  CSeq_id::eAcc_gb_gss),
    TAccInfoMapEntry("gb_htgs",                 CSeq_id::eAcc_gb_htgs),
    TAccInfoMapEntry("gb_other_nuc",            CSeq_id::eAcc_gb_other_nuc),
    TAccInfoMapEntry("gb_patent",               CSeq_id::eAcc_gb_patent),
    TAccInfoMapEntry("gb_patent_prot",          CSeq_id::eAcc_gb_patent_prot),
    TAccInfoMapEntry("gb_prot",                 CSeq_id::eAcc_gb_prot),
    TAccInfoMapEntry("gb_segset",               CSeq_id::eAcc_gb_segset),
    TAccInfoMapEntry("gb_sts",                  CSeq_id::eAcc_gb_sts),
    TAccInfoMapEntry("gb_tpa_nuc",              CSeq_id::eAcc_gb_tpa_nuc),
    TAccInfoMapEntry("gb_tpa_prot",             CSeq_id::eAcc_gb_tpa_prot),
    TAccInfoMapEntry("gb_wgs_nuc",              CSeq_id::eAcc_gb_wgs_nuc),
    TAccInfoMapEntry("gb_wgs_prot",             CSeq_id::eAcc_gb_wgs_prot),
    TAccInfoMapEntry("general",                 CSeq_id::eAcc_general),
    TAccInfoMapEntry("gi",                      CSeq_id::eAcc_gi),
    TAccInfoMapEntry("gibbmt",                  CSeq_id::eAcc_gibbmt),
    TAccInfoMapEntry("gibbsq",                  CSeq_id::eAcc_gibbsq),
    TAccInfoMapEntry("giim",                    CSeq_id::eAcc_giim),
    TAccInfoMapEntry("gpipe_chromosome",        CSeq_id::eAcc_gpipe_chromosome),
    TAccInfoMapEntry("gpipe_genomic",           CSeq_id::eAcc_gpipe_genomic),
    TAccInfoMapEntry("gpipe_mrna",              CSeq_id::eAcc_gpipe_mrna),
    TAccInfoMapEntry("gpipe_ncrna",             CSeq_id::eAcc_gpipe_ncrna),
    TAccInfoMapEntry("gpipe_other_nuc",         CSeq_id::eAcc_gpipe_other_nuc),
    TAccInfoMapEntry("gpipe_prot",              CSeq_id::eAcc_gpipe_prot),
    TAccInfoMapEntry("gpipe_scaffold",          CSeq_id::eAcc_gpipe_scaffold),
    TAccInfoMapEntry("gpipe_unreserved",        CSeq_id::eAcc_gpipe_unreserved),
    TAccInfoMapEntry("gsdb_dirsub",             CSeq_id::eAcc_gsdb_dirsub),
    TAccInfoMapEntry("local",                   CSeq_id::eAcc_local),
    TAccInfoMapEntry("maybe_ddbj",              CSeq_id::eAcc_maybe_ddbj),
    TAccInfoMapEntry("maybe_embl",              CSeq_id::eAcc_maybe_embl),
    TAccInfoMapEntry("maybe_gb",                CSeq_id::eAcc_maybe_gb),
    TAccInfoMapEntry("patent",                  CSeq_id::eAcc_patent),
    TAccInfoMapEntry("pdb",                     CSeq_id::eAcc_pdb),
    TAccInfoMapEntry("pir",                     CSeq_id::eAcc_pir),
    TAccInfoMapEntry("prf",                     CSeq_id::eAcc_prf),
    TAccInfoMapEntry("refseq_chromosome",       CSeq_id::eAcc_refseq_chromosome),
    TAccInfoMapEntry("refseq_contig",           CSeq_id::eAcc_refseq_contig),
    TAccInfoMapEntry("refseq_genome",           CSeq_id::eAcc_refseq_genome),
    TAccInfoMapEntry("refseq_genomic",          CSeq_id::eAcc_refseq_genomic),
    TAccInfoMapEntry("refseq_mrna",             CSeq_id::eAcc_refseq_mrna),
    TAccInfoMapEntry("refseq_mrna_predicted",   CSeq_id::eAcc_refseq_mrna_predicted),
    TAccInfoMapEntry("refseq_ncrna",            CSeq_id::eAcc_refseq_ncrna),
    TAccInfoMapEntry("refseq_ncrna_predicted",  CSeq_id::eAcc_refseq_ncrna_predicted),
    TAccInfoMapEntry("refseq_prot",             CSeq_id::eAcc_refseq_prot),
    TAccInfoMapEntry("refseq_prot_predicted",   CSeq_id::eAcc_refseq_prot_predicted),
    TAccInfoMapEntry("refseq_unreserved",       CSeq_id::eAcc_refseq_unreserved),
    TAccInfoMapEntry("refseq_wgs_intermed",     CSeq_id::eAcc_refseq_wgs_intermed),
    TAccInfoMapEntry("refseq_wgs_nuc",          CSeq_id::eAcc_refseq_wgs_nuc),
    TAccInfoMapEntry("refseq_wgs_prot",         CSeq_id::eAcc_refseq_wgs_prot),
    TAccInfoMapEntry("swissprot",               CSeq_id::eAcc_swissprot),
    TAccInfoMapEntry("unknown",                 CSeq_id::eAcc_unknown),
    TAccInfoMapEntry("unreserved_nuc",          CSeq_id::eAcc_unreserved_nuc),
    TAccInfoMapEntry("unreserved_prot",         CSeq_id::eAcc_unreserved_prot)
};
typedef CStaticArrayMap<const char*, CSeq_id::EAccessionInfo, PNocase_CStr> TAccInfoMap;
static const TAccInfoMap sc_AccInfoMap(sc_AccInfoArray, sizeof(sc_AccInfoArray));

static const char kDigits[] = "0123456789";

struct SAccGuide
{
    typedef CSeq_id::EAccessionInfo TAccInfo;
    typedef map<string, TAccInfo>   TPrefixes;
    typedef pair<string, TAccInfo>  TPair;
    typedef vector<TPair>           TPairs;
    typedef map<string, TPair>      TSpecialMap; // last -> first -> value
    typedef unsigned int            TFormatCode;

    struct SSubMap {
        TPrefixes    prefixes;
        TPairs       wildcards;
        TSpecialMap  specials;
    };
    typedef map<TFormatCode, SSubMap> TMainMap;

    SAccGuide(void) : count(0) { }
    void AddRule(const CTempString& rule);
    static TFormatCode s_Key(unsigned short letters, unsigned short digits)
        { return TFormatCode(letters) << 16 | digits; }
    
    unsigned int count;
    TMainMap     rules;
};

void SAccGuide::AddRule(const CTempString& rule)
{
    string         tmp1, tmp2;
    vector<string> tokens;
    SIZE_TYPE      pos, pos2;

    ++count;
    rule.Copy(tmp1, 0, rule.find("#")); // strip comment
    NStr::Tokenize(tmp1, " \t", tokens, NStr::eMergeDelims);
    if (tokens.empty()) {
        return;
    } else if (tokens.size() == 2
               &&  NStr::EqualNocase(tokens[0], "version")) {
        unsigned int version = NStr::StringToUInt(tokens[1],
                                                  NStr::fConvErr_NoThrow);
        if (version != 1) {
            ERR_POST("SAccGuide::AddRule: " << count
                     << ": Unsupported version " << tokens[1]);
            return;
        }
    } else if ((pos = tokens[0].find('+')) != NPOS
               &&  (tokens.size() == 3
                    ||  (tokens.size() == 4  &&  tokens[3] == "*"))) {
        // _VERIFY(NStr::SplitInTwo(tokens[0], "+", tmp1, tmp2));
        tmp1.assign(tokens[0], 0, pos);
        tmp2.assign(tokens[0], pos + 1, NPOS);
        TFormatCode fmt
            = s_Key(NStr::StringToUInt(tmp1, NStr::fConvErr_NoThrow),
                    NStr::StringToUInt(tmp2, NStr::fConvErr_NoThrow));
        TAccInfoMap::const_iterator it = sc_AccInfoMap.find(tokens[2].c_str());
        if (it == sc_AccInfoMap.end()) {
            ERR_POST("SAccGuide::AddRule: " << count
                     << ": unrecognized accession type " << tokens[2]);
        } else {
            TAccInfo value = it->second;
            if (tokens.size() == 4) {
                value = TAccInfo(value | CSeq_id::fAcc_specials);
            }
            if (tokens[1].find_first_of("?*") == NPOS) {
                rules[fmt].prefixes[tokens[1]] = value;
            } else {
                rules[fmt].wildcards.push_back(TPair(tokens[1], value));
            }
        }
    } else if (tokens.size() == 3 && NStr::EqualNocase(tokens[0], "special")) {
        TAccInfoMap::const_iterator it = sc_AccInfoMap.find(tokens[2].c_str());
        if (it == sc_AccInfoMap.end()) {
            ERR_POST("SAccGuide::AddRule: " << count
                     << ": unrecognized accession type " << tokens[2]);
        } else {
            TAccInfo value = it->second;
            pos  = tokens[1].find_first_of(kDigits);
            pos2 = tokens[1].find('-', pos);
            if (pos2 == NPOS) {
                TFormatCode fmt = s_Key(pos, tokens[1].size() - pos);
                rules[fmt].specials[tokens[1]] = TPair(tokens[1], value);
            } else {
                TFormatCode fmt = s_Key(pos, pos2 - pos);
                // _VERIFY(NStr::SplitInTwo(tokens[1], "-", tmp1, tmp2));
                tmp1.assign(tokens[1], 0, pos2);
                tmp2.assign(tokens[1], pos2 + 1, NPOS);
                rules[fmt].specials[tmp2] = TPair(tmp1, value);
            }
        }
    } else {
        ERR_POST(Warning << "SAccGuide::AddRule: " << count
                 << ": ignoring invalid line: " << rule);
    }
}


SAccGuide s_Guide;

static const char * kBuiltInGuide[] = {
    "# 8-character protein accessions",
    "3+5  AAE  gb_patent_prot",
    "3+5  A??  gb_prot",
    "3+5  B??  ddbj_prot",
    "3+5  C??  embl_prot *",
    "3+5  D??  gb_tpa_prot",
    "3+5  E??  gb_wgs_prot",
    "3+5  F??  ddbj_tpa_prot",
    "3+5  G??  ddbj_wgs_prot",
    "3+5  ???  unreserved_prot",
    "",
    "# whole genome shotgun accessions",
    "4+8   A???  gb_wgs_nuc",
    "4+9   A???  gb_wgs_nuc",
    "4+10  A???  gb_wgs_nuc",
    "4+8   B???  ddbj_wgs_nuc",
    "4+9   B???  ddbj_wgs_nuc",
    "4+10  B???  ddbj_wgs_nuc",
    "4+8   C???  embl_wgs_nuc",
    "4+9   C???  embl_wgs_nuc",
    "4+10  C???  embl_wgs_nuc",
    "",
    "# NCBI reference sequence accessions",
    "3+6  AC_      refseq_chromosome",
    "3+6  AP_      refseq_prot",
    "3+6  NC_      refseq_chromosome",
    "3+6  NG_      refseq_genomic",
    "3+6  NM_      refseq_mrna",
    "3+9  NM_      refseq_mrna",
    "3+6  NP_      refseq_prot",
    "3+9  NP_      refseq_prot",
    "3+6  NR_      refseq_ncrna",
    "3+6  NS_      refseq_genome",
    "3+6  NT_      refseq_contig",
    "3+6  NW_      refseq_wgs_intermed",
    "7+8  NZ_????  refseq_wgs_nuc",
    "3+6  XM_      refseq_mrna_predicted",
    "3+6  XP_      refseq_prot_predicted",
    "3+6  XR_      refseq_ncrna_predicted",
    "3+6  YP_      refseq_prot_predicted",
    "3+8  ZP_      refseq_wgs_prot",
    "3+6  ??_      refseq_unreserved",
    "3+7  ??_      refseq_unreserved",
    "3+8  ??_      refseq_unreserved",
    "3+9  ??_      refseq_unreserved",
    "",
    "# Genome pipeline accessions (number of digits not yet fixed)",
    "4+6  GPC_  gpipe_chromosome",
    "4+6  GPG_  gpipe_genomic",
    "4+6  GPM_  gpipe_mrna",
    "4+6  GPN_  gpipe_other_nuc",
    "4+6  GPP_  gpipe_prot",
    "4+6  GPR_  gpipe_ncrna",
    "4+6  GPS_  gpipe_scaffold",
    "4+7  GPC_  gpipe_chromosome",
    "4+7  GPG_  gpipe_genomic",
    "4+7  GPM_  gpipe_mrna",
    "4+7  GPN_  gpipe_other_nuc",
    "4+7  GPP_  gpipe_prot",
    "4+7  GPR_  gpipe_ncrna",
    "4+7  GPS_  gpipe_scaffold",
    "4+8  GPC_  gpipe_chromosome",
    "4+8  GPG_  gpipe_genomic",
    "4+8  GPM_  gpipe_mrna",
    "4+8  GPN_  gpipe_other_nuc",
    "4+8  GPP_  gpipe_prot",
    "4+8  GPR_  gpipe_ncrna",
    "4+8  GPS_  gpipe_scaffold",
    "4+9  GPC_  gpipe_chromosome",
    "4+9  GPG_  gpipe_genomic",
    "4+9  GPM_  gpipe_mrna",
    "4+9  GPN_  gpipe_other_nuc",
    "4+9  GPP_  gpipe_prot",
    "4+9  GPR_  gpipe_ncrna",
    "4+9  GPS_  gpipe_scaffold",
    "4+6  GP?_  gpipe_unreserved",
    "4+7  GP?_  gpipe_unreserved",
    "4+8  GP?_  gpipe_unreserved",
    "4+9  GP?_  gpipe_unreserved",
    "",
    "# 6-character accessions (mixed, but generally nucleotide)",
    "1+5  A  embl_patent",
    "1+5  B  gb_gss",
    "1+5  C  ddbj_est",
    "1+5  D  ddbj_dirsub",
    "1+5  E  ddbj_patent",
    "1+5  F  embl_est",
    "1+5  G  gb_sts",
    "1+5  H  gb_est",
    "1+5  I  gb_patent",
    "1+5  J  gsdb_dirsub",
    "1+5  K  gsdb_dirsub",
    "1+5  L  gsdb_dirsub",
    "1+5  M  gsdb_dirsub",
    "1+5  N  unreserved_nuc *",
    "1+5  O  swissprot",
    "1+5  P  swissprot",
    "1+5  Q  swissprot",
    "1+5  R  gb_est",
    "1+5  S  gb_backbone",
    "1+5  T  gb_est",
    "1+5  U  gb_dirsub",
    "1+5  V  embl_dirsub",
    "1+5  W  gb_est",
    "1+5  X  embl_dirsub",
    "1+5  Y  embl_dirsub",
    "1+5  Z  embl_dirsub",
    "1+5  ?  unreserved_nuc",
    "",
    "# 8-character nucleotide accessions",
    "2+6  AA  gb_est",
    "2+6  AB  ddbj_dirsub",
    "2+6  AC  gb_htgs",
    "2+6  AD  gb_gsdb",
    "2+6  AE  gb_genome",
    "2+6  AF  gb_dirsub",
    "2+6  AG  ddbj_genome",
    "2+6  AH  gb_con",
    "2+6  AI  gb_est",
    "2+6  AJ  embl_dirsub",
    "2+6  AK  ddbj_htgs",
    "2+6  AL  embl_genome",
    "2+6  AM  embl_dirsub",
    "2+6  AN  embl_con",
    "2+6  AO  unreserved_nuc",
    "2+6  AP  ddbj_genome",
    "2+6  AQ  gb_gss",
    "2+6  AR  gb_patent",
    "2+6  AS  gb_other_nuc",
    "2+6  AT  ddbj_est",
    "2+6  AU  ddbj_est",
    "2+6  AV  ddbj_est",
    "2+6  AW  gb_est",
    "2+6  AX  embl_patent",
    "2+6  AY  gb_dirsub",
    "2+6  AZ  gb_gss",
    "2+6  BA  ddbj_con",
    "2+6  BB  ddbj_est",
    "2+6  BC  gb_cdna",
    "2+6  BD  ddbj_patent",
    "2+6  BE  gb_est",
    "2+6  BF  gb_est",
    "2+6  BG  gb_est",
    "2+6  BH  gb_gss",
    "2+6  BI  gb_est",
    "2+6  BJ  ddbj_est",
    "2+6  BK  gb_tpa_nuc",
    "2+6  BL  gb_tpa_nuc",
    "2+6  BM  gb_est",
    "2+6  BN  embl_tpa_nuc",
    "2+6  BO  unreserved_nuc",
    "2+6  BP  ddbj_est",
    "2+6  BQ  gb_est",
    "2+6  BR  ddbj_tpa_nuc",
    "2+6  BS  ddbj_genome # chimp genomes, specifically",
    "2+6  BT  gb_cdna",
    "2+6  BU  gb_est",
    "2+6  BV  gb_sts",
    "2+6  BW  ddbj_est",
    "2+6  BX  embl_genome",
    "2+6  BY  ddbj_est",
    "2+6  BZ  gb_gss",
    "2+6  CA  gb_est",
    "2+6  CB  gb_est",
    "2+6  CC  gb_gss",
    "2+6  CD  gb_est",
    "2+6  CE  gb_gss",
    "2+6  CF  gb_est",
    "2+6  CG  gb_gss",
    "2+6  CH  gb_con",
    "2+6  CI  ddbj_est",
    "2+6  CJ  ddbj_est",
    "2+6  CK  gb_est",
    "2+6  CL  gb_gss",
    "2+6  CM  gb_con",
    "2+6  CN  gb_est",
    "2+6  CO  gb_est",
    "2+6  CP  gb_genome",
    "2+6  CQ  embl_patent",
    "2+6  CR  embl_genome",
    "2+6  CS  embl_patent",
    "2+6  CT  embl_genome",
    "2+6  CU  embl_genome",
    "2+6  CV  gb_est",
    "2+6  CW  gb_gss",
    "2+6  CX  gb_est",
    "2+6  CY  gb_genome",
    "2+6  CZ  gb_gss",
    "2+6  DA  ddbj_est",
    "2+6  DB  ddbj_est",
    "2+6  DC  ddbj_est",
    "2+6  DD  ddbj_patent",
    "2+6  DE  ddbj_gss",
    "2+6  DF  ddbj_con",
    "2+6  DG  ddbj_con",
    "2+6  DH  ddbj_gss",
    "2+6  DI  ddbj_other_nuc",
    "2+6  DJ  ddbj_other_nuc",
    "2+6  DK  ddbj_other_nuc",
    "2+6  DL  ddbj_other_nuc",
    "2+6  DM  ddbj_other_nuc",
    "2+6  DN  gb_est",
    "2+6  DO  unreserved_nuc",
    "2+6  DP  gb_htgs",
    "2+6  DQ  gb_dirsub",
    "2+6  DR  gb_est",
    "2+6  DS  gb_con",
    "2+6  DT  gb_est",
    "2+6  DU  gb_gss",
    "2+6  DV  gb_est",
    "2+6  DW  gb_est",
    "2+6  DX  gb_gss",
    "2+6  DY  gb_est",
    "2+6  DZ  gb_patent",
    "2+6  EA  gb_patent",
    "2+6  EB  gb_est",
    "2+6  EC  gb_est",
    "2+6  ED  gb_gss",
    "2+6  EE  gb_est",
    "2+6  EF  gb_dirsub",
    "2+6  EG  gb_est",
    "2+6  EH  gb_est",
    "2+6  EI  gb_gss",
    "2+6  EJ  gb_gss",
    "2+6  EK  gb_gss",
    "2+6  ??  unreserved_nuc",
    "",
    "# SPECIAL CASES",
    "",
    "# Early N accessions were assigned haphazardly, and sometimes ambiguously.",
    "# (These are all secondary accessions nowadays, though.)",
    "special  N00001-N00002  gb_embl",
    "special  N00003-N00004  gb_ddbj",
    "special  N00005         gb_embl_ddbj",
    "special  N00006-N00007  gb_ddbj",
    "special  N00008         gb_other_nuc",
    "special  N00009         gb_embl_ddbj",
    "special  N00010         gb_ddbj",
    "special  N00011         gb_embl",
    "special  N00012         gb_embl_ddbj",
    "special  N00013         gb_other_nuc",
    "special  N00014-N00017  gb_ddbj",
    "special  N00018-N00019  gb_other_nuc",
    "special  N00020         gb_embl_ddbj",
    "special  N00021         gb_ddbj",
    "special  N00022         gb_embl_ddbj",
    "special  N00023-N00024  gb_ddbj",
    "special  N00025         gb_embl_ddbj",
    "special  N00026         gb_ddbj",
    "special  N00027         gb_other_nuc",
    "special  N00028         ddbj_other_nuc",
    "special  N00029-N00034  gb_ddbj",
    "special  N00035         ddbj_other_nuc",
    "special  N00036         gb_ddbj",
    "special  N00037         ddbj_other_nuc",
    "special  N00038-N00040  gb_ddbj",
    "special  N00041         gb_other_nuc",
    "special  N00042-N00045  gb_ddbj",
    "special  N00046         gb_other_nuc",
    "special  N00047         gb_ddbj",
    "special  N00048         gb_other_nuc",
    "special  N00049-N00051  gb_ddbj",
    "special  N00052         gb_other_nuc",
    "special  N00053         ddbj_other_nuc",
    "special  N00054         gb_other_nuc",
    "special  N00055-N00056  gb_ddbj",
    "special  N00057         gb_embl",
    "special  N00058         gb_embl_ddbj",
    "special  N00059         gb_ddbj",
    "special  N00060         embl_other_nuc",
    "special  N00061-N00063  ddbj_other_nuc",
    "special  N00064         embl_other_nuc",
    "special  N00065-N00069  ddbj_other_nuc",
    "special  N00070         embl_ddbj",
    "special  N00078-N00079  ddbj_other_nuc",
    "special  N00083         ddbj_other_nuc",
    "special  N00088         ddbj_other_nuc",
    "special  N00090-N00094  ddbj_other_nuc",
    "special  N18624         gb_other_nuc",
    "special  N20000-N99999  gb_est",
    "",
    "# Some \"EMBL\" 8-character protein accessions are really third party",
    "# annotations.",
    "special  CAD29848-CAD29879  embl_tpa_prot # or unassigned, in some cases",
    "special  CAD43606           embl_tpa_prot",
    "special  CAD44269           embl_tpa_prot",
    "special  CAD55807           embl_tpa_prot",
    "special  CAD56854           embl_tpa_prot",
    "special  CAD59554           embl_tpa_prot",
    "special  CAD59973-CAD59975  embl_tpa_prot",
    "special  CAD62250           embl_tpa_prot",
    "special  CAD62384-CAD62385  embl_tpa_prot",
    "special  CAD65874-CAD65875  embl_tpa_prot",
    "special  CAD66056-CAD66057  embl_tpa_prot",
    "special  CAD66176           embl_tpa_prot",
    "special  CAD66451-CAD66453  embl_tpa_prot",
    "special  CAD66657           embl_tpa_prot",
    "special  CAD67552-CAD67553  embl_tpa_prot",
    "special  CAD67575-CAD67579  embl_tpa_prot",
    "special  CAD67582           embl_tpa_prot",
    "special  CAD67592-CAD67593  embl_tpa_prot",
    "special  CAD67595           embl_tpa_prot",
    "special  CAD67963-CAD67964  embl_tpa_prot",
    "special  CAD67985           embl_tpa_prot",
    "special  CAD68170-CAD68171  embl_tpa_prot",
    "special  CAD71139           embl_tpa_prot",
    "special  CAD80155-CAD80157  embl_tpa_prot",
    "special  CAD80167-CAD80169  embl_tpa_prot # '68 unassigned",
    "special  CAD80243           embl_tpa_prot",
    "special  CAD88272-CAD88273  embl_tpa_prot",
    "special  CAD89265-CAD89268  embl_tpa_prot",
    "special  CAD89361           embl_tpa_prot",
    "special  CAD89763           embl_tpa_prot",
    "special  CAD89874-CAD89875  embl_tpa_prot",
    "special  CAD91637           embl_tpa_prot",
    "special  CAD91909-CAD91911  embl_tpa_prot",
    "special  CAD92036           embl_tpa_prot",
    "special  CAD98145           embl_tpa_prot",
    "special  CAE00378-CAE00414  embl_tpa_prot",
    "special  CAE00502           embl_tpa_prot",
    "special  CAE12270-CAE12276  embl_tpa_prot",
    "special  CAE18110           embl_tpa_prot",
    "special  CAE30337           embl_tpa_prot",
    "special  CAE30362           embl_tpa_prot",
    "special  CAE30475-CAE30476  embl_tpa_prot",
    "special  CAE30490-CAE30502  embl_tpa_prot",
    "special  CAE45343           embl_tpa_prot",
    "special  CAE47417           embl_tpa_prot",
    "special  CAE48362-CAE48363  embl_tpa_prot",
    "special  CAE48373-CAE48393  embl_tpa_prot",
    "special  CAE48395-CAE48396  embl_tpa_prot",
    "special  CAE51393-CAE51417  embl_tpa_prot",
    "special  CAE51851           embl_tpa_prot",
    "special  CAE51855-CAE51856  embl_tpa_prot",
    "special  CAE51895-CAE51916  embl_tpa_prot",
    "special  CAE52317-CAE52320  embl_tpa_prot",
    "special  CAE54311-CAE54352  embl_tpa_prot",
    "special  CAE54495           embl_tpa_prot",
    "special  CAE75602-CAE75631  embl_tpa_prot",
    "special  CAE75743           embl_tpa_prot",
    "special  CAE82298-CAE82299  embl_tpa_prot",
    "special  CAF06526-CAF06530  embl_tpa_prot",
    "special  CAF18402           embl_tpa_prot",
    "special  CAF21736-CAF21739  embl_tpa_prot",
    "special  CAF32458           embl_tpa_prot",
    "special  CAG23871           embl_tpa_prot",
    "special  CAG26661-CAG26664  embl_tpa_prot",
    "special  CAG26750           embl_tpa_prot",
    "special  CAG29023-CAG29030  embl_tpa_prot",
    "special  CAG29113           embl_tpa_prot",
    "special  CAG30664           embl_tpa_prot",
    "special  CAG33760           embl_tpa_prot",
    "special  CAG34288-CAG34296  embl_tpa_prot",
    "special  CAH03726-CAH03727  embl_tpa_prot",
    "special  CAH17840-CAH17841  embl_tpa_prot",
    "special  CAH18925-CAH18926  embl_tpa_prot",
    "special  CAH56764           embl_tpa_prot",
    "special  CAH59193-CAH59194  embl_tpa_prot",
    "special  CAH69244-CAH69380  embl_tpa_prot",
    "special  CAH74220           embl_tpa_prot",
    "special  CAH74225           embl_tpa_prot",
    "special  CAH89261-CAH89263  embl_tpa_prot",
    "special  CAI56319-CAI56335  embl_tpa_prot",
    "special  CAI61342-CAI61347  embl_tpa_prot",
    "special  CAI77244-CAI77245  embl_tpa_prot",
    "special  CAI77247           embl_tpa_prot",
    "special  CAI84981-CAI85013  embl_tpa_prot",
    "special  CAI99158-CAI99163  embl_tpa_prot",
    "special  CAI99872           embl_tpa_prot",
    "special  CAJ00225-CAJ00252  embl_tpa_prot",
    "special  CAJ13823-CAJ13825  embl_tpa_prot",
    "special  CAJ29301-CAJ29302  embl_tpa_prot",
    "special  CAJ30479           embl_tpa_prot",
    "special  CAJ30481-CAJ30484  embl_tpa_prot",
    "special  CAJ31324           embl_tpa_prot",
    "special  CAJ33891           embl_tpa_prot",
    "special  CAJ43786-CAJ43809  embl_tpa_prot",
    "special  CAJ55345           embl_tpa_prot",
    "special  CAJ55730-CAJ55733  embl_tpa_prot",
    "special  CAJ55745-CAJ55747  embl_tpa_prot",
    "special  CAJ55783-CAJ55784  embl_tpa_prot",
    "special  CAJ55824-CAJ55825  embl_tpa_prot",
    "special  CAJ57445-CAJ57446  embl_tpa_prot",
    "special  CAJ70647-CAJ70649  embl_tpa_prot",
    "special  CAJ75788-CAJ75794  embl_tpa_prot # '90 unassigned",
    "special  CAJ77880-CAJ77886  embl_tpa_prot",
    "special  CAJ84770           embl_tpa_prot",
    "special  CAK26553           embl_tpa_prot",
    "special  CAK26777-CAK26786  embl_tpa_prot",
    "special  CAK32514           embl_tpa_prot",
    "special  CAL10024           embl_tpa_prot",
    "special  CAL59562-CAL59577  embl_tpa_prot",
    "special  CAL63903-CAL63904  embl_tpa_prot",
    "special  CAL64054-CAL64058  embl_tpa_prot",
    "special  CAM06633           embl_tpa_prot",
    "special  CAM12311           embl_tpa_prot",
    "# Err on the side of caution on as yet unassigned IDs, and hope that",
    "# there's not *too* much more backfilling.",
    "special  CAM28331-CZZ99999  unreserved_prot"
};
/* 
 * The preceding array initializer was generated by the script text2cstr.pl
 * with the following options:
 *   -v kBuiltInGuide
 */

static void s_LoadGuide(void)
{
    DEFINE_STATIC_FAST_MUTEX(mutex);
    CFastMutexGuard guard(mutex);
    if (s_Guide.count) {
        return;
    }
    if (CNcbiApplication* app = CNcbiApplication::Instance()) {
        string file = CDirEntry::MakePath(app->GetConfig().Get("NCBI", "Data"),
                                          "accguide.txt");
        if (CFile(file).Exists()) {
            try {
                CSeq_id::LoadAccessionGuide(file);
            } STD_CATCH_ALL("CSeq_id::LoadAccessionGuide")
        }
    }
    if ( !s_Guide.count ) {
        ERR_POST(Info << "CSeq_id::IdentifyAccession: " // minor lie
                 "falling back on built-in rules.");
        SAccGuide guide;
        static const unsigned int kNumBuiltInRules
            = sizeof(kBuiltInGuide) / sizeof(*kBuiltInGuide);
        for (unsigned int i = 0;  i < kNumBuiltInRules;  ++i) {
            guide.AddRule(kBuiltInGuide[i]);
        }
        swap(guide, s_Guide);
    }
}

CSeq_id::EAccessionInfo CSeq_id::IdentifyAccession(const string& acc)
{
    SIZE_TYPE main_size = acc.find('.');
    if (main_size == NPOS) {
        main_size = acc.size();
    } else if (main_size >= acc.size() - 1
               ||  acc.find_first_not_of(kDigits, main_size + 1) != NPOS) {
        return eAcc_unknown; // non-numeric "version"
    }
    SIZE_TYPE digit_pos = acc.find_first_of(kDigits);
    string pfx = acc.substr(0, digit_pos);
    NStr::ToUpper(pfx);
    if (digit_pos == NPOS) {
        return eAcc_unknown;
    } else {
        SIZE_TYPE non_dig_pos = acc.find_first_not_of(kDigits, digit_pos);
        if (non_dig_pos != NPOS  &&  non_dig_pos != main_size) {
            if (main_size != acc.size()) {
                return eAcc_unknown; // these should all be unversioned
            }
            if (digit_pos == 0  &&  main_size >= 4
                &&  (main_size <= 5
                     ||  (ispunct((unsigned char)acc[4])  &&  acc[4] != '.'))) {
                return eAcc_pdb;
            } else if (digit_pos == 1  &&  main_size == 6
                       &&  (pfx[0] == 'O' || pfx[0] == 'P' || pfx[0] == 'Q')
                       &&  isdigit((unsigned char)acc[1])
                       &&  isalnum((unsigned char)acc[2])
                       &&  isalnum((unsigned char)acc[3])
                       &&  isalnum((unsigned char)acc[4])
                       &&  isdigit((unsigned char)acc[5])) {
                return eAcc_swissprot;
            } else {
                return eAcc_unknown;
            }
        }
    }

    if ( !s_Guide.count ) {
        s_LoadGuide();
    }

    if (digit_pos == 0) {
        if (acc.find_first_not_of(kDigits) == NPOS) { // just digits
            return eAcc_gi;
        } else {
            return eAcc_unknown; // PDB already handled
        }
    }
    SAccGuide::TMainMap::const_iterator it
        = s_Guide.rules.find(SAccGuide::s_Key(digit_pos,
                                              main_size - digit_pos));
    if (it == s_Guide.rules.end()) {
        return eAcc_unknown;
    }
    const SAccGuide::SSubMap&            rules  = it->second;
    EAccessionInfo                       result = eAcc_unknown;
    SAccGuide::TPrefixes::const_iterator pit    = rules.prefixes.find(pfx);
    if (pit != rules.prefixes.end()) {
        result = pit->second;
    } else {
        ITERATE (SAccGuide::TPairs, wit, rules.wildcards) {
            if (NStr::MatchesMask(pfx, wit->first)) {
                result = wit->second;
                break;
            }
        }
    }
    if (result & fAcc_specials) {
        SAccGuide::TSpecialMap::const_iterator sit
            = rules.specials.lower_bound(acc.substr(0, main_size));
        if (sit != rules.specials.end()  &&  sit->second.first <= acc) {
            return sit->second.second;
        } else {
            return EAccessionInfo(result & ~fAcc_specials);
        }
    } else /* if (result != eAcc_unknown) */ {
        return result;
    }
}


CSeq_id::EAccessionInfo CSeq_id::IdentifyAccession(void) const
{
    EAccessionInfo type = (EAccessionInfo)Which();
    switch (type) {
    case e_Pir: case e_Swissprot: case e_Prf: // but *NOT* e_Pdb
        return (EAccessionInfo)(type | fAcc_prot); // always just protein
        
    case e_Genbank: case e_Embl: case e_Ddbj:
    case e_Tpg:     case e_Tpe:  case e_Tpd:
    case e_Other:   case e_Gpipe:
    {
        const CTextseq_id* tsid = GetTextseq_Id();
        if (tsid->IsSetAccession()) {
            EAccessionInfo ai = IdentifyAccession(tsid->GetAccession());
            if ((ai & eAcc_type_mask) == e_not_set) {
                // We *know* what the type should be....
                return (EAccessionInfo)((ai & eAcc_flag_mask) | type);
            } else if ((ai & eAcc_type_mask) == type) {
                return ai;
            } else { // misidentified or mislabeled; assume the former
                return type;
            }
        } else {
            return type;
        }
    }
    
    default:
        return type;
    }
}


void CSeq_id::LoadAccessionGuide(const string& filename)
{
    auto_ptr<ILineReader> lr(ILineReader::New(filename));
    LoadAccessionGuide(*lr);
}

void CSeq_id::LoadAccessionGuide(ILineReader& in)
{
    SAccGuide guide;
    while ( !in.AtEOF() ) {
        guide.AddRule(*++in);
    }
    swap(s_Guide, guide);
}


static inline
void x_GetLabel_Type(const CSeq_id& id, string* label,
                     CSeq_id::TLabelFlags flags)
{
    unsigned choice = id.Which();
    _ASSERT(choice < CSeq_id::e_MaxChoice);
    if (choice >= CSeq_id::e_MaxChoice) {
        return;
    }

    switch (choice) {   
    case CSeq_id::e_General:
        // we may encode 'gnl' or the database name as requested
        if (flags & CSeq_id::fLabel_GeneralDbIsContent) {
            *label += id.GetGeneral().GetDb();
        } else {
            *label += "gnl";
        }
        break;

    case CSeq_id::e_Patent:
        *label += id.GetPatent().GetCit().GetId().IsNumber() ? "pat" : "pgp";
        
    default:
        *label += s_TextId[choice];
        break;
    }

    // no extra flag interpretation currently
}


static inline
void x_GetLabel_Content(const CSeq_id& id, string* label,
                        CSeq_id::TLabelFlags flags)
{
    const CTextseq_id* tsid = id.GetTextseq_Id();

    //text id
    if (tsid) {
        string str;
        if (tsid->IsSetAccession()) {
            str = tsid->GetAccession();
        } else if (tsid->IsSetName()) {
            str = tsid->GetName();
        }

        if ( !str.empty() ) {
            if ( (flags & CSeq_id::fLabel_Version)  &&  tsid->IsSetVersion()) {
                str += "." + NStr::IntToString(tsid->GetVersion());
            }
        }
        *label += str;

    } else { //non-text id
        switch (id.Which()) {   
        case CSeq_id::e_not_set:
            break;

        case CSeq_id::e_Local:
            {{
                const CObject_id& oid = id.GetLocal();
                if (oid.IsId()) {
                    *label += NStr::IntToString(oid.GetId());
                } else if (oid.IsStr()) {
                    *label += oid.GetStr(); 
                }
            }}
            break;

        case CSeq_id::e_Gibbsq:
            *label += NStr::IntToString(id.GetGibbsq());
            break;

        case CSeq_id::e_Gibbmt:
            *label += NStr::IntToString(id.GetGibbmt());
            break;

        case CSeq_id::e_Giim:
            *label += NStr::IntToString(id.GetGiim().GetId());
            break;

        case CSeq_id::e_General:
            {{
                const CDbtag& dbt = id.GetGeneral();
                if (flags & CSeq_id::fLabel_GeneralDbIsContent) {
                    *label += dbt.GetDb() + '|';
                }
                if (dbt.GetTag().IsId()) {
                    *label += NStr::IntToString(dbt.GetTag().GetId());
                } else if (dbt.GetTag().IsStr()) {
                    *label += dbt.GetTag().GetStr();
                }
            }}
            break;

        case CSeq_id::e_Patent:
            {{
                const CId_pat& idp = id.GetPatent().GetCit();
                *label += idp.GetCountry() +
                    (idp.GetId().IsNumber() ?
                        idp.GetId().GetNumber() :
                        idp.GetId().GetApp_number()) +
                    NStr::IntToString(id.GetPatent().GetSeqid());
            }}
            break;

        case CSeq_id::e_Gi:
            *label += NStr::IntToString(id.GetGi());
            break;

        case CSeq_id::e_Pdb:
            {{
                const CPDB_seq_id& pid = id.GetPdb();
                char chain = (char)pid.GetChain();
                if (chain == '|') {
                    *label += pid.GetMol().Get() + "|VB";
                } else if (islower((unsigned char) chain) != 0) {
                    *label += pid.GetMol().Get() + "-" + (char) toupper((unsigned char) chain);
                } else if ( chain == '\0' ) {
                    *label += pid.GetMol().Get() + "-";
                } else {
                    *label += pid.GetMol().Get() + "-" + chain; 
                }
            }}
            break;

        default:
            break;
        }
    }
}


void CSeq_id::GetLabel(string* label, ELabelType type, TLabelFlags flags) const
{
    if ( !label ) {
        return;
    }

    switch (type) {
    case eFasta:
        *label = AsFastaString();
        break;

    case eBoth:
        x_GetLabel_Type(*this, label, flags);
        *label += "|";
        x_GetLabel_Content(*this, label, flags);
        break;

    case eType:
        x_GetLabel_Type(*this, label, flags);
        break;

    case eContent:
        x_GetLabel_Content(*this, label, flags);
        break;
    }
}



/*Return seqid string with optional version for text seqid type 
(default no version).*/ 
string CSeq_id::GetSeqIdString(bool with_version) const
{
    string label;
    TLabelFlags flags = 0;
    if (with_version) {
        flags |= fLabel_Version;
    }
    GetLabel(&label, eContent, flags);
    return label;
}


void CSeq_id::WriteAsFasta(ostream& out)
    const
{
    unsigned the_type = Which();
    if (the_type >= e_MaxChoice)  // New SeqId type
        the_type = e_not_set;

    if (IsPatent()  &&  !GetPatent().GetCit().GetId().IsNumber() ) {
        out << "pgp|";
    } else {
        out << s_TextId[the_type] << '|';
    }

    switch (the_type) {
    case e_not_set:
        break;
    case e_Local:
        GetLocal().AsString(out);
        break;
    case e_Gibbsq:
        out << GetGibbsq();
        break;
    case e_Gibbmt:
        out << GetGibbmt();
        break;
    case e_Giim:
        out << (GetGiim().GetId());
        break;
    case e_Genbank:
        GetGenbank().AsFastaString(out);
        break;
    case e_Embl:
        GetEmbl().AsFastaString(out);
        break;
    case e_Pir:
        GetPir().AsFastaString(out);
        break;
    case e_Swissprot:
        GetSwissprot().AsFastaString(out);
        break;
    case e_Patent:
        GetPatent().AsFastaString(out);
        break;
    case e_Other:
        GetOther().AsFastaString(out);
        break;
    case e_General:
        {
            const CDbtag& dbt = GetGeneral();
            out << (dbt.GetDb()) << '|';  // no Upcase per Ostell - Karl 7/2001
            dbt.GetTag().AsString(out);
        }
        break;
    case e_Gi:
        out << GetGi();
        break;
    case e_Ddbj:
        GetDdbj().AsFastaString(out);
        break;
    case e_Prf:
        GetPrf().AsFastaString(out);
        break;
    case e_Pdb:
        GetPdb().AsFastaString(out);
        break;
    case e_Tpg:
        GetTpg().AsFastaString(out);
        break;
    case e_Tpe:
        GetTpe().AsFastaString(out);
        break;
    case e_Tpd:
        GetTpd().AsFastaString(out);
        break;
    case e_Gpipe:
        GetGpipe().AsFastaString(out);
        break;
    default:
        out << "[UnknownSeqIdType]";
        break;
    }
}


const string CSeq_id::AsFastaString(void) const
{
    CNcbiOstrstream str;
    WriteAsFasta(str);
    return CNcbiOstrstreamToString(str);
}


//
// GetStringDescr()
// Given a bioseq, return the best possible ID description, in a number of
// appealing formats.  This function can produce FastA-formatted titles or a
// number of sub-titles (GI only, Best Accession with or without version).
//
string CSeq_id::GetStringDescr(const CBioseq& bioseq, EStringFormat fmt)
{
    bool is_na            = bioseq.GetInst().GetMol() != CSeq_inst::eMol_aa;
    CRef<CSeq_id> best_id = FindBestChoice(bioseq.GetId(),
                                           is_na ? CSeq_id::FastaNARank
                                           : CSeq_id::FastaAARank);
    switch (fmt) {
    case eFormat_FastA:
        {
            // FastA format
            // Here we have something like:
            //      gi|###|SOME_ACCESSION|title
            bool found_gi = false;

            CNcbiOstrstream out_str;
            ITERATE (CBioseq::TId, id, bioseq.GetId()) {
                if ((*id)->IsGi()) {
                    (*id)->WriteAsFasta(out_str);
                    found_gi = true;
                    break;
                }
            }

            if (best_id.NotEmpty()  &&  !best_id->IsGi() ) {
                if (found_gi) {
                    out_str << '|';
                }
                best_id->WriteAsFasta(out_str);
            }

            return CNcbiOstrstreamToString(out_str);
        }

    case eFormat_ForceGI:
        // eForceGI produces a string containing only the GI in FastA format
        // so we have:
        //    gi|####
        ITERATE (CBioseq::TId, iter, bioseq.GetId()) {
            if ( (*iter)->IsGi() ) {
                CNcbiOstrstream out_str;
                (*iter)->WriteAsFasta(out_str);

                return CNcbiOstrstreamToString(out_str);
            }
        }
        break;

    case eFormat_BestWithVersion:
        // eBestWithVersion produces only the 'best' accession name, with
        // its version indicator
        if (best_id.NotEmpty()) {
            string label;
            best_id->GetLabel(&label, eDefault, fLabel_Version);
            return label;
        }
        break;
        
    case eFormat_BestWithoutVersion:
        // eBestWithoutVersion produces only the 'best' accession name,
        // without its version indicator
        if (best_id.NotEmpty()) {
            string label;
            best_id->GetLabel(&label, eDefault, 0);
            return label;
        }
        break;
    }

    // catch-all for unusual events
    return "";
}


CSeq_id::CSeq_id(const CDbtag& dbtag, bool set_as_general)
{
    Set(dbtag, set_as_general);
}

CSeq_id& CSeq_id::Set(const CDbtag& dbtag, bool set_as_general)
{
    int version = -1;
    string acc, accver;

    switch (dbtag.GetTag().Which()) {
    case CObject_id::e_Str:
        accver = dbtag.GetTag().GetStr();
        s_SplitVersion(accver, acc, version);
        break;
    case CObject_id::e_Id:
        acc = accver = NStr::IntToString(dbtag.GetTag().GetId());
        break;
    default:
        NCBI_THROW(CSeqIdException, eFormat,
                   "Bad CDbtag tag type "
                   + CObject_id::SelectionName(dbtag.GetTag().Which()));
        break;
    }

    switch (dbtag.GetType()) {
    case CDbtag::eDbtagType_GenBank:
        try {
            int gi = NStr::StringToInt(acc);
            SetGi(gi);
        }
        catch (...) {
            SetGenbank().Set(accver);
        }
        break;

    case CDbtag::eDbtagType_EMBL:
        SetEmbl().Set(accver);
        break;

    case CDbtag::eDbtagType_DDBJ:
        SetDdbj().Set(accver);
        break;

    case CDbtag::eDbtagType_GI:
        if (dbtag.GetTag().IsStr()) {
            Set(e_Gi, dbtag.GetTag().GetStr());
        } else {
            SetGi(dbtag.GetTag().GetId());
        }
        break;

    case CDbtag::eDbtagType_bad:
    default:
        // not understood as a sequence id
        if (set_as_general) {
            SetGeneral().Assign(dbtag);
        } else {
            NCBI_THROW(CSeqIdException, eFormat,
                       "Unrecognized Dbtag DB " + dbtag.GetDb());
        }
        break;
    }

    return *this;
}


//SeqIdFastAConstructors
CSeq_id::CSeq_id( const string& the_id )
{
    Set(the_id);
}

CSeq_id& CSeq_id::Set(const string& the_id_in)
{
    string the_id = NStr::TruncateSpaces(the_id_in, NStr::eTrunc_Both);
    if (the_id.empty()) {
        NCBI_THROW(CSeqIdException, eFormat, "Empty bare accession supplied");
    } else if (the_id.find('|') == NPOS
               ||  isdigit((unsigned char)the_id[0])) {
        // If no vertical bar, tries to interpret the string as a pure
        // accession, inferring the type from the initial letter(s).
        EAccessionInfo info = IdentifyAccession(the_id);
        E_Choice       type = GetAccType(info);
        switch (type) {
        case e_not_set:
            NCBI_THROW(CSeqIdException, eFormat, "Malformatted ID " + the_id);
        case e_Pdb:
        {
            string mol(the_id, 0, 4), chain;
            // NStr::SplitInTwo(the_id, "|", mol, chain);
            if (the_id.size() > 5) {
                chain = the_id.substr(5);
            } else if (the_id.size() == 5  &&  the_id[4] != '|') {
                chain = the_id[4];
            }
            return Set(type, mol, chain);
        }
        default:
        {
            string acc;
            int    ver;
            s_SplitVersion(the_id, acc, ver);
            return Set(type, acc, kEmptyStr, ver);
        }
        }
    } else {
        list<string> fasta_pieces;
        NStr::Split(the_id, "|", fasta_pieces, NStr::eNoMergeDelims);
        x_Init(fasta_pieces);
        if ( !fasta_pieces.empty() ) {
            // tolerate trailing parts if they're all empty.
            ITERATE(list<string>, it, fasta_pieces) {
                if ( !it->empty() ) {
                    NCBI_THROW(CSeqIdException, eFormat,
                               "FASTA-style ID " + the_id
                               + " has too many parts.");
                }
            }
        }
        return *this;
    }
}


SIZE_TYPE CSeq_id::ParseFastaIds(CBioseq::TId& ids, const string& s,
                                 bool allow_partial_failure)
{
    string ss = NStr::TruncateSpaces(s, NStr::eTrunc_Both);
    if (ss.empty()) {
        return 0;
    }
    list<string> fasta_pieces;
    NStr::Split(ss, "|", fasta_pieces, NStr::eNoMergeDelims);
    if ((fasta_pieces.size() < 2  ||  isdigit((unsigned char)ss[0]))) {
        CRef<CSeq_id> id(new CSeq_id);
        // In this context, it's probably reasonable to expect GIs to be
        // tagged with gi| and to treat untagged numeric IDs as local.
        if (ss.find_first_not_of(kDigits) == NPOS) {
            id->Set(e_Local, ss);
        } else {
            try {
                id->Set(ss);
            } catch (CSeqIdException&) {
                id->Set(e_Local, ss);
            }
        }
        ids.push_back(id);
        return 1;
    }
    SIZE_TYPE count = 0;
    while ( !fasta_pieces.empty() ) {
        try {
            CRef<CSeq_id> id(new CSeq_id);
            id->x_Init(fasta_pieces);
            ids.push_back(id);
            ++count;
        } catch (std::exception& e) {
            if (allow_partial_failure) {
                ERR_POST(Warning << e.what());
            } else {
                throw;
            }
        }
    }
    return count;
}


void CSeq_id::x_Init(list<string>& fasta_pieces)
{
    _ASSERT(!fasta_pieces.empty());
    string typestr = fasta_pieces.front();
    fasta_pieces.pop_front();
    NStr::TruncateSpacesInPlace(typestr, NStr::eTrunc_Both);
    E_Choice type = WhichInverseSeqId(typestr.c_str());
    if (type == e_not_set  ||  typestr.size() > 3) {
        NCBI_THROW(CSeqIdException, eFormat, "Unsupported ID type " + typestr);
    }

    string    fields[3];
    SIZE_TYPE min_fields, max_fields;
    switch (type) {
    case e_Local:
    case e_Gibbsq:
    case e_Gibbmt:
    case e_Giim:
    case e_Gi:
        min_fields = max_fields = 1;
        break;
    case e_Patent:
        min_fields = max_fields = 3;
        break;
    case e_General:
        min_fields = max_fields = 2;
        break;
#if 0 // release no longer used
    case e_Other:
        min_fields = 1;
        max_fields = 3;
        break;
#endif
    default: // text seqid: accession and optional name
        min_fields = 1;
        max_fields = 2;
        break;
    }

    for (SIZE_TYPE i = 0;  i < max_fields;  ++i) {
        if (fasta_pieces.empty()) {
            if (i >= min_fields) {
                break;
            } else {
                NCBI_THROW(CSeqIdException, eFormat,
                           "Not enough fields for ID of type " + typestr);
            }
        } else {
            // XXX - stop if we have enough fields and the next one looks
            // like an ID type?
            fields[i] = fasta_pieces.front();
            fasta_pieces.pop_front();
        }
    }

    // Special case -- dbSNP IDs have historically contained internal
    // vertical bars, so we have to parse them greedily.
    if (type == e_General  &&  NStr::EqualNocase(fields[0], "dbSNP")
        &&  !fasta_pieces.empty() ) {
        fields[1] += '|';
        fields[1] += NStr::Join(fasta_pieces, "|");
        fasta_pieces.clear();
    }
    
    int ver = 0;
    if (type == e_Patent) {
        // actually sequence number within patent, but whatever...
        ver = NStr::StringToNumeric(fields[2]);
        if (ver <= 0) {
            NCBI_THROW(CSeqIdException, eFormat,
                       "Bad sequence number " + fields[2] + " for " + fields[0]
                       + " patent " + fields[1]);
        }
        // to distinguish applications from granted patents; the numeric
        // content has already made its way into ver.
        fields[2] = typestr;
    }

    Set(type, fields[0] /* acc */, fields[1] /* name */, ver,
        fields[2] /* rel */);
}


CSeq_id::CSeq_id(E_Choice the_type, int the_id)
{
    Set(the_type, the_id);
}

CSeq_id& CSeq_id::Set(E_Choice the_type, int the_id)
{
    if (the_id <= 0) {
        NCBI_THROW(CSeqIdException, eFormat,
                   "Non-positive numeric ID " + NStr::IntToString(the_id));
    }
  
    switch (the_type) {
    case e_Local:
        SetLocal().SetId(the_id);
        break;
    case e_Gibbsq:
        SetGibbsq(the_id);
        break;
    case e_Gibbmt:
        SetGibbmt(the_id);
        break;
    case e_Giim:
    {
        CGiimport_id& giim = SetGiim();
        giim.SetId(the_id);
        giim.ResetDb();
        giim.ResetRelease();
        break;
    }
    case e_Gi:
        SetGi(the_id);
        break;
    default:
        NCBI_THROW(CSeqIdException, eFormat,
                   "Invalid numeric ID type" + SelectionName(the_type));
    }
    return *this;
}


CSeq_id::CSeq_id(E_Choice      the_type,
                 const string& acc_in,
                 const string& name_in,
                 int           version,
                 const string& release_in)
{
    Set(the_type, acc_in, name_in, version, release_in);
}

// Karl Sirotkin 7/2001

CSeq_id& CSeq_id::Set(E_Choice      the_type,
                      const string& acc_in,
                      const string& name_in,
                      int           version,
                      const string& release_in)
{
    string acc     = NStr::TruncateSpaces(acc_in,     NStr::eTrunc_Both);
    string name    = NStr::TruncateSpaces(name_in,    NStr::eTrunc_Both);
    string release = NStr::TruncateSpaces(release_in, NStr::eTrunc_Both);

    int          the_id;
    CTextseq_id* tsid      = 0;
    bool         allow_dot = true;

    switch (the_type) {
    case e_not_set: // Will cause unspecified SeqId to be returned.
        break;

    case e_Local:
        {
            string::const_iterator it = acc.begin();

            if ( (the_id = NStr::StringToNumeric(acc)) >= 0 && *it != '0' ) {
                SetLocal().SetId(the_id);
            } else { // to cover case where embedded vertical bar in
                // string, could add code here, to concat a
                // '|' and name string, if not null/empty
                SetLocal().SetStr(acc);
            }
            break;
        }

        // numeric IDs
    case e_Gibbsq:
    case e_Gibbmt:
    case e_Giim:
    case e_Gi:
        if ( (the_id = NStr::StringToNumeric (acc)) >= 0 ) {
            return Set(the_type, the_id);
        } else {
            NCBI_THROW(CSeqIdException, eFormat,
                       "Negative, excessively large, or non-numeric "
                       + SelectionName(the_type)
                       + " ID " + acc);
        }
        break;

        // text IDs
    case e_Genbank:    tsid = &SetGenbank();    break;
    case e_Embl:       tsid = &SetEmbl();       break;
    case e_Pir:        tsid = &SetPir();        allow_dot = false;  break;
    case e_Swissprot:  tsid = &SetSwissprot();  allow_dot = false;  break;
    case e_Other:      tsid = &SetOther();      break;
    case e_Ddbj:       tsid = &SetDdbj();       break;
    case e_Prf:        tsid = &SetPrf();        allow_dot = false;  break;
    case e_Tpg:        tsid = &SetTpg();        break;
    case e_Tpe:        tsid = &SetTpe();        break;
    case e_Tpd:        tsid = &SetTpd();        break;
    case e_Gpipe:      tsid = &SetGpipe();      break;

    case e_Patent:
        {
            CPatent_seq_id&  pat    = SetPatent();
            CId_pat&         id_pat = pat.SetCit();
            CId_pat::C_Id&   id_pat_id = id_pat.SetId();
            id_pat.SetCountry(acc);

            if (NStr::EqualNocase(release, "pgp")) {
                id_pat_id.SetApp_number(name);
            } else {
                id_pat_id.SetNumber(name);
            }
            id_pat.ResetDoc_type();
            pat.SetSeqid(version);
            break;
        }

    case e_General:
        {
            CDbtag& dbt = SetGeneral();
            dbt.SetDb(acc);
            CObject_id& oid = dbt.SetTag();
            the_id = NStr::StringToNumeric(name);
            if (the_id >= 0  &&  (name.size() == 1 || name[0] != '0')) {
                oid.SetId(the_id);
            } else {
                oid.SetStr(name);
            }
            break;
        }

    case e_Pdb:
        {
            CPDB_seq_id& pdb = SetPdb();
            pdb.SetMol().Set(acc);

            if (name.empty()) {
                pdb.SetChain(' ');
            } else if (name.size() == 1) { // force upper case?
                pdb.SetChain(static_cast<unsigned char>(name[0]));
            } else if (NStr::EqualNocase(name, "VB")) {
                pdb.SetChain('|');
            } else if (name.size() == 2  &&  name[0] == name[1]) {
                pdb.SetChain(tolower(static_cast<unsigned char>(name[0])));
            } else {
                NCBI_THROW(CSeqIdException, eFormat,
                           "Unexpected PDB chain id " + name + " for " + acc);
            }
            pdb.ResetRel();
            break;
        }

    default:
        NCBI_THROW(CSeqIdException, eFormat,
                   "Unsupported Seq-id type " + SelectionName(the_type));
    }

    if (tsid) {
        tsid->Set(acc, name, version, release, allow_dot);
    }

    return *this;
}


bool CSeq_id::Equals(const CSerialObject& object, ESerialRecursionMode how) const
{
    if ( typeid(object) != typeid(*this) ) {
        ERR_POST(Fatal <<
            "CSeq_id::Assign() -- Assignment of incompatible types: " <<
            typeid(*this).name() << " = " << typeid(object).name());
    }
    return CSerialObject::Equals(object, how);
}


END_objects_SCOPE // namespace ncbi::objects::
END_NCBI_SCOPE

/*
 * ===========================================================================
 *
 * $Log$
 * Revision 6.145  2007/01/09 16:17:43  ucko
 * Revise eAcc_gpipe* classification, but hold off on adding anything to
 * the accession guide until the new terms have propagated.
 *
 * Revision 6.144  2007/01/08 16:06:58  ucko
 * Rework IdentifyAccession to use a separate accession guide, which can
 * be either explicitly supplied (via LoadAccessionGuide), autoloaded from
 * a common data directory, or initialized from an embedded fallback copy.
 *
 * Revision 6.143  2007/01/04 20:08:03  ucko
 * IdentifyAccession: allow for nucleotide(!) PDB accessions.
 *
 * Revision 6.142  2007/01/04 16:02:01  ucko
 * IdentifyAccession: EJ, EK -> eAcc_gb_gss.
 *
 * Revision 6.141  2006/12/20 15:07:48  ucko
 * IdentifyAccession: specifically assign DH to eAcc_ddbj_gss.
 *
 * Revision 6.140  2006/12/08 20:32:36  ucko
 * Update EMBL/TPE protein info.
 *
 * Revision 6.139  2006/12/05 15:31:32  ucko
 * IdentifyAccession: EI -> eAcc_gb_gss
 *
 * Revision 6.138  2006/11/14 21:45:37  ucko
 * Properly recognize RefSeq AC_ (alternate chromosome-class) records.
 *
 * Revision 6.137  2006/11/14 19:30:50  ucko
 * s_IdentifyCxxAcc: correct the known EMBL protein ID cutoff (slightly) upwards.
 *
 * Revision 6.136  2006/11/14 19:13:38  ucko
 * Cope (somewhat painfully) with EMBL's policy of mixing some TPA
 * proteins into their namespace.
 *
 * Revision 6.135  2006/11/03 19:14:40  ucko
 * IdentifyAccession: EH -> eAcc_gb_est.
 *
 * Revision 6.134  2006/09/18 18:07:44  ucko
 * IdentifyAccession: EG -> eAcc_gb_est
 *
 * Revision 6.133  2006/08/21 19:33:26  ucko
 * IdentifyAccession: EF -> eAcc_gb_dirsub
 *
 * Revision 6.132  2006/07/06 14:06:33  ucko
 * IdentifyAccession: EE -> eAcc_gb_est
 *
 * Revision 6.131  2006/06/29 15:05:37  ucko
 * IdentifyAccession: ED -> eAcc_gb_gss
 *
 * Revision 6.130  2006/06/20 21:02:48  ucko
 * IdentifyAccession: EMBL has specifically assigned CU to genome
 * projects; also correct the comment for unassigned DDBJ Dx prefixes.
 *
 * Revision 6.129  2006/06/15 14:19:17  ucko
 * Loosen syntax requirements for bare PDB accessions.
 *
 * Revision 6.128  2006/05/25 14:39:34  ucko
 * IdentifyAccession: EC -> eAcc_gb_est.
 *
 * Revision 6.127  2006/04/11 15:07:20  ucko
 * ParseFastaIds: when fed an empty string (or just whitespace), return 0
 * rather than storing a blank local ID.
 *
 * Revision 6.126  2006/04/06 15:59:34  ucko
 * DDBJ changes its use of DF from CON to scaffold/CON and will be using
 * DG for CON entries.  [We represent both as eAcc_ddbj_con.]
 *
 * Revision 6.125  2006/03/30 14:53:32  ucko
 * IdentifyAccession: DDBJ has specifically assigned DF to CON sequences.
 *
 * Revision 6.124  2006/03/24 21:30:37  ucko
 * Really fix ParseFastaIds' handling of untagged numeric IDs.
 *
 * Revision 6.123  2006/03/23 18:57:48  ucko
 * IdentifyAccession: EB -> eAcc_gb_est
 *
 * Revision 6.122  2006/02/15 17:17:42  ucko
 * Expose ranking methods used for FASTA deflines per Tom Madden's request.
 *
 * Revision 6.121  2006/02/07 19:29:11  ucko
 * Use pgp|... rather than pat|... for "pre-grant patents" (applications).
 *
 * Revision 6.120  2006/02/02 16:07:51  ucko
 * IdentifyAccession: DZ and EA are GenBank patents (eAcc_gb_patent).
 *
 * Revision 6.119  2006/01/25 15:59:26  ucko
 * IdentifyAccession: DY has been assigned to GenBank ESTs (eAcc_gb_est)
 *
 * Revision 6.118  2006/01/03 19:42:37  ucko
 * IdentifyAccession: DX -> eAcc_gb_gss.
 *
 * Revision 6.117  2005/12/28 17:05:13  ucko
 * CSeq_id::Set(const string&): put up with trailing parts in FASTA-style
 * IDs as long as they're all empty.
 *
 * Revision 6.116  2005/12/12 15:47:00  ucko
 * IdentifyAccession: DW has been allocated to GenBank ESTs.
 * ParseFastaIds: treat untagged numeric IDs as local IDs rather than GIs.
 *
 * Revision 6.115  2005/09/21 13:51:59  ucko
 * IdentifyAccession: DV -> eAcc_gb_est.
 *
 * Revision 6.114  2005/09/07 15:41:12  ucko
 * dbSNP is moving away from extra fields, so don't assume they're always
 * present.
 *
 * Revision 6.113  2005/08/25 14:02:04  jcherry
 * More accurate exception message for bad numeric accessions
 *
 * Revision 6.112  2005/08/18 14:42:26  ucko
 * By request, parse FASTA-style dbSNP IDs greedily, as they may contain
 * extra vertical bars as part of the tag.
 *
 * Revision 6.111  2005/07/28 18:28:51  ucko
 * CSeq_id::IdentifyAccession: DT -> gb_est, DU -> gb_gss.
 *
 * Revision 6.110  2005/07/06 13:54:05  ucko
 * IdentifyAccession: DS has been assigned to GenBank CON records.
 *
 * Revision 6.109  2005/06/30 20:06:32  ucko
 * ParseFastaIds: try to make sense of IDs without vertical bars,
 * treating them as bare accessions if possible and local IDs otherwise.
 *
 * Revision 6.108  2005/06/29 19:22:20  ucko
 * Refactor, introducing Set methods that can be called on previously
 * initialized IDs and a static ParseFastaIDs method.
 * Make an effort to weed out malformatted IDs in IdentifyAccession.
 * Also introduce CSeqIdException, and use it consistently.
 * Fully support gpipe IDs.
 * Various minor cleanups.
 *
 * Revision 6.107  2005/06/15 18:23:55  ucko
 * IdentifyAccession: CT has been assigned to eAcc_embl_genome.
 *
 * Revision 6.106  2005/06/03 16:53:08  lavr
 * Explicit (unsigned char) casts in ctype routines
 *
 * Revision 6.105  2005/05/04 19:03:32  ucko
 * Take advantage of PCase_CStr when comparing C strings.
 *
 * Revision 6.104  2005/04/28 19:05:14  ucko
 * Correction: DR is for ESTs, not STSs.
 *
 * Revision 6.103  2005/04/26 20:21:42  vasilche
 * Use e_MaxChoice as size of Seq-id types array.
 *
 * Revision 6.102  2005/04/05 15:22:46  ucko
 * IdentifyAccession: DR -> eAcc_gb_sts.
 *
 * Revision 6.101  2005/03/22 20:12:24  ucko
 * +DP (eAcc_gb_htgs), DQ (eAcc_gb_dirsub)
 *
 * Revision 6.100  2005/02/02 19:49:54  grichenk
 * Fixed more warnings
 *
 * Revision 6.99  2005/02/01 17:10:30  ucko
 * IdentifyAccession: DN -> eAcc_gb_est
 *
 * Revision 6.98  2005/01/25 17:24:55  ucko
 * IdentifyAccession: CS -> eAcc_embl_patent
 *
 * Revision 6.97  2005/01/13 15:59:23  dicuccio
 * Use PCase for case-sensitive comparisons in CStaticArrayMap<> - avoids
 * comparison by pointer
 *
 * Revision 6.96  2005/01/13 15:31:41  ucko
 * IdentifyAccession: use a CStaticArrayMap for RefSeq prefixes, and
 * recognize AP_ and YP_.
 *
 * Revision 6.95  2004/12/08 19:51:52  ucko
 * IdentifyAccession: We have now specifically assigned CZ for our own
 * GSS sequences.
 *
 * Revision 6.94  2004/12/08 15:20:03  ucko
 * IdentifyAccession: DDBJ has specifically assigned DE for GSS.
 *
 * Revision 6.93  2004/12/01 20:04:04  ucko
 * IdentifyAccession: CY is now specifically for (flu) genomes.
 *
 * Revision 6.92  2004/11/22 20:10:24  ucko
 * IdentifyAccession: CX is now specifically assigned to GenBank ESTs.
 *
 * Revision 6.91  2004/11/10 15:09:12  ucko
 * IdentifyAccession: DD -> DDBJ patent, DE-DM also to be used by DDBJ.
 *
 * Revision 6.90  2004/10/13 17:39:08  ucko
 * CSeq_id::IdentifyAccession: CX-CZ are reserved for GenBank
 * nucleotides, and DA-DZ are DDBJ ESTs.
 *
 * Revision 6.89  2004/09/15 14:10:12  ucko
 * IdentifyAccession: CW -> eAcc_gb_gss
 *
 * Revision 6.88  2004/08/06 17:20:59  ucko
 * IdentifyAccession: CV -> eAcc_gb_est
 *
 * Revision 6.87  2004/08/04 17:36:00  ucko
 * Recognize extended Swissprot/Uniprot accessions.
 *
 * Revision 6.86  2004/07/14 19:02:40  ucko
 * CP is now specifically assigned to GenBank genomes.
 *
 * Revision 6.85  2004/06/28 14:21:10  dicuccio
 * Implement flag: treat the db portion of a general ID as content or not
 *
 * Revision 6.84  2004/06/07 20:12:17  ucko
 * Revert previous change, as some code was relying on getting e_not_set
 * for unrecognized IDs.
 *
 * Revision 6.83  2004/06/07 19:00:34  ucko
 * CSeq_id::CSeq_id(const string&): if we can't identify the string at
 * all, turn it into a local ID.
 *
 * Revision 6.82  2004/06/04 14:09:58  ucko
 * IdentifyAccession: CO now specifically assigned to eAcc_gb_est.
 *
 * Revision 6.81  2004/06/01 15:26:07  johnson
 * Make CompareOrdered a true model of strict weak ordering
 *
 * Revision 6.80  2004/05/28 20:09:44  johnson
 * Added Compare for seq-id type General (CDbtag)
 *
 * Revision 6.79  2004/05/21 14:41:46  dicuccio
 * Moved database tag for general IDs to content part of label
 *
 * Revision 6.78  2004/05/19 17:26:25  gorelenk
 * Added include of PCH - ncbi_pch.hpp
 *
 * Revision 6.77  2004/05/16 16:57:44  dicuccio
 * Removed insertion of db type in general seq-id labels of type content - led to
 * duplicates of type
 *
 * Revision 6.76  2004/05/14 14:34:02  dicuccio
 * Include database name in label content if the db-tag is just an integer
 *
 * Revision 6.75  2004/03/25 15:59:06  gouriano
 * Added possibility to copy and compare serial object non-recursively
 *
 * Revision 6.74  2004/03/22 16:24:19  ucko
 * CN is now specifically assigned to GenBank ESTs.
 *
 * Revision 6.73  2004/01/22 21:03:58  dicuccio
 * Separated functionality of enums in GetLabel() into discrete mode and flags
 *
 * Revision 6.72  2004/01/22 18:45:46  dicuccio
 * Added new API: CSeq_id::GetLabel().  Rewired GetSeqIdString() to feed into
 * GetLabel().  Rewired GetStringDescr() to feed into GetLabel() directly instead
 * of feeding through GetSeqIdString().
 *
 * Revision 6.71  2004/01/21 22:55:47  ucko
 * GetSeqIdString: drop the database name from general IDs for
 * compatibility with code that can't handle its presence.
 *
 * Revision 6.70  2004/01/21 18:04:20  dicuccio
 * Added ctor to create a seq-id from a given dbtag, performing conversion to
 * specific seq-id types where possible
 *
 * Revision 6.69  2004/01/20 16:59:38  ucko
 * CSeq_id::IdentifyAccession: identify IDs consisting solely of digits as GIs.
 *
 * Revision 6.68  2004/01/16 17:39:17  vasilche
 * Fixed parsing 'gnl|xxx|999' format - integer tag detection.
 *
 * Revision 6.67  2004/01/16 15:58:19  ucko
 * CM now specifically assigned to eAcc_gb_con.
 *
 * Revision 6.66  2003/12/18 18:55:59  ucko
 * CSeq_id::IdentifyAccession: CQ is EMBL patents, CR is EMBL genomes,
 * CS-CU are reserved for future EMBL nucleotide use.
 *
 * Revision 6.65  2003/12/16 16:00:16  ucko
 * CSeq_id::IdentifyAccession: CL is GenBank GSS, CM-CP are GenBank
 * nucleotides to be assigned to specific projects as needed.
 *
 * Revision 6.64  2003/11/10 15:05:42  ucko
 * +CK to eAcc_gb_est
 *
 * Revision 6.63  2003/10/31 20:16:07  ucko
 * CSeq_id::IdentifyAccession: CI and CJ are both DDBJ EST.
 *
 * Revision 6.62  2003/10/24 14:57:03  ucko
 * IdentifyAccession: CH -> eAcc_gb_con.
 * GetSeqIdString: include the database name for IDs of type general.
 *
 * Revision 6.61  2003/08/25 21:15:41  ucko
 * Tweak slightly for efficiency.
 *
 * Revision 6.60  2003/08/22 15:16:48  dondosha
 * Correction in CSeq_id constructor, to allow id strings starting with a gi id
 *
 * Revision 6.59  2003/08/11 14:37:20  ucko
 * IdentifyAccession: "CG" is GenBank GSS.
 *
 * Revision 6.58  2003/07/14 20:11:59  ucko
 * +CF (eAcc_gb_est)
 *
 * Revision 6.57  2003/07/02 13:46:14  ucko
 * +CE (eAcc_gb_gss)
 *
 * Revision 6.56  2003/06/24 16:33:48  ucko
 * CSeq_id::IdentifyAccession: always return unknown for accessions that
 * contain no digits, even if they happen to look like prefixes.
 *
 * Revision 6.55  2003/05/09 14:22:56  ucko
 * CSeq_id::x_Init: treat missing (chain) names as spaces (reported by
 * Michel Dumontier) and get rid of some unnecessary calls to c_str().
 *
 * Revision 6.54  2003/04/30 14:41:01  ucko
 * CSeq_id::IdentifyAccession: CDnnnnnn -> eAcc_gb_est
 *
 * Revision 6.53  2003/03/25 15:37:18  ucko
 * CSeq_id::IdentifyAccession("CC...") -> eAcc_gb_gss
 *
 * Revision 6.52  2003/03/11 15:55:44  kuznets
 * iterate -> ITERATE
 *
 * Revision 6.51  2003/02/06 22:23:29  vasilche
 * Added CSeq_id::Assign(), CSeq_loc::Assign().
 * Added int CSeq_id::Compare() (not safe).
 * Added caching of CSeq_loc::GetTotalRange().
 *
 * Revision 6.50  2003/02/04 15:15:12  grichenk
 * Overrided Assign() for CSeq_loc and CSeq_id
 *
 * Revision 6.49  2003/01/18 08:40:03  kimelman
 * addes seqid constructor for numeric types
 *
 * Revision 6.48  2003/01/15 18:27:13  ucko
 * +AK (accidentally skipped earlier -- sigh)
 *
 * Revision 6.47  2003/01/10 15:57:30  ucko
 * Identify CB as gb_est.
 *
 * Revision 6.46  2003/01/08 16:48:03  ucko
 * +AL (accidentally skipped earlier)
 *
 * Revision 6.45  2003/01/07 19:52:15  ucko
 * Add more refseq types (NR_, NS_, NW_).
 *
 * Revision 6.44  2002/12/30 23:44:42  vakatov
 * CSeq_id::GetStringDescr() -- un-freeze "strstream" to avoid a mem.leak
 *
 * Revision 6.43  2002/12/26 16:39:25  vasilche
 * Object manager class CSeqMap rewritten.
 *
 * Revision 6.42  2002/12/03 15:55:12  dicuccio
 * Corrected processing of text id accessions with no accession set (in
 * GetSeqIdString()) - use name instead.
 *
 * Revision 6.41  2002/11/26 15:13:32  dicuccio
 * Added CSeq_id::GetStringDescr() - provides text representations of seq-ids in a
 * number of formats.
 *
 * Revision 6.40  2002/10/23 18:23:07  ucko
 * Add self-classification (using known type information).
 *
 * Revision 6.39  2002/10/22 20:19:14  jianye
 * Added GetSeqIdString()
 *
 * Revision 6.38  2002/10/18 16:03:08  ucko
 * +CA (eAcc_gb_est)
 *
 * Revision 6.37  2002/10/03 18:55:04  clausen
 * Removed extra whitespace
 *
 * Revision 6.36  2002/10/03 17:17:11  clausen
 * Added BestRank() and WorstRank()
 *
 * Revision 6.35  2002/10/03 16:03:00  ucko
 * +BZ (eAcc_gb_gss)
 *
 * Revision 6.34  2002/09/23 16:43:46  ucko
 * Change check for absence of '|' to use string::find.
 *
 * Revision 6.33  2002/09/20 19:55:29  ucko
 * +BY (eAcc_ddbj_est)
 *
 * Revision 6.32  2002/08/28 14:07:56  ucko
 * IdentifyAccession: handle BX (EMBL genome)
 *
 * Revision 6.31  2002/08/26 20:44:06  ucko
 * CSeq_id::IdentifyAccession: +BW (DDBJ EST)
 *
 * Revision 6.30  2002/08/19 16:54:30  ucko
 * IdentifyAccession: add BV (eAcc_gb_sts).
 *
 * Revision 6.29  2002/08/19 15:42:14  ucko
 * IdentifyAccession: add BU (eAcc_gb_est).
 *
 * Revision 6.28  2002/08/16 19:27:01  ucko
 * Recognize new WGS RefSeq accessions.
 *
 * Revision 6.27  2002/08/14 15:52:27  ucko
 * Add BT and XR_.
 *
 * Revision 6.26  2002/08/06 18:22:19  ucko
 * Properly handle versioned PDB accessions.
 *
 * Revision 6.25  2002/08/01 20:33:10  ucko
 * s_IdentifyAccession -> IdentifyAccession; s_ is only for module-static names.
 *
 * Revision 6.24  2002/07/30 19:42:44  ucko
 * Add s_IdentifyAccession, and use it in the string-based constructor if
 * the input isn't FASTA-format.
 * Move CVS log to end.
 *
 * Revision 6.23  2002/06/06 20:31:33  clausen
 * Moved methods using object manager to objects/util
 *
 * Revision 6.22  2002/05/22 14:03:40  grichenk
 * CSerialUserOp -- added prefix UserOp_ to Assign() and Equals()
 *
 * Revision 6.21  2002/05/06 03:39:12  vakatov
 * OM/OM1 renaming
 *
 * Revision 6.20  2002/05/03 21:28:17  ucko
 * Introduce T(Signed)SeqPos.
 *
 * Revision 6.19  2002/01/16 18:56:32  grichenk
 * Removed CRef<> argument from choice variant setter, updated sources to
 * use references instead of CRef<>s
 *
 * Revision 6.18  2002/01/10 19:00:04  clausen
 * Added GetLength
 *
 * Revision 6.17  2002/01/09 15:59:30  grichenk
 * Fixed includes
 *
 * Revision 6.16  2001/10/15 23:00:00  vakatov
 * CSeq_id::x_Init() -- get rid of unreachable "break;"
 *
 * Revision 6.15  2001/08/31 20:05:44  ucko
 * Fix ICC build.
 *
 * Revision 6.14  2001/08/31 16:02:10  clausen
 * Added new constructors for Fasta and added new id types, tpd, tpe, tpg
 *
 * Revision 6.13  2001/07/16 16:22:48  grichenk
 * Added CSerialUserOp class to create Assign() and Equals() methods for
 * user-defind classes.
 * Added SerialAssign<>() and SerialEquals<>() functions.
 *
 * Revision 6.12  2001/05/24 20:24:27  grichenk
 * Renamed seq/objmgrstub.hpp -> obgmgr/objmgr_base.hpp
 * Added Genbank, Embl and Ddbj support in CSeq_id::Compare()
 * Fixed General output by CSeq_id::WriteAsFasta()
 *
 * Revision 6.11  2001/04/17 04:14:49  vakatov
 * CSeq_id::AsFastaString() --> CSeq_id::WriteAsFasta()
 *
 * Revision 6.10  2001/01/03 16:39:05  vasilche
 * Added CAbstractObjectManager - stub for object manager.
 * CRange extracted to separate file.
 *
 * Revision 6.9  2000/12/26 17:28:55  vasilche
 * Simplified and formatted code.
 *
 * Revision 6.8  2000/12/15 19:30:31  ostell
 * Used Upcase() in AsFastaString() and changed to PNocase().Equals() style
 *
 * Revision 6.7  2000/12/08 22:19:45  ostell
 * changed MakeFastString to AsFastaString and to use ostream instead of string
 *
 * Revision 6.6  2000/12/08 20:45:14  ostell
 * added MakeFastaString()
 *
 * Revision 6.5  2000/12/04 15:09:41  vasilche
 * Added missing include.
 *
 * Revision 6.4  2000/11/30 22:08:18  ostell
 * finished Match()
 *
 * Revision 6.3  2000/11/30 16:13:12  ostell
 * added support for Textseq_id to Seq_id.Match()
 *
 * Revision 6.2  2000/11/28 12:47:41  ostell
 * fixed first switch statement to break properly
 *
 * Revision 6.1  2000/11/21 18:58:29  vasilche
 * Added Match() methods for CSeq_id, CObject_id and CDbtag.
 *
 * ===========================================================================
 */
