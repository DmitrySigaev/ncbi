/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqloc.asn'.
 *
 * ---------------------------------------------------------------------------
 * $Log$
 * Revision 6.9  2000/12/26 17:28:55  vasilche
 * Simplified and formatted code.
 *
 * Revision 6.8  2000/12/15 19:30:31  ostell
 * Used Upcase() in AsFastaString() and changed to PNocase().Equals() style
 *
 * Revision 6.7  2000/12/08 22:19:45  ostell
 * changed MakeFastString to AsFastaString and to use ostream instead of string
 *
 * Revision 6.6  2000/12/08 20:45:14  ostell
 * added MakeFastaString()
 *
 * Revision 6.5  2000/12/04 15:09:41  vasilche
 * Added missing include.
 *
 * Revision 6.4  2000/11/30 22:08:18  ostell
 * finished Match()
 *
 * Revision 6.3  2000/11/30 16:13:12  ostell
 * added support for Textseq_id to Seq_id.Match()
 *
 * Revision 6.2  2000/11/28 12:47:41  ostell
 * fixed first switch statement to break properly
 *
 * Revision 6.1  2000/11/21 18:58:29  vasilche
 * Added Match() methods for CSeq_id, CObject_id and CDbtag.
 *
 *
 * ===========================================================================
 */

// standard includes

// generated includes
#include <objects/seqloc/Seq_id.hpp>
#include <objects/general/Object_id.hpp>
#include <objects/general/Dbtag.hpp>
#include <objects/seqloc/Giimport_id.hpp>
#include <objects/seqloc/PDB_seq_id.hpp>
#include <objects/seqloc/Textseq_id.hpp>
#include <objects/seqloc/Patent_seq_id.hpp>

// object manager includes
#include <objects/objmgr/objmgr.hpp>
#include <objects/seq/Bioseq.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// constructor
CSeq_id::CSeq_id(void)
{
}

// destructor
CSeq_id::~CSeq_id(void)
{
}

const CTextseq_id* CSeq_id::GetTextseq_Id(void) const
{
    switch ( Which() ) {
    case e_Genbank:
        return &GetGenbank();
    case e_Embl:
        return &GetEmbl();
    case e_Ddbj:
        return &GetDdbj();
    default:
        return 0;
    }
}

// Compare() - are SeqIds equivalent?
CSeq_id::E_SIC CSeq_id::Compare(const CSeq_id& sid2) const
{
    if ( Which() != sid2.Which() ) { // only one case where this will work
        const CTextseq_id *tsip1 = GetTextseq_Id();
        if ( !tsip1 )
            return e_DIFF;

        const CTextseq_id *tsip2 = sid2.GetTextseq_Id();
        if ( !tsip2 )
            return e_DIFF;

        if ( tsip1->Match(*tsip2) ) // id Textseq_id match
            return e_YES;
        else
            return e_NO;
    }

    switch ( Which() ) { // now we only need to know one
    case e_Local:
        return GetLocal().Match(sid2.GetLocal())? e_YES: e_NO;
    case e_Gibbsq:
        return GetGibbsq() == sid2.GetGibbsq()? e_YES: e_NO;
    case e_Gibbmt:
        return GetGibbmt() == sid2.GetGibbmt()? e_YES: e_NO;
    case e_Giim:
        return GetGiim().GetId() == sid2.GetGiim().GetId()? e_YES: e_NO;
    case e_Pir:
        return GetPir().Match(sid2.GetPir())? e_YES: e_NO;
    case e_Swissprot:
        return GetSwissprot().Match(sid2.GetSwissprot())? e_YES: e_NO;
    case e_Patent:
        return GetPatent().Match(sid2.GetPatent())? e_YES: e_NO;
    case e_Other:
        return GetOther().Match(sid2.GetOther())? e_YES: e_NO;
    case e_General:
        return GetGeneral().Match(sid2.GetGeneral())? e_YES: e_NO;
    case e_Gi:
        return GetGi() == sid2.GetGi()? e_YES: e_NO;
    case e_Prf:
        return GetPrf().Match(sid2.GetPrf())? e_YES: e_NO;
    case e_Pdb:
        return GetPdb().Match(sid2.GetPdb())? e_YES: e_NO;
    default:
        return e_error;
    }
}

static const char* const txtid[16] = {     /* FASTA_LONG formats */
    "???" ,         /* not-set = ??? */
    "lcl",          /* local = lcl|integer or string */
    "bbs",          /* gibbsq = bbs|integer */
    "bbm",          /* gibbmt = bbm|integer */
    "gim",          /* giim = gim|integer */
    "gb",           /* genbank = gb|accession|locus */
    "emb",          /* embl = emb|accession|locus */
    "pir",          /* pir = pir|accession|name */
    "sp",           /* swissprot = sp|accession|name */
    "pat",          /* patent = pat|country|patent number (string)|seq number (integer) */
    "ref",          /* other = ref|accession|name|release - changed from oth to ref */
    "gnl",          /* general = gnl|database(string)|id (string or number) */
    "gi",           /* gi = gi|integer */
    "dbj",          /* ddbj = dbj|accession|locus */
    "prf",          /* prf = prf|accession|name */
    "pdb"           /* pdb = pdb|entry name (string)|chain id (char) */
};

ostream& CSeq_id::AsFastaString(ostream& s) const
{
	E_Choice the_type = Which();
	if (the_type > e_Pdb)  // new SeqId type
		the_type = e_not_set;

	s << txtid[the_type] << '|';

	switch (the_type) {
    case e_not_set:
        break;
    case e_Local:
        GetLocal().AsString(s);
        break;
    case e_Gibbsq:
        s << GetGibbsq();
        break;
    case e_Gibbmt:
        s << GetGibbmt();
        break;
    case e_Giim:
        s << (GetGiim().GetId());
        break;
    case e_Genbank:
        GetGenbank().AsFastaString(s);
        break;
    case e_Embl:
        GetEmbl().AsFastaString(s);
        break;
    case e_Pir:
        GetPir().AsFastaString(s);
        break;
    case e_Swissprot:
        GetSwissprot().AsFastaString(s);
        break;
    case e_Patent:
        GetPatent().AsFastaString(s);
        break;
    case e_Other:
        GetOther().AsFastaString(s);
        break;
    case e_General:
        {
            const CDbtag& dbt = GetGeneral();
            s << Upcase(dbt.GetDb()) << '|' << (dbt.GetTag().AsString(s));
        }
        break;
    case e_Gi:
        s << GetGi();
        break;
    case e_Ddbj:
        GetDdbj().AsFastaString(s);
        break;
    case e_Prf:
        GetPrf().AsFastaString(s);
        break;
    case e_Pdb:
        GetPdb().AsFastaString(s);
        break;
    default:
        s << "[UnknownSeqIdType]";
        break;

    }
	return s;
}

void CSeq_id::SetObjectManager(const CRef<CObjectManager>& objMgr)
{
    if ( m_ObjectManager )
        THROW1_TRACE(runtime_error, "CSeq_id::SetObjectManager: already set");
    if ( !objMgr )
        THROW1_TRACE(runtime_error, "CSeq_id::SetObjectManager: null pointer");

    m_ObjectManager = objMgr;
}

void CSeq_id::ResetObjectManager(const CRef<CObjectManager>& objMgr)
{
    if ( m_ObjectManager.GetPointer() != objMgr.GetPointer() )
        ERR_POST("CSeq_id::ResetObjectManager: not owner");
    m_ObjectManager.Reset();
}

CRef<CBioseq> CSeq_id::Resolve(void) const
{
    if ( !m_ObjectManager )
        THROW1_TRACE(runtime_error, "CSeq_id::Resolve: null pointer");

    return m_ObjectManager->GetBioseq(*this);
}

END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

