/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  J. Chen
 *
 * File Description:
 *   GetQualFromFeatureAnyType
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using the following specifications:
 *   'macro.asn'.
 */

// standard includes
#include <ncbi_pch.hpp>

// generated includes
#include <objects/macro/Feat_qual_choice.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
CFeat_qual_choice::~CFeat_qual_choice(void)
{
}

/*
string CFeat_qual_choice :: GetQualFromFeatureAnyType(const CSeq_feat& feat, const CString_constraint& str_cons, CConstRef <CScope> scope) const
{
   if (Which() == e_not_set) {
      return kEmptyStr;
   }

   vector <EFeat_qual_legal> v_legal_qual;

// fields common to all features 
// note, also known as comment 
   v_legal_qual.push_back(eFeat_qual_legal_note);
   v_legal_qual.push_back(eFeat_qual_legal_db_xref);
   v_legal_qual.push_back(eFeat_qual_legal_exception);
   v_legal_qual.push_back(eFeat_qual_legal_evidence);
   v_legal_qual.push_back(eFeat_qual_legal_citation); // how to do that?
   v_legal_qual.push_back(eFeat_qual_legal_location); // move SeqLocPrintUseBestID
   v_legal_qual.push_back(eFeat_qual_legal_pseudo);

// fields common to some features
   v_legal_qual.push_back(eFeat_qual_legal_product);
   v_legal_qual.push_back(eFeat_qual_legal_gene);
   v_legal_qual.push_back(eFeat_qual_legal_gene_description);
   v_legal_qual.push_back(eFeat_qual_legal_map);
   v_legal_qual.push_back(eFeat_qual_legal_allele);
   v_legal_qual.push_back(eFeat_qual_legal_locus_tag);
   v_legal_qual.push_back(eFeat_qual_legal_synonym);
   v_legal_qual.push_back(eFeat_qual_legal_description);
   v_legal_qual.push_back(eFeat_qual_legal_ec_number);
   v_legal_qual.push_back(eFeat_qual_legal_activity);
   v_legal_qual.push_back(eFeat_qual_legal_codons_recognized);
   v_legal_qual.push_back(eFeat_qual_legal_anticodon);
   v_legal_qual.push_back(eFeat_qual_legal_tag_peptide);
   v_legal_qual.push_back(eFeat_qual_legal_ncRNA_class);

   vector <EFeat_qual_legal> v_legal_only_qual;
   v_legal_only_qual.push_back(eFeat_qual_legal_gene_comment); 
   v_legal_only_qual.push_back(eFeat_qual_legal_transl_except); 
   v_legal_only_qual.push_back(eFeat_qual_legal_transl_table); 
   v_legal_only_qual.push_back(eFeat_qual_legal_translation); 
   v_legal_only_qual.push_back(eFeat_qual_legal_codon_start); 
   v_legal_only_qual.push_back(eFeat_qual_legal_name); 

   string name, rval(kEmptyStr);
   if (IsIllegal_qual()) { 
      string strtmp;
      const CString_constraint& illegal_str_cons = GetIllegal_qual();
      ITERATE (vector <EFeat_qual_legal>, it, v_legal_qual) {
        name = strtmp 
             = ENUM_METHOD_NAME(EFeat_qual_legal)()->FindName(*it, true);
        strtmp = (strtmp == "pseudo" ? "pseudogene" : strtmp);
        strtmp = (strtmp == "gene" ? "locus" : strtmp);
        strtmp = (strtmp == "gene-description" ? "description" : strtmp);
        strtmp = (strtmp == "locus-tag" ? "locus_tag" : strtmp);
        strtmp = (strtmp == "ec-number" ? "ec_number" : strtmp);
        strtmp = (strtmp == "ncRNA-classnumber" ? "ncRNA_class" : strtmp);
        strtmp = (strtmp == "codons-recognized" ? "codon-recognized" : strtmp);
        // codon-recognized && tag-peptide?  
        
        if (!illegal_str_cons.Empty() && !illegal_str_cons.Match(strtmp)) {
           name = kEmptyStr;
        }
        rval = x_GetQualViaFeatSeqTableColumn(name, feat, str_cons, scope);
        if (!rval.empty()) {
           break;
        }
      }
      if (rval.empty() && feat.CanGetQual()) { // actual GenBank qualifier
        rval = x_GetFirstGBQualMatchConstraintName( feat, GetIllegal_qual());
      }
   }
   else { // IsLegal_qual
     EFeat_qual_legal legal_qual = GetLegal_qual();
     name = x_GetLegalQualName(v_legal_qual, legal_qual);
     name = (name.empty() ? 
                  x_GetLegalQualName(v_legal_only_qual, legal_qual) : name);
     if (!name.empty()) {
        rval = x_GetQualViaFeatSeqTableColumn(name, feat, str_cons, scope);
     }

     // actual GenBank qualifiers
     if (rval.empty() && feat.CanGetQual()) {
        name = ENUM_METHOD_NAME(EFeat_qual_legal)()->FindName(legal_qual, true);
        int subfield = 0;
        if (name == "mobile-element-type-type") {
              name = "mobile-element-type";
              subfield = 1;
        }
         else if (name == "mobile-element-name") {
               name = "mobile-element-type";
               subfield = 2;
         }
         else if (name == "satellite-type") {
             name = "satellite";
             subfield = 1;
         }
         else if (name == "satellite-name") {
             name = "satellite";
             subfield = 2;
         }
         else if (name == "ec-number") {
             name = "EC-number";
         }
         else if (name == "pcr-conditions") {
             name = "PCR-conditions";
         }
         else if (name == "pseudo") {
             name = "pseudo";
         }
         NStr::Replace(name, "-", "_");
         if (name != "name" && name != "location") {
            rval 
              = x_GetFirstGBQualMatch(feat.GetQual(), name, subfield, str_cons);
         } 
     }
   }
}
*/

string CFeat_qual_choice :: x_GetLegalQualName(vector <EFeat_qual_legal>& v_qual, EFeat_qual_legal qual) const
{       
  ITERATE (vector <EFeat_qual_legal>, it, v_qual) {
    if (qual == *it) {
      string name = ENUM_METHOD_NAME(EFeat_qual_legal)()->FindName(qual, true);
      if (name == "name") {
           return ("region");
      }
      else if (name == "product") {
         return ("name");
      }
      else if (name == "gene") {
         return ("locus");
      }
      else if ( name == "locus-tag") {
          return("locus_tag");
      }
      return name;
    }
  }
  return kEmptyStr;
};

void CFeat_qual_choice :: x_GetTwoFieldSubfield(string& str, int subfield) const
{
  if (str.empty() || subfield > 2) {
      str = kEmptyStr;
  }
  if (subfield) {
    size_t pos = str.find(':');
    if (pos == string::npos) {
      if (subfield != 1) {
         str = kEmptyStr;
      }
    }
    else {
      if (subfield == 1) {
           str.substr(0, pos);
      }
      else {
        str = CTempString(str).substr(pos+1);
      }
    }
  }
};

string CFeat_qual_choice :: x_GetFirstGBQualMatch(const vector <CRef <CGb_qual> >& quals, const string& qual_name, int subfield, const CString_constraint& str_cons) const
{
  string str;
  ITERATE (vector <CRef <CGb_qual> >, it, quals) {
     if (NStr::EqualNocase( (*it)->GetQual(), qual_name)) {
        str = (*it)->GetVal();
        if (subfield) {
            x_GetTwoFieldSubfield(str, subfield);
        }
        if (str.empty() || !str_cons.Match(str)) {
           str = kEmptyStr;
        }
        else {
          break;
        }
     }
  }
  return str;
};

string CFeat_qual_choice :: GetFirstStringMatch(const list <string>& strs, const CString_constraint& str_cons)
{
   ITERATE (list <string>, sit, strs) {
     if ( !(*sit).empty() && str_cons.Match(*sit)) {
       return (*sit);
     }
   }
   return kEmptyStr;
};

string CFeat_qual_choice :: GetFirstStringMatch(const vector <string>& strs, const CString_constraint& str_cons)
{
   ITERATE (vector <string>, sit, strs) {
     if ( !(*sit).empty() && str_cons.Match(*sit)) {
        return (*sit);
     }
   }
   return kEmptyStr;
};

/*
string CFeat_qual_choice :: x_GetQualViaFeatSeqTableColumn(const string& name, const CSeq_feat& feat, const CString_constraint& str_cons, CConstRef <CScope> scope) const
{
   string rval;

   // for gene fields: GetGeneInfoForFeature (seq_feat, grp, gene);
   const CGene_ref* gene_ref = 0;
   const CSeq_feat* gene_feat = 0;
   if (feat.GetData().IsGene()) {
      gene_ref = &(feat.GetData().GetGene());
      gene_feat = &feat;
   }
   else {
      gene_ref = feat.GetGeneXref();
      if (!gene_ref) {
        CConstRef <CSeq_feat> 
          gene_feat_ref = sequence :: GetBestGeneForCds(feat,(CScope&)(*scope));
         if (gene_feat_ref.NotEmpty()) {
            gene_ref = &(gene_feat_ref->GetData().GetGene());
            gene_feat = gene_feat_ref.GetPointer();
         }
      }
      else if (gene_ref->IsSuppressed()) {
         gene_ref = 0;
      }
   }

   // for protein fields: GetProtRefForFeature (sfp)
   const CProt_ref* prot_ref=0;
   CBioseq_Handle prot_hl;
   if (feat.GetData().IsProt()) {
      prot_ref = &(feat.GetData().GetProt());
   }
   else if (feat.GetData().IsCdregion()) {
     prot_ref = feat.GetProtXref();
     if (!prot_ref && feat.CanGetProduct()) {
       CConstRef <CSeq_feat> 
         prot_seq_feat
           = sequence::GetBestOverlappingFeat(feat.GetProduct(),
                                             CSeqFeatData::e_Prot,
                                             sequence::eOverlap_Contains,
                                             (CScope&)(*scope));
       if (prot_seq_feat.NotEmpty()) {
         prot_ref = &(prot_seq_feat->GetData().GetProt());
       }
     }
   }

   set <string> gene_fields;
   gene_fields.insert("locus");
   gene_fields.insert("gene-description");
   gene_fields.insert("map");
   gene_fields.insert("allele");
   gene_fields.insert("locus_tag");
   gene_fields.insert("synonym");
// another:   gene_fields.insert("gene-comment");

   if (gene_fields.find(name) != gene_fields.end()) {
      if (gene_ref) {
         if (name == "locus") {
           if (gene_ref->CanGetLocus()) {
             rval = gene_ref->GetLocus();
           }
         }
         else if (name == "gene-description") {
           if (gene_ref->CanGetDesc()) {
              rval = gene_ref->GetDesc();
           }
         }   
         else if (name == "map") {
            if (gene_ref->CanGetMaploc()) {
              rval = gene_ref->GetMaploc();
            }
         }
         else if (name == "allele") {
            if (feat.GetData().GetSubtype() != CSeqFeatData::eSubtype_variation
                  && gene_ref->CanGetAllele()) {
               rval = gene_ref->GetAllele();
            }
         }
         else if (name == "locus_tag") {
            if (gene_ref->CanGetLocus_tag()) {
               rval = gene_ref->GetLocus_tag();
            }
         }
         else if (name == "synonym") {
            if (gene_ref->CanGetSyn()) {
               rval = GetFirstStringMatch(gene_ref->GetSyn(),str_cons);
            }
         }
      }
      if (name != "synonym" && !str_cons.Match(rval)) {
         rval = kEmptyStr;
      }
      return rval;
   }

   set <string> prot_fields;
   prot_fields.insert("description");
   prot_fields.insert("ec-number");
   prot_fields.insert("activity");
   if (prot_fields.find(name) != prot_fields.end()) {
      if (prot_ref) {
        if (name == "description") {
          if (prot_ref->CanGetDesc()) {
            rval = prot_ref->GetDesc();
            if (!rval.empty() && !str_cons.Match(rval)) {
               rval = kEmptyStr;
            } 
          }
        }  
        else if (name == "ec-number") {
           if (prot_ref->CanGetEc()) {
             rval = GetFirstStringMatch(prot_ref->GetEc(), str_cons);
           }
        }
        else if (name == "activity") {
          if (prot_ref->CanGetActivity()) {
             rval = GetFirstStringMatch (prot_ref->GetActivity(), str_cons);
          }
        }
        return rval;
      }
   }

   set <string> cd_fields;
   cd_fields.insert("transl-except");
   cd_fields.insert("transl-table");
   cd_fields.insert("translation");
   cd_fields.insert("codon-start");
   if (cd_fields.find(name) != cd_fields.end()) {
      if (!feat.GetData().IsCdregion()) {
        return kEmptyStr;
      }
      if (name == "transl-except") {
         if (feat.GetData().GetCdregion().CanGetCode_break()) {
            rval = x_GetCodeBreakString (feat, scope);
         }
      }
      else if (name == "transl-table") {
         if (feat.GetData().GetCdregion().CanGetCode()) {
            ITERATE (list < CRef <CGenetic_code::C_E> >, it,
                               feat.GetData().GetCdregion().GetCode().Get()) {
               if ( (*it)->IsId() ) {
                   rval = NStr::IntToString( (*it)->GetId());
               }
            }
         }
      }
      else if (name == "translation") {
         if (feat.CanGetProduct()) {
            CBioseq_Handle 
               prot_hl 
                  = sequence::GetBioseqFromSeqLoc(feat.GetProduct(),
                                                     (CScope&)(*scope));
            if (prot_hl && prot_hl.CanGetInst_Length()) {
               CSeqVector
                  seq_vec = prot_hl.GetSeqVector(CBioseq_Handle::eCoding_Iupac);
               seq_vec.GetSeqData(0, prot_hl.GetInst_Length(), rval);
            }
         }
      }
      else if (name == "codon-start") {
        if (feat.GetData().GetCdregion().CanGetFrame()) {
           rval = NStr::UIntToString((unsigned)feat.GetData().GetCdregion().GetFrame());
        }
        else rval = "1";
      }
      return rval;
   }

   vector <string> strs;
**
   if (!name.empty()) {
     CRef<CFeatureSeqTableColumnBase>
          feat_col (CFeatureSeqTableColumnBaseFactory::Create(name));
     if (feat_col) {
       if (name == "gene-comment" && gene_feat) {  // gene field
          rval = feat_col->GetFromFeature(*gene_feat);
          rval = (!str_cons.Match(rval) ? rval : kEmptyStr);
       }
       else {  // use feat in GetFromFeature
          rval = feat_col->GetFromFeature(feat);
          if (name == "product") {
             if (prot_ref) {
                 if (prot_ref->CanGetName()) {
                    rval = GetFirstStringMatch(prot_ref->GetName(), str_cons);
                 }
             }
             else if (!str_cons.Match(rval)) {
                 rval = kEmptyStr;
             }
          }
          else if (name== "db-xref" || name== "pseudo" || name== "tag-peptide"){
            vector <string> strs;
            strs = NStr::Tokenize(rval, ";", strs);
            rval = kEmptyStr;
            if (name == "db-xref") {
              ITERATE (vector <string>, it, strs) {
                 if (str_cons.Match(*it)) {
                    rval += *it + ";";
                 }
              }
              rval = CTempString(rval).substr(0, rval.size()-1);
            }
            else { // get 1st one
              ITERATE (vector <string>, it, strs) {
                 if (str_cons.Match(*it)) {
                    rval = *it;
                    break;
                 }
              } 
              if (name == "pesudo" 
                   && rval.empty() && feat.CanGetPseudo() && feat.GetPseudo()) {
                 rval = "unqualified";
              }
            }
            strs.clear();
          }
          else {
             if (name != "anticodon" && name != "codons-recognized") {
               if (!str_cons.Match(rval)) {
                 rval = kEmptyStr;
               }
             }
           }
       }
     }
   }
**

   return rval;  
};
*/

/*
string CFeat_qual_choice :: x_GetCodeBreakString(const CSeq_feat& feat, CConstRef <CScope> scope) const
{
  string rval(kEmptyStr);
  CBioseq_Handle 
       b_hl 
         = sequence::GetBioseqFromSeqLoc(feat.GetLocation(), (CScope&)(*scope));
  if (b_hl) {
     CFlatFileConfig 
        cfg(CFlatFileConfig::eFormat_GenBank, CFlatFileConfig::eMode_Release );
     CFlatFileContext ffctx(cfg);
     CBioseqContext ctx(b_hl, ffctx);
     const CCdregion& cd = feat.GetData().GetCdregion();
     if (cd.CanGetCode_break()) {
        CFlatCodeBreakQVal fcb(cd.GetCode_break());
        vector <CRef <CFormatQual> > quals;
        fcb.Format(quals, "transl_except", ctx, 0);
        ITERATE (vector <CRef <CFormatQual> >, it, quals) {
          rval += "/" + (*it)->GetName() + "=" + (*it)->GetValue() + "; ";
        }
     }
  };

  rval = CTempString(rval).substr(0, rval.size()-2);
  return rval;
};
*/

string CFeat_qual_choice :: x_GetFirstGBQualMatchConstraintName(const CSeq_feat& feat, const CString_constraint& str_cons) const
{
   string str;
   if (feat.CanGetQual()) {
     ITERATE (vector <CRef <CGb_qual> >, it, feat.GetQual()) {
        str = (*it)->GetVal();
        if (!str.empty() && str_cons.Match(str)) {
             return str;
        }
        else str = kEmptyStr;
     }
   }
   return str;
};

END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/* Original file checksum: lines: 57, chars: 1741, CRC32: 81a34e90 */
