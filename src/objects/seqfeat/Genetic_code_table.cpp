/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqfeat.asn'.
 */

// standard includes
#include <serial/serial.hpp>
#include <serial/objistr.hpp>

// generated includes
#include <objects/seqfeat/Genetic_code_table.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
CGenetic_code_table::~CGenetic_code_table(void)
{
}

// genetic code translation tables

// destructor
CTrans_table::~CTrans_table(void)
{
}

// translation finite state machine base codes - ncbi4na
enum EBaseCode {
    eBase_gap = 0,
    eBase_A,      /* A    */
    eBase_C,      /* C    */
    eBase_M,      /* AC   */
    eBase_G,      /* G    */
    eBase_R,      /* AG   */
    eBase_S,      /* CG   */
    eBase_V,      /* ACG  */
    eBase_T,      /* T    */
    eBase_W,      /* AT   */
    eBase_Y,      /* CT   */
    eBase_H,      /* ACT  */
    eBase_K,      /* GT   */
    eBase_D,      /* AGT  */
    eBase_B,      /* CGT  */
    eBase_N       /* ACGT */
};

// static instances of single copy translation tables common to all genetic codes
int   CTrans_table::sm_NextState  [4097];
int   CTrans_table::sm_RvCmpState [4097];
int   CTrans_table::sm_BaseToIdx  [256];

// initialize base conversion, next state, and reverse complement state tables
void CTrans_table::x_InitFsaTable (void)
{
    char         ch;
    int          i, j, k, p, q, r, nx, st;
    static char  charToBase [17] = "-ACMGRSVTWYHKDBN";
    static char  baseToComp [17] = "-TGKCYSBAWRDMHVN";

    // illegal characters map to 0
    for (i = 0; i < 256; i++) {
        sm_BaseToIdx [i] = 0;
    }

    // map iupacna alphabet to EBaseCode
    for (i = eBase_gap; i <= eBase_N; i++) {
        ch = charToBase [i];
        sm_BaseToIdx [(int) ch] = i;
        ch = tolower (ch);
        sm_BaseToIdx [(int) ch] = i;
    }
    sm_BaseToIdx [(int) 'U'] = eBase_T;
    sm_BaseToIdx [(int) 'u'] = eBase_T;
    sm_BaseToIdx [(int) 'X'] = eBase_N;
    sm_BaseToIdx [(int) 'x'] = eBase_N;

    // also map ncbi4na alphabet to EBaseCode
    for (i = eBase_gap; i <= eBase_N; i++) {
        sm_BaseToIdx [(int) i] = i;
    }

    // treat state 0 as already having seen NN,
    // avoiding single and double letter states
    sm_NextState [0] = 4081;
    sm_RvCmpState [0] = 4096;

    // states 1 through 4096 are triple letter states (---, --A, ..., NNT, NNN)
    for (i = eBase_gap, st = 1; i <= eBase_N; i++) {
        for (j = eBase_gap, nx = 1; j <= eBase_N; j++) {
            for (k = eBase_gap; k <= eBase_N; k++, st++, nx += 16) {
                sm_NextState [st] = nx;
                p = sm_BaseToIdx [(int) (Uint1) baseToComp [k]];
                q = sm_BaseToIdx [(int) (Uint1) baseToComp [j]];
                r = sm_BaseToIdx [(int) (Uint1) baseToComp [i]];
                sm_RvCmpState [st] = 256 * p + 16 * q + r + 1;
            }
        }
    }
}

// initialize genetic code specific translation tables
void CTrans_table::x_InitFsaTransl (const string *ncbieaa,
                                    const string *sncbieaa) const
{
    char        ch, aa, orf;
    bool        go_on;
    int         i, j, k, p, q, r, x, y, z, st, cd;
    static int  expansions [4] = {eBase_A, eBase_C, eBase_G, eBase_T};
                                // T = 0, C = 1, A = 2, G = 3
    static int  codonIdx [9] = {0, 2, 1, 0, 3, 0, 0, 0, 0};

    // return if unable to find ncbieaa and sncbieaa strings
    if (ncbieaa == 0 || sncbieaa == 0) return;

    // also check length of ncbieaa and sncbieaa strings
    if (ncbieaa->size () != 64 || sncbieaa->size () != 64) return;

    // ambiguous codons map to unknown amino acid or not start
    for (i = 0; i <= 4096; i++) {
        m_AminoAcid [i] = 'X';
        m_OrfStart [i] = '-';
    }

    // lookup amino acid for each codon in genetic code table
    for (i = eBase_gap, st = 1; i <= eBase_N; i++) {
        for (j = eBase_gap; j <= eBase_N; j++) {
            for (k = eBase_gap; k <= eBase_N; k++, st++) {
                aa = '\0';
                orf = '\0';
                go_on = true;

                // expand ambiguous IJK nucleotide symbols into component bases XYZ
                for (p = 0; p < 4 && go_on; p++) {
                    x = expansions [p];
                    if ((x & i) != 0) {
                        for (q = 0; q < 4 && go_on; q++) {
                            y = expansions [q];
                            if ((y & j) != 0) {
                                for (r = 0; r < 4 && go_on; r++) {
                                    z = expansions [r];
                                    if ((z & k) != 0) {

                                        // calculate offset in genetic code string
                                        cd = 16 * codonIdx [x] + 4 * codonIdx [y] + codonIdx [z];

                                        // lookup amino acid for codon XYZ
                                        ch = (*ncbieaa) [cd];
                                        if (aa == '\0') {
                                            aa = ch;
                                        } else if (aa != ch) {
                                            // allow Asx (Asp or Asn) and Glx (Glu or Gln)
                                            if ((aa == 'B' || aa == 'D' || aa == 'N') &&
                                                (ch == 'D' || ch == 'N')) {
                                                aa = 'B';
                                            } else if ((aa == 'Z' || aa == 'E' || aa == 'Q') &&
                                                       (ch == 'E' || ch == 'Q')) {
                                                aa = 'Z';
                                            } else {
                                                aa = 'X';
                                            }
                                        }

                                        // lookup translation start flag
                                        ch = (*sncbieaa) [cd];
                                        if (orf == '\0') {
                                            orf = ch;
                                        } else if (orf != ch) {
                                            orf = 'X';
                                        }

                                        // drop out of loop as soon as answer is known
                                        if (aa == 'X' && orf == 'X') {
                                            go_on = false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // assign amino acid and orf start
                if (aa != '\0') {
                    m_AminoAcid [st] = aa;
                }
                if (orf != '\0') {
                    m_OrfStart [st] = orf;
                }
            }
        }
    }
}

// implementation class for genetic code table and translation tables

class CGen_code_table_imp : public CObject
{
public:
    // constructor
    CGen_code_table_imp(void);
    // destructor
    ~CGen_code_table_imp(void);

    // return initialized translation table given genetic code
    const CTrans_table & GetTransTable (int  gc);
    const CTrans_table & GetTransTable (const CGenetic_code & gc);

private:
    // Genetic code table data
    CRef <CGenetic_code_table> m_GcTable;

    // typedefs
    typedef vector< CRef< CTrans_table > > TTransTablesById;

    // translation tables
    TTransTablesById  m_TransTablesById;

    // Initialize genetic-code table
    void InitGcTable (void);

    // Initialize translation table
    void InitTransTables (void);
};

// single instance of implementation class is initialized before Main
static CGen_code_table_imp s_cgencodeimp;


// public access functions

const CTrans_table & CGen_code_table::GetTransTable (int id)
{
    return s_cgencodeimp.GetTransTable (id);
}

const CTrans_table & CGen_code_table::GetTransTable (const CGenetic_code & gc)
{
    return s_cgencodeimp.GetTransTable (gc);
}

// constructor
CGen_code_table_imp::CGen_code_table_imp(void)
{
    InitGcTable ();
    CTrans_table::x_InitFsaTable ();
}

// destructor
CGen_code_table_imp::~CGen_code_table_imp(void)
{
}

// constructor
CTrans_table::CTrans_table(const CGenetic_code & gc)
{
    const string * ncbieaa  = 0;
    const string * sncbieaa = 0;

    iterate (CGenetic_code::Tdata, gcd, gc.Get ()) {
        switch ((*gcd)->Which ()) {
            case CGenetic_code::C_E::e_Ncbieaa :
                ncbieaa = & (*gcd)->GetNcbieaa ();
                break;
            case CGenetic_code::C_E::e_Sncbieaa :
                sncbieaa = & (*gcd)->GetSncbieaa ();
                break;
        }
    }

    // throw exception if unable to find ncbieaa and sncbieaa strings
    if (ncbieaa == 0 || sncbieaa == 0) {
        NCBI_THROW (CException, eUnknown, "Could not find ncbieaa and sncbieaa");
    }

    x_InitFsaTransl (ncbieaa, sncbieaa);
}

const CTrans_table & CGen_code_table_imp::GetTransTable (int id)
{
    if (id < m_TransTablesById.size ()) {
        CRef< CTrans_table> tbl = m_TransTablesById [id];
        if (tbl != 0) {
        	// already in list, already initialized, so return
            return *tbl;
        }
    }


    // this mutex is automatically freed when the function exits
    static CFastMutex mtx;
    CFastMutexGuard   LOCK (mtx);

    // test again within mutex lock to see if another thread was just adding it

    if (id < m_TransTablesById.size ()) {
        CRef< CTrans_table> tbl = m_TransTablesById [id];
        if (tbl != 0) {
        	// already in list, already initialized, so return
            return *tbl;
        }
    }

    // now look for the genetic code and initialize the translation table

    iterate (CGenetic_code_table::Tdata, gcl, m_GcTable->Get ()) {
        iterate (CGenetic_code::Tdata, gcd, (*gcl)->Get ()) {
            if ((*gcd)->IsId ()  &&  (*gcd)->GetId () == id) {

        	    // found proper genetic code, so create new trans table
        	    CRef< CTrans_table> tbl = new CTrans_table (**gcl);

        	    // extend size of translation table list, if necessary
        	    if (id >= m_TransTablesById.size ()) {
        	        m_TransTablesById.resize (id + 1);
        	    }

        	    // add new table to list of translation tables
        	    m_TransTablesById [id] = tbl;

        	    return *tbl;
            }
        }
    }

    // throw exception if failure
    NCBI_THROW (CException, eUnknown, "Unable to find genetic code number " +
                NStr::IntToString (id));
}

const CTrans_table & CGen_code_table_imp::GetTransTable (const CGenetic_code & gc)
{
    const string * ncbieaa  = 0;
    const string * sncbieaa = 0;

    iterate (CGenetic_code::Tdata, gcd, gc.Get ()) {
        switch ((*gcd)->Which ()) {
            case CGenetic_code::C_E::e_Id :
                // lookup table by ID
                int id = (*gcd)->GetId ();
                return GetTransTable (id);
                break;
            case CGenetic_code::C_E::e_Ncbieaa :
                ncbieaa = & (*gcd)->GetNcbieaa ();
                break;
            case CGenetic_code::C_E::e_Sncbieaa :
                sncbieaa = & (*gcd)->GetSncbieaa ();
                break;
        }
    }

    if (ncbieaa != 0  &&  sncbieaa != 0) {
      // return * new CTrans_table (gc);

      NCBI_THROW (CException, eUnknown, "GetTransTable without ID not yet supported");
    }

    NCBI_THROW (CException, eUnknown, "GetTransTable does not have sufficient information");
}

// local copy of gc.prt
static const char * kGenCodeTblMemStr = "Genetic-code-table ::= {\n" \
"{ name \"Standard\" , name \"SGC0\" , id 1 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"---M---------------M---------------M----------------------------\" } ,\n" \
"{ name \"Vertebrate Mitochondrial\" , name \"SGC1\" , id 2 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRRIIMMTTTTNNKKSS**VVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"--------------------------------MMMM---------------M------------\" } ,\n" \
"{ name \"Yeast Mitochondrial\" , name \"SGC2\" , id 3 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CCWWTTTTPPPPHHQQRRRRIIMMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"----------------------------------MM----------------------------\" } ,\n" \
"{ name \"Mold Mitochondrial; Protozoan Mitochondrial; Coelenterate\n" \
"Mitochondrial; Mycoplasma; Spiroplasma\" ,\n" \
"name \"SGC3\" , id 4 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"--MM---------------M------------MMMM---------------M------------\" } ,\n" \
"{ name \"Invertebrate Mitochondrial\" , name \"SGC4\" , id 5 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRRIIMMTTTTNNKKSSSSVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"---M----------------------------MMMM---------------M------------\" } ,\n" \
"{ name \"Ciliate Nuclear; Dasycladacean Nuclear; Hexamita Nuclear\" ,\n" \
"name \"SGC5\" , id 6 ,\n" \
"ncbieaa  \"FFLLSSSSYYQQCC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"-----------------------------------M----------------------------\" } ,\n" \
"{ name \"Echinoderm Mitochondrial\" , name \"SGC8\" , id 9 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRRIIIMTTTTNNNKSSSSVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"-----------------------------------M---------------M------------\" } ,\n" \
"{ name \"Euplotid Nuclear\" , name \"SGC9\" , id 10 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CCCWLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"-----------------------------------M----------------------------\" } ,\n" \
"{ name \"Bacterial and Plant Plastid\" , id 11 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"---M---------------M------------MMMM---------------M------------\" } ,\n" \
"{ name \"Alternative Yeast Nuclear\" , id 12 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CC*WLLLSPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"-------------------M---------------M----------------------------\" } ,\n" \
"{ name \"Ascidian Mitochondrial\" , id 13 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRRIIMMTTTTNNKKSSGGVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"-----------------------------------M----------------------------\" } ,\n" \
"{ name \"Flatworm Mitochondrial\" , id 14 ,\n" \
"ncbieaa  \"FFLLSSSSYYY*CCWWLLLLPPPPHHQQRRRRIIIMTTTTNNNKSSSSVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"-----------------------------------M----------------------------\" } ,\n" \
"{ name \"Blepharisma Macronuclear\" , id 15 ,\n" \
"ncbieaa  \"FFLLSSSSYY*QCC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"-----------------------------------M----------------------------\" } ,\n" \
"{ name \"Chlorophycean Mitochondrial\" , id 16 ,\n" \
"ncbieaa  \"FFLLSSSSYY*LCC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"-----------------------------------M----------------------------\" } ,\n" \
"{ name \"Trematode Mitochondrial\" , id 21 ,\n" \
"ncbieaa  \"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRRIIMMTTTTNNNKSSSSVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"-----------------------------------M---------------M------------\" } ,\n" \
"{ name \"Scenedesmus obliquus mitochondrial\" , id 22 ,\n" \
"ncbieaa  \"FFLLSS*SYY*LCC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"-----------------------------------M----------------------------\" } ,\n" \
"{ name \"Thraustochytrium mitochondrial code\" , id 23 ,\n" \
"ncbieaa  \"FF*LSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\",\n" \
"sncbieaa \"--------------------------------M--M---------------M------------\" } };\n";

// initialize genetic code specific translation tables
void CGen_code_table_imp::InitGcTable (void)
{
    // Create an in memory stream on kGenCodeTblMemStr
    CNcbiIstrstream is (kGenCodeTblMemStr);
    auto_ptr<CObjectIStream>
        asn_codes_in(CObjectIStream::Open(eSerial_AsnText, is));

    // Create m_GcTable and initialize from asn_codes_in
    m_GcTable = new CGenetic_code_table;
    *asn_codes_in >> *m_GcTable;
}

END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE


/*
* ===========================================================================
*
* $Log$
* Revision 6.1  2002/09/09 20:58:21  kans
* added CTrans_table and CGen_code_table classes
*
*
* ===========================================================================
*/
/* Original file checksum: lines: 64, chars: 1914, CRC32: 6d579336 */
