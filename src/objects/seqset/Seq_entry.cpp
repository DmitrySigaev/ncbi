/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqset.asn'.
 */

// standard includes

// generated includes
#include <objects/seqset/seqset_exception.hpp>
#include <objects/seqset/Seq_entry.hpp>
#include <objects/seqset/Bioseq_set.hpp>

#include <objects/seq/Bioseq.hpp>
#include <objects/seq/Delta_ext.hpp>
#include <objects/seq/Delta_seq.hpp>
#include <objects/seq/IUPACaa.hpp>
#include <objects/seq/IUPACna.hpp>
#include <objects/seq/Seq_descr.hpp>
#include <objects/seq/Seq_ext.hpp>
#include <objects/seq/Seq_inst.hpp>
#include <objects/seq/Seq_literal.hpp>
#include <objects/seq/Seqdesc.hpp>
#include <objects/seq/seqport_util.hpp>

#include <objects/seqloc/Seq_id.hpp>
#include <objects/seqloc/Seq_loc.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
CSeq_entry::~CSeq_entry(void)
{
}

void CSeq_entry::Parentize(void)
{
    if (m_ParentEntry != 0) {
        return; // already parentized
    }
    if ( IsSeq() ) {
        SetSeq().SetParentEntry(this);
    }
    else {
        CBioseq_set::TSeq_set::iterator s_end =
            SetSet().SetSeq_set().end();
        for (CBioseq_set::TSeq_set::iterator si =
            SetSet().SetSeq_set().begin(); si != s_end; si++) {
            (*si)->Parentize();
            (*si)->SetParentEntry(this);
        }
    }
    // Consider this to be the tree root.
    m_ParentEntry = this;
}

void CSeq_entry::UserOp_Assign(const CSerialUserOp& source)
{
    const CSeq_entry& src = dynamic_cast<const CSeq_entry&>(source);
    m_ParentEntry = 0;
}

bool CSeq_entry::UserOp_Equals(const CSerialUserOp& object) const
{
    const CSeq_entry& obj = dynamic_cast<const CSeq_entry&>(object);
    return m_ParentEntry == obj.m_ParentEntry;
}


SIZE_TYPE s_EndOfFastaID(const string& str, SIZE_TYPE pos)
{
    SIZE_TYPE vbar = str.find('|', pos);
    if (vbar == NPOS) {
        return NPOS; // bad
    }

    CSeq_id::E_Choice choice =
        CSeq_id::WhichInverseSeqId(str.substr(pos, vbar - pos).c_str());

#if 1
    if (choice != CSeq_id::e_not_set) {
        SIZE_TYPE vbar_prev = vbar;
        int count;
        for (count=0; ; ++count, vbar_prev = vbar) {
            vbar = str.find('|', vbar_prev + 1);
            if (vbar == NPOS) {
                break;
            }
            choice = CSeq_id::WhichInverseSeqId(
                str.substr(vbar_prev + 1, vbar - vbar_prev - 1).c_str());
            if (choice != CSeq_id::e_not_set) {
                vbar = vbar_prev;
                break;
            }
        }
    } else {
        return NPOS; // bad
    }
#else
    switch (choice) {
    case CSeq_id::e_Patent: case CSeq_id::e_Other: // 3 args
        vbar = str.find('|', vbar + 1);
        // intentional fall-through - this allows us to correctly
        // calculate the number of '|' separations for FastA IDs

    case CSeq_id::e_Genbank:   case CSeq_id::e_Embl:    case CSeq_id::e_Pir:
    case CSeq_id::e_Swissprot: case CSeq_id::e_General: case CSeq_id::e_Ddbj:
    case CSeq_id::e_Prf:       case CSeq_id::e_Pdb:     case CSeq_id::e_Tpg:
    case CSeq_id::e_Tpe:       case CSeq_id::e_Tpd:
        // 2 args
        if (vbar == NPOS) {
            return NPOS; // bad
        }
        vbar = str.find('|', vbar + 1);
        // intentional fall-through - this allows us to correctly
        // calculate the number of '|' separations for FastA IDs

    case CSeq_id::e_Local: case CSeq_id::e_Gibbsq: case CSeq_id::e_Gibbmt:
    case CSeq_id::e_Giim:  case CSeq_id::e_Gi:
        // 1 arg
        if (vbar == NPOS) {
            if (choice == CSeq_id::e_Other) {
                // this is acceptable - member is optional
                break;
            }
            return NPOS; // bad
        }
        vbar = str.find('|', vbar + 1);
        break;

    default: // unrecognized or not set
        return NPOS; // bad
    }
#endif

    return (vbar == NPOS) ? str.size() : vbar;
}


static void s_FixSeqData(CBioseq* seq)
{
    if (seq == 0) {
        return;
    }
    CSeq_inst& inst = seq->SetInst();
    if (inst.IsSetExt()  &&  inst.GetExt().IsDelta()) {
        TSeqPos length = 0;
        non_const_iterate (CDelta_ext::Tdata, it,
                           inst.SetExt().SetDelta().Set()) {
            if ((*it)->IsLiteral()) {
                CSeq_literal& lit  = (*it)->SetLiteral();
                CSeq_data&    data = lit.SetSeq_data();
                if (data.IsIupacna()) {
                    lit.SetLength(data.GetIupacna().Get().size());
                    CSeqportUtil::Pack(&data);
                } else {
                    lit.SetLength(data.GetIupacaa().Get().size());
                }
                length += lit.GetLength();
            }
        }
    } else {
        CSeq_data& data = inst.SetSeq_data();
        if (data.IsIupacna()) {
            inst.SetLength(data.GetIupacna().Get().size());
            CSeqportUtil::Pack(&data);
        } else {
            inst.SetLength(data.GetIupacaa().Get().size());
        }        
    }
}


static CSeq_data& s_LastData(CSeq_inst& inst)
{
    if (inst.IsSetExt()  &&  inst.GetExt().IsDelta()) {
        CDelta_ext::Tdata& delta_data = inst.SetExt().SetDelta().Set();
        if (delta_data.empty()  ||  !delta_data.back()->IsLiteral()) {
            CRef<CDelta_seq> delta_seq(new CDelta_seq);
            delta_data.push_back(delta_seq);
            return delta_seq->SetLiteral().SetSeq_data();
        } else {
            return delta_data.back()->SetLiteral().SetSeq_data();
        }
    } else {
        return inst.SetSeq_data();
    }
}


CRef<CSeq_entry> ReadFasta(CNcbiIstream& in, TReadFastaFlags flags)
{
    CRef<CSeq_entry>       entry(new CSeq_entry);
    CBioseq_set::TSeq_set& sset  = entry->SetSet().SetSeq_set();
    CRef<CBioseq>          seq(0); // current Bioseq
    string                 line;

    while ( !in.eof() ) {
        if ((flags & fReadFasta_OneSeq)  &&  seq.NotEmpty()
            &&  (in.peek() == '>')) {
            break;
        }
        NcbiGetlineEOL(in, line);
        if (in.eof()  &&  line.empty()) {
            break;
        }
        if (line[0] == '>') {
            // new sequence
            SIZE_TYPE       space = line.find_first_of(" \t");
            string          name  = line.substr(1, space - 1), local;
            CSeq_inst::EMol mol   = CSeq_inst::eMol_not_set;

            s_FixSeqData(seq);
            seq = new CBioseq;
            seq->SetInst().SetRepr(CSeq_inst::eRepr_raw);
            {{
                CRef<CSeq_entry> entry2(new CSeq_entry);
                entry2->SetSeq(*seq);
                sset.push_back(entry2);
            }}
            if (flags & fReadFasta_NoParseID) {
                local = name;
            } else {
                // try to parse out IDs
                SIZE_TYPE pos = 0;
                while (pos < name.size()) {
                    SIZE_TYPE end = s_EndOfFastaID(name, pos);
                    if (end == NPOS) {
                        if (pos > 0) {
                            NCBI_THROW2(CSeqsetParseException, eFormat,
                                        "ReadFasta: Bad ID "
                                        + name.substr(pos),
                                        pos);
                        } else {
                            local = name;
                            break;
                        }
                    }

                    CRef<CSeq_id> id(new CSeq_id(name.substr(pos, end - pos)));
                    seq->SetId().push_back(id);
                    if (mol == CSeq_inst::eMol_not_set
                        &&  !(flags & fReadFasta_ForceType)) {
                        CSeq_id::EAccessionInfo ai = id->IdentifyAccession();
                        if (ai & CSeq_id::fAcc_nuc) {
                            mol = CSeq_inst::eMol_na;
                        } else if (ai & CSeq_id::fAcc_prot) {
                            mol = CSeq_inst::eMol_na;
                        }
                    }
                    pos = end + 1;
                }
            }
            
            if ( !local.empty() ) {
                seq->SetId().push_back
                    (CRef<CSeq_id>(new CSeq_id(CSeq_id::e_Local, local,
                                               kEmptyStr)));
            }

            if (mol == CSeq_inst::eMol_not_set) {
                if (flags & fReadFasta_AssumeNuc) {
                    _ASSERT(!(flags & fReadFasta_AssumeProt));
                    mol = CSeq_inst::eMol_na;
                } else {
                    _ASSERT(flags & fReadFasta_AssumeProt);
                    mol = CSeq_inst::eMol_aa;
                }
            }
            seq->SetInst().SetMol(mol);

            if (space != NPOS) {
                CRef<CSeqdesc> desc(new CSeqdesc);
                desc->SetTitle(line.substr(space + 1));
                seq->SetDescr().Set().push_back(desc);
            }
        } else {
            // actual data; may contain embedded junk
            CSeq_inst& inst = seq->SetInst();
            string residues;
            for (SIZE_TYPE i = 0;  i < line.size();  ++i) {
                char c = line[i];
                if (isalpha(c)) {
                    residues += (char)toupper(c);
                } else if (c == '-'  &&  (flags & fReadFasta_ParseGaps)) {
                    CDelta_ext::Tdata& d = inst.SetExt().SetDelta().Set();
                    if (inst.GetRepr() == CSeq_inst::eRepr_raw) {
                        CRef<CDelta_seq> ds(new CDelta_seq);
                        inst.SetRepr(CSeq_inst::eRepr_delta);
                        if (inst.IsSetSeq_data()) {
                            ds->SetLiteral().SetSeq_data(inst.SetSeq_data());
                            d.push_back(ds);
                            inst.ResetSeq_data();
                        }
                    }
                    if ( !residues.empty() ) {
                        CSeq_data& data = s_LastData(inst);
                        if (inst.GetMol() == CSeq_inst::eMol_aa) {
                            data.SetIupacaa().Set() += residues;
                        } else {
                            data.SetIupacna().Set() += residues;
                        }                        
                    }
                    {{
                        CRef<CDelta_seq> gap(new CDelta_seq);
                        gap->SetLoc().SetNull();
                        d.push_back(gap);
                    }}
                }
            }
            
            // Add the accumulated data...
            {{
                CSeq_data& data = s_LastData(inst);
                if (inst.GetMol() == CSeq_inst::eMol_aa) {
                    data.SetIupacaa().Set() += residues;
                } else {
                    data.SetIupacna().Set() += residues;
                }
            }}
        }
    }

    s_FixSeqData(seq);
    // simplify if possible
    if (sset.size() == 1) {
        entry->SetSeq(*seq);
    }
    return entry;
}

END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/*
 * ===========================================================================
 *
 * $Log$
 * Revision 6.15  2003/03/10 21:08:19  grichenk
 * UserOp_Assign resets m_Parent
 *
 * Revision 6.14  2003/02/24 20:03:11  gouriano
 * use template-based exceptions instead of errno and parse exceptions
 *
 * Revision 6.13  2003/01/13 20:01:24  gouriano
 * corrected parsing fasta seq ids
 *
 * Revision 6.12  2003/01/10 19:34:50  gouriano
 * corrected s_EndOfFastaID in case of incomplete CSeq_id::e_Other
 *
 * Revision 6.11  2003/01/06 16:14:04  gouriano
 * corrected ReadFasta: set sequence's molecule class
 *
 * Revision 6.10  2003/01/03 13:16:08  dicuccio
 * Minor formatting change.  Added comment about intentional fall-through.  Fixed
 * big in parsing of FastA IDs: must skip trailing space in ID string
 *
 * Revision 6.9  2002/11/25 18:50:01  ucko
 * Skip initial > when parsing IDs (caught by Mike DiCuccio)
 *
 * Revision 6.8  2002/11/04 21:29:17  grichenk
 * Fixed usage of const CRef<> and CRef<> constructor
 *
 * Revision 6.7  2002/10/30 02:34:41  ucko
 * Change seq to seq.NotEmpty() in compound test to make MSVC happy.
 *
 * Revision 6.6  2002/10/29 22:09:36  ucko
 * +fReadFasta_OneSeq
 *
 * Revision 6.5  2002/10/23 19:23:15  ucko
 * Move the FASTA reader from objects/util/sequence.?pp to
 * objects/seqset/Seq_entry.?pp because it doesn't need the OM.
 * Move the CVS log to the end of the file per current practice.
 *
 * Revision 6.4  2002/07/25 15:01:55  grichenk
 * Replaced non-const GetXXX() with SetXXX()
 *
 * Revision 6.3  2002/05/22 14:03:41  grichenk
 * CSerialUserOp -- added prefix UserOp_ to Assign() and Equals()
 *
 * Revision 6.2  2001/07/16 16:22:50  grichenk
 * Added CSerialUserOp class to create Assign() and Equals() methods for
 * user-defind classes.
 * Added SerialAssign<>() and SerialEquals<>() functions.
 *
 * Revision 6.1  2001/06/13 14:59:33  grichenk
 * Initial revision
 *
 * ===========================================================================
 */
/* Original file checksum: lines: 61, chars: 1886, CRC32: 18c50f7 */
