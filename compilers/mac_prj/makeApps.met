-- C++ libs --

property pRootFolderName : "ncbi_cxx" -- name of the toolkit directory
property pRootFolderPath : "" -- full path of the parent of the toolkit directory. Optional
property pFLTKRootFolder : "" -- full path of the FLTK directory. Optional.

property pProjectFileExt : ".mcp"
property pAppExt : ".app"
property pCPlusPlusExt : ".cpp"
property pStaticLibExt : ".lib"
property pDynaLibExt : ".dylib"

-- Whether to recreate existing project files.
property pAlwaysCreateProjects : false

-- But profiling doesn't work for Mach-O Codewarrior projects currently.
property pCreateProfiledTargets : false

-- Whether to compile anything.
property pShouldBuild : true

property pStationeryName : "ApplicationStationery"

property pTargetKeyWords : "MSL BSD Debug Final"

--
--  Set Global variables
--

global gHomeDir
global gDistribRoot
global gProjectsDir
global gSourceDir
global gIncludeDir
global gRsrcsDir
global gMakeDir
global gLibsDir
global gFLTKRootFolder

global gProjectData

on ProjectData(projName, features, aFileData)
	
	if (count characters of projName) > 25 then
		set projName to characters 1 through 25 of projName as string
	end if
	
	tell application "CodeWarrior IDE"
		
		if features does not contain "C" and features does not contain "C++" then
			copy "C++" to end of features
		end if
		set myFeatures to features
		
		return {name:projName, features:myFeatures, rsrcs:{"Info.plc"}, settings:Â
			{Prefix File:"", ppcProject:{}}, projLibs:{}, dynaLibs:{}, sysPaths:{}, fileData:Â
			aFileData}
		
	end tell
end ProjectData

on SimpleProjectData(projName, section, features)
	
	-- Simple: the project name is also the name of the source file in the project.
	set myFileList to {projName}
	
	tell application "CodeWarrior IDE"
		
		if features does not contain "C" and features does not contain "C++" then
			copy "C++" to end of features
		end if
		set myFeatures to features
		if section contains ":" then
			set myLibs to {}
			set myPath to section & ":"
		else
			set myLibs to {section}
			set myPath to section & ":test:"
		end if
		return {name:projName, features:myFeatures, rsrcs:{"Info.plc"}, settings:Â
			{Prefix File:"", ppcProject:{}}, projLibs:myLibs, dynaLibs:{}, fileData:Â
			{my mkFileDataListFiles(gSourceDir & myPath, myFileList)}}
		
	end tell
end SimpleProjectData

on ComplexProjectData(projName, section, features, filesToAdd)
	
	tell application "CodeWarrior IDE"
		
		if features does not contain "C" and features does not contain "C++" then
			copy "C++" to end of features
		end if
		set myFeatures to features
		
		if section contains ":" then
			set myLibs to {}
			set myPath to section & ":"
		else
			set myLibs to {section}
			set myPath to section & ":test:"
		end if
		return {name:projName, features:myFeatures, rsrcs:{"Info.plc"}, settings:Â
			{Prefix File:"", ppcProject:{}}, projLibs:myLibs, dynaLibs:{}, fileData:Â
			{my mkFileDataListFiles(gSourceDir & myPath, filesToAdd)}}
		
	end tell
end ComplexProjectData

on AddProject(projData)
	copy projData to end of gProjectData
end AddProject

on AddSimpleProject(projName, features, section)
	AddProject(ProjectData(projName, features, {mkFileData(gSourceDir & section)}))
end AddSimpleProject

on AddSimpleProjectListFiles(projName, features, section, fileList)
	AddProject(ProjectData(projName, features, {mkFileDataListFiles(gSourceDir & section, fileList)}))
end AddSimpleProjectListFiles

on AddSimpleProjectExceptFiles(projName, features, section, fileNotList)
	AddProject(ProjectData(projName, features, {mkFileDataExceptFiles(gSourceDir & section, fileNotList)}))
end AddSimpleProjectExceptFiles

on mkFileData(fullPath)
	if (fullPath does not end with ":") then set fullPath to fullPath & ":"
	return {projPath:fullPath, fileList:GetFileNames(fullPath), fileNotList:{}}
end mkFileData

on mkFileDataListFiles(fullPath, fileList)
	if (fullPath does not end with ":") then set fullPath to fullPath & ":"
	return {projPath:fullPath, fileList:fileList, fileNotList:{}}
end mkFileDataListFiles

on mkFileDataExceptFiles(fullPath, fileNotList)
	if (fullPath does not end with ":") then set fullPath to fullPath & ":"
	return {projPath:fullPath, fileList:GetFileNames(fullPath), fileNotList:fileNotList}
end mkFileDataExceptFiles

on mkFileDataNoUL(fullPath) -- Get all the files, minus those whose basename ends with an underscore.
	set fileData to mkFileData(fullPath)
	set newFileList to {}
	repeat with f in fileList of fileData
		if f does not end with ("_.cpp") then
			copy f as text to end of newFileList
		end if
	end repeat
	set fileList of fileData to newFileList
	return fileData
end mkFileDataNoUL

on AppData(projName, features, section, staticLibs, dynamicLibs)
	set appProjData to ProjectData(projName, features, {mkFileDataNoUL(gSourceDir & section)})
	return DataPlusLibs(appProjData, staticLibs, dynamicLibs)
end AppData

on AddAppProject(projName, features, section, staticLibs, dynamicLibs)
	AddProject(AppData(projName, features, section, staticLibs, dynamicLibs))
end AddAppProject

on DataPlusSources(dataRec, newSrcs)
	repeat with i in newSrcs
		copy i to end of fileList of item 1 of fileData of dataRec
	end repeat
	return dataRec
end DataPlusSources

on DataPlusLibs(dataRec, newLibs, newDlls)
	repeat with i in newLibs
		copy i to end of projLibs of dataRec
	end repeat
	repeat with i in newDlls
		copy i to end of dynaLibs of dataRec
	end repeat
	return dataRec
end DataPlusLibs

on HideFolder(folderPath)
	tell application "Finder"
		if exists folder folderPath then
			set theName to name of folder folderPath
			set name of folder folderPath to ("(" & theName & ")")
		end if
	end tell
end HideFolder

on GetFileNames(fullSourcePath)
	set theFiles to list folder (fullSourcePath) without invisibles
	set theCFiles to EndsWith(theFiles, ".c")
	set theCppFiles to EndsWith(theFiles, pCPlusPlusExt)
	return theCFiles & theCppFiles
end GetFileNames

on EndsWith(aList, suffix)
	set newList to {}
	repeat with f in aList
		if (f ends with suffix) then
			copy (f as string) to end of newList
		end if
	end repeat
	return newList
end EndsWith

on SetProjectData()
	
	tell application "CodeWarrior IDE"
		
		set corelib to "corelib"
		set connect to "connect"
		set serial to "serial"
		set util to "util"
		set html to "html"
		
		set commonObjLibs to {Â
			"xncbi", "xser", "xutil", Â
			"seqset", "seq", "seqres", "seqloc", Â
			"seqcode", "seqalign", "seqfeat", "seqblock", Â
			"pub", "medline", "biblio", "general", "submit"}
		
		set objMgrLibs to {Â
			"seq", "seqcode", "cdd", "seqset", Â
			"pub", "biblio", "pubmed", "medline", Â
			"general", "submit", "xobjmgr", "id1", "xser", "xobjutil", "xutil", "xconnect", "xncbi"}
		
		-- datatool
		set myName to "datatool"
		set myFeatures to {"C++", "cmdline"}
		set mySettings to {Prefix File:"", ppcProject:{}}
		set myRsrcs to {"ncbilogo.r", "Info.plc"}
		set myLibs to {"xncbi", "xser", "xutil"}
		-- use all the files in the datatool directory
		set myFiles to {my mkFileData(gSourceDir & "serial:datatool:")}
		set datatoolData to {name:myName, features:myFeatures, settings:mySettings, rsrcs:myRsrcs, projLibs:myLibs, dynaLibs:{}, fileData:myFiles} Â
			
		
	end tell
	
	---------- GENOME WORK BENCH ----------
	AddAppProject("gbench", {"fltk", "sockets", "libdl"}, "gui:gbench", Â
		{"w_flek", "w_table"}, {"gui_core"})
	AddAppProject("gbench_plugin_scan", {"libdl", "cmdline", "plainname"}, "gui:gbench:gbench_plugin_scan", Â
		{}, {"gui_core"})
	
	---------- SERIAL ----------	
	AddProject(datatoolData)
	
	---------- OBJECTS ----------	
	AddProject(DataPlusLibs(SimpleProjectData("asn2asn", "app:asn2asn", {"C++"}), commonObjLibs, {}))
	AddProject(DataPlusLibs(ComplexProjectData("testvalidator", "objtools:validator:test", {"C++", "sockets"}, {"test_validator"}), Â
		objMgrLibs & {"xvalidate"}, {}))
	AddProject(DataPlusLibs(SimpleProjectData("id1_fetch_simple", "app:id1_fetch", {"C++", "sockets"}), Â
		commonObjLibs & {"id1", "xconnect"}, {}))
	
	
end SetProjectData


--  Set Global variables

on IsOSX()
	tell application "Finder"
		set vers to the version as text
		if second character of vers is equal to "." then
			set vers to "0" & vers
		end if
		return vers > 10 or vers = 10
	end tell
end IsOSX

on HomeDir()
	tell application "Finder"
		return the home as string
	end tell
end HomeDir

on ResolveAlias(pathname)
	tell application "Finder"
		if exists folder pathname then
			-- if pathname does not end with ":" then set pathname to pathname & ":"
			return folder pathname as string
		end if
		if exists alias file pathname then return the original item of alias file pathname as string
	end tell
	return ""
end ResolveAlias

on ModuleRoot()
	set modRoot to ""
	try
		set modRoot to ResolveAlias(pRootFolderPath & pRootFolderName)
	end try
	if modRoot is "" then
		set modRoot to ResolveAlias(gHomeDir & pRootFolderName)
	end if
	return modRoot
end ModuleRoot

on IsFltkFolder(aFolder, findit)
	set aFolder to ResolveAlias(aFolder)
	if aFolder is "" then return ""
	set pfolder to POSIX path of aFolder
	if findit then
		set aFltkRoot to do shell script ("ls -1r " & pfolder & "*/src/Fl.cxx | head -1")
	else
		set aFltkRoot to do shell script ("ls -1r " & pfolder & "src/Fl.cxx | head -1")
	end if
	if aFltkRoot is "" then return ""
	set aFltkRoot to (POSIX file aFltkRoot) as string
	-- strip off 'src/FL.cxx' from th path.
	set text item delimiters of AppleScript to ":"
	set aFltkRoot to (text items 1 thru -3 of aFltkRoot) as string
	set text item delimiters of AppleScript to ""
	return aFltkRoot & ":"
end IsFltkFolder

on FLTKRoot()
	-- look where specified.
	set aFltkRoot to IsFltkFolder(pFLTKRootFolder, false)
	if aFltkRoot is "" then
		-- look next to the C++ toolkit directory.
		set aFltkRoot to IsFltkFolder(pRootFolderPath, true)
		if aFltkRoot is "" then
			-- look in our home directory.
			set aFltkRoot to IsFltkFolder(gHomeDir, true)
		end if
	end if
	return aFltkRoot
end FLTKRoot

on GetMyPath()
	set myPath to path to me as string
	if myPath contains "Script Editor" then
		-- Oops! running under script editor. 'me' is Script Editor not this script.
		-- use the location this script is supposed to be in.
		return gDistribRoot & "compilers:mac_prj"
	else
		tell application "Finder"
			return container of myPath
		end tell
	end if
end GetMyPath

on SetGlobals()
	tell application "Finder"
		
		set gProjectData to {}
		
		set gHomeDir to my HomeDir()
		set gDistribRoot to my ModuleRoot()
		set gIncludeDir to gDistribRoot & "include:"
		set gSourceDir to gDistribRoot & "src:"
		set gProjectsDir to gDistribRoot & "compilers:mac_prj:bin:"
		set gLibsDir to gDistribRoot & "compilers:mac_prj:lib:"
		set gRsrcsDir to gDistribRoot & "compilers:mac_prj:"
		set gMakeDir to my GetMyPath()
		set gFLTKRootFolder to my FLTKRoot()
	end tell
end SetGlobals

on HeaderExists(header, headerDir)
	tell application "Finder"
		if headerDir is "" then set headerDir to folder gIncludeDir
		return exists file header of headerDir
	end tell
end HeaderExists

on IsOlderThan(fileA, fileB)
	tell application "Finder"
		return (the modification date of fileA < the modification date of fileB)
	end tell
end IsOlderThan

on UpdateRenameHeader(canonicalName, canonicalDir, dotHName, dotHDir)
	tell application "Finder"
		
		set needRename to (dotHName is not "")
		if not needRename then set dotHName to canonicalName
		if dotHDir is "" then set dotHDir to folder gIncludeDir
		
		-- This file is only present if the script was interrupted.
		if needRename and my HeaderExists(canonicalName, dotHDir) then
			delete file canonicalName of dotHDir
		end if
		
		-- The native config file.
		-- If it's missing, assume this is a prepared distribution and the header is already up-to-date.
		if not my HeaderExists(canonicalName, canonicalDir) then return
		set canonicalFile to file canonicalName of canonicalDir
		
		set needCopy to true
		if my HeaderExists(dotHName, dotHDir) then
			set dotHFile to file dotHName of dotHDir
			if my IsOlderThan(dotHFile, canonicalFile) then
				delete dotHFile
			else
				set needCopy to false
			end if
		end if
		
		if needCopy then
			duplicate canonicalFile to dotHDir
			if needRename then set name of file canonicalName of dotHDir to dotHName
		end if
		
	end tell
end UpdateRenameHeader

on UpdateHeader(headerName, headerDir)
	UpdateRenameHeader(headerName, headerDir, "", "")
end UpdateHeader

on CopyHeaders()
	tell application "Finder"
		
		set confFolder to folder "compilers" of folder (my ModuleRoot())
		set prefixFolder to folder "mac_prj" of confFolder
		
		my UpdateRenameHeader("ncbiconf.mac", confFolder, "ncbiconf.h", "")
		if gFLTKRootFolder is not "" then
			my UpdateRenameHeader("fltk-config.h", prefixFolder, "config.h", folder gFLTKRootFolder)
		end if
		my UpdateHeader("debug.pfx", prefixFolder)
		my UpdateHeader("release.pfx", prefixFolder)
		my UpdateHeader("Carbon-debug.pfx", prefixFolder)
		my UpdateHeader("Carbon-release.pfx", prefixFolder)
		my UpdateHeader("Carbon-debugMSL.pfx", prefixFolder)
		my UpdateHeader("Carbon-releaseMSL.pfx", prefixFolder)
		my UpdateHeader("ncbi_mslextras.h", prefixFolder)
		
	end tell
end CopyHeaders

on SetAccessPath(aPath, isRecursive, isUserPath)
	tell application "CodeWarrior IDE"
		if (aPath does not end with ":") then set aPath to aPath & ":"
		
		set aPath to POSIX path of aPath
		set pathsToAdd to {{name:aPath, recursive:isRecursive, origin:root relative, root:"OS X Volume", format:Unix Path}}
		if isUserPath then
			Set Preferences of panel "Access Paths" to {User Paths:pathsToAdd}
		else
			Set Preferences of panel "Access Paths" to {System Paths:pathsToAdd}
		end if
	end tell
end SetAccessPath

on SetupTarget(proj, targetIndex)
	tell application "CodeWarrior IDE"
		
		set targetName to name of target targetIndex of project document 1
		set targetAPI to "Mach-O"
		if targetName contains "Carbon" then
			return -- we are not supporting Carbon Libs.
		end if
		
		if targetName contains "Debug" then
			set targetDebug to true
			if pCreateProfiledTargets then
				set targetProfile to true
			else
				set targetProfile to false
			end if
		else -- if targeName contains "Final" then
			set targetDebug to false
			set targetProfile to false
		end if
		
		set libtype to "BSD"
		if targetName contains "MSL" then
			set libtype to "MSL"
		end if
		
		-- NOTE: no Profile targets. if pCreateProfiledTargets, we make the debug targets also profile-able.
		-- and currently MW doesn't let you profile Mach-O targets!
		
		set the current target of project document 1 to target targetIndex of project document 1
		
		-- initialize variables
		set projRsrcs to {}
		set projFeatures to {}
		set sysPaths to {}
		
		-- Grab the fields of our project record and store them in local variables.
		set projName to proj's name
		set projSettings to proj's settings
		try
			set projFeatures to proj's features
		end try
		try
			set sysPaths to proj's sysPaths
		end try
		try
			set projRsrcs to proj's rsrcs
		end try
		set projLibs to proj's projLibs
		set dynaLibs to proj's dynaLibs
		set projFileData to proj's fileData
		
		-- Figure out what our output file and input libraries will be named.
		set fileNameSuffix to ""
		
		if libtype is "MSL" then
			set fileNameSuffix to "_" & libtype
		end if
		
		-- Debug or not.
		if not targetDebug then
			set fileNameSuffix to fileNameSuffix & "_O" -- for Optimized.
		else
			set fileNameSuffix to fileNameSuffix & "_D"
		end if
		
		-- non debug targets get different output names.
		if projFeatures contains "plainname" then
			set targetFilename to projName --  all targets have the same name.
		else
			if not targetDebug then
				if libtype is "MSL" then
					set targetFilename to projName & "_" & libtype -- MSL Release just has _MSL on the end.
				else
					set targetFilename to projName --  Release has same name as project.
				end if
			else
				set targetFilename to projName & fileNameSuffix
			end if
		end if
		
		-- make sure target files have the right extension.
		if projFeatures does not contain "cmdline" then
			set targetFilename to targetFilename & pAppExt
		end if
		
		-- Get Preference Panel names.
		if targetAPI is "Mach-O" then
			set targetPanelName to "PPC Mac OS X Project"
			set codeGenPanelName to "PPC CodeGen Mach-O"
		end if
		
		-- Set the name of the output file (the application)
		if projFeatures contains "cmdline" then
			Set Preferences of panel targetPanelName to {Project Type:executable}
		end if
		Set Preferences of panel targetPanelName to {File Name:targetFilename}
		
		-- If specified, set the File Creator.
		try
			set creatorName to creator of projSettings
			Set Preferences of panel targetPanelName to {File Creator:creatorName}
		end try
		
		-- If we have any per-project override settings, set them.
		if (count ppcProject of projSettings) > 0 then
			Set Preferences of panel targetPanelName to ppcProject of projSettings
		end if
		
		if gFLTKRootFolder is not "" and Â
			projFeatures contains "fltk" or projFeatures contains "fltklib" then
			my SetAccessPath(gFLTKRootFolder & "FL:", false, true)
			my SetAccessPath(gFLTKRootFolder, false, false)
		end if
		
		-- Are we assuming a .c or a .cpp extension?
		if projFeatures contains "C++" then
			set fileExtension to pCPlusPlusExt
		else
			set fileExtension to ".c"
		end if
		
	end tell
	
	-- Add source files
	repeat with group in projFileData
		set projPath to projPath of group -- projPath is absolute,  not relative.
		my SetAccessPath(projPath, true, true) -- add this folder to the access paths, as a recursive user path.
		
		set fileList to group's fileList
		
		set filesToAdd to {}
		repeat with i in fileList
			if i does not contain "." then set i to i & fileExtension
			try -- ignore it if the file doesn't exist.
				
				-- NOTE: if the following line is within a tell "Codewarrior" block then
				--  the following Add Files command will fail.
				copy alias (projPath & i) to end of filesToAdd
			end try
		end repeat
		
		tell application "CodeWarrior IDE"
			Add Files filesToAdd
			
			-- Take out source files that do not belong.
			set fileNotList to group's fileNotList
			Remove Files fileNotList
		end tell
	end repeat
	
	my SetAccessPath(gDistribRoot & "include:", true, false)
	my SetAccessPath(gRsrcsDir, false, true)
	my SetAccessPath(gLibsDir, false, true)
	
	tell application "CodeWarrior IDE"
		
		-- take care of debugging and profiling settings
		if targetDebug then
			set the debug of every target file of target targetIndex Â
				of project document 1 to true
		end if
		
		-- Add user libraries.
		set filesToAdd to {}
		repeat with i in projLibs
			copy gLibsDir & i & fileNameSuffix & pStaticLibExt to end of filesToAdd
		end repeat
		repeat with i in dynaLibs
			copy gLibsDir & i & fileNameSuffix & pDynaLibExt to end of filesToAdd
		end repeat
		
		if projFeatures contains "libdl" then
			copy "/usr/lib/libdl.a" to end of filesToAdd
		end if
		
		try
			Add Files filesToAdd
		on error errmsg number errnum
			-- ignore errors when none of those libraries exist.
			-- happens when populating a target when we haven't built any of the libraries for that target spec.
			if errnum is not 9393 then error errmsg number errnum
		end try
		
		-- Add resources.
		set filesToAdd to {}
		repeat with i in projRsrcs
			copy gRsrcsDir & i to end of filesToAdd
		end repeat
		
		if projFeatures contains "cmdline" then
			copy gRsrcsDir & "Carbon.r" to end of filesToAdd
		end if
		Add Files filesToAdd
		
		Reset File Paths
		
	end tell
end SetupTarget

on CreateFolder(folderPath)
	set text item delimiters of AppleScript to ":"
	-- strip off disk name.
	set folderPath to (rest of text items of folderPath) as string
	set pathSoFar to ""
	tell application "Finder"
		repeat with f in (text items of folderPath)
			set longerPath to pathSoFar & ":" & f
			if not (exists folder (longerPath)) then
				make new folder at folder (pathSoFar) with properties {name:f}
			end if
			set pathSoFar to longerPath
		end repeat
	end tell
	set text item delimiters of AppleScript to ""
end CreateFolder

on CreateProject(proj)
	tell application "CodeWarrior IDE"
		try
			get proj's name
		on error
			return
		end try
		
		set projFilename to proj's name & pProjectFileExt
		set projPathname to gProjectsDir & projFilename
		if pAlwaysCreateProjects or not (exists file projPathname of application "Finder") then
			
			try
				close (the first project document whose name is projFilename)
			end try
			
			set stationeryName to my GetStationeryName(proj)
			
			try
				tell application "Finder" to delete file (gProjectsDir & ".DS_Store")
			end try
			Create Project projPathname from stationery alias stationeryName
			if the name of window 1 is "Project Messages" then
				close first window -- "close window 1" becomes "Close Window 1" (different event)
			end if
			
			repeat with i from 1 to (count targets of project document 1)
				my SetupTarget(proj, i)
			end repeat
			set the current target of project document 1 to target 1 of project document 1
			
			Close Project
		end if
	end tell
end CreateProject

on CreateAndBuildAllProjects()
	CreateFolder(gProjectsDir)
	CleanupFiles(gProjectsDir)
	set targetSpecs to GetTargetSpecs()
	
	repeat with proj in gProjectData
		CreateProject(proj)
		if pShouldBuild then
			try
				set projName to proj's name
			on error
				return
			end try
			BuildProject(projName, targetSpecs)
		end if
	end repeat
	
end CreateAndBuildAllProjects

(*
	a target spec is a string of words "MSL Debug", all of which appear on our list of keywords.
	Convert a Build file name to a target spec by filtering out non-keywords.
	Each Build file creates another target spec.
	A project target must match one of the target specs to compile.
	To match, a target's name must contain each of the words in the target spec.
	An empty target spec matches everything.
	An empty list of target specs matches nothing, (No Build files.) but
		we make sure that won't happen.
*)

property gTargetKeyWords : "MSL BSD Debug Final"

on GetTargetSpecs()
	set theFiles to list folder (gMakeDir) without invisibles
	set targetSpecs to {}
	repeat with f in theFiles
		if (f begins with "Build ") then
			set targetSpecs to targetSpecs & MakeTargetSpec(f)
		end if
	end repeat
	-- no Build files? match everything.
	if (count items of targetSpecs) is 0 then
		set targetSpecs to {""}
	end if
	return targetSpecs
end GetTargetSpecs

on MakeTargetSpec(f)
	set tspec to ""
	repeat with w in (words of f)
		if gTargetKeyWords contains w then
			set tspec to tspec & w & " "
		end if
	end repeat
	return tspec
end MakeTargetSpec

on OkaytoBuild(targetName, targetSpecs)
	repeat with ts in targetSpecs
		if MatchSpec2Target(ts, targetName) then return true
	end repeat
	return false
end OkaytoBuild

on MatchSpec2Target(targSpec, targName)
	repeat with w in (words of targSpec)
		if w is not in targName then return false
	end repeat
	return true
end MatchSpec2Target


on BuildProject(projName, targetSpecs)
	tell application "CodeWarrior IDE"
		open (gProjectsDir & projName & pProjectFileExt)
		if the name of window 1 is "Project Messages" then
			close first window -- "close window 1" becomes "Close Window 1" (different event)
		end if
		repeat with i from 1 to (count targets of project document 1)
			-- do we want to build this target?
			set thisTarget to name of target i of project document 1
			if my OkaytoBuild(thisTarget, targetSpecs) then
				
				set the current target of project document 1 to target i of project document 1
				Make Project
				-- If there were compiler warnings, then a compiler window will be in front.
				-- For whatever reason, this causes the next "set the current target..." to fail.
				-- So check for the window and close it.
				if the name of window 1 is "Errors & Warnings" then
					close first window -- "close window 1" becomes "Close Window 1" (different event)
				end if
			end if
		end repeat
		set the current target of project document 1 to target 1 of project document 1
		Close Project
	end tell
end BuildProject


on GetStationeryName(proj)
	set stationeryDir to gProjectsDir & pStationeryName & ":"
	set stationeryName to pStationeryName & pProjectFileExt
	
	CreateFolder(stationeryDir)
	
	tell application "Finder"
		-- does the Library Stationery already exist?
		if not (exists file (stationeryDir & stationeryName)) then
			-- copy it.
			duplicate file (stationeryName) of folder gRsrcsDir to folder stationeryDir
		end if
	end tell
	my CleanupFolder(stationeryDir, stationeryName)
	try
		tell application "Finder" to delete file (stationeryDir & ".DS_Store")
	end try
	
	return (stationeryDir & stationeryName)
end GetStationeryName

-- Delete everything in the folder 'thePath' except the saveFile.
on CleanupFolder(thePath, saveFile)
	repeat with f in list folder (thePath) with invisibles
		if (f as string is not saveFile) then
			try
				tell application "Finder" to delete folder (thePath & f)
			end try
			try
				tell application "Finder" to delete file (thePath & f)
			end try
		end if
	end repeat
end CleanupFolder

on CleanupFiles(thePath)
	-- get rid of all the files and folders starting with 'trashme' in thePath
	repeat with f in list folder (thePath) without invisibles
		if ((f as string) begins with "trashme") then
			try
				tell application "Finder" to delete folder (thePath & f)
			end try
			try
				tell application "Finder" to delete file (thePath & f)
			end try
		end if
	end repeat
	-- delete the stationery folders.
	try
		tell application "Finder" to delete folder (gProjectsDir & pStationeryName)
	end try
end CleanupFiles

on SignalCompletion()
	beep
end SignalCompletion

with timeout of 60000 seconds
	
	if not my IsOSX() then
		error "Only supported on Mac OSX systems. Sorry!"
	end if
	SetGlobals()
	SetProjectData()
	CopyHeaders()
	
	tell application "CodeWarrior IDE" to activate
	
	CreateAndBuildAllProjects()
	
	CleanupFiles(gProjectsDir)
	
	SignalCompletion()
	
end timeout

