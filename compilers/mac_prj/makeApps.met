-- C++ libs --

property pRootFolderName : "ncbi_cxx" -- name of the toolkit directory
property pRootFolderPath : "" -- full path of the parent of the toolkit directory. Optional
property pFLTKRootFolder : "" -- full path of the FLTK directory. Optional.
property pBdbRootFolder : "" -- full path of the BDB source folder. Optional.
property pDLRootFolder : "sw:" -- root folder for the dlcompat library & header file. Usually sw: or usr:.

property pSaveContinueOnErrors : false
-- true if we want to save compilation errors in a file and continue.
-- false if we want to stop on an error.

property pProjectFileExt : ".mcp"
property pAppExt : ".app"
property pCPlusPlusExt : ".cpp"
property pStaticLibExt : ".lib"
property pPluginExt : ".so"
property pDynaLibExt : ".dylib"

-- Whether to recreate existing project files.
property pAlwaysCreateProjects : false

-- whether to refresh the files and libraries in existing projects
property pUpdateExistingProjects : true

-- Whether to have the projects use CVS or not.
property pProjectsCVSEnabled : true

-- But profiling doesn't work for Mach-O Codewarrior projects currently.
property pCreateProfiledTargets : false

-- Whether to compile anything.
property pShouldBuild : true

-- do test/demo applications
property pBuildDemos : false

property pStationeryName : "ApplicationStationery"

property pTargetKeyWords : {"MSL", "BSD", "Debug", "Final"}
property pDefaultTargets : {"BSD", "Debug"}

--
--  Set Global variables
--

global gHomeDir
global gDistribRoot
global gProjectsDir
global gPluginsDir
global gSourceDir
global gIncludeDir
global gRsrcsDir
global gMakeDir
global gLibsDir
global gFLTKRootFolder
global gBdbRootFolder


global gProjectData

on ProjectData(projName, features, aFileData)
	
	if (count characters of projName) > 25 then
		set projName to characters 1 through 25 of projName as string
	end if
	
	tell application "CodeWarrior IDE"
		
		if features does not contain "C" and features does not contain "C++" then
			copy "C++" to end of features
		end if
		set myFeatures to features
		
		return {name:projName, features:myFeatures, rsrcs:{}, settings:Â
			{Prefix File:"", ppcProject:{}}, projLibs:{}, dynaLibs:{}, sysPaths:{}, fileData:Â
			aFileData}
		
	end tell
end ProjectData

on SimpleProjectData(projName, section, features)
	
	-- Simple: the project name is also the name of the source file in the project.
	set myFileList to {projName}
	
	tell application "CodeWarrior IDE"
		
		if features does not contain "C" and features does not contain "C++" then
			copy "C++" to end of features
		end if
		set myFeatures to features
		if section contains ":" then
			set myLibs to {}
			set myPath to section & ":"
		else
			set myLibs to {section}
			set myPath to section & ":test:"
		end if
		return {name:projName, features:myFeatures, rsrcs:{}, settings:Â
			{Prefix File:"", ppcProject:{}}, projLibs:myLibs, dynaLibs:{}, fileData:Â
			{my mkFileDataListFiles(gSourceDir & myPath, myFileList)}}
		
	end tell
end SimpleProjectData

on ComplexProjectData(projName, section, features, filesToAdd)
	
	tell application "CodeWarrior IDE"
		
		if features does not contain "C" and features does not contain "C++" then
			copy "C++" to end of features
		end if
		set myFeatures to features
		
		if section contains ":" then
			set myLibs to {}
			set myPath to section & ":"
		else
			set myLibs to {section}
			set myPath to section & ":test:"
		end if
		return {name:projName, features:myFeatures, rsrcs:{}, settings:Â
			{Prefix File:"", ppcProject:{}}, projLibs:myLibs, dynaLibs:{}, fileData:Â
			{my mkFileDataListFiles(gSourceDir & myPath, filesToAdd)}}
		
	end tell
end ComplexProjectData

on AddProject(projData)
	copy projData to end of gProjectData
end AddProject

on AddSimpleProject(projName, features, section)
	AddProject(ProjectData(projName, features, {mkFileData(gSourceDir & section)}))
end AddSimpleProject

on AddSimpleProjectListFiles(projName, features, section, fileList)
	AddProject(ProjectData(projName, features, {mkFileDataListFiles(gSourceDir & section, fileList)}))
end AddSimpleProjectListFiles

on AddSimpleProjectExceptFiles(projName, features, section, fileNotList)
	AddProject(ProjectData(projName, features, {mkFileDataExceptFiles(gSourceDir & section, fileNotList)}))
end AddSimpleProjectExceptFiles

on mkFileData(fullPath)
	if (fullPath does not end with ":") then set fullPath to fullPath & ":"
	return {projPath:fullPath, fileList:GetFileNames(fullPath), fileNotList:{}}
end mkFileData

on mkFileDataListFiles(fullPath, fileList)
	if (fullPath does not end with ":") then set fullPath to fullPath & ":"
	return {projPath:fullPath, fileList:fileList, fileNotList:{}}
end mkFileDataListFiles

on mkFileDataExceptFiles(fullPath, fileNotList)
	if (fullPath does not end with ":") then set fullPath to fullPath & ":"
	return {projPath:fullPath, fileList:GetFileNames(fullPath), fileNotList:fileNotList}
end mkFileDataExceptFiles

on mkFileDataNoUL(fullPath) -- Get all the files, minus those whose basename ends with an underscore.
	set fileData to mkFileData(fullPath)
	set newFileList to {}
	repeat with f in fileList of fileData
		if f does not end with ("_.cpp") then
			copy f as text to end of newFileList
		end if
	end repeat
	set fileList of fileData to newFileList
	return fileData
end mkFileDataNoUL

on AppData(projName, features, section, staticLibs, dynamicLibs)
	set appProjData to ProjectData(projName, features, {mkFileDataNoUL(gSourceDir & section)})
	return DataPlusLibs(appProjData, staticLibs, dynamicLibs)
end AppData

on AddAppProject(projName, features, section, staticLibs, dynamicLibs)
	AddProject(AppData(projName, features, section, staticLibs, dynamicLibs))
end AddAppProject

on DataPlusSources(dataRec, newSrcs)
	repeat with i in newSrcs
		copy i to end of fileList of item 1 of fileData of dataRec
	end repeat
	return dataRec
end DataPlusSources

on DataPlusLibs(dataRec, newLibs, newDlls)
	repeat with i in newLibs
		copy i to end of projLibs of dataRec
	end repeat
	repeat with i in newDlls
		copy i to end of dynaLibs of dataRec
	end repeat
	return dataRec
end DataPlusLibs

on HideFolder(folderPath)
	tell application "Finder"
		if exists folder folderPath then
			set theName to name of folder folderPath
			set name of folder folderPath to ("(" & theName & ")")
		end if
	end tell
end HideFolder

on GetFileNames(fullSourcePath)
	set theFiles to list folder (fullSourcePath) without invisibles
	set theCFiles to EndsWith(theFiles, ".c")
	set theCppFiles to EndsWith(theFiles, pCPlusPlusExt)
	return theCFiles & theCppFiles
end GetFileNames

on EndsWith(aList, suffix)
	set newList to {}
	repeat with f in aList
		if (f ends with suffix) then
			copy (f as string) to end of newList
		end if
	end repeat
	return newList
end EndsWith

on SetProjectData()
	
	tell application "CodeWarrior IDE"
		
		set corelib to "corelib"
		set connect to "connect"
		set serial to "serial"
		set util to "util"
		set html to "html"
		
		set commonObjLibs to {Â
			"xncbi", "xser", "xutil", Â
			"seqset", "seq", "seqres", "seqloc", Â
			"seqcode", "seqalign", "seqfeat", "seqblock", "sequtil", Â
			"pub", "medline", "biblio", "general", "submit"}
		
		set objMgrLibs to {Â
			"seq", "seqcode", "cdd", "seqset", "sequtil", Â
			"pub", "biblio", "pubmed", "medline", Â
			"general", "submit", "xobjmgr", "id1", "id2", "xser", "xobjutil", "xobjread", "xutil", "xconnect", "xncbi", "z", "bz2", "xcompress"}
		
		-- datatool
		set myName to "datatool"
		set myFeatures to {"C++", "cmdline"}
		set mySettings to {Prefix File:"", ppcProject:{}}
		set myLibs to {"xncbi", "xser", "xutil"}
		-- use all the files in the datatool directory
		set myFiles to {my mkFileData(gSourceDir & "serial:datatool:")}
		set datatoolData to {name:myName, features:myFeatures, settings:mySettings, rsrcs:{}, projLibs:myLibs, dynaLibs:{}, fileData:myFiles} Â
			
		
	end tell
	
	
	-- fluid
	set saveCppExt to pCPlusPlusExt
	set pCPlusPlusExt to ".cxx"
	set fluidFileData to mkFileData(gFLTKRootFolder & "fluid")
	AddProject(DataPlusLibs(ProjectData("fluid", {"fltklib"}, {fluidFileData}), {"fltk"}, {}))
	set pCPlusPlusExt to saveCppExt
	
	---------- GENOME WORK BENCH ----------
	AddAppProject("gbench", {"fltk", "sockets", "libdl"}, "gui:gbench", Â
		{"w_flek", "w_table", "w_fltable"}, {"gui_core"})
	AddAppProject("gbench_plugin_scan", {"libdl", "cmdline", "plainname"}, "gui:gbench:gbench_plugin_scan", Â
		{}, {"gui_core"})
	
	---------- SERIAL ----------	
	AddProject(datatoolData)
	
	---------- OBJECTS ----------	
	AddProject(DataPlusLibs(SimpleProjectData("asn2asn", "app:asn2asn", {"C++"}), commonObjLibs, {}))
	
	AddProject(DataPlusLibs(ComplexProjectData("testvalidator", "objtools:validator:test", {"C++", "sockets", "libdl"}, {"test_validator"}), Â
		objMgrLibs & {"xvalidate"}, {}))
	AddProject(DataPlusLibs(SimpleProjectData("id1_fetch_simple", "app:id1_fetch", {"C++", "sockets"}), Â
		commonObjLibs & {"id1", "xconnect"}, {}))
	
	if pBuildDemos then
		---- DEMO ---
		
		AddAppProject("demo_seqgraphic", {"fltk"}, "gui:widgets:seq_graphic:demo", {"w_seq_graphic", "xalnmgr", "w_gl"}, {"gui_core"})
		
		AddAppProject("demo_regedit", {"fltk"}, "gui:dialogs:registry:demo", Â
			{"gui_dlg_registry", "gui_utils", "w_flek", "w_fltable", "xncbi", "fltk"}, {})
		
		AddAppProject("test_toggletree", {"fltk"}, "gui:widgets:Flek:demo", Â
			{"w_flek", "xncbi", "fltk"}, {})
	end if
end SetProjectData


--  Set Global variables

on IsOSX()
	tell application "Finder"
		set vers to the version as text
		if second character of vers is equal to "." then
			set vers to "0" & vers
		end if
		return vers > 10 or vers = 10
	end tell
end IsOSX

on HomeDir()
	tell application "Finder"
		return the home as string
	end tell
end HomeDir

on ResolveAlias(pathname)
	tell application "Finder"
		if exists folder pathname then
			-- if pathname does not end with ":" then set pathname to pathname & ":"
			return folder pathname as string
		end if
		if exists alias file pathname then return the original item of alias file pathname as string
	end tell
	return ""
end ResolveAlias

on ModuleRoot()
	set modRoot to ""
	try
		set modRoot to ResolveAlias(pRootFolderPath & pRootFolderName)
	end try
	if modRoot is "" then
		set modRoot to ResolveAlias(gHomeDir & pRootFolderName)
	end if
	return modRoot
end ModuleRoot

-- number of directories in a Posix path.
on PathLength(aPath)
	set {stid, text item delimiters of AppleScript} to {text item delimiters of AppleScript, "/"}
	set n to length of (text items of aPath)
	set text item delimiters of AppleScript to stid
	return n
end PathLength

on IsSpecialFolder(aFolder, findit, filePattern)
	set aFolder to ResolveAlias(aFolder)
	if aFolder is "" then return ""
	set pfolder to POSIX path of aFolder
	if findit then
		set aRootFolder to do shell script ("ls -1r " & pfolder & "*/" & filePattern & " | head -1")
	else
		set aRootFolder to do shell script ("ls -1r " & pfolder & filePattern & " | head -1")
	end if
	if aRootFolder is "" then return ""
	set aRootFolder to (POSIX file aRootFolder) as string
	set lastDirIndex to (PathLength(filePattern) + 1)
	set text item delimiters of AppleScript to ":"
	set aRootFolder to (text items 1 thru -lastDirIndex of aRootFolder) as string
	set text item delimiters of AppleScript to ""
	return aRootFolder & ":"
end IsSpecialFolder

on FindSpecialFolder(default, pattern)
	-- look where specified.
	set aSpecialFolder to IsSpecialFolder(default, false, pattern)
	if aSpecialFolder is "" then
		-- look next to the C++ toolkit directory.
		set aSpecialFolder to IsSpecialFolder(pRootFolderPath, true, pattern)
	end if
	if aSpecialFolder is "" then
		-- look IN the C++ toolkit directory.
		set aSpecialFolder to IsSpecialFolder(gDistribRoot, true, pattern)
	end if
	if aSpecialFolder is "" then
		-- look in our home directory.
		set aSpecialFolder to IsSpecialFolder(gHomeDir, true, pattern)
	end if
	return aSpecialFolder
end FindSpecialFolder

on GetMyPath()
	set myPath to path to me as string
	if myPath contains "Script Editor" or Â
		myPath contains "osascript" or Â
		myPath contains "Smile.app" then
		-- Oops! running under script editor. 'me' is Script Editor not this script.
		-- use the location this script is supposed to be in.
		return gDistribRoot & "compilers:mac_prj:"
	else
		tell application "Finder"
			return (container of myPath as string) & ":"
		end tell
	end if
end GetMyPath

on SetGlobals()
	tell application "Finder"
		
		set gProjectData to {}
		
		set gHomeDir to my HomeDir()
		set gDistribRoot to my ModuleRoot()
		set gIncludeDir to gDistribRoot & "include:"
		set gSourceDir to gDistribRoot & "src:"
		set gProjectsDir to gDistribRoot & "compilers:mac_prj:bin:"
		set gPluginsDir to gDistribRoot & "compilers:mac_prj:plugins:"
		set gLibsDir to gDistribRoot & "compilers:mac_prj:lib:"
		set gRsrcsDir to gDistribRoot & "compilers:mac_prj:"
		set gMakeDir to my GetMyPath()
		set gFLTKRootFolder to my FindSpecialFolder(pFLTKRootFolder, "src/Fl.cxx")
		if gFLTKRootFolder is "" then
			display dialog "Warning: Can't find FLTK. (download from www.fltk.org into your home directory). Not creating Gui libraries." with icon caution
		end if
		set gBdbRootFolder to my FindSpecialFolder(pBdbRootFolder, "dbinc/db_int.in")
		if gBdbRootFolder is "" then
			display dialog "Can't find bdb. (download from http://www.sleepycat.com/ into your home directory). Some libraries will fail to build." with icon caution
		end if
	end tell
end SetGlobals

on HeaderExists(header, headerDir)
	tell application "Finder"
		if headerDir is "" then set headerDir to folder gIncludeDir
		return exists file header of headerDir
	end tell
end HeaderExists

on IsOlderThan(fileA, fileB)
	tell application "Finder"
		return (the modification date of fileA < the modification date of fileB)
	end tell
end IsOlderThan

on UpdateRenameHeader(canonicalName, canonicalDir, dotHName, dotHDir)
	tell application "Finder"
		
		set needRename to (dotHName is not "")
		if not needRename then set dotHName to canonicalName
		if dotHDir is "" then set dotHDir to folder gIncludeDir
		
		-- This file is only present if the script was interrupted.
		if needRename and my HeaderExists(canonicalName, dotHDir) then
			delete file canonicalName of dotHDir
		end if
		
		-- The native config file.
		-- If it's missing, assume this is a prepared distribution and the header is already up-to-date.
		if not my HeaderExists(canonicalName, canonicalDir) then return
		set canonicalFile to file canonicalName of canonicalDir
		
		set needCopy to true
		if my HeaderExists(dotHName, dotHDir) then
			set dotHFile to file dotHName of dotHDir
			if my IsOlderThan(dotHFile, canonicalFile) then
				delete dotHFile
			else
				set needCopy to false
			end if
		end if
		
		if needCopy then
			duplicate canonicalFile to dotHDir
			if needRename then set name of file canonicalName of dotHDir to dotHName
		end if
		
	end tell
end UpdateRenameHeader

on UpdateHeader(headerName, headerDir)
	UpdateRenameHeader(headerName, headerDir, "", "")
end UpdateHeader

on CopyHeaders()
	tell application "Finder"
		
		set confFolder to folder "compilers" of folder (my ModuleRoot())
		set prefixFolder to folder "mac_prj" of confFolder
		
		-- my UpdateRenameHeader("ncbiconf.mac", confFolder, "ncbiconf.h", "")
		if gFLTKRootFolder is not "" then
			my UpdateRenameHeader("fltk-config.h", prefixFolder, "config.h", folder gFLTKRootFolder)
		end if
		
		my UpdateHeader("db.h", prefixFolder)
		my UpdateHeader("db_int.h", prefixFolder)
		my UpdateHeader("db_config.h", prefixFolder)
		
		my UpdateHeader("debug.pfx", prefixFolder)
		my UpdateHeader("release.pfx", prefixFolder)
		my UpdateHeader("Carbon-debug.pfx", prefixFolder)
		my UpdateHeader("Carbon-release.pfx", prefixFolder)
		my UpdateHeader("Carbon-debugMSL.pfx", prefixFolder)
		my UpdateHeader("Carbon-releaseMSL.pfx", prefixFolder)
		my UpdateHeader("ncbi_mslextras.h", prefixFolder)
		
	end tell
end CopyHeaders

on AppendAccessPath(aPath, isRecursive, isUserPath)
	tell application "CodeWarrior IDE"
		if (aPath does not end with ":") then set aPath to aPath & ":"
		
		set aPath to POSIX path of aPath
		set pathsToAdd to {{name:aPath, recursive:isRecursive, origin:root relative, root:"OS X Volume", format:Unix Path}}
		if isUserPath then
			Set Preferences of panel "Access Paths" to {User Paths:pathsToAdd}
		else
			Set Preferences of panel "Access Paths" to {System Paths:pathsToAdd}
		end if
	end tell
end AppendAccessPath

on PushAccessPath(aPath, isRecursive, isUserPath)
	tell application "CodeWarrior IDE"
		if (aPath does not end with ":") then set aPath to aPath & ":"
		
		set aPath to POSIX path of aPath
		set pathToAdd to {name:aPath, recursive:isRecursive, origin:root relative, root:"OS X Volume", format:Unix Path}
		if isUserPath then
			set newPaths to Get Preferences of {User Paths} from panel "Access Paths"
			copy pathToAdd to beginning of User Paths of newPaths
			Set Preferences of panel "Access Paths" to {User Paths:{}}
			Set Preferences of panel "Access Paths" to newPaths
		else
			set newPaths to Get Preferences of {System Paths} from panel "Access Paths"
			copy pathToAdd to beginning of System Paths of newPaths
			Set Preferences of panel "Access Paths" to {System Paths:{}}
			Set Preferences of panel "Access Paths" to newPaths
		end if
	end tell
end PushAccessPath

on SetupTarget(proj, targetIndex)
	tell application "CodeWarrior IDE"
		
		set targetName to name of target targetIndex of project document 1
		set targetAPI to "Mach-O"
		if targetName contains "Carbon" then
			return -- we are not supporting Carbon Libs.
		end if
		
		if targetName contains "Debug" then
			set targetDebug to true
			if pCreateProfiledTargets then
				set targetProfile to true
			else
				set targetProfile to false
			end if
		else -- if targeName contains "Final" then
			set targetDebug to false
			set targetProfile to false
		end if
		
		set libtype to "BSD"
		if targetName contains "MSL" then
			set libtype to "MSL"
		end if
		
		-- NOTE: no Profile targets. if pCreateProfiledTargets, we make the debug targets also profile-able.
		-- and currently MW doesn't let you profile Mach-O targets!
		
		set the current target of project document 1 to target targetIndex of project document 1
		
		-- initialize variables
		set projRsrcs to {}
		set projFeatures to {}
		set sysPaths to {}
		
		-- Grab the fields of our project record and store them in local variables.
		set projName to proj's name
		set projSettings to proj's settings
		try
			set projFeatures to proj's features
		end try
		try
			set sysPaths to proj's sysPaths
		end try
		try
			set projRsrcs to proj's rsrcs
		end try
		set projLibs to proj's projLibs
		set dynaLibs to proj's dynaLibs
		set projFileData to proj's fileData
		
		-- Figure out what our output file and input libraries will be named.
		set fileNameSuffix to ""
		
		if libtype is "MSL" then
			set fileNameSuffix to "_" & libtype
		end if
		
		-- Debug or not.
		if not targetDebug then
			set fileNameSuffix to fileNameSuffix & "_O" -- for Optimized.
		else
			set fileNameSuffix to fileNameSuffix & "_D"
		end if
		
		-- non debug targets get different output names.
		if projFeatures contains "plainname" then
			set targetFilename to projName --  all targets have the same name.
		else
			if not targetDebug then
				if libtype is "MSL" then
					set targetFilename to projName & "_" & libtype -- MSL Release just has _MSL on the end.
				else
					set targetFilename to projName --  Release has same name as project.
				end if
			else
				set targetFilename to projName & fileNameSuffix
			end if
		end if
		
		-- make sure target files have the right extension.
		if projFeatures does not contain "cmdline" then
			set targetFilename to targetFilename & pAppExt
		end if
		
		-- Get Preference Panel names.
		if targetAPI is "Mach-O" then
			set targetPanelName to "PPC Mac OS X Project"
			set codeGenPanelName to "PPC CodeGen Mach-O"
		end if
		
		-- Set the name of the output file (the application)
		if projFeatures contains "cmdline" then
			Set Preferences of panel targetPanelName to {Project Type:executable}
		end if
		Set Preferences of panel targetPanelName to {File Name:targetFilename}
		
		-- If specified, set the File Creator.
		try
			set creatorName to creator of projSettings
			Set Preferences of panel targetPanelName to {File Creator:creatorName}
		end try
		
		-- If we have any per-project override settings, set them.
		if (count ppcProject of projSettings) > 0 then
			Set Preferences of panel targetPanelName to ppcProject of projSettings
		end if
		
		if projFeatures contains "fltk" or projFeatures contains "fltklib" then
			my AppendAccessPath(gFLTKRootFolder & "FL:", false, true)
			my AppendAccessPath(gFLTKRootFolder, false, false)
		end if
		if projFeatures contains "bdblib" then
			my AppendAccessPath(gDistribRoot & "include:", false, true)
			my AppendAccessPath(gBdbRootFolder, true, true)
		end if
		if projFeatures contains "bdb" then
			my PushAccessPath(gDistribRoot & "include:", false, false)
		end if
		
		-- Are we assuming a .c or a .cpp extension?
		if projFeatures contains "C++" then
			set fileExtension to pCPlusPlusExt
		else
			set fileExtension to ".c"
		end if
		
	end tell
	
	-- Add source files
	repeat with group in projFileData
		set projPath to projPath of group -- projPath is absolute,  not relative.
		my AppendAccessPath(projPath, true, true) -- add this folder to the access paths, as a recursive user path.
		
		set fileList to group's fileList
		
		set filesToAdd to {}
		repeat with i in fileList
			if i does not contain "." then set i to i & fileExtension
			try -- ignore it if the file doesn't exist.
				
				-- NOTE: if the following line is within a tell "Codewarrior" block then
				--  the following Add Files command will fail.
				copy alias (projPath & i) to end of filesToAdd
				-- Set the file's type so CW will have less problems with it.
				tell application "Finder"
					set file type of file (projPath & i) to "TEXT"
					set creator type of file (projPath & i) to "CWIE"
				end tell
			end try
		end repeat
		
		tell application "CodeWarrior IDE"
			Add Files filesToAdd
			
			-- Take out source files that do not belong.
			set fileNotList to group's fileNotList
			Remove Files fileNotList
		end tell
	end repeat
	
	my AppendAccessPath(gDistribRoot & "include:", true, false)
	my AppendAccessPath(gRsrcsDir, false, true)
	my AppendAccessPath(gLibsDir, false, true)
	
	tell application "CodeWarrior IDE"
		
		-- take care of debugging and profiling settings
		if targetDebug then
			set the debug of every target file of target targetIndex Â
				of project document 1 to true
		end if
		
		-- Add user libraries.
		set filesToAdd to {}
		repeat with i in projLibs
			if exists file (gLibsDir & i & fileNameSuffix & pStaticLibExt) of application "Finder" then
				copy (gLibsDir & i & fileNameSuffix & pStaticLibExt) to end of filesToAdd
			end if
		end repeat
		repeat with i in dynaLibs
			if exists file (gLibsDir & i & fileNameSuffix & pDynaLibExt) of application "Finder" then
				copy (gLibsDir & i & fileNameSuffix & pDynaLibExt) to end of filesToAdd
			end if
		end repeat
		
		if projFeatures contains "libdl" then
			my PushAccessPath(pDLRootFolder & "include", false, false)
			my PushAccessPath(pDLRootFolder & "lib", false, false)
			copy (POSIX path of pDLRootFolder) & "lib/libdl.a" to end of filesToAdd
		end if
		
		-- try
		Add Files filesToAdd
		-- on error errmsg number errnum
		-- ignore errors when none of those libraries exist.
		-- happens when populating a target when we haven't built any of the libraries for that target spec.
		-- 	if errnum is not 9393 then error errmsg number errnum
		-- end try
		
		-- Add resources.
		set filesToAdd to {}
		repeat with i in projRsrcs
			copy gRsrcsDir & i to end of filesToAdd
		end repeat
		
		if projFeatures contains "cmdline" then
			copy gRsrcsDir & "Carbon.r" to end of filesToAdd
		else
			copy gRsrcsDir & "Info.plc" to end of filesToAdd
			copy gRsrcsDir & "ncbi.icns" to end of filesToAdd
		end if
		Add Files filesToAdd
		
		Reset File Paths
	end tell
end SetupTarget


on GetTargetFiles(i)
	tell application "CodeWarrior IDE"
		-- get the target
		if (i > (count of targets of project document 1)) then
			return {}
		end if
		-- get references to all the targets files
		set atarget to get target i of project document 1
		set trefs to (target files of atarget whose linked is true)
	end tell
	set tfiles to {}
	if ((count of trefs) ­ 0) then
		repeat with tf in trefs
			-- get locations of the targets files (as file objects)
			tell application "CodeWarrior IDE"
				set f to (location of tf)
			end tell
			tell application "Finder"
				-- convert the file's to strings (colon style paths)
				try
					copy f as string to end of tfiles
				on error errmsg number errnum
					-- file in target but does not exist.
					if errnum ­ -2753 then -- variable not defined.
						error errmsg number errnum
					end if
				end try
			end tell
		end repeat
	end if
	return tfiles
end GetTargetFiles

on UpdateTarget(proj, targetIndex)
	tell application "CodeWarrior IDE"
		
		set targetName to name of target targetIndex of project document 1
		
		if targetName contains "Debug" then
			set targetDebug to true
		else -- if targeName contains "Final" then
			set targetDebug to false
		end if
		
		set libtype to "BSD"
		if targetName contains "MSL" then
			set libtype to "MSL"
		end if
		
		set the current target of project document 1 to target targetIndex of project document 1
		
		-- initialize variables
		set projFeatures to {}
		
		-- Grab the fields of our project record and store them in local variables.
		try
			set projFeatures to proj's features
		end try
		set projLibs to proj's projLibs
		set dynaLibs to proj's dynaLibs
		set projFileData to proj's fileData
		
		-- Figure out what our output file and input libraries will be named.
		set fileNameSuffix to ""
		
		if libtype is "MSL" then
			set fileNameSuffix to "_" & libtype
		end if
		
		-- Debug or not.
		if not targetDebug then
			set fileNameSuffix to fileNameSuffix & "_O" -- for Optimized.
		else
			set fileNameSuffix to fileNameSuffix & "_D"
		end if
		
		-- Are we assuming a .c or a .cpp extension?
		if projFeatures contains "C++" then
			set fileExtension to pCPlusPlusExt
		else
			set fileExtension to ".c"
		end if
		
	end tell
	
	-- Update source files
	set targetFileList to my GetTargetFiles(targetIndex)
	repeat with group in projFileData
		set projPath to projPath of group -- projPath is absolute,  not relative.
		
		set fileList to group's fileList
		
		set filesToAdd to {}
		
		repeat with i in fileList
			if i does not contain "." then set i to i & fileExtension
			set fileFullPath to projPath & i
			set found to targetFileList contains fileFullPath
			if (not found) then
				--try -- ignore it if the file doesn't exist.
				
				-- NOTE: if the following line is within a tell "Codewarrior" block then
				--  the following Add Files command will fail.
				
				copy alias fileFullPath to end of filesToAdd
				--end try
			end if
		end repeat
		
		tell application "CodeWarrior IDE"
			if ((count of filesToAdd) is not 0) then
				--display dialog filesToAdd
				Add Files filesToAdd
				set targetFileList to my GetTargetFiles(targetIndex)
			end if
			
			-- Take out source files that do not belong.
			set fileNotList to group's fileNotList
			Remove Files fileNotList
		end tell
	end repeat
	
	-- Update libraries
	set filesToAdd to {}
	repeat with i in projLibs
		set i to gLibsDir & i & fileNameSuffix & pStaticLibExt
		set found to targetFileList contains i
		if (not found) and (exists file (i) of application "Finder") then
			copy (i) to end of filesToAdd
		end if
	end repeat
	
	repeat with i in dynaLibs
		set i to gLibsDir & i & fileNameSuffix & pDynaLibExt
		set found to targetFileList contains i
		if (not found) and (exists file (i) of application "Finder") then
			copy (i) to end of filesToAdd
		end if
	end repeat
	
	
	tell application "CodeWarrior IDE"
		if ((count of filesToAdd) is not 0) then
			Add Files filesToAdd
			-- set targetFileList to my GetTargetFiles(targetIndex)
		end if
		
		Reset File Paths
		
	end tell
	
end UpdateTarget

on CreateFolder(folderPath)
	set text item delimiters of AppleScript to ":"
	-- strip off disk name.
	set folderPath to (rest of text items of folderPath) as string
	set pathSoFar to ""
	tell application "Finder"
		repeat with f in (text items of folderPath)
			set longerPath to pathSoFar & ":" & f
			if not (exists folder (longerPath)) then
				make new folder at folder (pathSoFar) with properties {name:f}
			end if
			set pathSoFar to longerPath
		end repeat
	end tell
	set text item delimiters of AppleScript to ""
end CreateFolder

on CreateProject(proj)
	tell application "CodeWarrior IDE"
		try
			get proj's name
		on error
			return
		end try
		
		set projFilename to proj's name & pProjectFileExt
		set projPathname to gProjectsDir & projFilename
		set openedProject to false
		if pAlwaysCreateProjects or not (exists file projPathname of application "Finder") then
			
			try
				close (the first project document whose name is projFilename)
			end try
			
			set stationeryName to my GetStationeryName(proj)
			
			try
				tell application "Finder" to delete file (gProjectsDir & ".DS_Store")
			end try
			Create Project projPathname from stationery alias stationeryName
			set openedProject to false
			if the name of window 1 is "Project Messages" then
				close first window -- "close window 1" becomes "Close Window 1" (different event)
			end if
			
			repeat with i from 1 to (count targets of project document 1)
				my SetupTarget(proj, i)
			end repeat
		else if pUpdateExistingProjects then
			-- project already exists. Make sure it has all right files.
			open (projPathname)
			set openedProject to false
			if the name of window 1 is "Project Messages" then
				close first window -- "close window 1" becomes "Close Window 1" (different event)
			end if
			repeat with i from 1 to (count targets of project document 1)
				my UpdateTarget(proj, i)
			end repeat
		end if
		if openedProject then
			if pProjectsCVSEnabled then
				--try
				Set Preferences of panel "VCS Setup" to {VCS Active:true, Connection Method:"mwCVS"}
				--end try
			end if
			set the current target of project document 1 to target 1 of project document 1
			Close Project
		end if
	end tell
end CreateProject

on CreateAndBuildAllProjects()
	CreateFolder(gProjectsDir)
	CleanupFiles(gProjectsDir)
	set targetSpecs to GetTargetSpecs()
	
	tell application "CodeWarrior IDE" to activate
	
	repeat with proj in gProjectData
		CreateProject(proj)
		if pShouldBuild then
			try
				set projName to proj's name
			on error
				return
			end try
			BuildProject(projName, targetSpecs)
		end if
	end repeat
	
end CreateAndBuildAllProjects

(*
	a target spec is a string of words "MSL Debug", all of which appear on our list of keywords.
	Convert a Build file name to a target spec by filtering out non-keywords.
	Each Build file creates another target spec.
	A project target must match one of the target specs to compile.
	To match, a target's name must contain each of the words in the target spec.
	An empty target spec matches everything.
	An empty list of target specs (no Build files) matches nothing, but
		we make sure that won't happen.
*)

on GetTargetSpecs()
	set theFiles to (list folder gMakeDir without invisibles)
	set targetSpecs to {}
	repeat with f in theFiles
		if (f begins with "Build ") then
			set targetSpecs to targetSpecs & MakeTargetSpec(f)
		end if
	end repeat
	-- no Build files? Ask what to build.
	if (count items of targetSpecs) is 0 then
		set targetSpecs to {AskForTargetSpec()}
	end if
	return targetSpecs
end GetTargetSpecs

on AskForTargetSpec()
	try
		choose from list pTargetKeyWords default items pDefaultTargets Â
			with prompt "Choose Target types to compile:" cancel button name "Build All" with multiple selections allowed
	on error errmsg number errnum
		if errnum is -1713 then -- no user interaction allowed.
			return "" -- build all
		else
			error errmsg number errnum
		end if
	end try
	set targ to result
	if targ is false then
		return "" -- build all
	end if
	set {stid, text item delimiters of AppleScript} to {text item delimiters of AppleScript, " "}
	set targ to targ as string
	set text item delimiters of AppleScript to stid
	return targ
end AskForTargetSpec

on MakeTargetSpec(f)
	set tspec to ""
	repeat with w in (words of f)
		if pTargetKeyWords contains w then
			set tspec to tspec & w & " "
		end if
	end repeat
	return tspec
end MakeTargetSpec

on OkaytoBuild(targetName, targetSpecs)
	repeat with ts in targetSpecs
		if MatchSpec2Target(ts, targetName) then return true
	end repeat
	return false
end OkaytoBuild

on MatchSpec2Target(targSpec, targName)
	repeat with w in (words of targSpec)
		if w is not in targName then return false
	end repeat
	return true
end MatchSpec2Target


on BuildProject(projName, targetSpecs)
	tell application "CodeWarrior IDE"
		open (gProjectsDir & projName & pProjectFileExt)
		if the name of window 1 is "Project Messages" then
			close first window -- "close window 1" becomes "Close Window 1" (different event)
		end if
		repeat with i from 1 to (count targets of project document 1)
			-- do we want to build this target?
			set thisTarget to name of target i of project document 1
			if my OkaytoBuild(thisTarget, targetSpecs) then
				
				set the current target of project document 1 to target i of project document 1
				if pSaveContinueOnErrors then
					try
						Make Project
					on error errmsg number errnum
						if (errnum = 5) then
							set errFileName to (gProjectsDir & projName & "-" & i & ".errs")
							Save Error Window As (file errFileName)
							close first window
						else
							error errmsg number errnum
						end if
					end try
				else -- stop on any error.
					Make Project
				end if
				-- If there were compiler warnings, then a compiler window will be in front.
				-- For whatever reason, this causes the next "set the current target..." to fail.
				-- So check for the window and close it.
				if the name of window 1 is "Errors & Warnings" then
					close first window -- "close window 1" becomes "Close Window 1" (different event)
				end if
			end if
		end repeat
		set the current target of project document 1 to target 1 of project document 1
		Close Project
	end tell
end BuildProject


on GetStationeryName(proj)
	set stationeryDir to gProjectsDir & pStationeryName & ":"
	set stationeryName to pStationeryName & pProjectFileExt
	
	CreateFolder(stationeryDir)
	tell application "Finder"
		-- does the Library Stationery already exist?
		if not (exists file (stationeryDir & stationeryName)) then
			-- copy it.
			duplicate file (stationeryName) of folder gRsrcsDir to folder stationeryDir
		end if
	end tell
	return (stationeryDir & stationeryName)
end GetStationeryName

on CleanupFiles(thePath)
	-- get rid of all the files and folders starting with 'trashme' in thePath
	repeat with f in list folder (thePath) without invisibles
		if ((f as string) begins with "trashme") then
			try
				tell application "Finder" to delete folder (thePath & f)
			end try
			try
				tell application "Finder" to delete file (thePath & f)
			end try
		end if
	end repeat
	-- delete the stationery folders.
	try
		tell application "Finder" to delete folder (gProjectsDir & pStationeryName)
	end try
end CleanupFiles

on SignalCompletion()
	beep
end SignalCompletion

with timeout of 60000 seconds
	
	if not my IsOSX() then
		error "Only supported on Mac OSX systems. Sorry!"
	end if
	SetGlobals()
	SetProjectData()
	CopyHeaders()
	
	CreateAndBuildAllProjects()
	
	CleanupFiles(gProjectsDir)
	
	SignalCompletion()
	
end timeout

