<!--#set var="TITLE" value="DATATOOL -- code generation utility (NCBI C++)" -->
<!--#set var="DOCROOT" value="../.." -->
<!--#include virtual="../../ssi/header.shtml" -->

<h1>DATATOOL<br />
code generation and data serialization utility</h1>

<ul>
<li>
  <a href="#refSynopsis">Synopsis</a>
</li>

<li>
  <a href="#refArgs">Invocation</a>
  <ul>
  <li>
    <a href="#refMainArgs">Main arguments</a>
  </li>
  <li>
    <a href="#refCodeGenerationArgs">Code generation arguments</a>
  </li>
  </ul>
</li>

<li>
  <a href="#refDefFile">Definition file</a>
  <ul>
  <li>
    <a href="#refDefCommon">Common definitions</a>
  </li>
  <li>
    <a href="#refDefSpecific">Definitions which affect specific types</a>
	<ul>
    <li>
      <a href="#refDefINT">INTEGER, REAL, BOOLEAN, NULL</a>
    </li>
    <li>
      <a href="#refDefENUM">ENUMERATED</a>
    </li>
    <li>
      <a href="#refDefOCTETS">OCTET STRING</a>
    </li>
    <li>
      <a href="#refDefArray">SEQUENCE OF, SET OF</a>
    </li>
    <li>
      <a href="#refDefClass">SEQUENCE, SET</a>
    </li>
    <li>
      <a href="#refDefChoice">CHOICE</a>
    </li>
	</ul>
  </li>
  <li>
    <a href="#refDefExample">Examples</a>
  </li>
  </ul>
</li>

<li>
  <a href="#refCode">Generated code</a>
  <ul>
  <li>
    <a href="#refNormalizedName">Normalized name</a>
  </li>
  <li>
    <a href="#refCodeEnum">ENUMERATED</a>
  </li>
  <li>
    <a href="#refCodeClass">SEQUENCE, SET</a>
  </li>
  <li>
    <a href="#refCodeChoice">CHOICE</a>
  </li>
  <li>
    <a href="#refCodeOther">Other</a>
  </li>
  </ul>
</li>

<li>
  <a href="dt_inside.html">Inside <span class="ncbi_app">DATATOOL</span></a>
</li>
</ul>



<a name="refSynopsis"></a>
<h2>Synopsis</h2>

<table border="1" cellspacing="0">
<tr valign="baseline">
  <th align="right">Location:</th>
  <td><span class="ncbi_dir">c++/src/serial/datatool</span></td>
</tr>
<tr valign="baseline">
  <th align="right">Synopsis:</th>
  <td>
    <ol>
	  <li>
Generate C++ data storage classes based on
<a href="http://asn1.elibel.tm.fr" target="_blank">
<acronym title="Abstract Syntax Notation number One">ASN.1</acronym>
</a> or
<a href="http://www.w3.org/TR/REC-xml" target="_blank">
<acronym title="Document Type Declaration">DTD</acronym>
</a>
specification to be used with
<a href="../../libs.html#ref_SumXSERIAL">NCBI data serialization streams</a>.
	  </li>
	  <li>
Convert ASN.1 specification into DTD and vice versa.
	  </li>
	  <li>
Convert data between ASN.1 and XML formats.
	  </li>
<!--
      <li>read ASN.1 data specifications</li>
      <li>read/write ASN.1 or XML data</li>
      <li>write ASN.1 or DTD data specification</li>
      <li>generate C++ classes to serialize (read/write) the data</li>
-->
    </ol>
<span class="ncbi_note">NOTE:</span>
Since ASN.1 and DTD are, in general, incompatible, the last two
functions are supported only partially.
  </td>
</tr>
</table>




<a name="refArgs"></a>
<h2>Invocation</h2>


<a name="refMainArgs"></a>
<h3>Main arguments</h3>

<table border="1" cellspacing="0">
<tr>
  <th>Argument</th>
  <th>Effect</th>
  <th>Comments</th>
</tr>

<tr>
  <td><span class="ncbi_app_a">-h</span></td>
  <td>display the <span class="ncbi_app">DATATOOL</span> arguments</a></td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td>
    <a name="refArg_m"></a>
	<span class="ncbi_app_a">-m &lt;file&gt;</span>
  </td>
  <td>ASN.1 or DTD module file(s)</td>
  <td>required argument</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-M &lt;file&gt;</span></td>
  <td>external module file(s)</td>
  <td rowspan="2">is used for IMPORT type resolution</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-i</span></td>
  <td>ignore unresolved types</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-f &lt;file&gt;</span></td>
  <td>write ASN.1 module file</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-fx &lt;file&gt;</span></td>
  <td>write DTD module file</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-dn &lt;string&gt;</span></td>
  <td>DTD module name in XML header</td>
  <td>no extension</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-v &lt;file&gt;</span></td>
  <td>read value in ASN.1 text format</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-vx &lt;file&gt;</span></td>
  <td>read value in XML format</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-F</span></td>
  <td>read value completely into memory</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-p &lt;file&gt;</span></td>
  <td>write value in ASN.1 text format</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-px &lt;file&gt;</span></td>
  <td>write value in XML format</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-d &lt;file&gt;</span></td>
  <td>read value in ASN.1 binary format</td>
  <td><span class="ncbi_app_a">-t</span> argument required</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-t &lt;type&gt;</span></td>
  <td>binary value type</td>
  <td>see <span class="ncbi_app_a">-d</span> argument</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-e &lt;file&gt;</span></td>
  <td>write value in ASN.1 binary format</td>
  <td>&nbsp;</td>
</tr>
</table>


<a name="refCodeGenerationArgs"></a>
<h3>Code generation arguments</h3>

<table border="1" cellspacing="0">
<tr>
  <th>Argument</th>
  <th>Effect</th>
  <th>Comments</th>
</tr>

<tr>
  <td>
    <a name="refArg_od"></a>
	<span class="ncbi_app_a">-od &lt;file&gt;</span>
  </td>
  <td>C++ code <a href="#refDefFile">definition file</a></td>
  <td>see <a href="#refDefFile">Definition file</a></td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-odi</span></td>
  <td>ignore absent code definition file</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-oA</span></td>
  <td>generate C++ files for all types</td>
  <td rowspan="2">only types from the main module are used<br />
    (see <a href="#refArg_m"><span class="ncbi_app_a">-m</span></a>
	 and <a href="#refArg_mx"><span class="ncbi_app_a">-mx</span></a> arguments)
  </td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-ot &lt;types&gt;</span></td>
  <td>generate C++ files for listed types</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-ox &lt;types&gt;</span></td>
  <td>exclude types from generation</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-oX</span></td>
  <td>turn off recursive type generation</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-of &lt;file&gt;</span></td>
  <td>write the list of generated C++ files</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-oc &lt;file&gt;</span></td>
  <td>write combining C++ files</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-on &lt;string&gt;</span></td>
  <td>default namespace</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><a name="refArg_op"></a><span class="ncbi_app_a">-opm &lt;dir></span></td>
  <td>directory for searching source modules</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-oph &lt;dir&gt;</span></td>
  <td>directory for generated *.hpp files</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-opc &lt;dir&gt;</span></td>
  <td>directory for generated *.cpp files</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><a name="refArg_or"></a><span class="ncbi_app_a">-or &lt;prefix&gt;</span></td>
  <td>add prefix to generated file names</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-orq</span></td>
  <td>use quoted syntax form for generated include files</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-ors</span></td>
  <td>add source file dir to generated file names</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-orm</span></td>
  <td>add module name to generated file names</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-orA</span></td>
  <td>combine all <a href="#refArg_or">-or*</a> prefixes</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-oR &lt;dir&gt;</span></td>
  <td>set <a href="#refArg_op">-op*</a> and <a href="#refArg_or">-or*</a>
    arguments for NCBI directory tree
  </td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><span class="ncbi_app_a">-lax_syntax</span></td>
  <td>allow non-standard ASN.1 syntax accepted by asntool</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td><a name="refArg_oex"></a><span class="ncbi_app_a">-oex &lt;export&gt;</span></td>
  <td>add storage-class modifier to generated classes</td>
  <td>can be overriden by<br />
    <a href="#refDefCommon"><span class="ncbi_keyword">[-]._export</span></a>
    in the definition file
  </td>
</tr>
</table>




<a name="refDefFile"></a>
<h2>Definition file</h2>
<p>
It is possible to tune up the C++ code generation by using a definition file, which
could be specified in <a href="#refArg_od"><span class="ncbi_app_a">-od</span></a> argument.
Definition file utilizes the generic
<a href="../../programming_manual/registry.html#syntax">NCBI configuration</a>
format also used in NCBI application's configuration (*.ini) files.
</p>

<p>
<span class="ncbi_app">DATATOOL</span> looks for code generation parameters
in several sections of the file in the following order:
<ol>
  <li><span class="ncbi_reg">[ModuleName.TypeName]</span></li>
  <li><span class="ncbi_reg">[TypeName]</span></li>
  <li><span class="ncbi_reg">[ModuleName]</span></li>
  <li><span class="ncbi_reg">[-]</span></li>
</ol>
Prefix of the parameter name in section is determined from the location of an element
in the data format specification (ASN.1 or DTD).
<br />For the root element prefix is empty.
<br />For an element of type
  <span class="ncbi_keyword">SET OF</span> or
  <span class="ncbi_keyword">SEQUENCE OF</span> - add
  <span class="ncbi_reg_var">E.</span> to prefix.
<br />For an element of type
  <span class="ncbi_keyword">SET</span>,
  <span class="ncbi_keyword">SEQUENCE</span> or
  <span class="ncbi_keyword">CHOICE</span> - add the element name
and dot (&quot;.&quot;) to prefix.
</p>



<a NAME="refDefCommon"></a>
<h3>Common definitions</h3>

<p>
Some definitions refer to the generated class as a whole:
<dl>
  <dt><span class="ncbi_keyword">_file</span></dt>
  <dd>
Defines the base file name for the generated C++ class.
<blockquote>
For example, the following definitions:
<br /><span class="ncbi_reg">[ModuleName.TypeName]</span>
<br /><span class="ncbi_reg_var">_file=AnotherName</span>
<br />or
<br /><span class="ncbi_reg">[TypeName]</span>
<br /><span class="ncbi_reg_var">_file=AnotherName</span>
<br />would put the class <span class="ncbi_class">CTypeName</span>
in files with the base name <span class="ncbi_file">AnotherName</span>.
<br />
<br />While these two:
<br /><span class="ncbi_reg">[ModuleName]</span>
<br /><span class="ncbi_reg_var">_file=AnotherName</span>
<br />or
<br /><span class="ncbi_reg">[-]</span>
<br /><span class="ncbi_reg_var">_file=AnotherName</span>
<br />put <em>all</em> the generated classes
into a single file with the base name <span class="ncbi_file">AnotherName</span>.
</blockquote>
  </dd>

  <dt><span class="ncbi_keyword">_dir</span></dt>
  <dd>Subdirectory in which the generated C++ files will be stored
    (in case <span class="ncbi_reg_var">_file</span> not specified).
  </dd>

  <dt><span class="ncbi_keyword">_class</span></dt>
  <dd>
The name of the generated class
(if <span class="ncbi_reg_var">_class=-</span> is specified, then
no code is generated for this type).
<blockquote>
For example, the following definitions:
<br /><span class="ncbi_reg">[ModuleName.TypeName]</span>
<br /><span class="ncbi_reg_var">_class=AnotherName</span>
<br />or
<br /><span class="ncbi_reg">[TypeName]</span>
<br /><span class="ncbi_reg_var">_class=AnotherName</span>
<br />would cause the class generated for the type 
<span class="ncbi_reg">TypeName</span> to be named
<span class="ncbi_class">CAnotherName</span>.
<br />
<br />While these two:
<br /><span class="ncbi_reg">[ModuleName]</span>
<br /><span class="ncbi_reg_var">_class=AnotherName</span>
<br />or
<br /><span class="ncbi_reg">[-]</span>
<br /><span class="ncbi_reg_var">_class=AnotherName</span>
<br />would result in <em>all</em> the generated classes
having the same name <span class="ncbi_class">CAnotherName</span>
(which is probably not what you want).
</blockquote>
  </dd>

  <dt><span class="ncbi_keyword">_namespace</span></dt>
  <dd>The namespace in which the generated class (or classes) will be placed.</dd>

  <dt><span class="ncbi_keyword">_parent_class</span></dt>
  <dd>The name of the base class from which the generated C++ class is derived.</dd>

  <dt><span class="ncbi_keyword">_parent_type</span></dt>
  <dd>Derive the generated C++ class from the class, which corresponds to the specified
type (in case <span class="ncbi_keyword">_parent_class</span> is not specified).
  </dd>
  <dt></dt>
  <dd></dd>
</dl>
</p>

<p>
It is also possible to specify a storage-class modifier, which is required on Microsoft Windows
to export/import generated classes from/to a DLL. This setting affects all generated classes
in a module. Appropriate section of the definition file should look like this:
<blockquote>
<span class="ncbi_reg">[-]</span>
<br /><span class="ncbi_reg_var">_export = EXPORT_SPECIFIER</span>
</blockquote>
Since this modifier could also be specified in the <a href="#refArg_oex">command line</a>,
<span class="ncbi_app">DATATOOL</span> code generator uses the following rules to choose
the proper one:
<ol>
  <li>
If no <span class="ncbi_app_a">-oex</span> flag is given in the command line,
then no modifier is added at all.
  </li>
  <li>
If <span class="ncbi_app_a">-oex &quot;&quot;</span>
(that is, an empty modifier) is specified in the command line,
then the modifier from the definition file will be used.
  </li>
  <li>
The command line parameter in the form 
<span class="ncbi_app_a">-oex FOOBAR</span> will cause
the generated classes to have <span class="ncbi_app_a">FOOBAR</span>
storage-class modifier, unless another one is specified in the definition file.
The modifier from the definition file always takes precedence.
  </li>
</ol>
</p>



<a name="refDefSpecific"></a>
<h3>Definitions which affect specific types</h3>


<a name="refDefINT"></a>
<h4>INTEGER, REAL, BOOLEAN, NULL</h4>
<dl>
  <dt><span class="ncbi_keyword">_type</span></dt>
  <dd>C++ type: int, short, unsigned, long etc.</dd>
</dl>


<a name="refDefENUM"></a>
<h4>ENUMERATED</h4>
<dl>
  <dt><span class="ncbi_keyword">_type</span></dt>
  <dd>C++ type: int, short, unsigned, long etc.</dd>
  <dt><span class="ncbi_keyword">_prefix</span></dt>
  <dd>Prefix for enum values' names. Default is "e".</dd>
</dl>


<a name="refDefOCTETS"></a>
<h4>OCTET STRING</h4>
<dl>
  <dt><span class="ncbi_keyword">_char</span></dt>
  <dd>Vector element type: char, unsigned char or signed char.</dd>
</dl>


<a name="refDefArray"></a>
<h4>SEQUENCE OF, SET OF</h4>
<dl>
  <dt><span class="ncbi_keyword">_type</span></dt>
  <dd>STL container type: list, vector, set, or multiset.</dd>
</dl>


<a name="refDefClass"></a>
<h4>SEQUENCE, SET</h4>
<dl>
  <dt><span class="ncbi_reg_var">memberName.</span><span class="ncbi_keyword">_delay</span></dt>
  <dd>Mark the specified member for delayed reading.</dd>
</dl>


<a name="refDefChoice"></a>
<h4>CHOICE</h4>
<dl>
  <dt><span class="ncbi_keyword">_virtual_choice</span></dt>
  <dd>If non-empty, do not generate a special class for choice.
    Rather make the choice class as parent one of all its variants.</dd>
  <dt><span class="ncbi_reg_var">variantName.</span><span class="ncbi_keyword">_delay</span></dt>
  <dd>Mark the specified variant for delayed reading.</dd>
</dl>



<a name="refDefExample"></a>
<h3>Examples</h3>
<p>
If we have the following ASN.1 specification:
<blockquote>
<pre class="ncbi_cmd">
<a name="refType_Date"></a>Date ::= CHOICE {
    <a name="refMember_Date_str"></a>str VisibleString,
    std <a href="#refType_Date_std">Date-std</a>
}
<a name="refType_Date_std"></a>Date-std ::= SEQUENCE {
    year INTEGER,
    month INTEGER OPTIONAL
}
<a name="refType_Dates"></a>Dates ::= SEQUENCE OF <a href="#refType_Date">Date</a>    
<a name="refType_Int_fuzz"></a>Int-fuzz ::= CHOICE {
    p-m INTEGER,
    <a name="refMember_Int_fuzz_range"></a>range SEQUENCE {
        max INTEGER,
        <a name="refMember_Int_fuzz_range_min"></a>min INTEGER
    },
    pct INTEGER,
    lim ENUMERATED {
        unk (0),
        gt (1),
        lt (2),
        tr (3),
        tl (4),
        circle (5),
        other (255)
    },
    <a name="refMember_Int_fuzz_alt"></a>alt SET OF INTEGER
}
</pre>
</blockquote>


Then the following definitions:
<blockquote>
      <span class="ncbi_reg">[<a href="#refType_Date">Date</a>]</span>
<br /><span class="ncbi_reg_var"><a href="#refMember_Date_str">str</a>._type = string</span>
</blockquote>
would affect the generation of <a href="#refMember_Date_str">str</a>
member of the <a href="#refType_Date">Date</a> structure.

<blockquote>
      <span class="ncbi_reg">[<a href="#refType_Dates">Dates</a>]</span>
<br /><span class="ncbi_reg_var">E._pointer = true</span>
</blockquote>
would affect the generation of elements of the <a href="#refType_Dates">Dates</a> container.

<blockquote>
      <span class="ncbi_reg">[<a href="#refType_Int_fuzz">Int-fuzz</a>]</span>
<br /><span class="ncbi_reg_var"><a href="#refMember_Int_fuzz_range">range</a>.
        <a href="#refMember_Int_fuzz_range_min">min</a>._type = long</span>
</blockquote>
would affect the generation of the <a href="#refMember_Int_fuzz_range_min">min</a>
member of the <a href="#refMember_Int_fuzz_range">range</a> member of the
<a href="#refType_Int_fuzz">Int-fuzz</a> structure.

<blockquote>
      <span class="ncbi_reg">[<a href="#refType_Int_fuzz">Int-fuzz</a>]</span>
<br /><span class="ncbi_reg_var"><a href="#refMember_Int_fuzz_alt">alt</a>.E._type = long</span>
</blockquote>
would affect the generation of elements of the <a href="#refMember_Int_fuzz_alt">alt</a>
member of the <a href="#refType_Int_fuzz">Int-fuzz</a> structure.
</p>




<a name="refCode"></a>
<h2>Generated code</h2>

<a name="refNormalizedName"></a>
<h3>Normalized name</h3>

<p>
Everywhere in generated code we use so-called 
<span class="ncbi_term">NormalizedName</span> which is produced
from an ASN.1 type name by replacing all minuses ("-") with underscores ("_")
and making first letter capital.
</p>

<a name="refCodeEnum"></a>
<h3>ENUMERATED types</h3>
By default, for every ENUMERATED type <span class="ncbi_app">DATATOOL</span>
will produce a C++ enum type with the name <span class="ncbi_term">ENormalizedName</span>.

<a name="refCodeClass"></a>
<h3>SEQUENCE and SET code</h3>

<a name="refCodeChoice"></a>
<h3>CHOICE code</h3>

<a name="refCodeOther"></a>
<h3>Other types code</h3>

<br />
<!--#include virtual="../../ssi/navlinks.shtml" -->

<!-- Begin footer content -->

<table border="0" cellspacing="0" width="100%" >
<tr>
<td align="left">
<address>
<a name="copyright"></a><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Eugene
Vasilchenko</a>&nbsp;</address>
</td>

<td>

<!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> --></td>

<td align="right"><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../../ssi/footer.shtml" -->
