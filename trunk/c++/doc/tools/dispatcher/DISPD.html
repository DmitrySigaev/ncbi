<!--#set var="TITLE" value="Network Service Mapper/Dispatcher (DISPD.CGI)" -->
<!--#set var="DOCROOT" value="../.." -->
<!--#include virtual="../../ssi/header.shtml" -->

<h1>Network Service Mapper/Dispatcher (<span class="ncbi_cgi">DISPD.CGI</span>)</h1>

<font size=1><span class="ncbi_note">Note</span>: Due to security issues, not all links in the public version
of this file could be accessible by outside NCBI users. Unrestricted version of this document is available to
inside NCBI users at:
<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/tools/dispatcher/DISPD.html" class="ncbi_url">http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/tools/dispatcher/DISPD.html</a>.
</font>

<h2>Contents</h2>

<ol>
<ul>
    <li> <a href="#ref_Overview">Overview</a>
    <li> <a href="#ref_Protocol">Protocol Description</a>
    <li> <a href="#ref_Communication">Communication schemes</a>
    <li> <a href="#ref_NCBID">Server Launcher (<span class="ncbi_cgi">NCBID.CGI</span>)</a>
</ul>
</ol>

<p><hr><p>

<a name="ref_Overview"></a><h2>Overview</h2>

<span class="ncbi_cgi">DISPD.CGI</span> is a CGI/1.0-compliant program, the purpose of which
is to map requested service name to an actual server location,
when the client has no direct access to <a href="LBSMD.html"><span class="ncbi_app">LBSMD</span></a>.
This mapping is called <span class="ncbi_term">dispatching</span>. Optionally <span class="ncbi_cgi">DISPD.CGI</span> can also pass data
between the client, requested the mapping, and the server, which implements the
service, and was found as a result of <span class="ncbi_term">dispatching</span>. This combined
mode is called <span class="ncbi_term">connection</span>. The client may choose either of these
modes if there is no special requirement on data transfer (e.g. firewall
connection). In some cases, however, the requested connection mode implicitly
limits the request to be a <span class="ncbi_term">dispatching</span>-only request, and actual
data flow between the client and the server occurs separately at a later stage.


<p><hr><p>

<a name="ref_Protocol"></a><h2>Protocol Description</h2>

Dispatching protocol is designed as an extension to HTTP/1.0 and is coded in the
HTTP header parts of the packets. The request (both <span class="ncbi_term">dispatching</span>
and <span class="ncbi_term">connection</span>) is done by sending an HTTP-packet to <span class="ncbi_cgi">DISPD.CGI</span> with
a query line of the form:

<blockquote class="ncbi_code">dispd.cgi?service=&lt;name></blockquote>

which can be followed by parameters (if applicable) to be passed to the
service. <span class="ncbi_var">&lt;name></span> defines the name of the service to be used.
The other parameters take form of one or more of the following construct:

<blockquote class="ncbi_code">&amp;&lt;param>[=&lt;value>]</blockquote>

where square brackets are used to denote an optional value part of the
parameter.

<p>
In case of a <span class="ncbi_term">connection</span> request, the request body can contain
data to be passed to the first found server, connection to which is
automatically initiated by <span class="ncbi_cgi">DISPD.GCI</span> after <span class="ncbi_term">dispatching</span>. On a contrary,
in case of a <span class="ncbi_term">dispatching</span>-only request the body is completely ignored, that is
the connection is dropped after the header has been read and then the reply gets
generated without consuming the body data and that may confuse an unprepared client.

<p>
Mapping of service name into server address is done via <a href="LBSMD.html">LBSM Daemon
(<span class="ncbi_app">LBSMD</span>)</a>, which has to run on the exactly same host where
<span class="ncbi_cgi">DISPD.CGI</span> has started. <span class="ncbi_cgi">DISPD.CGI</span> never
dispatches non-local client to a server marked as <span class="ncbi_term">local</span>-only (by means of
<a href="LBSMD.html#ref_Local"><span class="ncbi_value">L=yes</span></a> in configuration of <span class="ncbi_app">LBSMD</span>). Otherwise, the result
of dispatching is exactly what the client would get from <a href="../../libs/conn.html#ref_ServiceAPI">service
mapping API</a> if run locally. Explicitly specifying its capabilities, the client
can narrow the server search; for example, by choosing
<a href="#ref_Stateless">stateless</a> servers only.

<ul>

  <li>In the client request to <span class="ncbi_cgi">DISPD.CGI</span> the following additional
  HTTP tags are recognized:

  <p>
  <span class="ncbi_keyword">Accepted-Server-Types: &lt;list></span>
  <br>where <span class="ncbi_var">&lt;list></span> can include
  one or more of the following keywords separated by spaces:
  <ul type="square">
    <li><span class="ncbi_type">NCBID</span></li>
    <li><span class="ncbi_type">STANDALONE</span></li>
    <li><span class="ncbi_type">HTTP</span></li>
    <li><span class="ncbi_type">HTTP_GET</span></li>
    <li><span class="ncbi_type">HTTP_POST</span></li>
    <li><span class="ncbi_type">FIREWALL</span></li>
    <br>which describe <a href="LBSMD.html#ref_ServerType">server types</a> the client is capable to handle.<br>
    Default is <span class="ncbi_value">any</span> (when the tag is not present at all in the HTTP header),
    and in case of <span class="ncbi_term">connection</span> request, the dispatcher will accomodate an actual
    found server with the connection mode, which the client requested, by relaying data
    appropriately, and in a way suitable for the server.<br>
    <span class="ncbi_note">Note</span>: <span class="ncbi_type">FIREWALL</span> indicates that the client has chosen a <a href="#ref_Communication">firewall
    way of communication</a>.<br>
    <span class="ncbi_note">Note</span>: Some server types can be ignored if not compatible with current
    <a href="#Client-Mode">client mode</a>.
  </ul>

  <p>
  <a NAME="Client-Mode"></a><span class="ncbi_keyword">Client-Mode: &lt;client-mode></span>
  <br>where <span class="ncbi_var">&lt;client-mode></span> can be one of the following:
  <ul type="square">
    <li><a name="ref_Stateless"></a><span class="ncbi_type">STATELESS_ONLY</span></li> -
    specifies that the client is not capable of doing full-duplex data exchange
    with the server in a session mode (e.g. in a dedicated connection).
    <li><span class="ncbi_type">STATEFUL_CAPABLE</span></li> -
    should be used by the clients, which are
    capable of holding an open connection to a server. This keyword
    serves as a hint to dispatcher to try to open a direct TCP channel
    between the client and the server, thus reducing the network usage overhead.
  </ul>
  Default (when the tag is not present at all) is <span class="ncbi_type">STATELESS_ONLY</span> in order to support Web-browsers.

  <p>
  <span class="ncbi_keyword">Dispatch-Mode: &lt;dispatch-mode></span>
  <br>where <span class="ncbi_var">&lt;dispatch-mode></span> can be one of the following:
  <ul type="square">
    <li><span class="ncbi_type">INFORMATION_ONLY</span></li> - specifies that the request is a
    <span class="ncbi_term">dispatching</span> request, and no data and/or connection establishment
    with the server required at this stage. That is, <span class="ncbi_cgi">DISPD.CGI</span> only returns
    a list of available server specifications (if any), corresponding
    to requested service, and in accordance with client mode and server acceptance.<br>
    <li><span class="ncbi_type">NO_INFORMATION</span></li> - is used to disable sending the above
    mentioned dispatching information back to the client.
    This keyword is reserved solely for internal use by <span class="ncbi_cgi">DISPD.CGI</span> and
    should <em>not</em> be used by a side application.<br>
    <li><span class="ncbi_type">STATEFUL_INCLUSIVE</span></li> -
    informs <span class="ncbi_cgi">DISPD.CGI</span> that current request is a <span class="ncbi_term">connection</span> request,
    and because it is going over HTTP, it is treated as stateless, thus the
    dispatching would supply stateless servers only. This keyword modifies the
    default behavior, and dispatching information sent back along with
    server reply (resulting from data exchange) should include stateful
    servers as well, so allowing the client to go to a dedicated connection later.<br>
    <span class="ncbi_note">Note</span>: This keyword is not yet in use by present implementation of
    <a href="../../libs/conn.html#ref_ServiceConnector">service connector</a>.
  </ul>
  Default (in the absence of this tag) is <span class="ncbi_term">connection</span> request, and as it is going over HTTP,
  it is automatically considered stateless. This is to support calls for NCBI services from Web-browsers.

  <p>
  <span class="ncbi_keyword">Skip-Info-&lt;n>: &lt;server-info></span>
  <br>A number of <span class="ncbi_value">&lt;server-info></span> strings can be passed to <span class="ncbi_cgi">DISPD.CGI</span> to
  ignore the servers from being potential mapping targets
  (in case the client knows the listed servers either do not work or are not appropriate).
  <span class="ncbi_keyword">Skip-Info</span> tags are enumerated by numerical consequent suffices
  (<span class="ncbi_var">&lt;n></span>), starting from&nbsp;1. These tags are optional and should only be used
  if the client believes that the certain servers do not match the search
  criteria, or otherwise the client may end up with an unsuccessful mapping.

  <p>
  <span class="ncbi_keyword">Client-Host: &lt;host></span>
  <br>This tag is used by <span class="ncbi_cgi">DISPD.CGI</span> internally to identify the <span class="ncbi_var">&lt;host></span>,
  where the request comes from, in case of relaying involved. Although <span class="ncbi_cgi">DISPD.CGI</span>
  effectively disregards this tag if the request originates from outside NCBI, and
  thus it cannot be easily fooled by the address spoofing, inhouse applications <em>should not</em> use this
  tag when connecting to <span class="ncbi_cgi">DISPD.CGI</span> because the tag <em>is trusted and considered</em> within the NCBI Intranet.

  <p>
  <li>
  In response to the client <span class="ncbi_cgi">DISPD.CGI</span> can produce the following HTTP tags:

  <p>
  <span class="ncbi_keyword">Relay-Path: &lt;path></span>
  <br>the tag shows how the information was passed along by <span class="ncbi_cgi">DISPD.CGI</span> and <span class="ncbi_cgi">NCBID.CGI</span>.
  This is essential for debugging purposes.

  <p>
  <span class="ncbi_keyword">Server-Info-&lt;n>: &lt;server-info></span>
  <br>the tag(s) (enumerated increasingly by suffix <span class="ncbi_var">&lt;n></span>, starting from&nbsp;1) give a list of servers,
  where the requested service is available. The list can have up to&nbsp;5 entries. However,
  there is only one entry generated when the service was requested either in <a href="#ref_Communication">firewall mode</a>
  or by a Web-browser. For non-local client the returned server descriptors can include <span class="ncbi_type">FIREWALL</span>
  server specifications. Despite preserving information about host, port, type and other (but not all)
  parameters of the original servers, <span class="ncbi_type">FIREWALL</span> descriptors are not specifications of real servers,
  but they are created on-the-fly by <span class="ncbi_cgi">DISPD.CGI</span> to indicate that the connection point of the server
  cannot be otherwise reached without the use of <a href="#ref_Communication">either firewalling
  or relaying</a>.

  <p>
  <a name="ref_ConnectionInfo"></a><span class="ncbi_keyword">Connection-Info: &lt;host>&nbsp;&lt;port>&nbsp;&lt;ticket></span>
  <br>the tag gets generated in a response to a stateful-capable client and includes host (in a dotted notation) and port number
  (decimal value) of the connection point where the server is listening on (if either the server has specifically started or the
  <a href="fwdaemon.html">firewall daemon</a> has created that connection point due to the client request).
  The ticket value (hexadecimal) represents the 4-byte ticket that must be passed to the server as binary
  data in the very beginning of the stream. If instead of host, port and ticket
  information there is a keyword <span class="ncbi_type">TRY_STATELESS</span>, then for some reason
  (see <span class="ncbi_keyword">Dispatcher-Failures:</span> tag below) the request failed, but may succeed if the client would
  switch into stateless mode.

  <p>
  <span class="ncbi_keyword">Dispatcher-Failures: &lt;failures></span>
  <br>the tag value lists all transient failures, which dispatcher might have expirienced while
  processing request. Fatal error (if any) always appears as the last failure in the list.
  In this case, the reply body would contain a copy of the message, too.<br>
  <span class="ncbi_note">Note</span>: Fatal dispatching failure is also indicated by an unsuccessful HTTP completion code.

</ul>


<p><hr><p>

<a name="ref_Communication"></a><h2>Communication Schemes</h2>

After making <span class="ncbi_term">dispatching</span> request and using the dispatching information returned,
the client can usually connect to the server on its own. Sometimes however, the client has
to connect to <span class="ncbi_cgi">DISPD.CGI</span> again in order to proceed with communication with the server.
For <span class="ncbi_cgi">DISPD.CGI</span> this would then be a <span class="ncbi_term">connection</span> request, which can
go one of either 2 similar ways:  <span class="ncbi_term">relaying</span> and <span class="ncbi_term">firewalling</span>.

<ul type="circle">
  <li>In <span class="ncbi_term">relay</span> mode <span class="ncbi_cgi">DISPD.CGI</span> passes data from the client to
  the server and back, playing the role of a middleman. Data <span class="ncbi_term">relaying</span> occurs when, for instance,
  a Web-browser client wants to communicate with a service governed by <span class="ncbi_cgi">DISPD.CGI</span> itself.
  <li>In <span class="ncbi_term">firewall</span> mode <span class="ncbi_cgi">DISPD.CGI</span> only sends out the information
  about where the client has to connect to in order to communicate with the server.
  This connection point and verifiable ticket are specified in <a href="#ref_ConnectionInfo"><span class="ncbi_keyword">Connection-Info:</span></a>
  tag in the reply header.<br>
  <span class="ncbi_note">Note</span>: <span class="ncbi_term">Firewalling</span> is actually pertaining only to stateful-capable clients and servers.
</ul>
<span class="ncbi_term">Firewall</span> mode is selected by the presence of keyword <span class="ncbi_type">FIREWALL</span> in
<span class="ncbi_keyword">Accepted-Server-Types:</span> tag set by the client sitting behind a firewall,
and not being able to connect to an arbitrary port.

<p>
These are scenarios of data flow between the client and the server
depending on "stateness" of the client:
<ul>
  <li><span class="ncbi_term">Stateless</span> client
  <ul type="square">
  <li>Client is <em>not  using firewall</em> mode:
  <ol type="A">
  <li> the client has to connect to the server by its own, using dispatching
       information obtained earlier, or
  <li> the client connects to <span class="ncbi_cgi">DISPD.CGI</span> in <span class="ncbi_term">connection</span> request
       (e.g. the case of Web-browsers), and <span class="ncbi_cgi">DISPD.CGI</span>
       makes data relaying for the client to the server.
  </ol>
  <li>Client chooses to use <span class="ncbi_term">firewall</span> mode, then the only
  way to communicate with server is to connect to <span class="ncbi_cgi">DISPD.CGI</span> (making
  <span class="ncbi_term">connection</span> request), and use <span class="ncbi_cgi">DISPD.CGI</span> as a relay.
  <br>
  <span class="ncbi_note">Note</span>:
  Even if the server is standalone (but <span class="ncbi_term">lacking</span> <a href="LBSMD.html#ref_Stateful"><span class="ncbi_value">S=yes</span></a>
  in configuration file of <span class="ncbi_app">LBSMD</span>), then <span class="ncbi_cgi">DISPD.CGI</span> initiates a microsession
  to the server and wraps its output into HTTP/1.0-compliant reply.
  Data from both <span class="ncbi_interface">HTTP</span> and <span class="ncbi_interface">NCBID</span> servers are simply relayed one-to-one.
  </ul>

  <li><span class="ncbi_term">Stateful-capable</span> client
  <ul type="square">
  <li>Client <em>not using firewall</em> mode
      has to connect directly to the server, using dispatcher
      information obtained earlier (e.g. with the use of <span class="ncbi_type">INFORMATION_ONLY</span>
      in <span class="ncbi_keyword">Dispatch-Mode:</span> tag).
  <li>If <span class="ncbi_term">firewall</span> mode selected then the client has to expect <a href="#ref_ConnectionInfo"><span class="ncbi_keyword">Connection-Info:</span></a>
      to come back from <span class="ncbi_cgi">DISPD.CGI</span> pointing where to connect to
      the server. If <span class="ncbi_type">TRY_STATELESS</span> comes out as a value of the former
      tag, then the client has to switch into stateless mode (e.g. by setting <span class="ncbi_type">STATELESS_ONLY</span> in
      <span class="ncbi_keyword">Client-Mode:</span> tag) in order for the request to succeed.<br>
      <span class="ncbi_note">Note</span>: <span class="ncbi_type">TRY_STATELESS</span> could be induced by many reasons, mainly that all servers for the service are stateless
      ones, or that firewall daemon is not available on the host, where the client's request was received.
  </ul>
</ul>
<span class="ncbi_note">Note</span>: Outlined scenarios show that no prior dispatching information is required for a stateless client
to have in order to make a <span class="ncbi_term">connection</span> request, as <span class="ncbi_cgi">DISPD.CGI</span> can
always be used as a data relay (this way Web-browsers can access NCBI services).
But for stateful-capable client to establish a dedicated connection that
additional step of obtaining dispatching information must precede the actual <span class="ncbi_term">connection</span>.

<p>
In order to support requests from Web-browsers, which are unaware of HTTP
extensions comprising dispatching protocol, <span class="ncbi_cgi">DISPD.CGI</span> considers incoming request that
does not contain input dispatching tags, as a <span class="ncbi_term">connection</span> request from a stateless-only client.

<p>
<span class="ncbi_cgi">DISPD.CGI</span> uses simple heuristics in analyzing HTTP header to determine whether the <span class="ncbi_term">connection</span>
request comes from a Web-browser, or from an application (a <a href="../../libs/conn.html#ref_ServiceConnector">service
connector</a>, for instance). In case of a Web-browser, the data path could be chosen more expensive but more robust,
including connection retries if required, while on the contrary with an application, the dispatcher could return
an error and the retry is delegated to the application.

<p>
<span class="ncbi_cgi">DISPD.CGI</span> always preserves original HTTP tags <span class="ncbi_keyword">User-Agent:</span> and <span class="ncbi_keyword">Client-Platform:</span> when
doing both <span class="ncbi_term">relaying</span> and <span class="ncbi_term">firewalling</span>.


<p><hr><p>

<a name="ref_NCBID"></a><h2>Server Launcher (<span class="ncbi_cgi">NCBID.CGI</span>)</h2>

There are servers of type <a href="LBSMD.html#ref_ServerType"><span class="ncbi_app">NCBID</span></a>, which
are really programs that read requests from <span class="ncbi_keyword">stdin</span> and write responses into
<span class="ncbi_keyword">stdout</span> without having sort of a common protocol. Thus, HTTP/1.0 was
chosen as a framed protocol for wrapping both requests and replies, and <span class="ncbi_cgi">NCBID.CGI</span>
utility CGI program was created to pass the request from HTTP body to the
server and to put reply from the server into HTTP body and send back to the client.
Also, <span class="ncbi_cgi">NCBID.CGI</span> is to provide a dedicated connection between the
server and the client, if the client supports the stateful way of communication.
Formely <span class="ncbi_cgi">NCBID.CGI</span> was implemented as a
separate CGI program, but recently it was integrated into and became a part of
<span class="ncbi_cgi">DISPD.CGI</span> (now <span class="ncbi_cgi">NCBID.CGI</span> is a symbolic link to <span class="ncbi_cgi">DISPD.CGI</span>).

<p>
<span class="ncbi_cgi">NCBID.CGI</span> determines the requested service from the query string the
same way <span class="ncbi_cgi">DISPD.CGI</span> does so, i.e. by looking into the
value of CGI parameter <span class="ncbi_app_a">service</span>. Executable file that has to be run is then obtained by searching
configuration file (shared with <span class="ncbi_app">LBSMD</span>, default name is <span class="ncbi_file">servrc.cfg</span>):
the path to the executable along with optional command-line parameters is specified after the bar character
(<span class="ncbi_keyword">"|"</span>) in the line containing the <a href="LBSMD.html#ref_Service">service definition</a>.

<p>
<span class="ncbi_cgi">NCBID.CGI</span> can work in either of&nbsp;2 connection modes, stateless and stateful,
as determined by reading the following HTTP header tag:

<ul>
<span class="ncbi_keyword">Connection-Mode: &lt;mode></span>
<br>where <span class="ncbi_var">&lt;mode></span> is one of the following:
<ul type="square">
<li><span class="ncbi_type">STATEFUL</span></li>
<li><span class="ncbi_type">STATELESS</span></li>
</ul>
Default (when the tag is missing) is <span class="ncbi_type">STATELESS</span> to support calls from Web-browsers.
</ul>

<p>
When <span class="ncbi_cgi">DISPD.CGI</span> relays data to <span class="ncbi_cgi">NCBID.CGI</span> this tag is set in
accordance with current client mode.

<p>
<span class="ncbi_type">STATELESS</span> mode is almost identical to a call of a conventional CGI program,
except that in HTTP header there could be tags pertaining to dispatching protocol,
and resulting from data relaying (if any) by <span class="ncbi_cgi">DISPD.CGI</span>.

<p>
In <span class="ncbi_type">STATEFUL</span> mode <span class="ncbi_cgi">NCBID.CGI</span> starts the program in a more tricky way,
which is closer to work in firewall mode for <span class="ncbi_cgi">DISPD.CGI</span>. Namely, <span class="ncbi_cgi">NCBID.CGI</span>
loads the  program with its <span class="ncbi_keyword">stdin</span> and <span class="ncbi_keyword">stdout</span> bound to a port, which is
made listening. That is the program becomes sort of an Internet daemon (only exception
that exactly one incoming connection is allowed). Then the client is sent back an HTTP
reply containing <a href="#ref_ConnectionInfo"><span class="ncbi_keyword">Connection-Info:</span></a> tag.
The client has to use port, host and ticket from that tag in order to connect to
the server by creating a dedicated TCP connection.<br>
<span class="ncbi_note">Note</span>: <span class="ncbi_cgi">NCBID.CGI</span> <em>never</em> generates <span class="ncbi_type">TRY_STATELESS</span> keyword.

<p>
For the sake of backward compatibility, <span class="ncbi_cgi">NCBID.CGI</span> creates the following
environment variables (in addition to CGI/1.0 environment variables created by the HTTP daemon
when calling <span class="ncbi_cgi">NCBID.CGI</span>) before starting the service executables: <span class="ncbi_env">NI_CLIENT_IPADDR</span> and
<span class="ncbi_env">NI_CLIENT_PLATFORM</span>. The former contains an IP address of the remote host (could
be IP address of the firewall daemon if <span class="ncbi_cgi">NCBID.CGI</span> was started as a
result of <span class="ncbi_term">firewalling</span>. The latter environment variable contains the client
platform extracted from the HTTP tag <span class="ncbi_keyword">Client-Platform:</span> if any provided
by the client.


<!--#include virtual="../../ssi/navlinks.shtml" -->

<table border=0 width="100%" cellspacing=0>
<tr>
<td align=left>
  <address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Anton Lavrentiev</a></address>
</td>
<!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> -->
<td align=right><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../../ssi/footer.shtml" -->
