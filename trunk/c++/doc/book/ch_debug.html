<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Debugging, Exceptions, and Error Handling - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_debug" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="js/jig/1.7/js/jig.min.js"></script><script type="text/javascript" src="js/toolkitSymbolSearch.js"></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents â–¾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access - SQL, Berkley DB</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_xmlauthor.html">29. XML Authoring using Word</a></li><li class="half_rhythm"><a href="ch_faq.html">30. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">31. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a><ul class="simple-list"><li class="half_rhythm"><a href="release_notes.html">Release Notes (Version 9, May 2012)</a></li><li class="half_rhythm"><a href="release_notes_7-05_2011.html">Release Notes (Version 7, May 2011)</a></li><li class="half_rhythm"><a href="release_notes_06_29_2010.html">Release Notes (June, 2010)</a></li><li class="half_rhythm"><a href="release_notes_05_15_2009.html">Release Notes (May, 2009)</a></li><li class="half_rhythm"><a href="release_notes_12_24_2008.html">Release Notes (December, 2008)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2008.html">Release Notes (March, 2008)</a></li><li class="half_rhythm"><a href="release_notes_08_27_2007.html">Release Notes (August, 2007)</a></li><li class="half_rhythm"><a href="release_notes_03_12_2007.html">Release Notes (March, 2007)</a></li><li class="half_rhythm"><a href="release_notes_08_14_2006.html">Release Notes (August, 2006)</a></li><li class="half_rhythm"><a href="release_notes_04_30_2006.html">Release Notes (April 30, 2006)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2005.html">Release Notes (December 31, 2005)</a></li><li class="half_rhythm"><a href="release_notes_10_03_2005.html">Release Notes (August, 2005)</a></li><li class="half_rhythm"><a href="release_notes_05_05_2005.html">Release Notes (April, 2005)</a></li><li class="half_rhythm"><a href="release_notes_03_09_2005.html">Release Notes (February, 2005)</a></li><li class="half_rhythm"><a href="release_notes_11_22_2004.html">Release Notes (November 22, 2004)</a></li><li class="half_rhythm"><a href="release_notes_10_2_2004.html">Release Notes (October 2, 2004)</a></li><li class="half_rhythm"><a href="release_notes_7_8_2004.html">Release Notes (July 8, 2004)</a></li><li class="half_rhythm"><a href="release_notes_april_16_2004.html">Release Notes (April 16, 2004)</a></li><li class="half_rhythm"><a href="release_notes_12_08_2003.html">Release Notes (December 8, 2003)</a></li><li class="half_rhythm"><a href="release_notes_08_01_2003.html">Release Notes (August 1, 2003)</a></li></ul></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="part5.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="ch_grid.html">Next &gt;</a></div></div><div class="meta_content"><h1><span class="label">22</span><span class="title">Debugging, Exceptions, and Error Handling</span></h1><p class="small">Last Update: July 18, 2010.</p></div><div class="body_content"><div class="sec"><h2><span class="title">Overview</span></h2><p>The overview for this chapter consists of the following topics:</p><ul><li><p>Introduction</p></li><li><p>Chapter Outline</p></li></ul><div class="sec"><h3><span class="title">Introduction</span></h3><p>This chapter discusse the debugging mechanisms available in the NCBI C++ toolkit. There are two approaches to getting more information about an application, which does not behave correctly:</p><ul><li><p>Investigate the application's log without recompiling the program,</p></li><li><p>Add more diagnostics and recompile the program.</p></li></ul><p>Of course, there is always the third method which is to run the program under an external debugger. While using an external debugger is a viable option, this method relies on an external program and not on a log or diagnostics produced by the program itself which in many cases is customized to reflect the program behavior, and can, therefore, more quickly reveal the source of errors.</p></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p><ul><li><p><a href="ch_debug.html#ch_debug.extracting_debug_data">Extracting Debug Data</a></p><ul><li><p><a href="ch_debug.html#ch_debug.command_line">Command Line Parameters</a></p></li><li><p><a href="ch_debug.html#ch_debug.more_trace_data">Getting More Trace Data</a></p><ul><li><p><a href="ch_debug.html#ch_debug.tracing">Tracing</a></p></li><li><p><a href="ch_debug.html#ch_debug.diagnostic_messages">Diagnostic Messages</a></p></li></ul></li><li><p><a href="ch_debug.html#ch_debug.tracing_connection">Tracing in the Connection Library</a></p></li><li><p><a href="ch_debug.html#ch_debug.toolkit_diagnostics">NCBI C++ Toolkit Diagnostics</a></p></li><li><p><a href="ch_debug.html#ch_debug.object_state_dump">Object state dump</a></p></li><li><p><a href="ch_debug.html#ch_debug.exceptions">Exceptions</a></p></li></ul></li><li><p><a href="ch_debug.html#ch_debug.err_handling_diagnostics">NCBI C++ Error Handling and Diagnostics</a></p><ul><li><p><a href="ch_debug.html#ch_debug.debug_mode_internal">Debug-mode for Internal Use</a></p></li><li><p><a href="ch_debug.html#ch_debug.cpp_exceptions">C++ Exceptions</a></p><ul><li><p><a href="ch_debug.html#ch_debug.std_cpp_exceptions">Standard C++ Exception Classes, and Two Useful NCBI Exception Classes (CErrnoTemplException, CParseTemplException)</a></p></li><li><p><a href="ch_debug.html#ch_debug.using_std_catch">Using STD_CATCH_*(...) to catch and report exceptions</a></p></li><li><p><a href="ch_debug.html#ch_debug.throw_trace">Using THROW*_TRACE(...) to throw exceptions</a></p></li><li><p><a href="ch_debug.html#ch_debug.throw_excep_spec">THROWS*(...) -- Exception Specification</a></p></li></ul></li><li><p><a href="ch_debug.html#ch_debug.std_cpp_message_post">Standard NCBI C++ Message Posting</a></p><ul><li><p><a href="ch_debug.html#ch_debug.formatting_manipulators">Formatting and Manipulators</a></p></li><li><p><a href="ch_debug.html#ch_debug.ERR_POST_ref">ERR_POST macro</a></p></li><li><p><a href="ch_debug.html#ch_debug.turn_on_tracing">Turn on the Tracing</a></p></li></ul></li></ul></li><li><p><a href="ch_debug.html#ch_debug.debug_dump">DebugDump: Take an Object State Snapshot</a></p><ul><li><p><a href="ch_debug.html#ch_debug.debug_terminology">Terminology</a></p></li><li><p><a href="ch_debug.html#ch_debug.debug_requirements">Requirements</a></p></li><li><p><a href="ch_debug.html#ch_debug.debug_architecture">Architecture</a></p></li><li><p><a href="ch_debug.html#ch_debug.debug_impl">Implementation</a></p><ul><li><p><a href="ch_debug.html#ch_debug.CDebugDumpable">CDebugDumpable</a></p></li><li><p><a href="ch_debug.html#ch_debug.CDebugDumpContext">CDebugDumpContext</a></p></li><li><p><a href="ch_debug.html#ch_debug.CDebugDumpFormatter">CDebugDumpFormatter</a></p></li></ul></li><li><p><a href="ch_debug.html#ch_debug.debug_examples">Examples</a></p></li></ul></li><li><p><a href="ch_debug.html#ch_debug.excep_cpp_toolkit">Exception Handling (*) in the NCBI C++ Toolkit</a></p><ul><li><p><a href="ch_debug.html#ch_debug.ncbi_cpp_exceptions">NCBI C++ Exceptions</a></p><ul><li><p><a href="ch_debug.html#ch_debug.excep_requirements">Requirements</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_architecture">Architecture</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_impl">Implementation</a></p><ul><li><p><a href="ch_debug.html#ch_debug.CException">CException</a></p></li><li><p><a href="ch_debug.html#ch_debug.derived_exceptions">Derived exceptions</a></p></li><li><p><a href="ch_debug.html#ch_debug.reporting_exceptions">Reporting an exception</a></p></li><li><p><a href="ch_debug.html#ch_debug.CExceptionReporter">CExceptionReporter</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_err_codes">Choosing and analyzing error codes</a></p></li></ul></li><li><p><a href="ch_debug.html#ch_debug.excep_examples">Examples</a></p><ul><li><p><a href="ch_debug.html#ch_debug.excep_throwing_example">Throwing an exception</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_reporting_example">Reporting an exception</a></p></li></ul></li></ul></li><li><p><a href="ch_debug.html#ch_debug.CErrnoTemplException">The CErrnoTemplException Class</a></p></li><li><p><a href="ch_debug.html#ch_debug.CParseTemplException">The CParseTemplException Class</a></p></li><li><p><a href="ch_debug.html#ch_debug.std_excep_macros">Macros for Standard C++ Exception Handling</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_tracing">Exception Tracing</a></p></li></ul></li></ul></div></div><div class="sec" id="ch_debug.extracting_debug_data"><h2><span class="title">Extracting Debug Data</span></h2><p>The C++ Toolkit has several mechanisms which can be used by a programmer to extract information about the program usage, printing trace and diagnostic messages, and examining the object state dump. The following sections discuss these topics in more detail:</p><ul><li><p><a href="ch_debug.html#ch_debug.command_line">Command Line Parameters.</a></p></li><li><p><a href="ch_debug.html#ch_debug.more_trace_data">Getting More Trace Data.</a></p></li><li><p><a href="ch_debug.html#ch_debug.tracing_connection">Tracing in the Connection Library</a></p></li><li><p><a href="ch_debug.html#ch_debug.toolkit_diagnostics">NCBI C++ Toolkit Diagnostics</a></p></li><li><p><a href="ch_debug.html#ch_debug.object_state_dump">Object state dump</a></p></li><li><p><a href="ch_debug.html#ch_debug.exceptions">Exceptions</a></p></li></ul><div class="sec" id="ch_debug.command_line"><h3><span class="title">Command Line Parameters</span></h3><p>There are several command line parameters (see <a href="ch_debug.html#ch_debug.T1">Table 1</a>), which are applicable to any program which utilizes NCBI C++ toolkit, namely <a href="ch_core.html#ch_core.writing_simple_app">CNcbiApplication</a> class. They provide with the possibility</p><div class="table" id="ch_debug.T1"><div class="caption"><p>Table 1. Command line parameters available for use to any program that uses CNcbiApplication</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Flag</th><th align="left" valign="top" rowspan="1" colspan="1">Description</th><th align="left" valign="top" rowspan="1" colspan="1">Example</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-cmd">-h</span></td><td align="left" valign="top" rowspan="1" colspan="1">Print description of the application's command line parameters.</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-cmd">theapp -h</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-cmd">-logfile</span></td><td align="left" valign="top" rowspan="1" colspan="1">Redirect program's log into the specified file</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-cmd">theapp -logfile theapp_log</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-cmd">-conffile</span></td><td align="left" valign="top" rowspan="1" colspan="1">Read the program's configuration data from the specified file</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-cmd">theapp -conffile theapp_cfg</span></td></tr></tbody></table></div><ul><li><p>to obtain a general description of the program as well as description of all available command line parameters (<span class="nctnt ncbi-cmd">-h</span> flag),</p></li><li><p>to redirect the program's <a href="ch_core.html#ch_core.diag">diagnostic messages</a> into a specified file (<span class="nctnt ncbi-cmd">-logfile</span> key),</p></li><li><p>to read the program's <a href="ch_core.html#ch_core.registry">configuration data</a> from a specified file (<span class="nctnt ncbi-cmd">-conffile</span> key).</p></li></ul></div><div class="sec" id="ch_debug.more_trace_data"><h3><span class="title">Getting More Trace Data</span></h3><p>All NCBI C++ toolkit libraries produce a good deal of diagnostic messages. Still, many of them remain "invisible" - as long as the tracing is disabled. Some tracing data is only available in debug builds - see <a href="ch_core.html#ch_core._TRACE">_TRACE</a> macro for example. Other - e.g., the one produced by <a href="ch_core.html#ch_core.ERR_POST">ERR_POST</a> or <span class="nctnt ncbi-macro">LOG_POST</span> macros - could be disabled. There are three ways to manipulate these settings, that is enable or disable tracing, or set the severity level of messages to print:</p><ul><li><p>from the application itself,</p></li><li><p>from the application's configuration file,</p></li><li><p>with the help of environment variables.</p></li></ul><p>The following additional topics relating to trace data are presented in the subsections that follow:</p><ul><li><p><a href="ch_debug.html#ch_debug.tracing">Tracing</a></p></li><li><p><a href="ch_debug.html#ch_debug.diagnostic_messages">Diagnostic Messages</a></p></li></ul><div class="sec" id="ch_debug.tracing"><h4><span class="title">Tracing</span></h4><p>There are two ways to post trace messages: using either the <a href="ch_core.html#ch_core._TRACE">_TRACE</a> macro or the <a href="ch_core.html#ch_core.ERR_POST">ERR_POST</a> macro. Trace messages produced with the help of <span class="nctnt ncbi-macro">_TRACE</span> macro are only available in debug mode, while those posted by <span class="nctnt ncbi-macro">ERR_POST</span> are available in both release and debug builds. By default, tracing is disabled. See <a href="ch_debug.html#ch_debug.T2">Table 2</a> for settings to enable tracing.</p><div class="table" id="ch_debug.T2"><div class="caption"><p>Table 2. Enabling Tracing</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">C++ toolkit API</th><th align="left" valign="top" rowspan="1" colspan="1">Configuration file</th><th align="left" valign="top" rowspan="1" colspan="1">Environment</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">call:<br /><span class="nctnt ncbi-code">SetDiagTrace(eDT_Enable);</span></td><td align="left" valign="top" rowspan="1" colspan="1">define <span class="nctnt ncbi-var">DIAG_TRACE</span> entry in the <span class="nctnt ncbi-var">DEBUG</span> section:<br /><span class="nctnt ncbi-code">[DEBUG]</span><br /><span class="nctnt ncbi-code">DIAG_TRACE=1</span></td><td align="left" valign="top" rowspan="1" colspan="1">define <span class="nctnt ncbi-var">DIAG_TRACE</span> environment variable:<br /><span class="nctnt ncbi-cmd">set DIAG_TRACE=1</span></td></tr></tbody></table></div><p>Please note, when enabling trace from a configuration file, some trace messages could be lost: before configuration file is found and read the application may assume that the trace was disabled. The only way to enable tracing from the very beginning is by setting the environment variable.</p></div><div class="sec" id="ch_debug.diagnostic_messages"><h4><span class="title">Diagnostic Messages</span></h4><p>Diagnostic messages produced by <a href="ch_core.html#ch_core.ERR_POST">ERR_POST</a> macro are available both in debug and release builds. Such messages have a <a href="ch_core.html#ch_core.diag_severity">severity level</a>, which defines whether the message will be actually printed or not, and whether the program will be aborted or not. To change the severity level threshold for posting diagnostic messages, see <a href="ch_debug.html#ch_debug.T3">Table 3</a>.</p><div class="table" id="ch_debug.T3"><div class="caption"><p>Table 3. Changing severity level for diagnostic messages</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">C++ toolkit API</th><th align="left" valign="top" rowspan="1" colspan="1">Configuration file</th><th align="left" valign="top" rowspan="1" colspan="1">Environment</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">call:<br /><span class="nctnt ncbi-code">SetDiagPostLevel(EDiagSev postSev);</span><br />Valid arguments are <span class="nctnt ncbi-var">eDiag_Info</span>, <span class="nctnt ncbi-var">eDiag_Warning</span>, <span class="nctnt ncbi-var">eDiag_Error</span>, <span class="nctnt ncbi-var">eDiag_Critical</span>, <span class="nctnt ncbi-var">eDiag_Fatal</span>.</td><td align="left" valign="top" rowspan="1" colspan="1">define <span class="nctnt ncbi-var">DIAG_POST_LEVEL</span> entry in the <span class="nctnt ncbi-var">DEBUG</span> section:<br /><span class="nctnt ncbi-code">[DEBUG]</span><br /><span class="nctnt ncbi-code">DIAG_POST_LEVEL=Info</span><br />Valid values are <span class="nctnt ncbi-monospace">Info</span>, <span class="nctnt ncbi-monospace">Warning</span>, <span class="nctnt ncbi-monospace">Error</span>, <span class="nctnt ncbi-monospace">Critical</span>, <span class="nctnt ncbi-monospace">Fatal</span>.</td><td align="left" valign="top" rowspan="1" colspan="1">define <span class="nctnt ncbi-var">DIAG_POST_LEVEL</span> environment variable:<br /><span class="nctnt ncbi-cmd">set DIAG_POST_LEVEL=Info</span><br />Valid values are <span class="nctnt ncbi-monospace">Info</span>, <span class="nctnt ncbi-monospace">Warning</span>, <span class="nctnt ncbi-monospace">Error</span>, <span class="nctnt ncbi-monospace">Critical</span>, <span class="nctnt ncbi-monospace">Fatal</span>.</td></tr></tbody></table></div><p>Only those messages, which severity is equal or exceeds the threshold will be posted. By default, messages posted with <span class="nctnt ncbi-monospace">Fatal</span> severity level also abort execution of the program. This can be changed by <span class="nctnt ncbi-func">SetDiagDieLevel(EDiagSev dieSev)</span> API function.</p></div></div><div class="sec" id="ch_debug.tracing_connection"><h3><span class="title">Tracing in the Connection Library</span></h3><p>The <a href="ch_conn.html">connection library</a> has its own <a href="ch_conn.html#ch_conn.conn_debug_tools">tracing options</a>. It is possible to print the connection parameters each time the link is established, and even log all data transmitted through the socket during the life of the connection (see <a href="ch_debug.html#ch_debug.T4">Table 4</a>).</p><div class="table" id="ch_debug.T4"><div class="caption"><p>Table 4. Setting up trace options for connection library</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1"></th><th align="left" valign="top" rowspan="1" colspan="1">Configuration file</th><th align="left" valign="top" rowspan="1" colspan="1">Environment</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><b>Connection parameters:</b></td><td align="left" valign="top" rowspan="1" colspan="1">define <span class="nctnt ncbi-var">DEBUG_PRINTOUT</span> entry in the <span class="nctnt ncbi-var">CONN</span> section:<br /><span class="nctnt ncbi-code">[CONN]</span><br /><span class="nctnt ncbi-code">DEBUG_PRINTOUT=TRUE</span><br />Valid values are <span class="nctnt ncbi-monospace">TRUE</span>, or <span class="nctnt ncbi-monospace">YES</span>, or <span class="nctnt ncbi-monospace">SOME</span>.</td><td align="left" valign="top" rowspan="1" colspan="1">define <span class="nctnt ncbi-var">CONN_DEBUG_PRINTOUT</span> environment variable:<br /><span class="nctnt ncbi-cmd">set CONN_DEBUG_PRINTOUT=TRUE</span><br />Valid values are <span class="nctnt ncbi-monospace">TRUE</span>, or <span class="nctnt ncbi-monospace">YES</span>, or <span class="nctnt ncbi-monospace">SOME</span>.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><b>All data:</b></td><td align="left" valign="top" rowspan="1" colspan="1">define <span class="nctnt ncbi-var">DEBUG_PRINTOUT</span> entry in the <span class="nctnt ncbi-var">CONN</span> section:<br /><span class="nctnt ncbi-code">[CONN]</span><br /><span class="nctnt ncbi-code">DEBUG_PRINTOUT=ALL</span><br />Valid values are <span class="nctnt ncbi-monospace">ALL</span>, or <span class="nctnt ncbi-monospace">DATA</span>. </td><td align="left" valign="top" rowspan="1" colspan="1">define <span class="nctnt ncbi-var">CONN_DEBUG_PRINTOUT</span> environment variable:<br /><span class="nctnt ncbi-cmd">set CONN_DEBUG_PRINTOUT=ALL</span><br />Valid values are <span class="nctnt ncbi-monospace">ALL</span>, or <span class="nctnt ncbi-monospace">DATA</span>.</td></tr></tbody></table></div></div><div class="sec" id="ch_debug.toolkit_diagnostics"><h3><span class="title">NCBI C++ Toolkit Diagnostics</span></h3><p>NCBI C++ toolkit provides with a sophisticated <a href="ch_debug.html#ch_debug.std_cpp_message_post">diagnostic mechanism</a>. Diagnostic messages could be redirected to different output channels. It is possible to set up what <a href="ch_core.html#ch_core.diag_post_flags">additional information</a> should be printed with a message, for example date/time stamp, file name, line number etc. Some macros are defined only in debug mode:<span class="nctnt ncbi-macro">_TRACE</span>, <span class="nctnt ncbi-macro">_ASSERT</span>, <span class="nctnt ncbi-macro">_TROUBLE</span>. Others are also defined in release mode as well: <span class="nctnt ncbi-macro">_VERIFY</span>, <span class="nctnt ncbi-macro">THROW*_TRACE</span>.</p></div><div class="sec" id="ch_debug.object_state_dump"><h3><span class="title">Object state dump</span></h3><p>Potentially useful technique in case of trouble is to use <a href="ch_debug.html#ch_debug.debug_dump">object state dump API</a>. In order to use it, the object's class must be derived from <a href="ch_debug.html#ch_debug.CDebugDumpable">CDebugDumpable</a> class, and implementation of the class should supply meaningful dump data in its <span class="nctnt ncbi-func">DebugDump</span> function. Debug dump gives an object's state snapshot, which can help in identifying the cause of problem at run time.</p></div><div class="sec" id="ch_debug.exceptions"><h3><span class="title">Exceptions</span></h3><p>NCBI C++ toolkit defines its own type of <a href="ch_debug.html#ch_debug.excep_cpp_toolkit">C++ exceptions</a>. Unlike standard ones, this class</p><ul><li><p>makes it possible to define error codes (specific to each exception class), which could be analyzed from a program,</p></li><li><p>provides with more information about where a particular exception has been thrown from (file name and line number),</p></li><li><p>gives the possibility to create a stack of exceptions to accumulate a backlog of events (unfinished jobs) which caused the problem,</p></li><li><p>has elaborated, customizable reporting mechanism,</p></li><li><p>supports using standard <a href="ch_core.html#ch_core.diag">diagnostic mechanism</a> with all the configuration options it provides.</p></li></ul></div></div><div class="sec" id="ch_debug.err_handling_diagnostics"><h2><span class="title">NCBI C++ Error Handling and Diagnostics</span></h2><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_debug.html#ch_debug.debug_mode_internal">Debug-mode for Internal Use</a></p></li><li><p><a href="ch_debug.html#ch_debug.cpp_exceptions">C++ Exceptions</a></p></li><li><p><a href="ch_debug.html#ch_debug.std_cpp_message_post">Standard NCBI C++ Message Posting</a></p></li></ul><div class="sec" id="ch_debug.debug_mode_internal"><h3><span class="title">Debug-mode for Internal Use</span></h3><p><span class="nctnt ncbi-code">#include &lt;corelib/ncbidbg.hpp&gt;</span> [also included in &lt;corelib/ncbistd.hpp&gt;]</p><p>There are four preprocessor macros (<span class="nctnt ncbi-macro">_TROUBLE</span>, <span class="nctnt ncbi-macro">_ASSERT</span>, <span class="nctnt ncbi-macro">_VERIFY</span> and <span class="nctnt ncbi-macro">_TRACE</span>) to help the developer to catch some (logical) errors on the early stages of code development and to hardcode some assertions on the code and data behaviour for internal use. All these macros gets disabled in the non-debug versions lest to affect the application performance and functionality; to turn them on, one must <span class="nctnt ncbi-code">#define</span> the <span class="nctnt ncbi-macro">_DEBUG</span> preprocessor variable. Developer must be careful and do not use any code with side effects in <span class="nctnt ncbi-macro">_ASSERT</span> or <span class="nctnt ncbi-macro">_TRACE</span> as this will cause a discrepancy in functionality between debug and non-debug code. For example, <span class="nctnt ncbi-macro">_ASSERT(a++)</span> and <span class="nctnt ncbi-code">_TRACE("a++ = " &lt;&lt; a++)</span> would increment <span class="nctnt ncbi-var">"a"</span> in the debug version but do nothing in the non-debug one).</p><ul><li><p><span class="nctnt ncbi-macro">_TROUBLE</span> -- Has absolutely no effect if <span class="nctnt ncbi-macro">_DEBUG</span> is not defined; otherwise, unconditionally halt the application.</p></li><li><p><span class="nctnt ncbi-macro">_ASSERT(expr)</span> -- Has absolutely no effect if <span class="nctnt ncbi-macro">_DEBUG</span> is not defined; otherwise, evaluate expression <span class="nctnt ncbi-var">expr</span> and halt the application if <span class="nctnt ncbi-var">expr</span> resulted in zero(or <span class="nctnt ncbi-monospace">"false"</span>).</p></li><li><p><span class="nctnt ncbi-macro">_VERIFY(expr)</span> -- Evaluate expression <span class="nctnt ncbi-var">expr</span>; if <span class="nctnt ncbi-macro">_DEBUG</span> is defined and <span class="nctnt ncbi-var">expr</span> resulted in zero(or <span class="nctnt ncbi-monospace">"false"</span>) then halt the application.</p></li><li><p><span class="nctnt ncbi-macro">_TRACE(message)</span> -- Has absolutely no effect if <span class="nctnt ncbi-macro">_DEBUG</span> is not defined; otherwise, it outputs the <span class="nctnt ncbi-var">message</span> using <a href="ch_debug.html#ch_debug.std_cpp_message_post">Standard NCBI C++ message posting</a>. NOTE: as a matter of fact, the tracing is turned off by default, even if <span class="nctnt ncbi-macro">_DEBUG</span> is defined, and you still have to do <a href="ch_debug.html#ch_debug.turn_on_tracing">a special configuration</a> to really turn it on.</p></li></ul><p>All these macros automatically report the file name and line number to the diagnostics. For example, this code located in file <span class="nctnt ncbi-path">"somefile.cpp"</span> at line 333:</p><pre>int x = 100;<br />_TRACE( "x + 5 = " &lt;&lt; (x + 5) );</pre><p>will output:</p><pre>"somefile.cpp", line 333: Trace: x + 5 = 105</pre></div><div class="sec" id="ch_debug.cpp_exceptions"><h3><span class="title">C++ Exceptions</span></h3><p><span class="nctnt ncbi-code">#include &lt;corelib/ncbiexpt.hpp&gt;</span> [also included in &lt;corelib/ncbistd.hpp&gt;]</p><p>The following additional topics are discussed in this section:</p><ul><li><p><a href="ch_debug.html#ch_debug.std_cpp_exceptions">Standard C++ Exception Classes, and Two Useful NCBI Exception Classes (CErrnoTemplException, CParseTemplException)</a></p></li><li><p><a href="ch_debug.html#ch_debug.using_std_catch">Using STD_CATCH_*(...) to catch and report exceptions</a></p></li><li><p><a href="ch_debug.html#ch_debug.throw_trace">Using THROW*_TRACE(...) to throw exceptions</a></p></li><li><p><a href="ch_debug.html#ch_debug.throw_excep_spec">THROWS*(...) -- Exception Specification</a></p></li></ul><div class="sec" id="ch_debug.std_cpp_exceptions"><h4><span class="title">Standard C++ Exception Classes, and Two Useful NCBI Exception Classes (CErrnoTemplException, CParseTemplException)</span></h4><p>One must use <a href="ch_debug.html#ch_debug.CException">CException</a> as much as possible. When not possible, <a href="http://www.cplusplus.com/doc/tutorial/tut5-3.html">standard C++ exceptions</a> should be used. There are also a couple of auxiliary exception classes derived from <span class="nctnt ncbi-class">std::runtime_error</span> that may be used if necessary.</p><ul><li><p><span class="nctnt ncbi-class">CErrnoTemplException</span> -- to report failure in a standard C library function; it automatically appends to the user message a system-specific description reported by <span class="nctnt ncbi-var">errno</span></p></li><li><p><span class="nctnt ncbi-class">CParseTemplException</span> -- to report an erroneous position (passed in the additional constructor parameter) along with the user message</p></li></ul><p>Then, it is <b>strongly recommended</b> that when <a href="ch_debug.html#ch_debug.CException">CException</a> can't be used, and when the basic functionality provided by standard C++ exceptions is insufficient for some reason, one must derive new ad hoc exception classes from one of the standard exception classes. This provides a more uniform way of exception handling, because most exceptions can be caught and appropriately handled using the <span class="nctnt ncbi-macro">STD_CATCH_*(...)</span> preprocessor macros as described below.</p></div><div class="sec" id="ch_debug.using_std_catch"><h4><span class="title">Using <span class="nctnt ncbi-macro">STD_CATCH_*(...)</span> to catch and report exceptions</span></h4><p>You can use the <span class="nctnt ncbi-macro">STD_CATCH_*(...)</span> macros to catch exceptions potentially derived from the standard exception class <span class="nctnt ncbi-class">std::exception</span> when you just want to print out a given error name, subcode, and message along with the information returned from <span class="nctnt ncbi-func">std::exception::what()</span>.</p><p>The <span class="nctnt ncbi-macro">STD_CATCH_X(subcode, message)</span> and <span class="nctnt ncbi-macro">STD_CATCH_XX(name, subcode, message)</span> macros only catch exceptions derived from <span class="nctnt ncbi-class">std::exception</span>, and post the given error name, subcode, and message along with the information returned from <span class="nctnt ncbi-func">std::exception::what()</span>.</p><p>The <span class="nctnt ncbi-macro">STD_CATCH_ALL_X(subcode, message)</span> and <span class="nctnt ncbi-macro">STD_CATCH_ALL_XX(name, subcode, message)</span> macros first try to catch a <span class="nctnt ncbi-class">std::exception</span>-derived exception (using the <span class="nctnt ncbi-macro">STD_CATCH_X</span> and <span class="nctnt ncbi-macro">STD_CATCH_XX</span> macros, respectively), and if the thrown exception was not caught (i.e. if it is not derived from <span class="nctnt ncbi-class">std::exception</span>) then they catch all exceptions and post the given error name, subcode, and message.</p><p>The name argument must match one of the pre-defined values in the <span class="nctnt ncbi-path">error_codes.hpp</span> header for the relevant module (e.g. <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/include_2connect_2error__codes_8hpp.html">connect</a>), and the subcode argument must be within the range specified in the same place. The message argument can be of any form acceptable by the <a href="ch_debug.html#ch_debug.std_cpp_message_post">diagnostic class CNcbiDiag</a>.</p><p>Using these macros makes dealing with exceptions in NCBI C++ code easy:</p><pre>class foreign_exception { ..... };<br />class exception_derived_user : public exception { ..... };<br />char arg1 = "qqq";<br />int arg2 = 888;<br />try {<br />    SomeFunc(arg1, arg2);<br />} catch (foreign_exception&amp; fe) {<br />    // do something special with the particular "non-standard"<br />    // (not derived from "std::exception") exception "foreign_exception"<br />} catch (exception_derived_user&amp; eu) {<br />    // do something special with the particular "standard"<br />    // (derived from "std::exception") exception "exception_derived_user"<br />}<br />// handle all other "standard" exceptions in a uniform way<br />STD_CATCH_X( 1, "in SomeFunc(" &lt;&lt; arg1 &lt;&lt; "," &lt;&lt; arg2 &lt;&lt; ")" );</pre><p>Here, if <span class="nctnt ncbi-func">SomeFunc()</span> executes <span class="nctnt ncbi-code">throw std::runtime_error("Invalid Arg2");</span> then the application will print out (to its diagnostic stream) something like:</p><pre>Error: (101.1) [in SomeFunc(qqq,888)] Exception: Invalid Arg2</pre><p>In this output, the <span class="nctnt ncbi-monospace">(101.1)</span> indicates the error code (defined in the module's <span class="nctnt ncbi-path">error_codes.hpp</span> header) and the subcode passed to <span class="nctnt ncbi-macro">STD_CATCH_X</span>.</p></div><div class="sec" id="ch_debug.throw_trace"><h4><span class="title">Using <span class="nctnt ncbi-macro">THROW*_TRACE(...)</span> to throw exceptions</span></h4><p>If you use one of <span class="nctnt ncbi-macro">THROW*_TRACE(...)</span> macros to <span class="nctnt ncbi-monospace">throw</span> an exception, and the source was compiled in a debug mode (i.e. with the preprocessor <span class="nctnt ncbi-macro">_DEBUG</span> defined), then you can turn on the following features that proved to be very useful for debugging:</p><ul><li><p>If the <a href="ch_debug.html#ch_debug.turn_on_tracing">tracing is on</a>, then the location of the <span class="nctnt ncbi-monospace">throw</span> in the source code and the thrown exception will be printed out to the current diagnostic stream, e.g.:<br /><span class="nctnt ncbi-code">THROW_TRACE(CParseException, ("Failed parsing(at pos. 123)", 123));</span><br /><br /><span class="nctnt ncbi-code">"coretest.cpp", line 708: Trace: CParseException: {123}</span><br /><span class="nctnt ncbi-code">Failed parsing(at pos. 123)</span><br /><br /><span class="nctnt ncbi-code">---------------------------------</span><br /><br /><span class="nctnt ncbi-code">strtod("1e-999999", 0);</span><br /><span class="nctnt ncbi-code">THROW1_TRACE(CErrnoException, "Failed strtod('1e-999999', 0)");</span><br /><br /><span class="nctnt ncbi-code">"coretest.cpp", line 718: Trace: CErrnoException:</span><br /><span class="nctnt ncbi-code">Failed strtod('1e-999999', 0): Result too large</span></p></li><li><p>Sometimes, it can be convenient to just abort the program execution at the place where you throw an exception, e.g. in order to examine the program stack and overall state that led to this <span class="nctnt ncbi-monospace">throw</span>. By default, this feature is not activated. You can turn it on for your whole application by either setting the environment variable <span class="nctnt ncbi-var">$ABORT_ON_THROW</span> to an arbitrary non-empty string, or by setting the application's registry entry <span class="nctnt ncbi-var">ABORT_ON_THROW</span> (in the <span class="nctnt ncbi-var">[DEBUG]</span> section) to an arbitrary non-empty value. You also can turn it on and off in your program code, calling function <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/ncbiexpt_8cpp.html#a2">SetThrowTraceAbort()</a>.</p></li></ul><p>NOTE: if the source was not compiled in the debug mode, then the <span class="nctnt ncbi-macro">THROW*_TRACE(...)</span> would just <span class="nctnt ncbi-monospace">throw</span> the specified exception, without doing any of the "fancy stuff" we just described.</p></div><div class="sec" id="ch_debug.throw_excep_spec"><h4><span class="title"><span class="nctnt ncbi-macro">THROWS*(...)</span> -- Exception Specification</span></h4><p>One is discouraged from writing <a href="http://www.gamedev.net/reference/articles/article953.asp">exception specifications</a> - either with <span class="nctnt ncbi-code">throw()</span> or the <span class="nctnt ncbi-macro">THROWS*</span> macros.</p></div></div><div class="sec" id="ch_debug.std_cpp_message_post"><h3><span class="title">Standard NCBI C++ Message Posting</span></h3><p><span class="nctnt ncbi-code">#include &lt;corelib/ncbidiag.hpp&gt;</span> [also included in &lt;corelib/ncbistd.hpp&gt;]</p><p>Standard diagnostics is provided with the <span class="nctnt ncbi-class">CNcbiDiag</span> class. A given application can have as many objects of this class as needed. An important point to remember is that each instance of the <span class="nctnt ncbi-class">CNcbiDiag</span> class actually stores (and allows to append to) only one message at a time. When the message controlled by an instance of <span class="nctnt ncbi-class">CNcbiDiag</span> is complete, <span class="nctnt ncbi-class">CNcbiDiag</span> invokes the <span class="nctnt ncbi-func">Post()</span> method of a global handler object (of type <span class="nctnt ncbi-class">CDiagHandler</span>) and passes the message (along with its severity level) as the method's argument.</p><p>Usually, this global object would merely dump the message to a diagnostic stream, and there is an auxiliary function <span class="nctnt ncbi-func">SetDiagStream()</span> that can be used to specify the output stream for the diagnostics. One can call <span class="nctnt ncbi-func">SetDiagStream(&amp;NcbiCerr)</span> to dump the diagnostics to the standard error output stream:</p><pre>/// Set diagnostic stream.<br />///<br />/// Error diagnostics are written to output stream "os"<br />/// This uses the SetDiagHandler() functionality.<br />NCBI_XNCBI_EXPORT<br />extern void SetDiagStream<br />(CNcbiOstream* os,<br /> bool          quick_flush  = true,///&lt; Do stream flush after every message<br /> FDiagCleanup  cleanup      = 0,   ///&lt; Call "cleanup(cleanup_data)" if diag.<br /> void*         cleanup_data = 0    ///&lt; Stream is changed (see SetDiagHandler)<br /> );</pre><p>Using <span class="nctnt ncbi-func">SetDiagHandler()</span>, one can install a custom handler object of type <span class="nctnt ncbi-class">CDiagHandler</span> to process the messages posted via <span class="nctnt ncbi-class">CNcbiDiag</span>. The implementation of the <span class="nctnt ncbi-class">CStreamDiagHandler</span> in <span class="nctnt ncbi-path">"ncbidiag.cpp"</span> is a good example of how to do this.</p><pre>/////////////////////////////////////////////////////////////////////////////<br />///<br />/// CDiagHandler --<br />///<br />/// Base diagnostic handler class.<br /><br />class NCBI_XNCBI_EXPORT CDiagHandler<br />{<br />public:<br />    /// Destructor.<br />    virtual ~CDiagHandler(void) {}<br /><br />    /// Post message to handler.<br />    virtual void Post(const SDiagMessage&amp; mess) = 0;<br />};<br /><br />/// Set the diagnostic handler using the specified diagnostic handler class.<br />NCBI_XNCBI_EXPORT<br />extern void SetDiagHandler(CDiagHandler* handler,<br />                           bool can_delete = true);<br /><br />/// Get the currently set diagnostic handler class.<br />NCBI_XNCBI_EXPORT<br />extern CDiagHandler* GetDiagHandler(bool take_ownership = false);</pre><p>where:</p><pre><span class="nctnt-pre ncbi-code">/////////////////////////////////////////////////////////////////////////////<br />///<br />/// SDiagMessage --<br />///<br />/// Diagnostic message structure.<br />///<br />/// Defines structure of the "data" message that is used with message handler<br />/// function("func"),  and destructor("cleanup").<br />/// The "func(..., data)" to be called when any instance of "CNcbiDiagBuffer"<br />/// has a new diagnostic message completed and ready to post.<br />/// "cleanup(data)" will be called whenever this hook gets replaced and<br />/// on the program termination.<br />/// NOTE 1:  "func()", "cleanup()" and "g_SetDiagHandler()" calls are<br />///          MT-protected, so that they would never be called simultaneously<br />///          from different threads.<br />/// NOTE 2:  By default, the errors will be written to standard error stream.<br /><br />struct SDiagMessage {<br />    /// Initalize SDiagMessage fields.<br />    SDiagMessage(EDiagSev severity, const char* buf, size_t len,<br />                 const char* file = 0, size_t line = 0,<br />                 TDiagPostFlags flags = eDPF_Default, const char* prefix = 0,<br />                 int err_code = 0, int err_subcode = 0,<br />                 const char* err_text = 0);<br /><br />    mutable EDiagSev m_Severity;   ///&lt; Severity level<br />    const char*      m_Buffer;     ///&lt; Not guaranteed to be '\0'-terminated!<br />    size_t           m_BufferLen;  ///&lt; Length of m_Buffer<br />    const char*      m_File;       ///&lt; File name<br />    size_t           m_Line;       ///&lt; Line number in file<br />    int              m_ErrCode;    ///&lt; Error code<br />    int              m_ErrSubCode; ///&lt; Sub Error code<br />    TDiagPostFlags   m_Flags;      ///&lt; Bitwise OR of "EDiagPostFlag"<br />    const char*      m_Prefix;     ///&lt; Prefix string<br />    const char*      m_ErrText;    ///&lt; Sometimes 'error' has no numeric code,<br />                                   ///&lt; but can be represented as text<br /><br />    // Compose a message string in the standard format(see also "flags"):<br />    //    "&lt;file&gt;", line &lt;line&gt;: &lt;severity&gt;: [&lt;prefix&gt;] &lt;message&gt; [EOL]<br />    // and put it to string "str", or write to an output stream "os".<br /><br />    /// Which write flags should be output in diagnostic message.<br />    enum EDiagWriteFlags {<br />        fNone   = 0x0,      ///&lt; No flags<br />        fNoEndl = 0x01      ///&lt; No end of line<br />    };<br /><br />    typedef int TDiagWriteFlags; /// Binary OR of "EDiagWriteFlags"<br /><br />    /// Write to string.<br />    void Write(string&amp; str, TDiagWriteFlags flags = fNone) const;<br /><br />    /// Write to stream.<br />    CNcbiOstream&amp; Write(CNcbiOstream&amp; os, TDiagWriteFlags flags = fNone) const;<br />};</span></pre><p>Installing a new handler typically destroys the previous handler, which can be a problem if you need to keep the old handler around for some reason. There are two ways to address this issue:</p><ul><li><p>Declare an object of class <span class="nctnt ncbi-class">CDiagRestorer</span> at the top of the block of code in which you will be using your new handler. This will protect the old handler from destruction, and automatically restore it -- along with any other diagnostic settings -- when the block exits in any fashion. As such, you can safely use the result of calling <span class="nctnt ncbi-func">GetDiagHandler()</span> at the beginning of the block even if you have changed the handler within the block.</p></li><li><p>Call <span class="nctnt ncbi-func">GetDiagHandler(true)</span> and then destroy the old handler yourself when done with it. This works in some circumstances in which <span class="nctnt ncbi-class">CDiagRestorer</span> is unsuitable, but places much more responsibility on your code.</p></li></ul><p>For compatibility with older code, the diagnostic system also supports specifying simple callbacks:</p><pre><span class="nctnt-pre ncbi-code">/// Diagnostic handler function type.<br />typedef void (*FDiagHandler)(const SDiagMessage&amp; mess);<br /><br />/// Diagnostic cleanup function type.<br />typedef void (*FDiagCleanup)(void* data);<br /><br />/// Set the diagnostic handler using the specified diagnostic handler class.<br />NCBI_XNCBI_EXPORT<br />extern void SetDiagHandler(CDiagHandler* handler,<br />                           bool can_delete = true);</span></pre><p>However, it is better to use the object-based interface for new code.</p><p>The following additional topics are discussed in this section:</p><ul><li><p><a href="ch_debug.html#ch_debug.formatting_manipulators">Formatting and Manipulators</a></p></li><li><p><a href="ch_debug.html#ch_debug.ERR_POST_ref">ERR_POST macro</a></p></li><li><p><a href="ch_debug.html#ch_debug.turn_on_tracing">Turn on the Tracing</a></p></li></ul><div class="sec" id="ch_debug.formatting_manipulators"><h4><span class="title">Formatting and Manipulators</span></h4><p>To compose a diagnostic message with <span class="nctnt ncbi-class">CNcbiDiag</span> you can use the formatting operator "<span class="nctnt ncbi-code">&lt;&lt;</span>". It works practically the same way as operator "<span class="nctnt ncbi-code">&lt;&lt;</span>" for standard C++ output streams. <span class="nctnt ncbi-class">CNcbiDiag</span> class also has some <span class="nctnt ncbi-class">CNcbiDiag</span>-specific <span class="nctnt ncbi-monospace">manipulators</span> to control the message severity level:</p><ul><li><p><span class="nctnt ncbi-class">Info</span> -- set severity level to <span class="nctnt ncbi-var">eDiag_Info</span></p></li><li><p><span class="nctnt ncbi-class">Warning</span> -- set severity level to <span class="nctnt ncbi-var">eDiag_Warning</span></p></li><li><p><span class="nctnt ncbi-class">Error</span> -- set severity level to <span class="nctnt ncbi-var">eDiag_Error</span> [default]</p></li><li><p><span class="nctnt ncbi-class">Fatal</span> -- set severity level to <span class="nctnt ncbi-var">eDiag_Fatal</span></p></li><li><p><span class="nctnt ncbi-class">Trace</span> -- set severity level to <span class="nctnt ncbi-var">eDiag_Trace</span></p></li></ul><p>NOTE: whenever the severity level is changed, <span class="nctnt ncbi-class">CNcbiDiag</span> also automatically executes the following two <span class="nctnt ncbi-monospace">manipulators</span>:</p><ul><li><p><span class="nctnt ncbi-class">Endm</span> -- means that the message is complete and to be flushed(via the global callback as described above)</p></li><li><p><span class="nctnt ncbi-class">Reset</span> -- directs to discard the content of presently composed message</p></li></ul><p>The <span class="nctnt ncbi-class">Endm</span> manipulator also gets executed on the <span class="nctnt ncbi-class">CNcbiDiag</span> object destruction.</p><p>For example, this code:</p><pre><span class="nctnt-pre ncbi-code">int iii = 1234;<br />CNcbiDiag diag1;<br /><br />diag1 &lt;&lt; "Message1_Start " &lt;&lt; iii;<br />         // message 1 is started but not ready yet<br />{ CNcbiDiag diag2; diag2 &lt;&lt; Info &lt;&lt; "Message2"; }<br />         // message 2 flushed in destructor<br />diag1 &lt;&lt; "Message1_End" &lt;&lt; Endm;<br />         // message 1 finished and flushed by "Endm"<br />diag1 &lt;&lt; "Message1_1"; // will be flushed by the following "Warning"<br />diag1 &lt;&lt; Warning &lt;&lt; "Discard this warning" &lt;&lt; ++iii &lt;&lt; Reset;<br />         // message discarded<br />diag1 &lt;&lt; "This is a warning " &lt;&lt; iii;<br />diag1 &lt;&lt; Endm;</span></pre><p>will write to the diagnostic stream(if the latter was set with <span class="nctnt ncbi-func">SetDiagStream()</span>):</p><pre><span class="nctnt-pre ncbi-code">Error: Message1_Start 1234<br />Info: Message2<br />Error: Message1_End<br />Error: Message1_1<br />Warning: This is a warning 1235</span></pre></div><div class="sec" id="ch_debug.ERR_POST_ref"><h4><span class="title">ERR_POST macro</span></h4><p>There is an <span class="nctnt ncbi-macro">ERR_POST(message)</span> macro that can be used to shorten the error posting code. This macro is discussed in the <a href="ch_core.html#ch_core.ERR_POST">chapter on Core Library</a>.</p></div><div class="sec" id="ch_debug.turn_on_tracing"><h4><span class="title">Turn on the Tracing</span></h4><p>The tracing (messages with severity level <span class="nctnt ncbi-var">eDiag_Trace</span>) is considered to be a special, debug-oriented feature, and therefore it is not affected by <span class="nctnt ncbi-func">SetDiagPostLevel()</span> and <span class="nctnt ncbi-func">SetDiagDieLevel()</span>. To turn the tracing on or off in your code you can use function <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/ncbidiag_8cpp.html#a22">SetDiagTrace()</a>.</p><p>By default, the tracing is off -- unless you assign environment variable <span class="nctnt ncbi-var">$DIAG_TRACE</span> to an arbitrary non-empty string (or, alternatively, you can set <span class="nctnt ncbi-var">DIAG_TRACE</span> entry in the <span class="nctnt ncbi-var">[DEBUG]</span> section of your registry to any non-empty value).</p></div></div></div><div class="sec" id="ch_debug.debug_dump"><h2><span class="title">DebugDump: Take an Object State Snapshot</span></h2><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_debug.html#ch_debug.debug_terminology">Terminology</a></p></li><li><p><a href="ch_debug.html#ch_debug.debug_requirements">Requirements</a></p></li><li><p><a href="ch_debug.html#ch_debug.debug_architecture">Architecture</a></p></li><li><p><a href="ch_debug.html#ch_debug.debug_impl">Implementation</a></p></li><li><p><a href="ch_debug.html#ch_debug.debug_examples">Examples</a></p></li></ul><p>Debugging is an inevitable part of software development. When it comes to a "mystical" problem, one can spend days and days hunting for a glitch. So, being prepared is not just a "nice thing to have", it is a requirement.</p><p>When a system being developed crashes consistently, debugging is easy in the sense that the problem is reproducable. Were that all bugs like this! It is much more "fun", when the system crashes intermittently, under circumstances about which we have only a vague idea, if any, of the symptoms or the cause. What the developer needs in this case is information - the more the better. One short message ("Assertion failed") is good and a coredump is better, but we typically need a more user-friendly reporting of the program status at the point of failure.</p><p>One possible idea is to make the object tell about itself. That is, in case of trouble (but not necessarily trouble), an object could call a function that would report as much as possible about itself and other object it contains or to which it refers. During such operation the object should not do anything important, something that could potentially cause other problems. The diagnostic must of course be safe - it should only take a snapshot of an object's state and never alter that data.</p><p>Sure, <span class="nctnt ncbi-func">DebugDump</span> may cause problems by itself, even if everything is "correct". Let us say there are two objects, which "know" each other: <span class="nctnt ncbi-var">Object A</span> refers to <span class="nctnt ncbi-var">Object B</span>, while <span class="nctnt ncbi-var">Object B</span> refers to <span class="nctnt ncbi-var">Object A</span> (very common scenario in fact). Now dumping contents of <span class="nctnt ncbi-var">Object A</span> will cause dumping of <span class="nctnt ncbi-var">Object B</span>, which in turn will cause dumping of <span class="nctnt ncbi-var">Object A</span>, and so on until the stack overflows.</p><div class="sec" id="ch_debug.debug_terminology"><h3><span class="title">Terminology</span></h3><p>So, dumping the object contents should look as a single function call, i.e. something like this:</p><pre><span class="nctnt-pre ncbi-code">Object name;<br />...<br />name.DebugDump(?);</span></pre><p>The packet of information produced by such operation we call <span class="nctnt ncbi-monospace">bundle</span>. The class <span class="nctnt ncbi-class">Object</span> is most likely derived from other classes. The function should be called sequentially for each subclass, so it could print its data members. The piece of information produced by the subclass we call <span class="nctnt ncbi-monospace">frame</span>. The object may refer to other objects. Dumping of such object produces a <span class="nctnt ncbi-monospace">sub-bundle</span>, which consists of its own <span class="nctnt ncbi-monospace">frames</span>. To help fight cyclicity, we introduce <span class="nctnt ncbi-monospace">depth</span> of the dump. When an object being dumped wants to dump other objects it refers to, it should reduce the <span class="nctnt ncbi-monospace">depth</span> by one. If the <span class="nctnt ncbi-monospace">depth</span> is already zero, other objects should not be dumped.</p></div><div class="sec" id="ch_debug.debug_requirements"><h3><span class="title">Requirements</span></h3><ul><li><p>The dump data should be separated from its representation. That is, the object should only supply data, something else should format it. Examples of formatting may include generating human-readable text or file in a special format (HTML, XML), or even transmitting the data over the network.</p></li><li><p>Debug and release libraries should be compatible.</p></li><li><p>It should be globally configurable as to whether the dump produces any output or not,</p></li></ul></div><div class="sec" id="ch_debug.debug_architecture"><h3><span class="title">Architecture</span></h3><p>Class <span class="nctnt ncbi-class">CDebugDumpable</span> is a special abstract base class. Its purpose is to define a virtual function <span class="nctnt ncbi-func">DebugDump</span>, which any derived class should implement. Another purpose is to store any global dump options. Any real dump should be initiated through a non-virtual function of this class - so, global option could be applied. Class <span class="nctnt ncbi-class">CObject</span> is derived from this class. So, any classes based on <span class="nctnt ncbi-class">CObject</span> may benefit from this functionality right away. Other classes may use this class as a base later on (e.g. using multiple inheritance).</p><p>Class <span class="nctnt ncbi-class">CDebugDumpContext</span> provides a generic dump interface for dumpable objects. The class has nothing to do with data representation. Its purpose is the ability to describe the location of where the data comes from, accept it from the object and transfer to the data formatter.</p><p>Class <span class="nctnt ncbi-class">CDebugDumpFormatter</span> defines the dump formatting interface. It is an abstract class.</p><p>Class <span class="nctnt ncbi-class">CDebugDumpFormatterText</span> is derived from <span class="nctnt ncbi-class">CDebugDumpFormatter</span>. Based on incoming data, it generates a human-readable text and passes it into any output stream (<span class="nctnt ncbi-class">ostream</span>).</p><p>In general, the system works like this:</p><ul><li><p>Client creates DebugDump formatter object (it could be an object of class <span class="nctnt ncbi-class">CDebugDumpFormatterText</span> or any other class derived from <span class="nctnt ncbi-class">CDebugDumpFormatter</span>) and passes it to a proper, non-virtual function of the object to be dumped. Bundle name is to be defined here - it can be anything, but a reasonable guess would be to specify the location of the call and the name of the object being dumped.</p></li><li><p><span class="nctnt ncbi-class">CDebugDumpable</span> analyses global settings, creates <span class="nctnt ncbi-class">CDebugDumpContext</span> object and calls virtual DebugDump() function of the object.</p></li><li><p>DebugDump function of each subclass defines a frame name (which must be the type of the subclass), calls DebugDump function of a base class and finally logs its own data members. From within the DebugDump(), the object being dumped "sees" only <span class="nctnt ncbi-class">CDebugDumpContext</span>. It does not know any specifics about target format in which dump data will be eventually represented.</p></li></ul></div><div class="sec" id="ch_debug.debug_impl"><h3><span class="title">Implementation</span></h3><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_debug.html#ch_debug.CDebugDumpable">CDebugDumpable</a></p></li><li><p><a href="ch_debug.html#ch_debug.CDebugDumpContext">CDebugDumpContext</a></p></li><li><p><a href="ch_debug.html#ch_debug.CDebugDumpFormatter">CDebugDumpFormatter</a></p></li></ul><div class="sec" id="ch_debug.CDebugDumpable"><h4><span class="title">CDebugDumpable</span></h4><p>The class is an abstract one. Global options are stored as static variable(s).</p><pre><span class="nctnt-pre ncbi-code">public:<br />    // Enable/disable debug dump<br />    static void EnableDebugDump(bool on);<br /><br />    // Dump using text formatter<br />    void DebugDumpText(ostream&amp; out,<br />                       const string&amp; bundle,<br />                       unsigned int depth) const;<br /><br />    // Dump using external dump formatter<br />    void DebugDumpFormat(CDebugDumpFormatter&amp; ddf,<br />                         const string&amp; bundle,<br />                         unsigned int depth) const;<br /><br />    // Function that does the dump - to be overloaded<br />    virtual void DebugDump(CDebugDumpContext ddc,<br />                           unsigned int depth) const = 0;</span></pre><p>Any derived class must impelement a relevant DebugDump function.</p></div><div class="sec" id="ch_debug.CDebugDumpContext"><h4><span class="title">CDebugDumpContext</span></h4><p>The class defines a public dump interface for a client object. It receives the data from the object and decides when and what functions of dump formatter to call.</p><p>The dump interface looks like this:</p><pre><span class="nctnt-pre ncbi-code">public:<br />    CDebugDumpContext(CDebugDumpFormatter&amp; formatter,<br />                       const string&amp; bundle);<br />    // This is not exactly a copy constructor -<br />    // this mechanism is used internally to find out<br />    // where are we on the Dump tree<br />    CDebugDumpContext(CDebugDumpContext&amp; ddc);<br />    CDebugDumpContext(CDebugDumpContext&amp; ddc, const string&amp; bundle);<br /><br />public:<br />    // First thing in DebugDump() function - call this function<br />    // providing class type as the frame name<br />    void SetFrame(const string&amp; frame);<br />    // Log data in the form [name, data, comment]<br />    // All data is passed to a formatter as string, still sometimes<br />    // it is probably worth to emphasize that the data is REALLY a<br />    // string<br />    void Log(const string&amp; name,<br />             const string&amp; value,<br />             bool is_string = true,<br />             const string&amp; comment = kEmptyStr<br />             );<br />    void Log(const string&amp; name,<br />             bool value,<br />             const string&amp; comment = kEmptyStr<br />             );<br />    void Log(const string&amp; name,<br />             long value,<br />             const string&amp; comment = kEmptyStr<br />             );<br />    void Log(const string&amp; name,<br />             unsigned long value,<br />             const string&amp; comment = kEmptyStr<br />             );<br />    void Log(const string&amp; name,<br />             double value,<br />             const string&amp; comment = kEmptyStr<br />             );<br />    void Log(const string&amp; name,<br />             const void* value,<br />             const string&amp; comment = kEmptyStr<br />             );<br />    void Log(const string&amp; name,<br />             const CDebugDumpable* value,<br />             unsigned int depth<br />             );</span></pre><p>A number of overloaded <span class="nctnt ncbi-func">Log</span> functions is provided for convenience only.</p></div><div class="sec" id="ch_debug.CDebugDumpFormatter"><h4><span class="title">CDebugDumpFormatter</span></h4><p>This abstract class defines dump formatting interface:</p><pre><span class="nctnt-pre ncbi-code">public:<br />    virtual bool StartBundle(unsigned int level, const string&amp; bundle) = 0;<br />    virtual void EndBundle(  unsigned int level, const string&amp; bundle) = 0;<br /><br />    virtual bool StartFrame( unsigned int level, const string&amp; frame) = 0;<br />    virtual void EndFrame(   unsigned int level, const string&amp; frame) = 0;<br /><br />    virtual void PutValue(   unsigned int level, const string&amp; name,<br />                             const string&amp; value, bool is_string,<br />                             const string&amp; comment) = 0;</span></pre></div></div><div class="sec" id="ch_debug.debug_examples"><h3><span class="title">Examples</span></h3><p>Supposed that there is an object <span class="nctnt ncbi-var">m_ccObj</span> of class <span class="nctnt ncbi-class">CSomeObject</span> derived from <span class="nctnt ncbi-class">CObject</span>. In order to dump it into the standard <span class="nctnt ncbi-var">cerr</span> stream, one should do one of the following:</p><pre><span class="nctnt-pre ncbi-code">m_ccObj.DebugDumpText(cerr, "m_ccObj", 0);</span></pre><p>or</p><pre><span class="nctnt-pre ncbi-code">{<br />    CDebugDumpFormatterText ddf(cerr);<br />    m_ccObj.DebugDumpFormat(ddf, "m_ccObj", 0);<br />}</span></pre><p>The <span class="nctnt ncbi-func">DebugDump</span> function should look like this:</p><pre><span class="nctnt-pre ncbi-code">void CSomeObject::DebugDump(CDebugDumpContext ddc, unsigned int depth) const<br />{<br />    ddc.SetFrame("CSomeObject");<br />    CObject::DebugDump(ddc,depth);<br />    ddc.Log("m_1", m_1);<br />    ddc.Log("m_2", m_2);<br />    ... etc for each data member<br />}</span></pre></div></div><div class="sec" id="ch_debug.excep_cpp_toolkit"><h2><span class="title">Exception Handling (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/corelib/ncbiexpt.hpp">*</a>) in the NCBI C++ Toolkit</span></h2><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_debug.html#ch_debug.ncbi_cpp_exceptions">NCBI C++ Exceptions</a></p></li><li><p><a href="ch_debug.html#ch_debug.CErrnoTemplException">The CErrnoTemplException Class</a></p></li><li><p><a href="ch_debug.html#ch_debug.CParseTemplException">The CParseTemplException Class</a></p></li><li><p><a href="ch_debug.html#ch_debug.std_excep_macros">Macros for Standard C++ Exception Handling</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_tracing">Exception Tracing</a></p></li></ul><div class="sec" id="ch_debug.ncbi_cpp_exceptions"><h3><span class="title">NCBI C++ Exceptions</span></h3><p>C++ exceptions is a standard mechanism of communicating abnormal or unexpected events to a higher execution context. By throwing an exception a piece of code says it was unable to complete the task and it is up to others to decide what to do next.</p><p>What the standard mechanism lacks is backlog, history of unfinished tasks and its consequences. Say for instance, a program tries to load some data from a database. An exception occurs, which says a connection to some port could not be created -- so what? How meaningfull is it? What did the program try to do? Where did the request for the connection come from?</p><p>Another problem is analyzing and handling exceptions in a program. When an exception is caught, what is known for sure is only that something bad has happened -- but what exactly? The standard exception has only type (exception class) and a text message. The latter probably makes sense for a human, but not for a program. The former does not seem to be clear enough.</p><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_debug.html#ch_debug.excep_requirements">Requirements</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_architecture">Architecture</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_impl">Implementation</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_examples">Examples</a></p></li></ul><div class="sec" id="ch_debug.excep_requirements"><h4><span class="title">Requirements</span></h4><p>In order for exceptions to be more useful, they should meet the following requirements:</p><ul><li><p>Exceptions should contain information about where exactly has it been thrown -- for a human.</p></li><li><p>Exceptions should have a numeric id -- for a program.</p></li><li><p>It should be possible to create a stack of exceptions -- to accumulate a backlog of events (unfinished jobs) which caused the problem. Still, for a client, it should look like a single exception. That is, a client should be able to ignore completely the compound structure of the exception being thrown and still get some meaningful information.</p></li><li><p>The system should provide for the ability to analyze the exception backlog and possibly print information about each exception separately.</p></li><li><p>It should be possible to report the exception data into an arbitrary output channel and possibly format it differently for each channel.</p></li></ul></div><div class="sec" id="ch_debug.excep_architecture"><h4><span class="title">Architecture</span></h4><p>Each subsystem (library) has its own type of exceptions. It may have several types, if necessary, but all of them should be derived from a single base class (which in turn is derived from a system-wide base class). So, the type of an exception uniquely identifies the library which produced it.</p><p>Each exception has a numeric id, which is unique throughout the subsystem. Such an id gives an unambiguous description of the problem occurred. Each id is associated with a text message. Strictly speaking, there is only one message associated with a given id, so there is no need to include the message in the exception itself -- it could be taken from an external source. Still, we suggest using the message -- it serves as an additional comment. Also, it does not restrict us from using an external source of messages in the future.</p><p>Each exception has information about the location where it has been thrown -- file name and line number.</p><p>An exception can have a reference to the "lower level" one, which makes it possible to analyze the backlog. Naturally, such a backlog cannot be created automatically - it is a developer's responsibility. The system only provides the mechanism, it does not solve problems by itself. The developer is supposed to catch exceptions in proper places and re-throw them with the backlog information added.</p><p>The exception constructor's mandatory parameters include location information, exception id and a message. This constructor is to be used at the lower level, when the exception is thrown initially. At higher levels we need a constructor, which would accept the exception from the lower level as one of its parameters.</p><p>The NCBI exception mechanism has a sophisticated reporting mechanism -- the standard <span class="nctnt ncbi-func">exception::what()</span> function is definitely not enough. There are three groups of reporting mechanisms:</p><ul><li><p>exception formats its data by itself and either returns the result as a string or puts it into an output stream;</p></li><li><p>client provides an external exception data formatter;</p></li><li><p>NCBI standard diagnostic mechanism is used.</p></li></ul></div><div class="sec" id="ch_debug.excep_impl"><h4><span class="title">Implementation</span></h4><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_debug.html#ch_debug.CException">CException</a></p></li><li><p><a href="ch_debug.html#ch_debug.derived_exceptions">Derived exceptions</a></p></li><li><p><a href="ch_debug.html#ch_debug.reporting_exceptions">Reporting an exception</a></p></li><li><p><a href="ch_debug.html#ch_debug.CExceptionReporter">CExceptionReporter</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_err_codes">Choosing and analyzing error codes</a></p></li></ul><div class="sec" id="ch_debug.CException"><h5><span class="title">CException</span></h5><p>There is a single system-wide exception base class -- <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CException&amp;d=C">CException</a>. Each subsystem <b>must</b> implement its own type of exceptions, which must be be derived from this class. The class defines basic requirements of an exception construction, backlog and reporting mechanisms.</p><p>The <span class="nctnt ncbi-class">CException</span> constructor includes location information, exception id and a message. Each exception class defines its own error codes. So, the error code "by itself" is meaningless -- one should also know the the exception class, which produced it.</p><pre><span class="nctnt-pre ncbi-code">/// Constructor.<br />///<br />/// When throwing an exception initially, "prev_exception" must be 0.<br />CException(const char* file, int line,<br />           const CException* prev_exception,<br />           EErrCode err_code,const string&amp; message) throw();</span></pre><p>To make it easier to throw/re-throw an exception, the following macros are defined:</p><pre><span class="nctnt-pre ncbi-code">NCBI_THROW(exception_class, err_code, message)<br />NCBI_RETHROW(prev_exception, exception_class, err_code,message)<br />NCBI_RETHROW_SAME(prev_exception, message)</span></pre><p>The last one (<span class="nctnt ncbi-macro">NCBI_RETHROW_SAME</span>) re-throws the same exception with backlog information added.</p><p>The <span class="nctnt ncbi-class">CException</span> class has numerous reporting methods (the contents of reports is defined by <a href="ch_core.html#ch_core.diag_post_flags">diagnostics post flags</a>):</p><pre><span class="nctnt-pre ncbi-code">    /// Standard report (includes full backlog).<br />    virtual const char* what(void) const throw();<br /><br />    /// Report the exception.<br />    ///<br />    /// Report the exception using "reporter" exception reporter.<br />    /// If "reporter" is not specified (value 0), then use the default<br />    /// reporter as set with CExceptionReporter::SetDefault.<br />    void Report(const char* file, int line,<br />                const string&amp; title, CExceptionReporter* reporter = 0,<br />                TDiagPostFlags flags = eDPF_Trace) const;<br /><br />    /// Report this exception only.<br />    ///<br />    /// Report as a string this exception only. No backlog is attached.<br />    string ReportThis(TDiagPostFlags flags = eDPF_Trace) const;<br /><br />    /// Report all exceptions.<br />    ///<br />    /// Report as a string all exceptions. Include full backlog.<br />    string ReportAll (TDiagPostFlags flags = eDPF_Trace) const;<br /><br />    /// Report "standard" attributes.<br />    ///<br />    /// Report "standard" attributes (file, line, type, err.code, user message)<br />    /// into the "out" stream (this exception only, no backlog).<br />    void ReportStd(ostream&amp; out, TDiagPostFlags flags = eDPF_Trace) const;<br /><br />    /// Report "non-standard" attributes.<br />    ///<br />    /// Report "non-standard" attributes (those of derived class) into the<br />    /// "out" stream.<br />    virtual void ReportExtra(ostream&amp; out) const;<br /><br />    /// Enable background reporting.<br />    ///<br />    /// If background reporting is enabled, then calling what() or ReportAll()<br />    /// would also report exception to the default exception reporter.<br />    /// @return<br />    ///   The previous state of the flag.<br />    static bool EnableBackgroundReporting(bool enable);</span></pre><p>Also, the following macro is defined that calls the <span class="nctnt ncbi-func">CExceptionReporter::ReportDefault()</span> method to produce a report for the exception:</p><pre><span class="nctnt-pre ncbi-code">NCBI_REPORT_EXCEPTION(title,e)</span></pre><p>Finally, the following data access functions help to analyze exceptions from a program:</p><pre><span class="nctnt-pre ncbi-code">    /// Get class name as a string.<br />    virtual const char* GetType(void) const;<br /><br />    /// Get error code interpreted as text.<br />    virtual const char* GetErrCodeString(void) const;<br /><br />    /// Get file name used for reporting.<br />    const string&amp; GetFile(void) const;<br /><br />    /// Get line number where error occurred.<br />    int GetLine(void) const;<br /><br />    /// Get error code.<br />    EErrCode GetErrCode(void) const;<br /><br />    /// Get message string.<br />    const string&amp; GetMsg (void) const;<br /><br />    /// Get "previous" exception from the backlog.<br />    const CException* GetPredecessor(void) const;</span></pre></div><div class="sec" id="ch_debug.derived_exceptions"><h5><span class="title">Derived exceptions</span></h5><p>The only requirement for a derived exception is to define error codes as well as its textual representation. Implementation of several other functions (e.g. constructors) are, in general, pretty straightforward -- so we put it into a macro definition, <span class="nctnt ncbi-macro">NCBI_EXCEPTION_DEFAULT</span>. Please note, this macro can only be used when the derived class has no additional data members. Here is an example of an exception declaration:</p><pre><span class="nctnt-pre ncbi-code">class CSubsystemException : public CException<br />{<br />public:<br />    /// Error types that subsystem can generate.<br />    enum EErrCode {<br />        eType1,   ///&lt; Meaning of eType1<br />        eType2    ///&lt; Meaning of eType2<br />    };<br /><br />    /// Translate from the error code value to its string representation.<br />    virtual const char* GetErrCodeString(void) const<br />    {<br />        switch (GetErrCode()) {<br />        case eType1: return "eType1";<br />        case eType2: return "eType2";<br />        default:     return CException::GetErrCodeString();<br />        }<br />    }<br /><br />    // Standard exception boilerplate code.<br />    NCBI_EXCEPTION_DEFAULT(CSubsystemException, CException);<br />};</span></pre><p>In case the derived exception has data members not found in the base class, it should also implement its own <span class="nctnt ncbi-func">ReportExtra</span> method -- to report this non-standard data.</p></div><div class="sec" id="ch_debug.reporting_exceptions"><h5><span class="title">Reporting an exception</span></h5><p>There are several way to report an NCBI C++ exception:</p><ul><li><p>An exception is capable of formatting its own data, returning a string (or a pointer to a string buffer). Each exception report occupies one line. Still, since an exception may contain a backlog of previously thrown exceptions, the resulting report could contain several lines of text - one for each exception thrown. The report normally contains information about the location from which the exception has been thrown, the text representation of the exception class and error code, and a description of the error. The content of the report is defined by <a href="ch_core.html#ch_core.diag_post_flags">diagnostics post flags</a>. The following methods generate reports of this type:<br /><span class="nctnt ncbi-code">    /// Standard report (includes full backlog).</span><br /><span class="nctnt ncbi-code">    virtual const char* what(void) const throw();</span><br /><br /><span class="nctnt ncbi-code">    /// Report the exception.</span><br /><span class="nctnt ncbi-code">    ///</span><br /><span class="nctnt ncbi-code">    /// Report the exception using "reporter" exception reporter.</span><br /><span class="nctnt ncbi-code">    /// If "reporter" is not specified (value 0), then use the default</span><br /><span class="nctnt ncbi-code">    /// reporter as set with CExceptionReporter::SetDefault.</span><br /><span class="nctnt ncbi-code">    void Report(const char* file, int line,</span><br /><span class="nctnt ncbi-code">                const string&amp; title, CExceptionReporter* reporter = 0,</span><br /><span class="nctnt ncbi-code">                TDiagPostFlags flags = eDPF_Trace) const;</span><br /><br /><span class="nctnt ncbi-code">    /// Report this exception only.</span><br /><span class="nctnt ncbi-code">    ///</span><br /><span class="nctnt ncbi-code">    /// Report as a string this exception only. No backlog is attached.</span><br /><span class="nctnt ncbi-code">    string ReportThis(TDiagPostFlags flags = eDPF_Trace) const;</span><br /><br /><span class="nctnt ncbi-code">    /// Report all exceptions.</span><br /><span class="nctnt ncbi-code">    ///</span><br /><span class="nctnt ncbi-code">    /// Report as a string all exceptions. Include full backlog.</span><br /><span class="nctnt ncbi-code">    string ReportAll (TDiagPostFlags flags = eDPF_Trace) const;</span><br /><br /><span class="nctnt ncbi-code">    /// Report "standard" attributes.</span><br /><span class="nctnt ncbi-code">    ///</span><br /><span class="nctnt ncbi-code">    /// Report "standard" attributes (file, line, type, err.code, user message)</span><br /><span class="nctnt ncbi-code">    /// into the "out" stream (this exception only, no backlog).</span><br /><span class="nctnt ncbi-code">    void ReportStd(ostream&amp; out, TDiagPostFlags flags = eDPF_Trace) const;</span><br /><br />Functions <span class="nctnt ncbi-func">what()</span> and <span class="nctnt ncbi-func">ReportAll()</span> may also generate a <span class="nctnt ncbi-monospace">background</span> report - the one generated by a default exception reporter. This feature can be disabled by calling the static method<br /><span class="nctnt ncbi-code">CException::EnableBackgroundReporting(false);</span></p></li><li><p>A client can provide its own <a href="ch_debug.html#ch_debug.CExceptionReporter">exception reporter</a>. An object of this class may either use exception data access functions to create its own reports, or redirect reports into its own output channel(s). While it is possible to specify the reporter in the <span class="nctnt ncbi-func">CException::Report()</span> function, it is better if the same reporting functions are used for exceptions, to install the reporter as a default one instead, using<br /><span class="nctnt ncbi-code">CExceptionReporter::SetDefault(const CExceptionReporter* handler);</span> static function, and use the standard <span class="nctnt ncbi-macro">NCBI_REPORT_EXCEPTION</span> macro in the program.</p></li><li><p>Still another way to report an exception is to use the standard <a href="ch_core.html#ch_core.diag">diagnostic</a> mechanism provided by NCBI C++ toolkit. In this case the code to generate the report would look like this:<br /><span class="nctnt ncbi-code">try {</span><br /><span class="nctnt ncbi-code">    ...</span><br /><span class="nctnt ncbi-code">} catch (CException&amp; e) {</span><br /><span class="nctnt ncbi-code">    ERR_POST_X(1, Critical &lt;&lt; "Your message here." &lt;&lt; e);</span><br /><span class="nctnt ncbi-code">}</span></p></li></ul></div><div class="sec" id="ch_debug.CExceptionReporter"><h5><span class="title">CExceptionReporter</span></h5><p>One of possible ways to report an exception is to use an external "reporter" modeled by the <span class="nctnt ncbi-class">CExceptionReporter</span> abstract class. The reporter is an object that formats exception data and sends it to its own output channel. A client can install its own, custom exception reporter. This is not required, though. In case the default was not set, the standard NCBI diagnostic mechanism is used.</p><p>The <span class="nctnt ncbi-class">CExceptionReporter</span> is an abstract class, which defines the reporter interface:</p><pre><span class="nctnt-pre ncbi-code">    /// Set default reporter.<br />    static void SetDefault(const CExceptionReporter* handler);<br /><br />    /// Get default reporter.<br />    static const CExceptionReporter* GetDefault(void);<br /><br />    /// Enable/disable using default reporter.<br />    ///<br />    /// @return<br />    ///   Previous state of this flag.<br />    static bool EnableDefault(bool enable);<br /><br />    /// Report exception using default reporter.<br />    static void ReportDefault(const char* file, int line,<br />                              const string&amp; title, const CException&amp; ex,<br />                              TDiagPostFlags flags = eDPF_Trace);<br /><br />    /// Report exception with _this_ reporter<br />    virtual void Report(const char* file, int line,<br />                        const string&amp; title, const CException&amp; ex,<br />                        TDiagPostFlags flags = eDPF_Trace) const = 0;</span></pre></div><div class="sec" id="ch_debug.excep_err_codes"><h5><span class="title">Choosing and analyzing error codes</span></h5><p>Choosing and interpreting error codes can potentially create some problems because each exception class has its own error codes, and interpretation. Error codes are implemented as an enum type, <span class="nctnt ncbi-type">EErrCode</span>, and the enumerated values are stored internally in a program as numbers. So, the same number can be interpreted incorrectly for a different exception class than the one in which the enum type was defined. Say for instance, there is an exception class, which is derived from <a href="ch_debug.html#ch_debug.derived_exceptions">CSubsystemException</a> -- let us call it <span class="nctnt ncbi-class">CBiggersystemException</span> -- which also defines two error codes: <span class="nctnt ncbi-var">eBigger1</span> and <span class="nctnt ncbi-var">eBigger2</span>:</p><pre><span class="nctnt-pre ncbi-code">class CBiggersystemException : public CSubsystemException<br />{<br />public:<br />    /// Error types that subsystem can generate.<br />    enum EErrCode {<br />        eBigger1,    ///&lt; Meaning of error code, eBigger1<br />        eBigger2     ///&lt; Meaning of error code, eBigger2<br />    };<br /><br />    /// Translate from the error code value to its string representation.<br />    virtual const char* GetErrCodeString(void) const<br />    {<br />        switch (GetErrCode()) {<br />        case eBigger1: return "eBigger1";<br />        case eBigger2: return "eBigger2";<br />        default:      return CException::GetErrCodeString();<br />        }<br />    }<br /><br />    // Standard exception boilerplate code.<br />    NCBI_EXCEPTION_DEFAULT(CBiggersystemException, CSubsystemException);<br />};</span></pre><p>Now, suppose an exception <span class="nctnt ncbi-class">CBiggersystemException</span> has been thrown somewhere. On a higher level it has been caught as <span class="nctnt ncbi-class">CSubsystemException</span>. It is easy to see that the error code returned by the <span class="nctnt ncbi-class">CSubsystemException</span> object would be completely meaningless: the error code of <span class="nctnt ncbi-class">CBiggersystemException</span> cannot be interpreted in terms of <span class="nctnt ncbi-class">CSubsystemException</span>.</p><p>One reasonable solution seems to be isolating error codes of different exception classes -- by assigning different numeric values to them. And this has to be done by the developer. Such isolation should only be done within each branch of derivatives only. Another solution is to make sure that the exception in question does belong to the desired class, not to any intermediate classes in the derivation hierarchy. The template function <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=UppermostCast">UppermostCast()</a> can be used to perform this check:</p><pre><span class="nctnt-pre ncbi-code">/// Return valid pointer to uppermost derived class only if "from" is _really_<br />/// the object of the desired type.<br />///<br />/// Do not cast to intermediate types (return NULL if such cast is attempted).<br />template &lt;class TTo, class TFrom&gt;<br />const TTo* UppermostCast(const TFrom&amp; from)<br />{<br />    return typeid(from) == typeid(TTo) ? dynamic_cast&lt;const TTo*&gt;(&amp;from) : 0;<br />}</span></pre><p><span class="nctnt ncbi-func">UppermostCast()</span> utilizes the runtime information using the <span class="nctnt ncbi-func">typeid()</span> function, and dynamic cast conversion to return either a pointer to "uppermost" exception object or NULL.</p><p>The following shows how <span class="nctnt ncbi-func">UppermostCast()</span> can be used to catch the correct error types:</p><pre><span class="nctnt-pre ncbi-code">try {<br />    ...<br />    NCBI_THROW(CBiggersystemException,eBigger1,"your message here");<br />    ...<br />}<br />catch (CSubsystemException&amp; e) {<br />    // call to UppermostCast&lt;CSubsystemException&gt;(e) would return 0 here!<br />    // which means that "e" was actually the object of a different class<br />    const CBiggersystemException *p = UppermostCast&lt;CBiggersystemException&gt;(e);<br />    if (p) {<br />        switch (p-&gt;GetErrCode()) {<br />        case CBiggersystemException::eBigger1:<br />            ...<br />            break;<br />        case CBiggersystemException::eBigger2:<br />            ...<br />            break;<br />        default:<br />            ...<br />            break;<br />        }<br />    }<br />    NCBI_RETHROW_SAME(e,"your message here");<br />}</span></pre><p>It is possible to use the runtime information to do it even better. Since <span class="nctnt ncbi-func">GetErrCode</span> function is non-virtual, it might check the type of the object, for which it has been called, against the type of the class to which it belongs. If these two do not match, the function returns <span class="nctnt ncbi-monospace">invalid</span> error code. Such code only means that the caller did not know the correct type of the exception, and the function is unable to interpret it.</p></div></div><div class="sec" id="ch_debug.excep_examples"><h4><span class="title">Examples</span></h4><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_debug.html#ch_debug.excep_throwing_example">Throwing an exception</a></p></li><li><p><a href="ch_debug.html#ch_debug.excep_reporting_example">Reporting an exception</a></p></li></ul><div class="sec" id="ch_debug.excep_throwing_example"><h5><span class="title">Throwing an exception</span></h5><p>It is important to remember that the system only provides a mechanism to create a backlog of unfinished tasks, it does not create this backlog automatically. It is up to developer to catch exceptions and re-throw them with the backlog information added. Here is an example of throwing <a href="ch_debug.html#ch_debug.derived_exceptions">CSubsystemException</a> exception:</p><pre><span class="nctnt-pre ncbi-code">... // your code<br />NCBI_THROW(CSubsystemException,eType1,"your message here");<br />...</span></pre><p>The code that catches, and possibly re-throws the exception might look like this:</p><pre><span class="nctnt-pre ncbi-code">try {<br />    ... // your code<br />} catch (CSubsystemException&amp; e) {<br />    if (e.GetErrCode() == CSubsystemException::eType2) {<br />        ...<br />    } else {<br />        NCBI_RETHROW(e, CSubsystemException, eType1, " your message here")<br />    }<br />} catch (CException&amp; e) {<br />    NCBI_RETHROW(e, CException, eUnknown, "your message here")<br />}</span></pre></div><div class="sec" id="ch_debug.excep_reporting_example"><h5><span class="title">Reporting an exception</span></h5><p>There are a <a href="ch_debug.html#ch_debug.reporting_exceptions">number of ways</a> to report <span class="nctnt ncbi-class">CException</span>, for example:</p><pre><span class="nctnt-pre ncbi-code">try {<br />    ... // your code<br />} catch (CSubsystemException&amp; e) {<br />    NCBI_REPORT_EXCEPTION("your message here", e);<br />    ERR_POST_X(CMyException::eMyErrorXyz, Critical &lt;&lt; "message" &lt;&lt; e);<br />    cerr &lt;&lt; e.ReportAll();<br />    cerr &lt;&lt; e.what();<br />    e.Report(__FILE__, __LINE__, "your message here");<br />}</span></pre><p>We suggest using <span class="nctnt ncbi-macro">NCBI_REPORT_EXCEPTION(title,e)</span> macro (which is equivalent to calling <span class="nctnt ncbi-code">e.Report(__FILE__,__LINE__,title)</span>) - it redirects the output into standard diagnostic channels and is highly configurable.</p></div></div></div><div class="sec" id="ch_debug.CErrnoTemplException"><h3><span class="title">The CErrnoTemplException Class</span></h3><p>The <span class="nctnt ncbi-class">CErrnoTemplException</span> class is a template class used for generating error exception classes:</p><pre><span class="nctnt-pre ncbi-code">/////////////////////////////////////////////////////////////////////////////<br />///<br />/// CErrnoTemplException --<br />///<br />/// Define template class for easy generation of Errno-like exception classes.<br /><br />template&lt;class TBase&gt; class CErrnoTemplException :<br />                        public CErrnoTemplExceptionEx&lt;TBase, CStrErrAdapt::strerror&gt;<br />{<br />public:<br />    /// Parent class type.<br />    typedef CErrnoTemplExceptionEx&lt;TBase, CStrErrAdapt::strerror&gt; CParent;<br /><br />    /// Constructor.<br />    CErrnoTemplException&lt;TBase&gt;(const char* file,int line,<br />        const CException* prev_exception,<br />        typename CParent::EErrCode err_code,const string&amp; message) throw()<br />        : CParent(file, line, prev_exception,<br />                 (typename CParent::EErrCode) CException::eInvalid, message)<br />    NCBI_EXCEPTION_DEFAULT_IMPLEMENTATION_TEMPL(CErrnoTemplException&lt;TBase&gt;, CParent)<br />};</span></pre><p>The template class is derived form another template class, the <span class="nctnt ncbi-class">ErrnoTemplExceptionEx</span> which implements a parent class with the template parameter <span class="nctnt ncbi-monospace">TBase</span>. The parent <span class="nctnt ncbi-class">ErrnoTemplExceptionEx</span> class implements the basic exception methods such as <span class="nctnt ncbi-func">ReportExtra()</span>, <span class="nctnt ncbi-func">GetErrCode()</span>, <span class="nctnt ncbi-func">GetErrno()</span>, <span class="nctnt ncbi-func">GetType()</span>. The <span class="nctnt ncbi-class">ErrnoTemplExceptionEx</span> class has an <span class="nctnt ncbi-type">int</span> data member called <span class="nctnt ncbi-var">m_Errno</span>. The constructor automatically adds information about the most recent error state as obtained via the global system variable <span class="nctnt ncbi-var">errno</span> to this data member.</p><p>The constructor for the derived <span class="nctnt ncbi-class">CErrnoTemplException</span> class is defined in terms of the <span class="nctnt ncbi-macro">NCBI_EXCEPTION_DEFAULT_IMPLEMENTATION_TEMPL</span> macro which defines the program code for implementing the constructor.</p><p>The <span class="nctnt ncbi-monospace">TBase</span> template parameter is an exception base class such as <span class="nctnt ncbi-class">CException</span> or <span class="nctnt ncbi-class">CCoreException</span>, or another class similar to these. The <span class="nctnt ncbi-func">CStrErrAdapt::strerror</span> template parameter is a function defined in an adaptor class for getting the error description string. The <span class="nctnt ncbi-class">CErrnoTemplException</span> has only one <a href="ch_debug.html#ch_debug.excep_err_codes">error core</a> - <span class="nctnt ncbi-var">eErrno</span> defined in the parent class, <span class="nctnt ncbi-class">ErrnoTemplExceptionEx</span>. To analyze the actual reason of the exception one should use <span class="nctnt ncbi-func">GetErrno()</span> method:</p><pre><span class="nctnt-pre ncbi-code">int GetErrno(void) const;</span></pre><p>The <span class="nctnt ncbi-class">CErrnoTemplException</span> is used to create exception classes. Here is an example of how the <span class="nctnt ncbi-class">CExecException</span> class is created from <span class="nctnt ncbi-class">CErrnoTemplException</span>. In this example, the <span class="nctnt ncbi-monospace">TBase</span> template parameter is the exception base class <span class="nctnt ncbi-class">CCoreException</span>:</p><pre><span class="nctnt-pre ncbi-code">/////////////////////////////////////////////////////////////////////////////<br />///<br />/// CExecException --<br />///<br />/// Define exceptions generated by CExec.<br />///<br />/// CExecException inherits its basic functionality from<br />/// CErrnoTemplException&lt;CCoreException&gt; and defines additional error codes<br />/// for errors generated by CExec.<br /><br />class NCBI_XNCBI_EXPORT CExecException :<br />                        public CErrnoTemplException&lt;CCoreException&gt;<br />{<br />public:<br />    /// Error types that CExec can generate.<br />    enum EErrCode {<br />        eSystem,        ///&lt; System error<br />        eSpawn          ///&lt; Spawn error<br />    };<br /><br />    /// Translate from the error code value to its string representation.<br />    virtual const char* GetErrCodeString(void) const<br />    {<br />        switch (GetErrCode()) {<br />        case eSystem: return "eSystem";<br />        case eSpawn:  return "eSpawn";<br />        default:      return CException::GetErrCodeString();<br />        }<br />    }<br /><br />    // Standard exception boilerplate code.<br />    NCBI_EXCEPTION_DEFAULT(CExecException,<br />                           CErrnoTemplException&lt;CCoreException&gt;);<br />};</span></pre></div><div class="sec" id="ch_debug.CParseTemplException"><h3><span class="title">The CParseException Class</span></h3><p>The <span class="nctnt ncbi-class">CParseTemplException</span> is a template class whose parent class is the template parameter <span class="nctnt ncbi-monospace">TBase</span>. The <span class="nctnt ncbi-class">CParseTemplException</span> class includes an additional <span class="nctnt ncbi-type">int</span> data member, called <span class="nctnt ncbi-var">m_Pos</span>. This class was specifically defined to support complex parsing tasks, and its constructor requires that positional information be supplied along with the description message. This makes it impossible to use the standard <span class="nctnt ncbi-macro">NCBI_THROW</span> macro to throw it, so we defined two additional macros:</p><pre><span class="nctnt-pre ncbi-code">/// Throw exception with extra parameter.<br />///<br />/// Required to throw exceptions with one additional parameter<br />/// (e.g. positional information for CParseException).<br />#define NCBI_THROW2(exception_class, err_code, message, extra) \<br />    throw exception_class(__FILE__, __LINE__, \<br />        0,exception_class::err_code, (message), (extra))<br /><br />/// Re-throw exception with extra parameter.<br />///<br />/// Required to re-throw exceptions with one additional parameter<br />/// (e.g. positional information for CParseException).<br />#define NCBI_RETHROW2(prev_exception,exception_class,err_code,message,extra) \<br />    throw exception_class(__FILE__, __LINE__, \<br />        &amp;(prev_exception), exception_class::err_code, (message), (extra))</span></pre></div><div class="sec" id="ch_debug.std_excep_macros"><h3><span class="title">Macros for Standard C++ Exception Handling</span></h3><p>The C++ <span class="nctnt ncbi-func">throw()</span> statement provides a mechanism for specifying the types of exceptions that may be thrown by a function. Functions that do <b>not</b> include a <span class="nctnt ncbi-func">throw()</span> statement in their declaration can throw any type of exception, but where the <span class="nctnt ncbi-func">throw()</span> statement <b>is</b> used, undeclared exception types that are thrown will cause <span class="nctnt ncbi-func">std::unexpected()</span> to be raised. Various compilers handle these events differently, and the first two macros listed in <a href="ch_debug.html#ch_debug.T5">Table 5</a>, (<span class="nctnt ncbi-macro">THROWS(())</span>, <span class="nctnt ncbi-macro">THROWS_NONE</span>, are provided to support platform-independent exception specifications.</p><div class="table" id="ch_debug.T5"><div class="caption"><p>Table 5. Platform Independent Exception Macros</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Macro</th><th align="left" valign="top" rowspan="1" colspan="1">C++ Equivalent </th><th align="left" valign="top" rowspan="1" colspan="1">Synopsis </th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-macro">THROWS((types))</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">throw(types)</span></td><td align="left" valign="top" rowspan="1" colspan="1">Defines the type of exceptions thrown by the given function. <span class="nctnt ncbi-var">types</span> may be a single object type or a comma delimited list.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-macro">THROWS_NONE</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">throw()</span></td><td align="left" valign="top" rowspan="1" colspan="1">Specifies that the given function throws no exceptions.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-macro">STD_CATCH_X(subcode, message)</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">catch(std::exception)</span></td><td align="left" valign="top" rowspan="1" colspan="1">Calls <span class="nctnt ncbi-macro">STD_CATCH_XX()</span> using the currently selected error code name.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-macro">STD_CATCH_XX(name, subcode, message)</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">catch(std::exception)</span></td><td align="left" valign="top" rowspan="1" colspan="1">Provides uniform handling of all exceptions derived from <span class="nctnt ncbi-class">std::exception</span> using the given error code name, subcode, and message. Does not catch exceptions <i>not</i> derived from <span class="nctnt ncbi-class">std::exception</span>.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-macro">STD_CATCH_ALL_X(subcode, message)</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">catch(...)</span></td><td align="left" valign="top" rowspan="1" colspan="1">Calls <span class="nctnt ncbi-macro">STD_CATCH_ALL_XX()</span> using the currently selected error code name.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-macro">STD_CATCH_ALL_XX(name, subcode, message)</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">catch(...)</span></td><td align="left" valign="top" rowspan="1" colspan="1">Applies <span class="nctnt ncbi-macro">STD_CATCH_XX()</span> to <span class="nctnt ncbi-class">std::exception</span> derived objects. Catches non-standard exceptions and generates an "Unknown exception" message using the given error code name, subcode, and message.</td></tr></tbody></table></div><p>The <span class="nctnt ncbi-macro">catch</span> macros provide uniform, routine exception handling with minimal effort from the programmer. We provide convenient <span class="nctnt ncbi-macro">STD_CATCH_*()</span> macros to print formatted messages to the application's <a href="ch_core.html#ch_core.diag">diagnostic stream</a>. For example, if <span class="nctnt ncbi-func">F()</span> throws an exception of the form:</p><pre><span class="nctnt-pre ncbi-code">throw std::runtime_error(throw-msg)</span></pre><p>then</p><pre><span class="nctnt-pre ncbi-code">try {F();}<br />STD_CATCH_X(1, catch-msg); // here 1 is the error subcode</span></pre><p>will generate a message of the form:</p><pre><span class="nctnt-pre ncbi-monospace">Error: (101.1) [catch-msg] Exception: throw-msg</span></pre><p>In this output, the <span class="nctnt ncbi-monospace">(101.1)</span> indicates the error code (defined in the module's <span class="nctnt ncbi-path">error_codes.hpp</span> header) and the subcode passed to <span class="nctnt ncbi-macro">STD_CATCH_X</span>.</p><p>In this example, the generated message starts with the Error tag, as that is the <a href="ch_core.html#ch_core.diag_severity">severity level</a> for the default diagnostic stream. User-defined classes that are derived from <span class="nctnt ncbi-class">std::exception</span> will be treated uniformly in the same manner. The <span class="nctnt ncbi-code">throw</span> clause in this case creates a new instance of <span class="nctnt ncbi-class">std::runtime_error</span> whose data member <span class="nctnt ncbi-var">desc</span> is initialized to <span class="nctnt ncbi-var">throw-msg</span>. When the exception is then caught, the exception's member function <span class="nctnt ncbi-func">what()</span> can be used to retrieve that message.</p><p>The <span class="nctnt ncbi-macro">STD_CATCH_ALL_X</span> macro catches all exceptions. If however, the exception caught is <b>not</b> derived from <span class="nctnt ncbi-class">std::exception</span>, then the <span class="nctnt ncbi-code">catch</span> clause cannot assume that <span class="nctnt ncbi-func">what()</span> has been defined for this object, and a default message is generated of the form:</p><pre><span class="nctnt-pre ncbi-monospace">Error: (101.1) [catch-msg] Exception: Unknown exception</span></pre><p>Again, the <span class="nctnt ncbi-monospace">(101.1)</span> indicates the error code (defined in the module's <span class="nctnt ncbi-path">error_codes.hpp</span> header) and the subcode passed to <span class="nctnt ncbi-macro">STD_CATCH_ALL_X</span>.</p></div><div class="sec" id="ch_debug.excep_tracing"><h3><span class="title">Exception Tracing</span></h3><p>Knowing exactly where an exception first occurs can be very useful for debugging purposes. <a href="ch_debug.html#ch_debug.CException">CException</a> class has this functionality built in, so it is highly recommended to use exceptions derived from it. In addition to this a set of <span class="nctnt ncbi-macro">THROW*_TRACE()</span> macros defined in the NCBI C++ Toolkit combine exception handling with <a href="ch_core.html#ch_core._TRACE">trace</a> mechanisms to provide such information.</p><p>The most commonly used of these macros, <span class="nctnt ncbi-code">THROW1_TRACE(class_name, init_arg)</span>, instantiates an exception object of type <span class="nctnt ncbi-var">class_name</span> using <span class="nctnt ncbi-var">init_arg</span> to initialize it. The definition of this macro is:</p><pre><span class="nctnt-pre ncbi-code">/// Throw trace.<br />///<br />/// Combines diagnostic message trace and exception throwing. First the<br />/// diagnostic message is printed, and then exception is thrown.<br />///<br />/// Arguments can be any exception class with the specified initialization<br />/// argument. The class argument need not be derived from std::exception as<br />/// a new class object is constructed using the specified class name and<br />/// initialization argument.<br />///<br />/// Example:<br />/// -  THROW1_TRACE(runtime_error, "Something is weird...");<br />#  define THROW1_TRACE(exception_class, exception_arg) \<br />    throw NCBI_NS_NCBI::DbgPrint(DIAG_COMPILE_INFO, \<br />        exception_class(exception_arg), #exception_class)</span></pre><p>From the <span class="nctnt ncbi-func">throw()</span> statement here, we see that the object actually being thrown by this macro is the value returned by <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=DbgPrint">DbgPrint()</a>. <span class="nctnt ncbi-func">DbgPrint()</span> in turn calls <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=DbgPrint">DoDbgPrint()</a>. The latter is an overloaded function that simply creates a diagnostic stream and writes the file name, line number, and the exception's <span class="nctnt ncbi-func">what()</span> message to that stream. The exception object (which is of type <span class="nctnt ncbi-var">class_name</span>) is then the value returned by <span class="nctnt ncbi-func">DbgPrint()</span>.</p><p>More generally, three sets of <span class="nctnt ncbi-macro">THROW*_TRACE</span> macros are defined:</p><ul><li><p><span class="nctnt ncbi-macro">THROW0_TRACE(exception_object)</span></p></li><li><p><span class="nctnt ncbi-macro">THROW0p_TRACE(exception_object)</span></p></li><li><p><span class="nctnt ncbi-macro">THROW0np_TRACE(exception_object)</span></p></li><li><p><span class="nctnt ncbi-macro">THROW1_TRACE(exception_class, exception_arg)</span></p></li><li><p><span class="nctnt ncbi-macro">THROW1p_TRACE(exception_class, exception_arg)</span></p></li><li><p><span class="nctnt ncbi-macro">THROW1np_TRACE(exception_class, exception_arg)</span></p></li><li><p><span class="nctnt ncbi-macro">THROW_TRACE(exception_class, exception_args)</span></p></li><li><p><span class="nctnt ncbi-macro">THROWp_TRACE(exception_class, exception_args)</span></p></li><li><p><span class="nctnt ncbi-macro">THROWnp_TRACE(exception_class, exception_args)</span></p></li></ul><p>The first three macros (<span class="nctnt ncbi-macro">THROW0*_TRACE</span>) take a single argument, which may be a newly constructed exception, as in:</p><pre><span class="nctnt-pre ncbi-code">THROW0_TRACE(runtime_error("message"))</span></pre><p>or simply a <span class="nctnt ncbi-monospace">printable</span> object to be thrown, as in:</p><pre><span class="nctnt-pre ncbi-code">THROW0_TRACE("print this message")</span></pre><p>The <span class="nctnt ncbi-macro">THROW0_TRACE</span> macro accepts either an exception object or a string as the argument to be thrown. The <span class="nctnt ncbi-macro">THROW0p_TRACE</span> macro generalizes this functionality by accepting any <span class="nctnt ncbi-monospace">printable</span> object, such as <span class="nctnt ncbi-code">complex(1,3)</span>, as its single argument. Any object with a defined output operator is, of course, printable. The third macro generalizes this one step further, and accepts aggregate arguments such as <span class="nctnt ncbi-type">vector&lt;T&gt;</span>, where <span class="nctnt ncbi-var">T</span> is a printable object. Note that in cases where the object to be thrown is not a <span class="nctnt ncbi-class">std::exception</span>, you will need to use <span class="nctnt ncbi-macro">STD_CATCH_ALL_{X|XX}</span> or a customized catch statement to catch the thrown object.</p><p>The remaining six macros accept two arguments: an "exception" class name and an initialization argument, where both arguments are also passed to the trace message. The class argument need not actually be derived from <span class="nctnt ncbi-class">std::exception</span>, as the pre-processor simply uses the class name to construct a new object of that type using the initialization argument. All of the <span class="nctnt ncbi-macro">THROW1*_TRACE</span> macros assume that there is a single initialization argument. As in the first three macros, <span class="nctnt ncbi-macro">THROW1_TRACE()</span>, <span class="nctnt ncbi-macro">THROW1p_TRACE()</span> and <span class="nctnt ncbi-macro">THROW1np_TRACE()</span> specialize in different types of printable objects, ranging from exceptions and numeric and character types, to aggregate and container types.</p><p>The last three macros parallel the previous two sets of macros in their specializations, and may be applied where the exception object's constructor takes multiple arguments. (See also the discussion on <a href="ch_debug.html#ch_debug.cpp_exceptions">Exception handling</a>).</p><p>It is also possible to specify that execution should abort immediately when an exception occurs. By default, this feature is not activated, but the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SetThrowTraceAbort">SetThrowTraceAbort()</a> function can be used to activate it. Alternatively, you can turn it on for the entire application by setting either the <span class="nctnt ncbi-var">$ABORT_ON_THROW</span> environment variable, or the application's registry <span class="nctnt ncbi-var">ABORT_ON_THROW</span> entry (in the <span class="nctnt ncbi-var">[DEBUG]</span> section) to an arbitrary non-empty value.</p></div></div></div></div><div id="tkb_internal" class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_debug.extracting_debug_data">Extracting Debug Data</a></li><li><a href="#ch_debug.err_handling_diagnostics">NCBI C++ Error Handling and Diagnostics</a></li><li><a href="#ch_debug.debug_dump">DebugDump: Take an Object State Snapshot</a></li><li><a href="#ch_debug.excep_cpp_toolkit">Exception Handling (*) in the NCBI C++ Toolkit</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_debug.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                        middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />Â Â 					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                        middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" /><label for="iToolkitAll" title="Search in the C/C++ source code,  this Book, and Wiki">All</label></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><label for="iLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><label for="iLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><span class="bkp_prtlt_txt"> LXR: </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a><span class="bkp_prtlt_txt"> / </span><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Doxygen: </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a><span class="bkp_prtlt_txt"> / </span><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><span class="bkp_prtlt_txt"> Documentation: </span><a href="/books/NBK7170/#ch_getcode_svn.code_retrieval">in-house</a><span class="bkp_prtlt_txt"> / </span><a href="/books/NBK7170/#ch_getcode_svn.external">public</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (dev): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a><span class="bkp_prtlt_txt"> / </span><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c++/" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (extra): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (prod): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lib_search/libsearch.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Search Tool</a></li><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/depgraphs/dglistdeps.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Dependencies Tool</a></li><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Wiki</a></li><li class="internal-only"><a href="http://jira/browse/CXX" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">JIRA</a></li><li class="internal-only"><a href="http://intranet/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="/books/NBK7156/">Release Notes</a></li><li><a href="/books/NBK7170/#ch_getcode_svn.ftp_download">Download</a></li><li><a href="/books/NBK7160/pdf/TOC.pdf">PDF of the book</a></li><li><a href="/books/NBK7147/">Coding Style</a></li><li><a href="/books/NBK7177/#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div><div id="tkb_public" class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_debug.extracting_debug_data">Extracting Debug Data</a></li><li><a href="#ch_debug.err_handling_diagnostics">NCBI C++ Error Handling and Diagnostics</a></li><li><a href="#ch_debug.debug_dump">DebugDump: Take an Object State Snapshot</a></li><li><a href="#ch_debug.excep_cpp_toolkit">Exception Handling (*) in the NCBI C++ Toolkit</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_debug.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                        middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />Â Â 					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                        middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr><td colspan="2"><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td></tr><tr><td colspan="2"><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td colspan="2"><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="/books/NBK7170/#ch_getcode_svn.external">Documentation</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c++/" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Web (dev)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lib_search/libsearch.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Search Tool</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/depgraphs/dglistdeps.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Dependencies Tool</a></li><li><a href="/books/NBK7156/">Release Notes</a></li><li><a href="/books/NBK7170/#ch_getcode_svn.ftp_download">Download</a></li><li><a href="/books/NBK7160/pdf/TOC.pdf">PDF of the book</a></li><li><a href="/books/NBK7147/">Coding Style</a></li><li><a href="/books/NBK7177/#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
