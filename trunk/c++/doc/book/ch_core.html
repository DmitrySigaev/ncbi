<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Portability, Core Functionality and Application Framework - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_core" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="js/jig/1.7/js/jig.min.js"></script><script type="text/javascript" src="js/toolkitSymbolSearch.js"></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents ▾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access - SQL, Berkley DB</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_xmlauthor.html">29. XML Authoring using Word</a></li><li class="half_rhythm"><a href="ch_faq.html">30. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">31. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a><ul class="simple-list"><li class="half_rhythm"><a href="release_notes.html">Release Notes (Version 9, May 2012)</a></li><li class="half_rhythm"><a href="release_notes_7-05_2011.html">Release Notes (Version 7, May 2011)</a></li><li class="half_rhythm"><a href="release_notes_06_29_2010.html">Release Notes (June, 2010)</a></li><li class="half_rhythm"><a href="release_notes_05_15_2009.html">Release Notes (May, 2009)</a></li><li class="half_rhythm"><a href="release_notes_12_24_2008.html">Release Notes (December, 2008)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2008.html">Release Notes (March, 2008)</a></li><li class="half_rhythm"><a href="release_notes_08_27_2007.html">Release Notes (August, 2007)</a></li><li class="half_rhythm"><a href="release_notes_03_12_2007.html">Release Notes (March, 2007)</a></li><li class="half_rhythm"><a href="release_notes_08_14_2006.html">Release Notes (August, 2006)</a></li><li class="half_rhythm"><a href="release_notes_04_30_2006.html">Release Notes (April 30, 2006)</a></li><li class="half_rhythm"><a href="release_notes_12_31_2005.html">Release Notes (December 31, 2005)</a></li><li class="half_rhythm"><a href="release_notes_10_03_2005.html">Release Notes (August, 2005)</a></li><li class="half_rhythm"><a href="release_notes_05_05_2005.html">Release Notes (April, 2005)</a></li><li class="half_rhythm"><a href="release_notes_03_09_2005.html">Release Notes (February, 2005)</a></li><li class="half_rhythm"><a href="release_notes_11_22_2004.html">Release Notes (November 22, 2004)</a></li><li class="half_rhythm"><a href="release_notes_10_2_2004.html">Release Notes (October 2, 2004)</a></li><li class="half_rhythm"><a href="release_notes_7_8_2004.html">Release Notes (July 8, 2004)</a></li><li class="half_rhythm"><a href="release_notes_april_16_2004.html">Release Notes (April 16, 2004)</a></li><li class="half_rhythm"><a href="release_notes_12_08_2003.html">Release Notes (December 8, 2003)</a></li><li class="half_rhythm"><a href="release_notes_08_01_2003.html">Release Notes (August 1, 2003)</a></li></ul></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="part3.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="ch_conn.html">Next &gt;</a></div></div><div class="meta_content"><h1><span class="label">8</span><span class="title">Portability, Core Functionality and Application Framework</span></h1><p class="small">Last Update: June 13, 2012.</p></div><div class="body_content"><div class="sec"><h2><span class="title">Overview</span></h2><p>The overview for this chapter consists of the following topics:</p><ul><li><p>Introduction</p></li><li><p>Chapter Outline</p></li></ul><div class="sec"><h3><span class="title">Introduction</span></h3><ul><li><p><b>CORELIB library </b><span class="nctnt ncbi-path">xncbi</span>:<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/corelib">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/corelib">src</a></p></li></ul><p>The CORELIB provides a portable low-level API and many useful application framework classes for argument processing, diagnostics, environment interface, object and reference classes, portability definitions, portable exceptions, stream wrappers, string manipulation, threads, etc.</p><p>This chapter provides reference material for many of CORELIB's facilities. For an overview of CORELIB, please refer to the <a href="ch_intro.html#ch_intro.intro_corelib">CORELIB section in the introductory chapter</a> on the C++ Toolkit.</p><p><span class="nctnt highlight">Note</span>: The CORELIB must be linked to every executable that uses the NCBI C++ Toolkit!</p><ul><li><p><b>UTIL library </b><span class="nctnt ncbi-path">xutil</span>:<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/util">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/util">src</a></p></li></ul><p>The UTIL module is a collection of useful classes which can be used in more then one application. This chapter provides reference material for many of UTIL's facilities. For an overview of the UTIL module please refer to the <a href="ch_intro.html#ch_intro.intro_util">UTIL section in the introductory chapter</a> on the C++ Toolkit.</p></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p><ul><li><p><a href="ch_core.html#ch_core.writing_simple_app">Writing a Simple Application</a></p><ul><li><p><a href="ch_core.html#ch_core.basic_classes">NCBI C++ Toolkit Application Framework Classes</a></p><ul><li><p><a href="ch_core.html#ch_core.CNcbiApplication">CNcbiApplication</a></p></li><li><p><a href="ch_core.html#ch_core.CNcbiArguments">CNcbiArguments</a></p></li><li><p><a href="ch_core.html#ch_core.CNcbiEnvironment">CNcbiEnvironment</a></p></li><li><p><a href="ch_core.html#ch_core.CNcbiRegistry">CNcbiRegistry</a></p></li><li><p><a href="ch_core.html#ch_core.CNcbiDiag">CNcbiDiag</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.creating_simple_app">Creating a Simple Application</a></p><ul><li><p><a href="ch_core.html#ch_core.creating_unix_app">Unix-like Systems</a></p></li><li><p><a href="ch_core.html#ch_core.creating_ms_app">MS Windows</a></p></li><li><p><a href="ch_core.html#ch_core.discuss_sample_app">Discussion of the Sample Application</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.inside_app_class">Inside the NCBI Application Class</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.cmd_line_args">Processing Command-Line Arguments</a></p><ul><li><p><a href="ch_core.html#ch_core.cmd_line_APIs">Capabilities of the Command-Line API</a></p></li><li><p><a href="ch_core.html#ch_core.arg_classes">The Relationships between the CArgDescriptions, CArgs, and CArgValue Classes</a></p></li><li><p><a href="ch_core.html#ch_core.cmd_line_syntax">Command-Line Syntax</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions">The CArgDescriptions (*) Class</a></p><ul><li><p><a href="ch_core.html#ch_core.argdescr.CArgDescriptions_Cons">The CArgDescriptions Constructor</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_Attr">Describing Argument Attributes</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_Types">Argument Types</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_StdValueTypes">Restricting the Input Argument Values</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_UserValueTypes">Implementing User-defined Restrictions Using the CArgAllow Class</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_App">Using CArgDescriptions in Applications</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_Usage">Generating a USAGE Message</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.CArgs">The CArgs (*) Class: A Container Class for CArgValue (*) Objects</a></p></li><li><p><a href="ch_core.html#ch_core.CArgValue">CArgValue (*) Class: The Internal Representation of Argument Values</a></p></li><li><p><a href="ch_core.html#ch_core.Supporting_CommandBased_Command">Supporting Command-Based Command Lines</a></p></li><li><p><a href="ch_core.html#ch_core.arg_code_example">Code Examples</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.namespace_concat">Namespace, Name Concatenation, and Compiler-specific Macros</a></p><ul><li><p><a href="ch_core.html#ch_core.ncbi_namespace">NCBI Namespace</a></p></li><li><p><a href="ch_core.html#ch_core.other_namespace_macros">Other Namespace Macros</a></p></li><li><p><a href="ch_core.html#ch_core.name_concat">Name Concatenation</a></p></li><li><p><a href="ch_core.html#ch_core.compiler_specific_macros">Compiler-specific Macros</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.Configuration_Parame">Configuration Parameters</a></p><ul><li><p><a href="ch_core.html#ch_core.General_Usage_Inform">General Usage Information</a></p></li><li><p><a href="ch_core.html#ch_core.Macros_for_Creating_">Macros for Creating Parameters</a></p></li><li><p><a href="ch_core.html#ch_core.Methods_for_Using_Pa">Methods for Using Parameters</a></p></li><li><p><a href="ch_core.html#ch_core.Supporting_Classes">Supporting Classes</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.registry">Using the CNcbiRegistry Class</a></p><ul><li><p><a href="ch_core.html#ch_core.registry_intro">Working with the Registry Class: CNcbiRegistry</a></p></li><li><p><a href="ch_core.html#ch_core.registry_syntax">Syntax of the Registry Configuration File</a></p></li><li><p><a href="ch_core.html#ch_core.ini_search_order">Search Order for Initialization (*.ini) Files</a></p></li><li><p><a href="ch_core.html#ch_core.registry_Eflags">Fine-Tuning Registry Parameters Using IRegistry::EFlags</a></p></li><li><p><a href="ch_core.html#ch_core.registry_mainmethods">Main Methods of CNcbiRegistry</a></p></li><li><p><a href="ch_core.html#ch_core.registry_addmethods">Additional Registry Methods</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.stream_wrappers">Portable Stream Wrappers</a></p></li><li><p><a href="ch_core.html#ch_core.diag">Working with Diagnostic Streams (*)</a></p><ul><li><p><a href="ch_core.html#ch_core.Where_Diagnostic_Messages_Go">Where Diagnostic Messages Go</a></p></li><li><p><a href="ch_core.html#ch_core.diag_severity">Setting Diagnostic Severity Levels</a></p></li><li><p><a href="ch_core.html#ch_core.diagnostic_messages_filtering">Diagnostic Messages Filtering</a></p></li><li><p><a href="ch_core.html#ch_core.Log_File_Format">Log File Format</a></p><ul><li><p><a href="ch_core.html#ch_core.The_Old_Post_Format">The Old Post Format</a></p></li><li><p><a href="ch_core.html#ch_core.The_New_Post_Format">The New Post Format</a></p></li><li><p><a href="ch_core.html#ch_core.diag_post_flags">Controlling Appearance of Diagnostic Message Using Post Flags</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.diag_set_stream">Defining the Output Stream</a></p></li><li><p><a href="ch_core.html#ch_core.Tee_Output_to_STDERR">Tee Output to STDERR</a></p></li><li><p><a href="ch_core.html#ch_core.diag_buffering">The Message Buffer</a></p></li><li><p><a href="ch_core.html#ch_core.Request_Exit_Status_Codes">Request Exit Status Codes</a></p><ul><li><p><a href="ch_core.html#ch_core.Standard_HTTPlike_status_codes">Standard (HTTP-like) status codes</a></p></li><li><p><a href="ch_core.html#ch_core.NCBIspecific_status_codes">NCBI-specific status codes</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.diag_errcodes">Error Codes and Their Descriptions</a></p><ul><li><p><a href="ch_core.html#ch_core.err_msg_file">Preparing an Error Message File</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.diag_handlers">Defining Custom Handlers Using CDiagHandler</a></p></li><li><p><a href="ch_core.html#ch_core.ERR_POST">The ERR_POST and LOG_POST Macros</a></p></li><li><p><a href="ch_core.html#ch_core._TRACE">The _TRACE macro</a></p></li><li><p><a href="ch_core.html#ch_core.Stack_Traces">Stack Traces</a></p><ul><li><p><a href="ch_core.html#ch_core.Printing_a_Stack_Trace">Printing a Stack Trace</a></p></li><li><p><a href="ch_core.html#ch_core.Obtaining_a_Stack_Trace_for_Exce">Obtaining a Stack Trace for Exceptions</a></p></li></ul></li></ul></li><li><p><a href="ch_core.html#ch_core.debug_module_ref">Debug Macros</a></p></li><li><p><a href="ch_core.html#ch_core.exception_handling_ref">Handling Exceptions</a></p></li><li><p><a href="ch_core.html#ch_core.std_ncbi_types">Defining the Standard NCBI C++ Types and Their Limits</a></p><ul><li><p><a href="ch_core.html#ch_core.port_header_files">Headers Files Containing Portability Definitions</a></p></li><li><p><a href="ch_core.html#ch_core.built_in_integral_types">Built-in Integral Types</a></p></li><li><p><a href="ch_core.html#ch_core.auxiliary_types">Auxiliary Types</a></p></li><li><p><a href="ch_core.html#ch_core.fixed_size_integers">Fixed-Size Integer Types</a></p></li><li><p><a href="ch_core.html#ch_core.big_scalar">The "Ncbi_BigScalar" Type</a></p></li><li><p><a href="ch_core.html#ch_core.types_policy">Encouraged and Discouraged Types</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.smart_ptrs">Understanding Smart Pointers: the CObject and CRef Classes</a></p><ul><li><p><a href="ch_core.html#ch_core.auto_ptr">STL auto_ptrs</a></p></li><li><p><a href="ch_core.html#ch_core.CRef">The CRef (*) Class</a></p></li><li><p><a href="ch_core.html#ch_core.CObject">The CObject (*) Class</a></p></li><li><p><a href="ch_core.html#ch_core.CObjectFor">The CObjectFor (*) Class: Using Smart Pointers for Standard Types</a></p></li><li><p><a href="ch_core.html#ch_core.CRef_usage">When to Use CRefs and auto_ptrs</a></p></li><li><p><a href="ch_core.html#ch_core.CRef_pitfalls">CRef Pitfalls</a></p><ul><li><p><a href="ch_core.html#ch_core.object_destruction">Inadvertent Object Destruction</a></p></li></ul></li></ul></li><li><p><a href="ch_core.html#ch_core.atomic_counters">Atomic Counters</a></p></li><li><p><a href="ch_core.html#ch_core.portable_dll">Portable Mechanisms for Loading DLLs</a></p><ul><li><p><a href="ch_core.html#ch_core.CDll_constructor">CDll Constructor</a></p></li><li><p><a href="ch_core.html#ch_core.CDll_basename">CDll Basename</a></p></li><li><p><a href="ch_core.html#ch_core.CDll_methods">Other CDll Methods</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.CExec">Executing Commands and Spawing Processes Using the CExec Class</a></p><ul><li><p><a href="ch_core.html#ch_core.system_call">Executing a System Command Using the System() Method</a></p></li><li><p><a href="ch_core.html#ch_core.process_modes">Defining Spawned Process Modes (EMode Type)</a></p></li><li><p><a href="ch_core.html#ch_core.spawn_process">Spawning a Process Using SpawnX() Methods</a></p></li><li><p><a href="ch_core.html#ch_core.wait_method">Waiting for a Process to Terminate Using the Wait() Method</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.threads">Implementing Parallelism Using Threads and Synchronization Mechanisms</a></p><ul><li><p><a href="ch_core.html#ch_core.using_threads">Using Threads</a></p></li><li><p><a href="ch_core.html#ch_core.thread_public_methods">CThread (*) Class Public Methods</a></p></li><li><p><a href="ch_core.html#ch_core.thread_protected_methods">CThread (*) Class Protected Methods</a></p></li><li><p><a href="ch_core.html#ch_core.thread_life_cycle">Thread Life Cycle</a></p></li><li><p><a href="ch_core.html#ch_core.referencing_threads">Referencing Thread Objects</a></p></li><li><p><a href="ch_core.html#ch_core.thread_local_storage">Thread Local Storage (CTls&lt;&gt; class [*])</a></p></li><li><p><a href="ch_core.html#ch_core.mutexes">Mutexes</a></p><ul><li><p><a href="ch_core.html#ch_core.CMutex">CMutex</a></p></li><li><p><a href="ch_core.html#ch_core.CFastMutex">CFastMutex</a></p></li><li><p><a href="ch_core.html#ch_core.SSystemMutex">SSystemMutex and SSystemFastMutex</a></p></li><li><p><a href="ch_core.html#ch_core.CMutexGuard">CMutexGuard and CFastMutexGuard</a></p></li><li><p><a href="ch_core.html#ch_core.lock_classes">Lock Classes</a></p><ul><li><p><a href="ch_core.html#ch_core.CRWLock">CRWLock</a></p></li><li><p><a href="ch_core.html#ch_core.CAutoRW">CAutoRW</a></p></li><li><p><a href="ch_core.html#ch_core.CReadLockGuard">CReadLockGuard</a></p></li><li><p><a href="ch_core.html#ch_core.CWriteLockGuard">CWriteLockGuard</a></p></li><li><p><a href="ch_core.html#ch_core.CInternalRWLock">CInternalRWLock</a></p></li><li><p><a href="ch_core.html#ch_core.CSemaphore">CSemaphore</a></p></li></ul></li></ul></li></ul></li><li><p><a href="ch_core.html#ch_core.files_dirs">Working with File and Directories Using CFile and CDir</a></p><ul><li><p><a href="ch_core.html#ch_core.CDirEntry">CDirEntry Class</a></p></li><li><p><a href="ch_core.html#ch_core.CFile">CFile Class</a></p></li><li><p><a href="ch_core.html#ch_core.CDir">CDir Class</a></p></li><li><p><a href="ch_core.html#ch_core.CMemoryFile">CMemoryFile Class</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.string_classes">String APIs</a></p><ul><li><p><a href="ch_core.html#ch_core.string_consts">String Constants</a></p></li><li><p><a href="ch_core.html#ch_core.NStr">NStr Class</a></p></li><li><p><a href="ch_core.html#ch_core.UTF_strings">UTF Strings</a></p></li><li><p><a href="ch_core.html#ch_core.pcase">PCase and PNocase</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.portable_time_class">Portable Time Class</a></p><ul><li><p><a href="ch_core.html#ch_core.CTime">CTime Class Constructors</a></p></li><li><p><a href="ch_core.html#ch_core.CTimeMethods">Other CTime Methods</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.template_utils">Template Utilities</a></p><ul><li><p><a href="ch_core.html#ch_core.function_objects">Function Objects</a></p></li><li><p><a href="ch_core.html#ch_core.template_functions">Template Functions</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.misc_types_macros">Miscellaneous Types and Macros</a></p><ul><li><p><a href="ch_core.html#ch_core.misc_enum_types">Miscellaneous Enumeration Types</a></p></li><li><p><a href="ch_core.html#ch_core.AutoPtr">AutoPtr Class</a></p></li><li><p><a href="ch_core.html#ch_core.ITERATE_macros">ITERATE Macros</a></p></li><li><p><a href="ch_core.html#ch_core.seq_pos_types">Sequence Position Types</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.Containers">Containers</a></p><ul><li><p><a href="ch_core.html#ch_core.template_typename_Co">template&lt;typename Coordinate&gt; class CRange</a></p><ul><li><p><a href="ch_core.html#ch_core._Typedefs_1">Typedefs</a></p></li><li><p><a href="ch_core.html#ch_core._Methods_1">Methods</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core._template_typename_Ob_2">template&lt;typename Object, typename Coordinate = int&gt; class CRangeMap</a></p></li><li><p><a href="ch_core.html#ch_core._template_typename_Ob_3">template&lt;typename Object, typename Coordinate = int&gt; class CRangeMultiMap</a></p></li><li><p><a href="ch_core.html#ch_core.class_CIntervalTree">class CIntervalTree</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.Thread_Pools">Thread Pools</a></p><ul><li><p><a href="ch_core.html#ch_core.CTreadPool">class CThreadPool</a></p></li><li><p><a href="ch_core.html#ch_core.Class_CThreadPool_Ta">class CThreadPool_Task</a></p></li><li><p><a href="ch_core.html#ch_core.Class_CThreadPool_Ta">class CThreadPool_Thread</a></p></li><li><p><a href="ch_core.html#ch_core._Class_CThreadPool_Co">class CThreadPool_Controller</a></p></li><li><p><a href="ch_core.html#ch_core._Class_CThreadPool_Co">class CThreadPool_Controller_PID</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.Miscellaneous_Classe">Miscellaneous Classes</a></p><ul><li><p><a href="ch_core.html#ch_core.class_CLightString">class CTempString</a></p></li><li><p><a href="ch_core.html#ch_core.class_CChecksum">class CChecksum</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.Input_Output_Utility">Input/Output Utility Classes</a></p><ul><li><p><a href="ch_core.html#ch_core.class_CIStreamBuffer">class CIStreamBuffer</a></p></li><li><p><a href="ch_core.html#ch_core.class_COStreamBuffer">class COStreamBuffer</a></p></li><li><p><a href="ch_core.html#ch_core.class_CByteSource">class CByteSource</a></p></li><li><p><a href="ch_core.html#ch_core.class_CStreamByteSou">class CStreamByteSource</a></p></li><li><p><a href="ch_core.html#ch_core.class_CFStreamByteSo">class CFStreamByteSource</a></p></li><li><p><a href="ch_core.html#ch_core.class_CFileByteSourc">class CFileByteSource</a></p></li><li><p><a href="ch_core.html#ch_core.class_CMemoryByteSou">class CMemoryByteSource</a></p></li><li><p><a href="ch_core.html#ch_core.class_CByteSourceRea">class CByteSourceReader</a></p></li><li><p><a href="ch_core.html#ch_core.class_CSubSourceColl">class CSubSourceCollector</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.Using_the_C_Toolkit_from_a_Third">Using the C++ Toolkit from a Third Party Application Framework</a></p></li></ul></div><p><b>Demo Cases</b> [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/basic">src/sample/app/basic</a>]</p></div><div class="sec" id="ch_core.writing_simple_app"><h2><span class="title">Writing a Simple Application</span></h2><p>This section discusses how to write a simple application using the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNcbiApplication.html">CNcbiApplication</a> and related class. A <a href="ch_intro.html#ch_intro.intro_appframe">conceptual understanding of the uses of the CNcbiApplication and related classes</a> is presented in the introductory chapter on the C++ Toolkit.</p><p>This section discusses the following topics:</p><ul><li><p><a href="ch_core.html#ch_core.basic_classes">Basic Classes of the NCBI C++ Toolkit</a></p></li><li><p><a href="ch_core.html#ch_core.creating_simple_app">Creating a Simple Application</a></p></li><li><p><a href="ch_core.html#ch_core.inside_app_class">Inside the NCBI Application Class</a></p></li></ul><p><span class="nctnt highlight">Note:</span> The C++ Toolkit can also be <a href="ch_core.html#ch_core.Using_the_C_Toolkit_from_a_Third">used from a third party application framework</a>.</p><div class="sec" id="ch_core.basic_classes"><h3><span class="title">NCBI C++ Toolkit Application Framework Classes</span></h3><p>The following five fundamental classes form the foundation of the C++ Toolkit Application Framework:</p><ul><li><p><a href="ch_core.html#ch_core.CNcbiApplication">CNcbiApplication</a></p></li><li><p><a href="ch_core.html#ch_core.CNcbiArguments">CNcbiArguments</a> (see also <a href="ch_core.html#ch_core.cmd_line_args">CArgDescriptions, CArgs, ...</a>)</p></li><li><p><a href="ch_core.html#ch_core.CNcbiEnvironment">CNcbiEnvironment</a></p></li><li><p><a href="ch_core.html#ch_core.CNcbiRegistry">CNcbiRegistry</a></p></li><li><p><a href="ch_core.html#ch_core.CNcbiDiag">CNcbiDiag</a></p></li></ul><p>Each of these classes is discussed in the following sections:</p><div class="sec" id="ch_core.CNcbiApplication"><h4><span class="title">CNcbiApplication</span></h4><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNcbiApplication.html">CNcbiApplication</a> is an abstract class used to define the basic functionality and behavior of an NCBI application. Because this application class effectively supersedes the C-style <span class="nctnt ncbi-func">main()</span> function, minimally, it must provide the same functionality, i.e.:</p><ul><li><p>a mechanism to execute the actual application</p></li><li><p>a data structure for holding program command-line arguments (<span class="nctnt ncbi-var">"argv"</span>)</p></li><li><p>a data structure for holding environment variables</p></li></ul><p>In addition, the application class provides the same features previously implemented in the C Toolkit, namely:</p><ul><li><p>mechanisms for specifying where, when, and how errors should be reported</p></li><li><p>methods for reading, accessing, modifying, and writing information in the application's registry (configuration) file</p></li><li><p>methods to describe, and then automatically parse, validate, and access program command-line arguments and to generate the <span class="nctnt ncbi-monospace">USAGE</span> message</p></li></ul><p>The mechanism to execute the application is provided by <span class="nctnt ncbi-class">CNcbiApplication</span>'s member function <span class="nctnt ncbi-func">Run()</span>, for which you must write your own implementation. The <span class="nctnt ncbi-func">Run()</span> function will be automatically invoked by <span class="nctnt ncbi-func">CNcbiApplication::AppMain()</span>, after it has initialized its <span class="nctnt ncbi-class">CNcbiArguments, CNcbiEnvironment, CNcbiRegistry</span>, and <span class="nctnt ncbi-class">CNcbiDiag</span> data members.</p></div><div class="sec" id="ch_core.CNcbiArguments"><h4><span class="title">CNcbiArguments</span></h4><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNcbiArguments.html">CNcbiArguments</a> class provides a data structure for holding the application's command-line arguments, along with methods for accessing and modifying these. Access to the argument values is implemented using the built-in <span class="nctnt ncbi-code">[ ]</span> operator. For example, the first argument in <span class="nctnt ncbi-var">argv</span> (following the program name) can be retrieved using the <span class="nctnt ncbi-func">CNcbiApplication::GetArguments()</span> method:</p><pre><span class="nctnt-pre ncbi-code">string arg1_value = GetArguments()[1];</span></pre><p>Here, <span class="nctnt ncbi-func">GetArguments()</span> returns the <span class="nctnt ncbi-class">CNcbiArguments</span> object, whose argument values can then be retrieved using the <span class="nctnt ncbi-code">[ ]</span> operator. Four additional <span class="nctnt ncbi-class">CNcbiArguments</span> member functions support retrieval and modification of the program name (initially <span class="nctnt ncbi-var">argv[0]</span>). A helper class, described in <a href="ch_core.html#ch_core.cmd_line_args">Processing Command-Line Arguments</a>, supports the generation of <span class="nctnt ncbi-monospace">USAGE</span> messages and the imposition of constraints on the values of the input arguments.</p><p>In addition to the <span class="nctnt ncbi-class">CNcbiArguments</span> class, there are other related classes used for argument processing. The <span class="nctnt ncbi-class">CArgDescriptions</span> and <span class="nctnt ncbi-class">CArgDesc</span> classes are used for describing unparsed arguments; <span class="nctnt ncbi-class">CArgs</span> and <span class="nctnt ncbi-class">CArgValue</span> for parsed argument values; <span class="nctnt ncbi-class">CArgException</span> and <span class="nctnt ncbi-class">CArgHelpException</span> for argument exceptions; and <span class="nctnt ncbi-class">CArgAllow</span>, <span class="nctnt ncbi-class">CArgAllow_{Strings, ..., Integers, Doubles}</span> for argument constraints. These classes are discussed in the section on <a href="ch_core.html#ch_core.cmd_line_args">Processing Command-Line Arguments</a>.</p><p>When using the C++ Toolkit on the Mac OS, you can specify command-line arguments in a separate file with the name of your executable and ".args" extension. Each argument should be on a separate line (see <a href="ch_core.html#ch_core.T1">Table 1</a>).</p><div class="table" id="ch_core.T1"><div class="caption"><p>Table 1. Example of Command-line Arguments</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Command-Line Parameters</th><th align="left" valign="top" rowspan="1" colspan="1">File Content</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-gi "Integer" (GI id of the Seq-Entry to examine) OPTIONAL ARGUMENTS: -h (Print this USAGE message; ignore other arguments) -reconstruct (Reconstruct title) -accession (Prepend accession) -organism (Append organism name) </td><td align="left" valign="top" rowspan="1" colspan="1">-gi 10200 -reconstruct -accession -organism </td></tr></tbody></table><div class="table-wrap-foot"><div class="small" id="ch_core.TF.1"><p>Please note:</p></div><div class="small" id="ch_core.TF.2"><p>File must contain Macintosh-style line breaks.</p></div><div class="small" id="ch_core.TF.3"><p>No extra spaces are allowed after argument ("-accession" and not "-accession ").</p></div><div class="small" id="ch_core.TF.4"><p>Arguments must be followed by an empty terminating line.</p></div></div></div></div><div class="sec" id="ch_core.CNcbiEnvironment"><h4><span class="title">CNcbiEnvironment</span></h4><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNcbiEnvironment.html">CNcbiEnvironment</a> class provides a data structure for storing, accessing, and modifying the environment variables accessed by the C library routine <span class="nctnt ncbi-func">getenv()</span>.</p><p>The following describes the public interface to the <span class="nctnt ncbi-class">CNcbiEnvironment</span>:</p><pre><span class="nctnt-pre ncbi-code">class  CNcbiEnvironment<br />{<br />public:<br />    /// Constructor.<br />    CNcbiEnvironment(void);<br />    /// Constructor with the envp parameter.<br />    CNcbiEnvironment(const char* const* envp);<br />    /// Destructor.<br />    virtual ~CNcbiEnvironment(void);<br />    /// Reset environment.<br />    ///<br />    /// Delete all cached entries, load new ones from "envp" (if not NULL).<br />    void Reset(const char* const* envp = 0);<br />    /// Get environment value by name.<br />    ///<br />    /// If environmnent value is not cached then call "Load(name)" to load<br />    /// the environmnent value.  The loaded name/value pair will then be<br />    /// cached, too, after the call to "Get()".<br />    const string&amp; Get(const string&amp; name) const;<br />};</span></pre><p>For example, to retrieve the value of environment variable <span class="nctnt ncbi-var">PATH</span>:</p><pre><span class="nctnt-pre ncbi-code">string arg1_value = GetEnvironment().Get("PATH");</span></pre><p>In this example, the <span class="nctnt ncbi-func">GetEnvironment()</span> is defined in the <span class="nctnt ncbi-class">CNcbiApplication</span> class and returns the <span class="nctnt ncbi-class">CNcbiEnvironment</span> object for which the <span class="nctnt ncbi-func">Get()</span> method is called with the environment variable <span class="nctnt ncbi-var">PATH</span>.</p><p>To delete all of the cached entries and reload new ones from the environment pointer (envp), use the <span class="nctnt ncbi-func">CNcbiEnvironment::Reset()</span> method.</p></div><div class="sec" id="ch_core.CNcbiRegistry"><h4><span class="title">CNcbiRegistry</span></h4><p>Complete details for the <span class="nctnt ncbi-class">CNcbiRegistry</span> can be found in the section on <a href="ch_core.html#ch_core.registry">The CNcbiRegistry Class</a>.</p></div><div class="sec" id="ch_core.CNcbiDiag"><h4><span class="title">CNcbiDiag</span></h4><p>The <a href="ch_core.html#ch_core.diag">CNcbiDiag</a> class implements much of the functionality of the NCBI C++ Toolkit error-processing mechanisms; however, it is not intended to be used directly. Instead, use the <a href="ch_core.html#ch_core.ERR_POST"><tt>{ERR|LOG}_POST*</tt></a> and <a href="ch_core.html#ch_core._TRACE"><tt>_TRACE</tt></a> macros. See the sections on <a href="ch_core.html#ch_core.diag">Diagnostic Streams</a> and <a href="ch_debug.html#ch_debug.std_cpp_message_post">Message Posting</a> for related information.</p></div></div><div class="sec" id="ch_core.creating_simple_app"><h3><span class="title">Creating a Simple Application</span></h3><p>This section discusses the following topics:</p><ul><li><p><a href="ch_core.html#ch_core.creating_unix_app">Unix-like Systems</a></p></li><li><p><a href="ch_core.html#ch_core.creating_ms_app">MS Windows</a></p></li><li><p><a href="ch_core.html#ch_core.discuss_sample_app">Discussion of the Sample Application</a></p></li></ul><div class="sec" id="ch_core.creating_unix_app"><h4><span class="title">Unix-like Systems</span></h4><p>Using the <a href="ch_proj.html#ch_proj.outside_tree">new_project</a> shell script, create a new project <span class="nctnt ncbi-path">example</span>:</p><pre><span class="nctnt-pre ncbi-cmd">new_project example app</span></pre><p>This will create:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">the project folder -- <span class="nctnt ncbi-path">example</span></p></dd><dt>2</dt><dd><p class="no_top_margin">the source file -- <span class="nctnt ncbi-path">example.cpp</span></p></dd><dt>3</dt><dd><p class="no_top_margin">the makefiles -- <span class="nctnt ncbi-path">Makefile</span>, <span class="nctnt ncbi-path">Makefile.builddir</span>, <span class="nctnt ncbi-path">Makefile.in</span>, <span class="nctnt ncbi-path">Makefile.example.app</span>, <span class="nctnt ncbi-path">Makefile.example_app</span>, <span class="nctnt ncbi-path">Makefile.out</span></p></dd></dl><p>Then build the project and run the application:</p><pre><span class="nctnt-pre ncbi-cmd">cd example; make; ./example</span></pre></div><div class="sec" id="ch_core.creating_ms_app"><h4><span class="title">MS Windows</span></h4><p>Using the <a href="ch_proj.html#ch_proj.outside_tree">new_project</a> shell script, create a new project <span class="nctnt ncbi-path">example</span>:</p><pre><span class="nctnt-pre ncbi-cmd">new_project example app</span></pre><p>This will create:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">the project folder -- <span class="nctnt ncbi-path">example</span></p></dd><dt>2</dt><dd><p class="no_top_margin">the source file -- <span class="nctnt ncbi-path">example\src\example\basic_sample.cpp</span> (the source file name is always <span class="nctnt ncbi-path">basic_sample.cpp</span>, regardless of the project name)</p></dd><dt>3</dt><dd><p class="no_top_margin">the MSVC project file -- <span class="nctnt ncbi-path">example\compilers\msvc{900|1000}_prj\static\build\example\example.exe.vcproj</span></p></dd><dt>4</dt><dd><p class="no_top_margin">the MSVC solution file -- <span class="nctnt ncbi-path">example\compilers\msvc{900|1000}_prj\static\build\example.sln</span></p></dd><dt>5</dt><dd><p class="no_top_margin">a project makefile -- <span class="nctnt ncbi-path">example\src\example\Makefile.example.app</span></p></dd><dt>6</dt><dd><p class="no_top_margin">other folders and files needed for building under Windows</p></dd></dl><p><span class="nctnt highlight">Note:</span> If you prefer to have your source file name match your project name, you can achieve that by making the following edits before opening Visual Studio (for basic application projects, that is - other project types might require more edits):</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Rename the source file from <span class="nctnt ncbi-path">example\src\example\basic_sample.cpp</span> to <span class="nctnt ncbi-path">example.cpp</span>.</p></dd><dt>2</dt><dd><p class="no_top_margin">Edit the MSVC project file <span class="nctnt ncbi-path">example\compilers\msvc{900|1000}_prj\static\build\example\example.exe.vcproj</span> and replace "basic_sample" with "example".</p></dd><dt>3</dt><dd><p class="no_top_margin">Edit the project makefile <span class="nctnt ncbi-path">example\src\example\Makefile.example.app</span> and replace "basic_sample" with "example".</p></dd></dl><p>Then open the solution file <span class="nctnt ncbi-path">example\compilers\msvc{900|1000}_prj\static\build\example.sln</span> with MSVS and:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Build the <span class="nctnt ncbi-var">-CONFIGURE-</span> project (reloading the project when prompted).</p></dd><dt>2</dt><dd><p class="no_top_margin">Build the project and run the application.</p></dd></dl></div><div class="sec" id="ch_core.discuss_sample_app"><h4><span class="title">Discussion of the Sample Application</span></h4><p>In the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/basic/basic_sample.cpp">sample application</a> above:</p><p>1. There is an application class derived from <span class="nctnt ncbi-class">CNcbiApplication</span>, which overrides the purely virtual function <span class="nctnt ncbi-func">Run()</span> as well as the initialization (<span class="nctnt ncbi-func">Init()</span>) and cleanup (<span class="nctnt ncbi-func">Exit()</span>) functions:</p><pre><span class="nctnt-pre ncbi-code">class CSampleBasicApplication : public CNcbiApplication<br />{<br />private:<br />    virtual void Init(void);<br />    virtual int  Run(void);<br />    virtual void Exit(void);<br />};</span></pre><p>2. The program's main function creates an object of the application class and calls its <span class="nctnt ncbi-func">AppMain()</span> function:</p><pre><span class="nctnt-pre ncbi-code">int main(int argc, const char* argv[])<br />{<br />    // Execute main application function<br />    return CSampleBasicApplication().AppMain(argc, argv);<br />}</span></pre><p>3. The application's initialization function creates an <a href="ch_core.html#ch_core.cmd_line_args">argument descriptions object</a>, which describes the expected command-line arguments and the usage context:</p><pre><span class="nctnt-pre ncbi-code">void CSampleBasicApplication::Init(void)<br />{<br />    // Create command-line argument descriptions<br />    auto_ptr&lt;CArgDescriptions&gt; arg_desc(new CArgDescriptions);<br /><br />    // Specify USAGE context<br />    arg_desc-&gt;SetUsageContext(GetArguments().GetProgramBasename(),<br />                              "CArgDescriptions demo program");<br />    ...<br />    // Setup arg.descriptions for this application<br />    SetupArgDescriptions(arg_desc.release());<br />}</span></pre><p>4. The application's <span class="nctnt ncbi-func">Run()</span> function prints those arguments into the standard output stream or in a file.</p><p>More <a href="ch_demo.html">realistic examples of applications</a> that use the NCBI C++ Toolkit are available.</p></div></div><div class="sec" id="ch_core.inside_app_class"><h3><span class="title">Inside the NCBI Application Class</span></h3><p>Here is a somewhat simplified view of the application's class definition:</p><pre><span class="nctnt-pre ncbi-code">class CNcbiApplication<br />{<br />public:<br />    /// Main function (entry point) for the NCBI application.<br />    ///<br />    /// You can specify where to write the diagnostics<br />    ///  to (EAppDiagStream), and where to get<br />    /// the configuration file (LoadConfig()) to load<br />    /// to the application registry (accessible via GetConfig()).<br />    ///<br />    /// Throw exception if:<br />    ///  - not-only instance<br />    ///  - cannot load explicitly specified config.file<br />    ///  - SetupDiag() throws an exception<br />    ///<br />    /// If the application name is not specified, a default of "ncbi" is used.<br />    /// Certain flags such as -logfile, -conffile, and -version are<br />    /// special, so AppMain() processes them separately.<br />    /// @return<br />    ///   Exit code from Run(). Can also return a non-zero value if<br />    ///   the application threw an exception.<br />    /// @sa<br />    ///   Init(), Run(), Exit()<br />    int AppMain(int argc, const char **argv, const char **envp,<br />               EAppDiagStream diag, const char* config, const string&amp; name);<br /><br />    /// Initialize the application.<br />    ///<br />    /// The default behavior of this is "do nothing". If you have<br />    /// special initialization logic that needs to be performed,<br />    ///  then you must override this method with your own logic.<br />    virtual void Init(void);<br /><br />    /// Run the application.<br />    ///<br />    /// It is defined as a pure virtual method -- so you must(!)<br />    ///  supply theRun() method to implement the<br />    /// application-specific logic.<br />    /// @return<br />    ///   Exit code.<br />    virtual int  Run(void) = 0;<br /><br />    /// Cleanup on application exit.<br />    ///<br />    /// Perform cleanup before exiting. The default behavior of this<br />    /// is "do nothing". If you have special cleanup logic that needs<br />    /// to be performed, then you must override this method with<br />    /// your own logic.<br />    virtual void Exit(void);<br /><br />    /// Get the application's cached unprocessed command-line<br />    /// arguments.<br />    const CNcbiArguments&amp; GetArguments(void) const;<br /><br />    /// Get parsed command-line arguments.<br />    ///<br />    /// Get command-line arguments parsed according to the arg<br />    /// descriptions set by SetArgDescriptions(). Throw exception<br />    /// if no descriptions have been set.<br />    /// @return<br />    ///   The CArgs object containing parsed cmd.-line arguments.<br />    /// @sa<br />    ///   SetArgDescriptions().<br />    const CArgs&amp; GetArgs(void) const;<br /><br />    /// Get the application's cached environment.<br />    const CNcbiEnvironment&amp; GetEnvironment(void) const;<br /><br />    /// Get the application's cached configuration parameters.<br />    const CNcbiRegistry&amp; GetConfig(void) const;<br /><br />    /// Flush the in-memory diagnostic stream (for "eDS_ToMemory"<br />    /// case only).<br />    ///<br />    /// In case of "eDS_ToMemory", the diagnostics is stored in<br />    /// the internal application memory buffer ("m_DiagStream").<br />    /// Call this function to dump all the diagnostics to stream "os" and<br />    /// purge the buffer.<br />    /// @param  os<br />    ///   Output stream to dump diagnostics to. If it is NULL, then<br />    ///   nothing will be written to it (but the buffer will still be<br />    ///   purged).<br />    /// @param  close_diag<br />    ///   If "close_diag" is TRUE, then also destroy "m_DiagStream".<br />    /// @return<br />    ///   Total number of bytes actually written to "os".<br />    SIZE_TYPE FlushDiag(CNcbiOstream* os, bool close_diag = false);<br /><br />    /// Get the application's "display" name.<br />    ///<br />    /// Get name of this application, suitable for displaying<br />    /// or for using as the base name for other files.<br />    /// Will be the 'name' argument of AppMain if given.<br />    /// Otherwise will be taken from the actual name of the<br />    /// application file or argv[0].<br />    string GetProgramDisplayName(void) const;<br /><br />protected:<br />    /// Setup application specific diagnostic stream.<br />    ///<br />    /// Called from SetupDiag when it is passed the eDS_AppSpecific<br />    /// parameter. Currently, this calls SetupDiag(eDS_ToStderr) to setup<br />    /// diagonistic stream to the std error channel.<br />    /// @return<br />    ///   TRUE if successful, FALSE otherwise.<br />   virtual bool SetupDiag_AppSpecific(void);<br /><br />    /// Load configuration settings from the configuration file to<br />    /// the registry.<br />    ///<br />    /// Load (add) registry settings from the configuration file<br />    /// specified as the "conf" arg passed to AppMain(). The<br />    /// "conf" argument has the following special meanings:<br />    ///  - NULL      -- don't even try to load the registry from any<br />    ///                 file at all;<br />    ///  - non-empty -- if "conf" contains a path, then try to load<br />    ///                 from theconf.file of name "conf" (only!). Else -<br />    ///                 see NOTE.<br />    ///                 TIP: if the path is not fully qualified then:<br />    ///                      if it starts from "../" or "./" -- look<br />    ///                      starting from the current working dir.<br />    ///  - empty     -- compose conf.file name from the application<br />    ///                 name plus ".ini". If it does not match an existing<br />    ///                 file, then try to strip file extensions, e.g., for<br />    ///                 "my_app.cgi.exe" -- try subsequently:<br />    ///                 "my_app.cgi.exe.ini", "my_app.cgi.ini",<br />    ///                 "my_app.ini".<br />    ///<br />    /// NOTE:<br />    /// If "conf" arg is empty or non-empty, but without path, then<br />    /// config file will be sought for in the following order:<br />    ///  - in the current work directory;<br />    ///  - in the dir defined by environment variable "NCBI";<br />    ///  - in the user home directory;<br />    ///  - in the program dir.<br />    ///<br />    /// Throw an exception if "conf" is non-empty, and cannot open<br />    /// file.<br />    /// Throw an exception if file exists, but contains invalid entries.<br />    /// @param reg<br />    ///   The loaded registry is returned via the reg parameter.<br />    /// @param conf<br />    ///   The configuration file to loaded the registry entries from.<br />    /// @return<br />    ///   TRUE only if the file was non-NULL, found and successfully<br />    ///   read.<br />   virtual bool LoadConfig(CNcbiRegistry&amp; reg, const string* conf);<br />   .............<br />};</span></pre><p>The <span class="nctnt ncbi-func">AppMain() </span>function is also inherited from the parent class. Although this function accepts up to six arguments, this example passes only the first two, with missing values supplied by defaults. The remaining four arguments specify:</p><ul><li><p>(#3) a NULL-terminated array of '\0'-terminated character strings from which the environment variables can be read</p></li><li><p>(#4) how to setup a diagnostic stream for message posting</p></li><li><p>(#5) the name of a <span class="nctnt ncbi-path">.ini</span> configuration file (see <a href="ch_core.html#ch_core.CNcbiRegistry">above</a> for its default location)</p></li><li><p>(#6) a program name (to be used in lieu of <span class="nctnt ncbi-var">argv[0]</span>)</p></li></ul><p><span class="nctnt ncbi-func">AppMain() </span>begins by resetting the internal data members with the actual values provided by the arguments of <span class="nctnt ncbi-func">main()</span>. Once these internal data structures have been loaded, <span class="nctnt ncbi-func">AppMain() </span>calls the virtual functions <span class="nctnt ncbi-func">Init(), Run(), </span>and <span class="nctnt ncbi-func">Exit() </span>in succession to execute the application.</p><p>The <span class="nctnt ncbi-func">Init() </span>and <span class="nctnt ncbi-func">Exit()</span> virtual functions are provided as places for developers to add their own methods for specific applications. If your application does not require additional initialization/termination, these two functions can be left empty or simply not implemented. The <span class="nctnt ncbi-func">Run()</span> method carries out the main work of the application.</p><p>The <span class="nctnt ncbi-func">FlushDiag()</span> method is useful if the diagnostic stream has been set to <span class="nctnt ncbi-code">eDS_toMemory</span>, which means that diagnostic messages are stored in an internal application memory buffer. You can then call <span class="nctnt ncbi-func">FlushDiag()</span> to output the stored messages on the specified output stream. The method will also return the number of bytes written to the output stream. If you specify <span class="nctnt ncbi-macro">NULL</span> for the output stream, the memory buffers containing the diagnostic messages will be purged but not deallocated, and nothing will be written to the output. If the <span class="nctnt ncbi-var">close_diag</span> parameter to <span class="nctnt ncbi-func">FlushDiag()</span> is set to true, then the memory buffers will be deallocated (and purged, of course).</p><p>The <span class="nctnt ncbi-func">GetProgramDisplayName()</span> method simply returns the name of the running application, suitable for displaying in reports or for using as the base name for building other related file names.</p><p>The protected virtual function <span class="nctnt ncbi-func">SetupDiag_AppSpecific()</span> can be redefined to set up error posting specific for your application. <span class="nctnt ncbi-func">SetupDiag_AppSpecific()</span> will be called inside <span class="nctnt ncbi-func">AppMain()</span> by default if the error posting has not been set up already. Also, if you pass <span class="nctnt ncbi-code">diag = eDS_AppSpecific</span> to <span class="nctnt ncbi-func">AppMain()</span>, then <span class="nctnt ncbi-func">SetupDiag_AppSpecific()</span> will be called for sure, regardless of the error posting setup that was active before the <span class="nctnt ncbi-func">AppMain()</span> call.</p><p>The protected virtual function <span class="nctnt ncbi-func">LoadConfig()</span> reads the program's <span class="nctnt ncbi-path">.ini </span>configuration file to load the application's parameters into the registry. The default implementation of <span class="nctnt ncbi-func">LoadConfig()</span> expects to find a configuration file named <span class="nctnt ncbi-path">&lt;program_name&gt;.ini</span> and, if the <span class="nctnt ncbi-var">DIAG_POST_LEVEL</span> environment variable is set to "Info", it will generate a diagnostics message if no such file is found.</p><p>The NCBI application (built by deriving from <span class="nctnt ncbi-class">CNcbiApplication</span>) throws the exception <span class="nctnt ncbi-class">CAppException</span> when any of the following conditions are true:</p><ul><li><p>Command-line argument description cannot be found and argument descriptions have not been disabled (via call to protected method <span class="nctnt ncbi-func">DisableArgDescription()</span>.</p></li><li><p>Application diagnostic stream setup has failed.</p></li><li><p>Registry data failed to load from a specified configuration file.</p></li><li><p>An attempt is made to create a second instance of the <span class="nctnt ncbi-class">CNcbiApplication</span> (at any time, only one instance can be running).</p></li><li><p>The specified configuration file cannot be opened.</p></li></ul><p>As shown above, source files that utilize the <span class="nctnt ncbi-class">CNcbiApplication</span> class must <span class="nctnt ncbi-code">#include</span> the header file where that class is defined, <span class="nctnt ncbi-path">corelib/ncbiapp.hpp</span>, in the <span class="nctnt ncbi-path">include/</span> directory. This header file in turn includes <span class="nctnt ncbi-path">corelib/ncbistd.hpp</span>, which should <b>always</b> be <span class="nctnt ncbi-code">#include</span>'d.</p></div></div><div class="sec" id="ch_core.cmd_line_args"><h2><span class="title">Processing Command-Line Arguments</span></h2><p>This section discusses the classes that are used to process command-line arguments. A conceptual overview of these classes is covered in an <a href="ch_intro.html#ch_intro.intro_args">introductory section</a>. This section discusses these classes in detail and gives sample programs that use these classes.</p><p>This section discusses the following topics:</p><ul><li><p><a href="ch_core.html#ch_core.cmd_line_APIs">Capabilities of the Command-Line API</a></p></li><li><p><a href="ch_core.html#ch_core.arg_classes">The Relationships between the CArgDescriptions, CArgs, and CArgValue Classes</a></p></li><li><p><a href="ch_core.html#ch_core.cmd_line_syntax">Command-Line Syntax</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions">The CArgDescriptions Class</a></p></li><li><p><a href="ch_core.html#ch_core.CArgs">The CArgs Class: A Container Class for CArgValue Objects</a></p></li><li><p><a href="ch_core.html#ch_core.CArgValue">CArgValue Class: The Internal Representation of Argument Values</a></p></li><li><p><a href="ch_core.html#ch_core.Supporting_CommandBased_Command">Supporting Command-Based Command Lines</a></p></li><li><p><a href="ch_core.html#ch_core.arg_code_example">Code Examples</a></p></li></ul><div class="sec" id="ch_core.cmd_line_APIs"><h3><span class="title">Capabilities of the Command-Line API</span></h3><p>The set of classes for argument processing implement automated command line parsing. Specifically, these classes allow the developer to:</p><ul><li><p>Specify attributes of expected arguments, such as name, synopsis, comment, data type, etc.</p></li><li><p>validate values of the arguments passed to the program against these specifications</p></li><li><p>validate the number of positional arguments in the command line</p></li><li><p>generate a <a href="ch_core.html#ch_core.CArgDescriptions_Usage">USAGE</a> message based on the argument descriptions</p></li></ul><p><span class="nctnt highlight">NOTE:</span><span class="nctnt ncbi-cmd"> -h</span> flag to print the <a href="ch_core.html#ch_core.CArgDescriptions_Usage">USAGE</a> is defined by default.</p><ul><li><p>access the input argument values specifically typecast according to their descriptions</p></li></ul><p>Normally, a <span class="nctnt ncbi-class">CArgDescriptions</span> object that contains the argument description is required and <a href="ch_core.html#ch_core.CArgDescriptions_App">should be created</a> in the application's <span class="nctnt ncbi-func">Init()</span> function before any other initialization. Otherwise, <span class="nctnt ncbi-class">CNcbiApplication</span> creates a default one, which allows any program that uses the NCBI C++ Toolkit to provide some <span class="nctnt ncbi-monospace">standard</span> command -line options, namely:</p><ul><li><p>to obtain a general description of the program as well as description of all available command-line parameters (<span class="nctnt ncbi-cmd">-h</span> flag)</p></li><li><p>to redirect the program's <a href="ch_core.html#ch_core.diag">diagnostic messages</a> into a specified file (<span class="nctnt ncbi-cmd">-logfile</span> key)</p></li><li><p>to read the program's <a href="ch_core.html#ch_core.registry">configuration data</a> from a specified file (<span class="nctnt ncbi-cmd">-conffile</span> key)</p></li></ul><p>See <a href="ch_core.html#ch_core.T3">Table 3</a> for the standard command-line options for the default instance of <span class="nctnt ncbi-class">CArgDescriptions</span>.</p><div class="table" id="ch_core.T3"><div class="caption"><p>Table 3. Standard command-line options for the default instance of CArgDescriptions</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Flag</th><th align="left" valign="top" rowspan="1" colspan="1">Description</th><th align="left" valign="top" rowspan="1" colspan="1">Example</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-h</td><td align="left" valign="top" rowspan="1" colspan="1">Print description of the application's command-line parameters.</td><td align="left" valign="top" rowspan="1" colspan="1">theapp -h</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-logfile</td><td align="left" valign="top" rowspan="1" colspan="1">Redirect program's log into the specified file.</td><td align="left" valign="top" rowspan="1" colspan="1">theapp -logfile theapp_log</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">-conffile</td><td align="left" valign="top" rowspan="1" colspan="1">Read the program's configuration data from the specified file.</td><td align="left" valign="top" rowspan="1" colspan="1">theapp -conffile theapp_cfg</td></tr></tbody></table></div><p>To avoid creation of a default <span class="nctnt ncbi-class">CArgDescriptions</span> object that may not be needed, for instance if the standard flags described in <a href="ch_core.html#ch_core.T3">Table 3</a> are not used, one should call the <span class="nctnt ncbi-func">CNcbiApplication::DisableArgDescriptions()</span> function from an application object constructor.</p><p>It is also possible to use the <span class="nctnt ncbi-func">CNcbiApplication::HideStdArgs(THideStdArgs hide_mask)</span> method to hide description of the standard arguments (<span class="nctnt ncbi-cmd">-h, -logfile, -conffile</span>) in the <a href="ch_core.html#ch_core.CArgDescriptions_Usage">USAGE</a> message. Please note: This only hides the description of these flags; it is still possible to use them.</p></div><div class="sec" id="ch_core.arg_classes"><h3><span class="title">The Relationships between the <span class="nctnt ncbi-class">CArgDescriptions</span>, <span class="nctnt ncbi-class">CArgs</span>, and <span class="nctnt ncbi-class">CArgValue</span> Classes</span></h3><p>The <a href="ch_core.html#ch_core.CArgDescriptions">CArgDescriptions</a> class provides an interface to describe the data type and attributes of command-line arguments via a set of <span class="nctnt ncbi-class">AddXxx()</span> methods. Additional constraints on the argument values can be imposed using the <span class="nctnt ncbi-class">SetConstraint()</span> method. The <span class="nctnt ncbi-class">CreateArgs() </span>method is passed the values of all command-line arguments at runtime. This method verifies their overall syntactic structure and matches their values against the stored descriptions. If the arguments are parsed successfully, a new <a href="ch_core.html#ch_core.CArgs">CArgs</a> object is returned by <span class="nctnt ncbi-class">CreateArgs()</span>.</p><p>The resulting <a href="ch_core.html#ch_core.CArgs">CArgs</a> object will contain parsed, verified, and ready-to-use argument values, which are stored as <a href="ch_core.html#ch_core.CArgValue">CArgValue</a>. The value of a particular argument can be accessed using the argument's name (as specified in the <a href="ch_core.html#ch_core.CArgDescriptions">CArgDescriptions</a> object), and the returned <a href="ch_core.html#ch_core.CArgValue">CArgValue</a> object can then be safely type-cast to a correct C++ type (<span class="nctnt ncbi-type">int</span>, <span class="nctnt ncbi-type">string</span>, <span class="nctnt ncbi-type">stream</span>, etc.) because the argument types have been verified. These class relations and methods can be summarized schematically as shown in <a href="ch_core.html#ch_core.F1">Figure 1</a>.</p><div class="figure" id="ch_core.F1"><div class="graphic"><img src="img/flow.gif" alt="Figure 1. Argument processing class relations." /></div><div class="caption"><p>Figure 1. Argument processing class relations.</p></div></div><p>The last statement in this example implicitly references a <a href="ch_core.html#ch_core.CArgValue">CArgValue</a> object, in the value returned when the <span class="nctnt ncbi-code">[ ] </span>operator is applied to <span class="nctnt ncbi-var">myArgs</span>. The method <span class="nctnt ncbi-func">CArgValue::AsDouble() </span>is then applied to this object to retrieve a <span class="nctnt ncbi-type">double</span>.</p></div><div class="sec" id="ch_core.cmd_line_syntax"><h3><span class="title">Command-Line Syntax</span></h3><p><span class="nctnt highlight">Note:</span> The C++ Toolkit supports two types of command line: "command-based" and "command-less". A "command-based" command line begins with a "command" (a case-sensitive keyword), typically followed by other arguments. A "command-less" command line doesn't contain such "commands".</p><p>This section deals primarily with command-less command lines, while the <a href="ch_core.html#ch_core.Supporting_CommandBased_Command">Supporting Command-Based Command Lines</a> section covers command-based command lines.</p><p>Command-less command-line arguments fit the following profile:</p><pre><span class="nctnt-pre ncbi-cmd">progname {arg_key, arg_key_opt, arg_key_dflt, arg_flag} [--]<br />         {arg_pos} {arg_pos_opt, arg_pos_dflt}<br />         {arg_extra} {arg_extra_opt}</span></pre><p>where:</p><div class="table" id="ch_core.T.nc_arg_keykey_value__mandatory"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1">arg_key</td><td align="left" valign="top" rowspan="1" colspan="1">-&lt;key&gt; &lt;value&gt; -- (mandatory)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">arg_key_opt</td><td align="left" valign="top" rowspan="1" colspan="1">[-&lt;key&gt; &lt;value&gt;] -- (optional, without default value)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">arg_key_dflt</td><td align="left" valign="top" rowspan="1" colspan="1">[-&lt;key&gt; &lt;value&gt;] -- (optional, with default value)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">arg_flag</td><td align="left" valign="top" rowspan="1" colspan="1">-&lt;flag&gt; -- (always optional)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">--</td><td align="left" valign="top" rowspan="1" colspan="1">optional delimiter to indicate the beginning of pos. args</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">arg_pos</td><td align="left" valign="top" rowspan="1" colspan="1">&lt;value&gt; -- (mandatory)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">arg_pos_opt</td><td align="left" valign="top" rowspan="1" colspan="1">[&lt;value&gt;] -- (optional, without default value)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">arg_pos_dflt</td><td align="left" valign="top" rowspan="1" colspan="1">[&lt;value&gt;] -- (optional, with default value)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">arg_extra</td><td align="left" valign="top" rowspan="1" colspan="1">&lt;value&gt; -- (dep. on the constraint policy)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">arg_extra_opt</td><td align="left" valign="top" rowspan="1" colspan="1">[&lt;value&gt;] -- (dep. on the constraint policy)</td></tr></tbody></table></div><p>and: <span class="nctnt ncbi-cmd">&lt;key&gt;</span> must be followed by <span class="nctnt ncbi-cmd">&lt;value&gt;</span>. In all cases '<span class="nctnt ncbi-cmd">-&lt;key&gt; &lt;value&gt;</span>' is equivalent to '<span class="nctnt ncbi-cmd">-&lt;key&gt;=&lt;value&gt;</span>'. If '=' is used as separator, the value can be empty ('<span class="nctnt ncbi-cmd">-&lt;key&gt;=</span>'). For arguments with a single-char name <span class="nctnt ncbi-monospace">fOptionalSeparator</span> flag can be set. In this case the value can be specified without any separator: <span class="nctnt ncbi-cmd">-&lt;k&gt;&lt;value&gt;</span></p><p><span class="nctnt highlight">NOTE:</span> No other argument's name can start with the same character to avoid conflicts. <span class="nctnt ncbi-cmd">&lt;flag&gt;</span> and <span class="nctnt ncbi-cmd">&lt;key&gt;</span> are case-sensitive, and they can contain only alphanumeric characters and dash ('-'). Only one leading dash is allowed. The leading dash can be used to create arguments which look like <span class="nctnt ncbi-cmd">--&lt;key&gt;</span> in the command line. <span class="nctnt ncbi-cmd">&lt;value&gt;</span> is an arbitrary string (additional constraints can be applied in the argument description, see "EType"). {arg_pos***} and {arg_extra***} are position-dependent arguments, with no tag preceding them. {arg_pos***} arguments have individual names and descriptions (see methods <span class="nctnt ncbi-func">AddPositional</span>***). {arg_extra***} arguments have one description for all (see method <span class="nctnt ncbi-func">AddExtra</span>). User can apply constraints on the number of mandatory and optional {arg_extra***} arguments.</p><p>Examples of command-less command lines:</p><pre><span class="nctnt-pre ncbi-cmd">MyProgram1 -reverse -depth 5 -name Lisa -log foo.log 1.c 2.c 3.c<br />MyProgram2 -i foo.txt -o foo.html -color red<br />MyProgram3 -a -quiet -pattern 'Error:' bar.txt<br />MyProgram4 -int-value=5 -str-value= -kValue</span></pre><p>The <a href="ch_core.html#ch_core.Supporting_CommandBased_Command">Supporting Command-Based Command Lines</a> section addresses how to support command-based command lines, such as:</p><pre><span class="nctnt-pre ncbi-cmd">svn diff myapp.cpp<br />svn checkin -m "message" myapp.cpp</span></pre></div><div class="sec" id="ch_core.CArgDescriptions"><h3><span class="title">The <span class="nctnt ncbi-class">CArgDescriptions</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">*</a>) class</span></h3><p><span class="nctnt ncbi-class">CArgDescriptions</span> contains a description of unparsed arguments, that is, user-specified descriptions that are then used to parse the arguments. <span class="nctnt ncbi-class">CArgDescriptions</span> is used as a container to store the command-line argument descriptions. The argument descriptions are used for parsing and verifying actual command-line arguments.</p><p>The following is a list of topics discussed in this section:</p><ul><li><p><a href="ch_core.html#ch_core.argdescr.CArgDescriptions_Cons">The CArgDescriptions Constructor</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_Attr">Describing Argument Attributes</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_Types">Argument Types</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_StdValueTypes">Restricting the Input Argument Values</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_UserValueTypes">Implementing User-defined Restrictions Using the CArgAllow Class</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_App">Using CArgDescriptions in Applications</a></p></li><li><p><a href="ch_core.html#ch_core.CArgDescriptions_Usage">Generating a USAGE Message</a></p></li></ul><div class="sec" id="ch_core.argdescr.CArgDescriptions_Cons"><h4><span class="title">The CArgDescriptions Constructor</span></h4><p>The constructor for <span class="nctnt ncbi-class">CArgDescriptions</span> accepts a Boolean argument, auto_help, set to TRUE by default.</p><p><span class="nctnt ncbi-code">CArgDescriptions(bool auto_help = true);</span></p><p>If "auto_help" is passed TRUE, then a special flag "-h" will be added to the list of accepted arguments, and passing "-h" in the command line will print out USAGE and ignore all other passed arguments.</p></div><div class="sec" id="ch_core.CArgDescriptions_Attr"><h4><span class="title">Describing Argument Attributes</span></h4><p><span class="nctnt ncbi-class">CNcbiArguments</span> contains many methods, called <span class="nctnt ncbi-func">AddXxx()</span>. The "Xxx" refers to the types of arguments, such as mandatory key (named) arguments, optional key arguments, positional arguments, flag arguments, etc. For example, the <span class="nctnt ncbi-func">AddKey()</span> method refers to adding a description for a mandatory key argument.</p><p>The methods for <span class="nctnt ncbi-func">AddXxx()</span> are passed the following argument attributes:</p><ul><li><p><i>name</i>, the string that will be used to identify the variable, as in: <span class="nctnt ncbi-var">CArgs[name]</span>. For all tagged variables in a command line, <i>name</i> is also the key (or flag) to be used there, as in: "<span class="nctnt ncbi-cmd">-name value</span>" (or "<span class="nctnt ncbi-cmd">-name"</span>).</p></li><li><p><i>synopsis</i>, for <span class="nctnt ncbi-type">key_***</span> arguments only. The automatically generated <a href="ch_core.html#ch_core.CArgDescriptions_Usage">USAGE</a> message includes an argument description in the format: <i>-name [synopsis] &lt;type, constraint&gt;</i> comment.</p></li><li><p><i>comment</i>, to be displayed in the <a href="ch_core.html#ch_core.CArgDescriptions_Usage">USAGE</a> message, as described above.</p></li><li><p><i>value type</i>, one of the scalar values defined in the <a href="ch_core.html#ch_core.CArgDescriptions_StdValueTypes">EType</a> enumeration, which defines the type of the argument.</p></li><li><p><i>default,</i> for <span class="nctnt ncbi-type">key_dflt</span> and <span class="nctnt ncbi-type">pos_dflt</span> arguments only. A default value to be used if the argument is not included in the command line (only available for optional program arguments).</p></li><li><p><i>flags</i>, the <span class="nctnt ncbi-monospace">flags</span> argument, to provide additional control of the arguments' behavior.</p></li></ul></div><div class="sec" id="ch_core.CArgDescriptions_Types"><h4><span class="title">Argument Types</span></h4><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">CArgDescriptions</a> class enables registration of command-line arguments that fit one of the following pattern types:</p><p><b>Mandatory named arguments:</b><span class="nctnt ncbi-cmd">-&lt;key&gt; &lt;value&gt;</span> (example: <span class="nctnt ncbi-cmd">-age 31</span>) Position-independent arguments that <b>must</b> be present in the command line. <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">AddKey (key, synopsis, comment, value_type, flags)</a></p><p><b>Optional named arguments:</b><span class="nctnt ncbi-cmd">[-&lt;key&gt; &lt;value&gt;]</span> (example: <span class="nctnt ncbi-cmd">-name Lisa</span>) Position-independent arguments that are <b>optional</b>. <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">AddOptionalKey (key, synopsis, comment, value_type, flags)</a> A default value can be specified in the argument's description to cover those cases where the argument does not occur in the command line<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">. AddDefaultKey (key, synopsis, comment, value_type, default_value, flags)</a></p><p><b>Optional named flags:</b><span class="nctnt ncbi-cmd">[-&lt;flag&gt;]</span> (example: <span class="nctnt ncbi-type">-reverse</span>) Position-independent boolean (without value) arguments. These arguments are <b>always</b> optional. <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">AddFlag (flag, comment, set_value)</a></p><p><b>Mandatory named positional arguments:</b><span class="nctnt ncbi-cmd">&lt;value&gt;</span> (example: <span class="nctnt ncbi-cmd">12 Feb</span>) These are position-<span class="nctnt ncbi-monospace">dependent</span> arguments (of any type), which are read using a <span class="nctnt ncbi-cmd">value</span> only. They do, however, have names stored with their descriptions, which they are associated with in an order-dependent fashion. Specifically, the order in which untagged argument descriptions are added to the <span class="nctnt ncbi-class">CArgDescriptions</span> object using <span class="nctnt ncbi-func">AddPositional()</span> defines the order in which these arguments should appear in the command line. <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">AddPositional (key, comment, value_type, flags)</a></p><p><b>Optional named positional arguments:</b><span class="nctnt ncbi-cmd">[value]</span> (example: <span class="nctnt ncbi-cmd">foo.txt bar</span>) Position-<span class="nctnt ncbi-monospace">dependent</span> arguments that are <span class="nctnt ncbi-monospace">optional</span>. They always go after the <span class="nctnt ncbi-monospace">mandatory</span> positional arguments. The order in which untagged argument descriptions are added to the <span class="nctnt ncbi-class">CArgDescriptions</span> object using <span class="nctnt ncbi-func">Add[Optional|Default]Positional()</span> defines the order in which these arguments should appear in the command line. <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">AddOptionalPositional (key, comment, value_type, flags)</a><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">AddDefaultPositional (key, comment, value_type, default_value, flags)</a></p><p><b>Unnamed positional arguments</b> (all of the same type: <span class="nctnt ncbi-cmd">&lt;value1&gt; | [valueN]</span> (example: <span class="nctnt ncbi-cmd">foo.c bar.c xxx.c</span>). These are also position-<span class="nctnt ncbi-monospace">dependent</span> arguments that are read using a <span class="nctnt ncbi-cmd">value</span> only. They are expected to appear at the very end of the command line, after all named arguments. Unlike the previous argument type, however, these arguments do not have individual, named descriptions but share a single "unnamed" description. You can specify how many mandatory and how many optional arguments to expect using <span class="nctnt ncbi-var">n_mandatory</span> and <span class="nctnt ncbi-var">n_optional</span> parameters: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">AddExtra (n_mandatory, n_optional, comment, type, flags)</a></p><p><b>Aliases</b> can be created for any arguments. They allow using an alternative argument name in the command line. However, only the original argument name can be used to access its value in the C++ code.</p><p>Any of the registered descriptions can be tested for existence and/or deleted using the following <span class="nctnt ncbi-class">CArgDescriptions</span> methods:</p><pre><span class="nctnt-pre ncbi-code">bool Exist(const string&amp; name) const;<br />void Delete(const string&amp; name);</span></pre><p>These methods can also be applied to the unnamed positional arguments (as a <span class="nctnt ncbi-cmd">group</span>), using: <span class="nctnt ncbi-code">Exist(kEmptyStr)</span> and <span class="nctnt ncbi-code">Delete(kEmptyStr).</span></p></div><div class="sec" id="ch_core.CArgDescriptions_StdValueTypes"><h4><span class="title">Restricting the Input Argument Values</span></h4><p>Although each argument's input value is initially loaded as a simple character string, the argument's specified type implies a restricted set of possible values. For example, if the type is <span class="nctnt ncbi-var">eInteger</span>, then any integer value is acceptable, but floating point and non-numerical values are not. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">EType</a> enumeration quantifies the allowed types and is defined as:</p><pre><span class="nctnt-pre ncbi-code">/// Available argument types.<br />enum EType {<br />    eString = 0, ///&lt; An arbitrary string<br />    eBoolean,    ///&lt; {'true', 't', 'false', 'f'},  case-insensitive<br />    eInteger,    ///&lt; Convertible into an integer number (int)<br />    eDouble,     ///&lt; Convertible into a floating point number (double)<br />    eInputFile,  ///&lt; Name of file (must exist and be readable)<br />    eOutputFile, ///&lt; Name of file (must be writeable)<br />    k_EType_Size ///&lt; For internal use only<br />};</span></pre></div><div class="sec" id="ch_core.CArgDescriptions_UserValueTypes"><h4><span class="title">Implementing User-defined Restrictions Using the <span class="nctnt ncbi-class">CArgAllow</span> Class</span></h4><p>It may be necessary to specify a restricted range for argument values. For example, an integer argument that has a range between 5 and 10. Further restrictions on the allowed values can be specified using the <span class="nctnt ncbi-func">CArgDescriptions::SetConstraint()</span> method with the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgAllow.html">CArgAllow</a> class. For example:</p><pre><span class="nctnt-pre ncbi-code">auto_ptr&lt;CArgDescriptions&gt; args(new CArgDescriptions);<br />// add descriptions for "firstint" and "nextint" using AddXxx( ...)<br />...<br />CArgAllow* constraint = new CArgAllow_Integers(5,10);<br />args-&gt;SetConstraint("firstInt", constraint);<br />args-&gt;SetConstraint("nextInt", constraint);</span></pre><p>This specifies that the arguments named <span class="nctnt ncbi-cmd">"firstInt"</span> and <span class="nctnt ncbi-cmd">"nextInt"</span> must both be in the range [5, 10].</p><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgAllow__Integers.html">CArgAllow_Integers</a> class is derived from the <b>abstract</b><span class="nctnt ncbi-class">CArgAllow</span> class. The constructor takes the two integer arguments as lower and upper bounds for allowed values. Similarly, the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgAllow__Doubles.html">CArgAllow_Doubles</a> class can be used to specify a range of allowed floating point values. For both classes, the order of the numeric arguments does not matter, because the constructors will use min/max comparisons to generate a valid range.</p><p>A third class derived from the <span class="nctnt ncbi-class">CArgAllow</span> class is the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgAllow__Strings.html">CArgAllow_Strings</a> class. In this case, the set of allowed values cannot be specified by a <span class="nctnt ncbi-class">range</span>, but the following construct can be used to enumerate all eligible string values:</p><pre><span class="nctnt-pre ncbi-code">CArgAllow* constraint = (new CArgAllow_Strings())-&gt;<br />                             Allow("this)-&gt;Allow("that")-&gt;Allow("etc");<br />args.SetConstraint("someString", constraint);</span></pre><p>Here, the constructor takes no arguments, and the <span class="nctnt ncbi-func">Allow() </span>method returns <span class="nctnt ncbi-var">this</span>. Thus, a list of allowed strings can be specified by daisy-chaining a set of calls to <span class="nctnt ncbi-func">Allow()</span>. A bit unusual yet terser notation can also be used by engaging the comma operator, as in:</p><pre><span class="nctnt-pre ncbi-code">args.SetConstraint("someString",<br />                   &amp;(*new CArgAllow_Strings, "this", "that", "etc"));</span></pre><p>There are two other pre-defined constraint classes: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgAllow__Symbols.html">CArgAllow_Symbols</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgAllow__String.html">CArgAllow_String</a>. If the value provided on the command line is not in the allowed set of values specified for that argument, then an exception will be generated. This exception can be caught and handled in the usual manner, as described in the discussion of <a href="ch_core.html#ch_core.CArgDescriptions_Usage">Generating a USAGE message.</a></p></div><div class="sec" id="ch_core.CArgDescriptions_App"><h4><span class="title">Using <span class="nctnt ncbi-class">CArgDescriptions</span> in Applications</span></h4><p>The description of program arguments should be provided in the application's <span class="nctnt ncbi-func">Init()</span> function before any other initialization. A good idea is also to specify the description of the program here:</p><pre><span class="nctnt-pre ncbi-code">auto_ptr&lt;CArgDescriptions&gt; arg_desc(new CArgDescriptions);<br />arg_desc-&gt;SetUsageContext(GetArguments().GetProgramBasename(),<br />                          "program's description here");<br />// Define arguments, if any<br />...<br />SetupArgDescriptions(arg_desc.release());</span></pre><p>The <span class="nctnt ncbi-func">SetUsageContext()</span> method is used to define the name of the program and its description, which is to be displayed in the <span class="nctnt ncbi-monospace">USAGE</span> message. As long as the initialization of the application is completed and there is still no argument description, <span class="nctnt ncbi-class">CNcbiApplication</span> class provides a "default" one. This behavior can be overridden by calling the <span class="nctnt ncbi-func">DisableArgDescriptions()</span> method of <span class="nctnt ncbi-path">CNcbiAppliation</span>.</p></div><div class="sec" id="ch_core.CArgDescriptions_Usage"><h4><span class="title">Generating a <span class="nctnt ncbi-monospace">USAGE </span>Message</span></h4><p>One of the functions of the <span class="nctnt ncbi-class">CArgDescriptions</span> object is to generate a <span class="nctnt ncbi-monospace">USAGE</span> message automatically (this gives yet another reason to define one). Once such object is <a href="ch_core.html#ch_core.CArgDescriptions_App">defined</a>, there is nothing else to worry about; <span class="nctnt ncbi-class">CNcbiApplication</span> will do the job for you. The <span class="nctnt ncbi-func">SetupArgDescriptions()</span> method includes parsing the command line and matching arguments against their descriptions. Should an error occur, e.g., a mandatory argument is missing, the program prints a message explaining what was wrong and terminates. The output in this case might look like this:</p><pre><span class="nctnt-pre ncbi-monospace">USAGE<br />  myApp -h -k MandatoryKey [optarg]<br />DESCRIPTION<br />   myApp test program<br />REQUIRED ARGUMENTS<br /> -k &lt;String&gt;<br />   This is a mandatory alpha-num key argument<br />OPTIONAL ARGUMENTS<br /> -h<br />   Print this USAGE message;  ignore other arguments<br /> optarg &lt;File_Out&gt;<br />   This is an optional named positional argument without default<br />   value</span></pre><p>The message shows a description of the program and a summary of each argument. In this example, the description of the input file argument was defined as:</p><pre><span class="nctnt-pre ncbi-code">arg_desc-&gt;AddKey( "k", "MandatoryKey",<br />                  "This is a mandatory alpha-num key argument",<br />                  CArgDescriptions::eString);</span></pre><p>The information generated for each argument is displayed in the format:</p><blockquote id="idp18463856"><p><i>me [synopsis] &lt;type [, constraint] &gt; comment [default = .....]</i></p></blockquote><p>The arguments in the USAGE message can be arranged into groups by using <span class="nctnt ncbi-func">SetCurrentGroup()</span> method of the <span class="nctnt ncbi-class">CArgDescriptions</span> object.</p></div></div><div class="sec" id="ch_core.CArgs"><h3><span class="title">The CArgs (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgs.html">*</a>) Class: A Container Class for CArgValue (<a href="ch_core.html#ch_core.CArgValue">*</a>) Objects</span></h3><p>The <span class="nctnt ncbi-class">CArgs</span> class provides a data structure where the values of the parsed arguments can be stored and includes access routines in its public interface. Argument values are obtained from the unprocessed command-line arguments via the <span class="nctnt ncbi-class">CNcbiArguments</span> class and then verified and processed according to the argument descriptions defined by the user in <span class="nctnt ncbi-class">CArgDescriptions</span>. The following describes the public interface methods in <span class="nctnt ncbi-class">CArgs</span>:</p><pre><span class="nctnt-pre ncbi-code">class  CArgs<br />{<br />public:<br />    /// Constructor.<br />    CArgs(void);<br />    /// Destructor.<br />    ~CArgs(void);<br />    /// Check existence of argument description.<br />    ///<br />    /// Return TRUE if arg 'name' was described in the parent CArgDescriptions.<br />    bool Exist(const string&amp; name) const;<br />    /// Get value of argument by name.<br />    ///<br />    /// Throw an exception if such argument does not exist.<br />    /// @sa<br />    ///   Exist() above.<br />    const CArgValue&amp; operator[] (const string&amp; name) const;<br />    /// Get the number of unnamed positional (a.k.a. extra) args.<br />    size_t GetNExtra(void) const { return m_nExtra; }<br />    /// Return N-th extra arg value,  N = 1 to GetNExtra().<br />    const CArgValue&amp; operator[] (size_t idx) const;<br />    /// Print (append) all arguments to the string 'str' and return 'str'.<br />    string&amp; Print(string&amp; str) const;<br />    /// Add new argument name and value.<br />    ///<br />    /// Throw an exception if the 'name' is not an empty string, and if<br />    /// there is an argument with this name already.<br />    ///<br />    /// HINT: Use empty 'name' to add extra (unnamed) args, and they will be<br />    /// automatically assigned with the virtual names: '#1', '#2', '#3', etc.<br />    void Add(CArgValue* arg);<br />    /// Check if there are no arguments in this container.<br />    bool IsEmpty(void) const;<br />};</span></pre><p>The CArgs object is created by executing the <span class="nctnt ncbi-func">CArgDescriptions::CreateArgs()</span> method. What happens when the <span class="nctnt ncbi-func">CArgDescriptions::CreateArgs()</span> method is executed is that the arguments of the command line are validated against the registered descriptions, and a <span class="nctnt ncbi-class">CArgs</span> object is created. Each argument value is internally represented as a <a href="ch_core.html#ch_core.CArgValue">CArgValue</a> object and is added to a container managed by the <span class="nctnt ncbi-class">CArgs</span> object.</p><p>All <span class="nctnt ncbi-monospace">named</span> arguments can be accessed using the <span class="nctnt ncbi-code">[ ]</span> operator, as in: <span class="nctnt ncbi-code">myCArgs["f"]</span>, where <span class="nctnt ncbi-monospace">"f"</span> is the name registered for that argument. There are two ways to access the <b>N</b>-th <span class="nctnt ncbi-monospace">unnamed</span> positional argument: <span class="nctnt ncbi-code">myCArgs["#N"]</span> and <span class="nctnt ncbi-code">myCArgs[N]</span>, where 1 &lt;= <b>N</b> &lt;= GetNExtra().</p></div><div class="sec" id="ch_core.CArgValue"><h3><span class="title"><span class="nctnt ncbi-class">CArgValue</span> (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgValue.html">*</a>) Class: The Internal Representation of Argument Values</span></h3><p>The internal representation of an argument value, as it is stored and retrieved from its <a href="ch_core.html#ch_core.CArgs">CArgs</a> container, is an instance of a <span class="nctnt ncbi-class">CArgValue</span>. The primary purpose of this class is to provide type-validated loading through a set of <span class="nctnt ncbi-func">AsXxx()</span> methods where "<span class="nctnt ncbi-func">Xxx</span>" is the argument type such as "Integer", "Boolean", "Double", etc. The following describes the public interface methods in <span class="nctnt ncbi-class">CArgValue</span>:</p><pre><span class="nctnt-pre ncbi-code">class  CArgValue : public CObject<br />{<br />public:<br />    /// Get argument name.<br />    const string&amp; GetName(void) const { return m_Name; }<br />    /// Check if argument holds a value.<br />    ///<br />    /// Argument does not hold value if it was described as optional argument<br />    /// without default value, and if it was not passed a value in the command<br />    /// line.  On attempt to retrieve the value from such "no-value" argument,<br />    /// exception will be thrown.<br />    virtual bool HasValue(void) const = 0;<br />    operator bool (void) const { return  HasValue(); }<br />    bool operator!(void) const { return !HasValue(); }<br />    /// Get the argument's string value.<br />    ///<br />    /// If it is a value of a flag argument, then return either "true"<br />    /// or "false".<br />    /// @sa<br />    ///   AsInteger(), AsDouble(), AsBoolean()<br />    virtual const string&amp; AsString(void) const = 0;<br />    /// Get the argument's integer value.<br />    ///<br />    /// If you request a wrong value type, such as a call to "AsInteger()"<br />    /// for a "boolean" argument, an exception is thrown.<br />    /// @sa<br />    ///   AsString(), AsDouble, AsBoolean()<br />    virtual int    AsInteger(void) const = 0;<br />    /// Get the argument's double value.<br />    ///<br />    /// If you request a wrong value type, such as a call to "AsDouble()"<br />    /// for a "boolean" argument, an exception is thrown.<br />    /// @sa<br />    ///   AsString(), AsInteger, AsBoolean()<br />    virtual double AsDouble (void) const = 0;<br />    /// Get the argument's boolean value.<br />    ///<br />    /// If you request a wrong value type, such as a call to "AsBoolean()"<br />    /// for a "integer" argument, an exception is thrown.<br />    /// @sa<br />    ///   AsString(), AsInteger, AsDouble()<br />    virtual bool   AsBoolean(void) const = 0;<br />    /// Get the argument as an input file stream.<br />    virtual CNcbiIstream&amp; AsInputFile (void) const = 0;<br />    /// Get the argument as an output file stream.<br />    virtual CNcbiOstream&amp; AsOutputFile(void) const = 0;<br />    /// Close the file.<br />    virtual void CloseFile (void) const = 0;<br />};</span></pre><p>Each of these <span class="nctnt ncbi-func">AsXxx()</span> methods will access the string storing the value of the requested argument and attempt to convert that string to the specified type, using for example, functions such as <span class="nctnt ncbi-func">atoi() </span>or <span class="nctnt ncbi-func">atof()</span>. Thus, the following construct can be used to obtain the value of a floating point argument named "f":</p><pre><span class="nctnt-pre ncbi-code">float f = args["f"].AsDouble();</span></pre><p>An exception will be generated with an appropriate error message, if:</p><ul><li><p>the conversion fails, or</p></li><li><p>"f" was described as an optional key or positional argument without default value (i.e., using the <span class="nctnt ncbi-func">AddOptional***()</span> method), and it was not defined in the command line. Note that you can check for this case using the <span class="nctnt ncbi-func">CArgValue::HasValue()</span> method.</p></li></ul></div><div class="sec" id="ch_core.Supporting_CommandBased_Command"><h3><span class="title">Supporting Command-Based Command Lines</span></h3><p>For some applications, multiple command-based command line forms are needed, with different arguments depending on the command. For example:</p><pre><span class="nctnt-pre ncbi-cmd">myapp list<br />myapp create &lt;queue&gt;<br />myapp post   &lt;queue&gt; [-imp importance] &lt;message&gt;<br />myapp query  [queue]</span></pre><p>Commands are case-sensitive keywords and are typically followed by other arguments. Programs that support command-based command lines can support any number of commands (each with its own set of supported arguments), and may optionally support a command-less command line in addition.</p><p>Command-based command lines have a requirement that command-less command lines don't - the ability to have optional arguments between mandatory arguments. Opening arguments address this requirement. Opening arguments are essentially identical to mandatory positional arguments except that opening arguments must precede optional arguments whereas mandatory positional arguments must follow them. Thus, opening arguments allow usage forms such as the "post" command in the above example, which has an optional argument between mandatory arguments.</p><p>At a high level, setting up a program to support a command-less command-line requires creating a <span class="nctnt ncbi-class">CArgDescriptions</span> object, adding argument descriptions to it, and passing it to <span class="nctnt ncbi-func">SetupArgDescriptions()</span>.</p><p>Setting up a program to support command-based command lines is similar, but requires a <span class="nctnt ncbi-class">CCommandArgDescriptions</span> object instead. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCCommandArgDescriptions.html">CCommandArgDescriptions</a> class is derived from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCArgDescriptions.html">CArgDescriptions</a>, so all the same functionality is available; however, the <span class="nctnt ncbi-func">AddCommand()</span> method of <span class="nctnt ncbi-class">CCommandArgDescriptions</span> allows you to create multiple <span class="nctnt ncbi-class">CArgDescriptions</span> objects (one for each command) in addition to the overall program description. Other command-specific features are also provided, such as command grouping. <span class="nctnt highlight">Note:</span> The <span class="nctnt ncbi-type">ECommandPresence</span> parameter of the <span class="nctnt ncbi-class">CCommandArgDescriptions</span> constructor controls whether or not the user must enter a command-based command line. Use <span class="nctnt ncbi-var">eCommandOptional</span> only when you are setting up both command-less and command-based command lines.</p><p>Programs that support command-based command lines must execute these steps:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Create a command descriptions object (class <span class="nctnt ncbi-class">CCommandArgDescriptions</span>) for the overall program description.</p></dd><dt>2</dt><dd><p class="no_top_margin">Create argument descriptions objects (class <span class="nctnt ncbi-class">CArgDescriptions</span>) for each command.</p></dd><dt>3</dt><dd><p class="no_top_margin">Add the actual argument descriptions to the argument descriptions objects using methods such as <span class="nctnt ncbi-func">AddOpening()</span>, <span class="nctnt ncbi-func">AddPositional()</span>, etc.</p></dd><dt>4</dt><dd><p class="no_top_margin">Add each argument descriptions object to the overall command descriptions object.</p></dd><dt>5</dt><dd><p class="no_top_margin">Determine which command was specified on the command line.</p></dd><dt>6</dt><dd><p class="no_top_margin">Process the appropriate arguments for the given command.</p></dd></dl><p>For a sample program that demonstrates argument processing for command-based command lines, see <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/basic/multi_command.cpp">multi_command.cpp</a>.</p><p>For more information on standard command lines and general information applicable to all command line processing, see the <a href="ch_core.html#ch_core.cmd_line_syntax">Command-Line Syntax</a> and <a href="ch_core.html#ch_core.CArgDescriptions">CArgDescriptions</a> sections.</p></div><div class="sec" id="ch_core.arg_code_example"><h3><span class="title">Code Examples</span></h3><p>A simple application program, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/corelib/test/test_ncbiargs_sample.cpp">test_ncbiargs_sample.cpp</a> demonstrates the usage of these classes for argument processing. See also <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/corelib/test/test_ncbiargs.cpp">test_ncbiargs.cpp</a> (especially <span class="nctnt ncbi-func">main()</span>, <span class="nctnt ncbi-func">s_InitTest0()</span> and <span class="nctnt ncbi-func">s_RunTest0()</span> there), and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/asn2asn/asn2asn.cpp">asn2asn.cpp</a> for more examples.</p></div></div><div class="sec" id="ch_core.namespace_concat"><h2><span class="title">Namespace, Name Concatenation, and Compiler-specific Macros</span></h2><p>The file <span class="nctnt ncbi-path">ncbistl.hpp</span> provides a number of macros on namespace usage, name concatenation, and macros for handling compiler-specific behavior.</p><p>These topics are discussed in greater detail in the following subsections:</p><ul><li><p><a href="ch_core.html#ch_core.ncbi_namespace">NCBI Namespace</a></p></li><li><p><a href="ch_core.html#ch_core.other_namespace_macros">Other Name Space Macros</a></p></li><li><p><a href="ch_core.html#ch_core.name_concat">Name Concatenation</a></p></li><li><p><a href="ch_core.html#ch_core.compiler_specific_macros">Compiler Specific Macros</a></p></li></ul><div class="sec" id="ch_core.ncbi_namespace"><h3><span class="title">NCBI Namespace</span></h3><p>All new NCBI classes must be in the <span class="nctnt ncbi-var">ncbi::</span> namespace to avoid naming conflicts with other libraries or code. Rather than enclose all newly defined code in the following, it is, from a stylistic point of view, better to use specially defined macros such as <span class="nctnt ncbi-macro">BEGIN_NCBI_SCOPE</span>, <span class="nctnt ncbi-macro">END_NCBI_SCOPE</span>, <span class="nctnt ncbi-macro">USING_NCBI_SCOPE</span>:</p><pre><span class="nctnt-pre ncbi-code">namespace ncbi {<br />    // Indented code etc.<br />}</span></pre><p>The use of <span class="nctnt ncbi-macro">BEGIN_NCBI_SCOPE</span>, <span class="nctnt ncbi-macro">END_NCBI_SCOPE</span>, and <span class="nctnt ncbi-macro">USING_NCBI_SCOPE</span> is discussed in <a href="ch_style.html#ch_style.using_NCBI_namespace">use of the NCBI name scope</a>.</p></div><div class="sec" id="ch_core.other_namespace_macros"><h3><span class="title">Other Namespace Macros</span></h3><p>The <span class="nctnt ncbi-macro">BEGIN_NCBI_SCOPE</span>, <span class="nctnt ncbi-macro">END_NCBI_SCOPE</span>, and <span class="nctnt ncbi-macro">USING_NCBI_SCOPE</span> macros in turn use the more general purpose <span class="nctnt ncbi-macro">BEGIN_SCOPE(ns)</span>, <span class="nctnt ncbi-macro">END_SCOPE(ns)</span>, and <span class="nctnt ncbi-macro">USING_SCOPE(ns)</span> macros, where the macro parameter <span class="nctnt ncbi-var">ns</span> is the namespace being defined. All NCBI-related code should be in the <span class="nctnt ncbi-var">ncbi::</span> namespace so the <span class="nctnt ncbi-macro">BEGIN_NCBI_SCOPE</span>, <span class="nctnt ncbi-macro">END_NCBI_SCOPE</span>, and <span class="nctnt ncbi-macro">USING_NCBI_SCOPE</span> should be adequate for new NCBI code. However, in those rare circumstances, if you need to define a new name scope, you can directly use the <span class="nctnt ncbi-macro">BEGIN_SCOPE(ns)</span>, <span class="nctnt ncbi-macro">END_SCOPE(ns)</span>, and <span class="nctnt ncbi-macro">USING_SCOPE(ns)</span> macros.</p></div><div class="sec" id="ch_core.name_concat"><h3><span class="title">Name Concatenation</span></h3><p>The macros <span class="nctnt ncbi-macro">NCBI_NAME2</span> and <span class="nctnt ncbi-macro">NCBI_NAME3</span> define concatenation of two and three names, respectively. These are used to build names for program-generated class, struct, or method names.</p></div><div class="sec" id="ch_core.compiler_specific_macros"><h3><span class="title">Compiler-specific Macros</span></h3><p>To cater to the idiosyncrasies of compilers that have non-standard behavior, certain macros are defined to normalize their behavior.</p><p>The <span class="nctnt ncbi-macro">BREAK(it)</span> macro advances the iterator to the end of the loop and then breaks out of the loop for the Sun WorkShop compiler with versions less than 5.3. This is done because this compiler fails to call destructors for objects created in for-loop initializers. This macro prevents trouble with iterators that contain CRefs by advancing them to the end using a while-loop, thus avoiding the "deletion of referenced CObject" errors. For other compilers, <span class="nctnt ncbi-macro">BREAK(it)</span> is defined as the keyword <span class="nctnt ncbi-code">break</span>.</p><p>The ICC compiler may fail to generate code preceded by <span class="nctnt ncbi-code">template&lt;&gt;</span>. In this case, use the macro <span class="nctnt ncbi-macro">EMPTY_TEMPLATE</span> instead, which expands to an empty string for the ICC compiler and to <span class="nctnt ncbi-code">template&lt;&gt;</span> for all other compilers.</p><p>For MSVC v6.0, the <span class="nctnt ncbi-code">for</span> keyword is defined as a macro to overcome a problem with for-loops in the compiler. The local variables in a for-loop initalization are visible outside the loop:</p><pre><span class="nctnt-pre ncbi-code">for (int i; i &lt; 10; ++i) {<br />// scope of i<br />}<br />// i should not be visible, but is visible in MSVC 6.0</span></pre><p>Another macro called <span class="nctnt ncbi-macro">NCBI_EAT_SEMICOLON</span> is used in creating new names that can allow a trailing semicolon without producing a compiler warning in some compilers.</p></div></div><div class="sec" id="ch_core.Configuration_Parame"><h2><span class="title">Configuration Parameters</span></h2><p>The <span class="nctnt ncbi-class">CParam</span> class is the preferred method for defining configuration parameters. This class enables storing parameters with per-object values, thread-wide defaults, and application-wide defaults. Global default values may be set through the application registry or the environment.</p><p>The following topics discuss using the <span class="nctnt ncbi-class">CParam</span> class.</p><ul><li><p><a href="ch_core.html#ch_core.General_Usage_Inform">General Usage Information</a></p></li><li><p><a href="ch_core.html#ch_core.Macros_for_Creating_">Macros for Creating Parameters</a></p></li><li><p><a href="ch_core.html#ch_core.Methods_for_Using_Pa">Methods for Using Parameters</a></p></li><li><p><a href="ch_core.html#ch_core.Supporting_Classes">Supporting Classes</a></p></li></ul><div class="sec" id="ch_core.General_Usage_Inform"><h3><span class="title">General Usage Information</span></h3><p>A <span class="nctnt ncbi-class">CParam</span> instance gets its initial value from one of three sources. If the application registry specifies a value, then that value will be used. Otherwise if the environment specifies a value, then that value will be used. Otherwise the default value supplied in the definition will be used. Later, the value can be changed <a href="ch_core.html#ch_core.Methods_for_Using_Pa">using various methods</a>.</p><p><span class="nctnt highlight">N.B.</span> statically defined instances of configuration parameters will be assigned their default values even if the environment and / or application registry specify (possibly different) values for them. This is because they are constructed (using their default value) at program startup and at that time the application framework for reading from the environment and application registry hasn't been set up yet. Therefore it is important to call the <span class="nctnt ncbi-func">Reset()</span> method for these parameters prior to reading their value. Alternatively, the <span class="nctnt ncbi-func">GetState()</span> method will indicate whether or not all possible sources were checked when a value was assigned to a configuration parameter - if they were, it will have either the value <span class="nctnt ncbi-var">eState_Config</span> or <span class="nctnt ncbi-var">eState_User</span>.</p><p>For more information on the application framework, the environment, and the application registry, see the sections on <a href="ch_core.html#ch_core.CNcbiApplication">CNcbiApplication</a>, <a href="ch_core.html#ch_core.CNcbiEnvironment">CNcbiEnvironment</a>, and <a href="ch_core.html#ch_core.registry">CNcbiRegistry</a>.</p><p>Be sure to include the header file in your source files:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;corelib/ncbi_param.hpp&gt;</span></pre><p>and include the NCBI core library in your makefile:</p><pre><span class="nctnt-pre ncbi-monospace">LIB = xncbi</span></pre></div><div class="sec" id="ch_core.Macros_for_Creating_"><h3><span class="title">Macros for Creating Parameters</span></h3><p>The <span class="nctnt ncbi-class">CParam</span> class is not designed to be used directly for creating configuration parameter variables. Instead, it supplies macros which your code should use. These macros have parameters for types, sections, names, default values, flags, and environment.</p><p>The <span class="nctnt ncbi-var">type</span> macro parameter must:</p><ul><li><p>be a <a href="http://en.wikipedia.org/wiki/Plain_old_data_structures">POD</a> type;</p></li><li><p>be initializable by the pre-processor from a literal;</p></li><li><p>be readable from and writable to streams.</p></li></ul><p>Typically, the <span class="nctnt ncbi-var">type</span> is a simple type such as string, bool, int, or enum, as these are most convenient for specifying parameter values.</p><p>The <span class="nctnt ncbi-var">section</span> macro parameter indicates which section of a configuration file the parameter should be located in.</p><p>The <span class="nctnt ncbi-var">name</span> macro parameter uniquely identifies the parameter within the section.</p><p>The <span class="nctnt ncbi-var">default_value</span> macro parameter provides the default value for the parameter - i.e. the value the parameter has from the time it is created until it is overwritten by a value from the environment, configuration file, or user code - and the value it is assigned by the <span class="nctnt ncbi-func">Reset()</span> method.</p><p>The <span class="nctnt ncbi-var">flags</span> macro parameter (a bitwise OR of enum values) can be used to control certain behavior options for the parameter. Currently, these enum values are:</p><div class="table" id="ch_core.T.nc_Enum_ValuePurposeeParam_Def"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Enum Value</th><th align="left" valign="top" rowspan="1" colspan="1">Purpose</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">eParam_Default</td><td align="left" valign="top" rowspan="1" colspan="1">Default flags</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">eParam_NoLoad</td><td align="left" valign="top" rowspan="1" colspan="1">Do not load from registry or environment</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">eParam_NoThread</td><td align="left" valign="top" rowspan="1" colspan="1">Do not use per-thread values</td></tr></tbody></table></div><p>See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ENcbiParamFlags&amp;d=">enum definition</a> for an up-to-date list.</p><p>The <span class="nctnt ncbi-var">env</span> macro parameter can be used to specify the environment variable to be searched. If the <span class="nctnt ncbi-var">env</span> macro parameter is not used, the environment will be searched for a variable having the form <span class="nctnt ncbi-macro">NCBI_CONFIG__&lt;section&gt;__&lt;name&gt;</span> (<span class="nctnt highlight">note:</span> the first underscore is single; the others are double).</p><p><span class="nctnt ncbi-class">CParam</span> instances must be declared and defined before use. A typedef may also be created.</p><p>To <i>declare</i> simple parameters, use the <span class="nctnt ncbi-macro">NCBI_PARAM_DECL</span> macro:</p><pre><span class="nctnt-pre ncbi-code">NCBI_PARAM_DECL(type, section, name);</span></pre><p>For example, declaring a host name parameter for a server might look like:</p><pre><span class="nctnt-pre ncbi-code">NCBI_PARAM_DECL(string, XyzSrv, Host);</span></pre><p>To declare an enum:</p><pre><span class="nctnt-pre ncbi-code">NCBI_PARAM_ENUM_DECL(type, section, name);</span></pre><p>Additional macros for parameter declarations include:</p><ul><li><p><span class="nctnt ncbi-macro">NCBI_PARAM_DECL_EXPORT</span> and <span class="nctnt ncbi-macro">NCBI_PARAM_ENUM_DECL_EXPORT</span> to include the EXPORT specifier (i.e. <span class="nctnt ncbi-macro">NCBI_XNCBI_EXPORT</span>). <span class="nctnt highlight">Note:</span> this form must be used if the parameter is defined in a header file and compiled into a library. Otherwise the linker may create several instances of the parameter which could contain different values.</p></li></ul><p>To <i>define</i> simple parameters, use the <span class="nctnt ncbi-macro">NCBI_PARAM_DEF</span> or <span class="nctnt ncbi-macro">NCBI_PARAM_DEF_EX</span> macro:</p><pre><span class="nctnt-pre ncbi-code">NCBI_PARAM_DEF(type, section, name, default_value); // OR<br />NCBI_PARAM_DEF_EX(type, section, name, default_value, flags, env);</span></pre><p>For example, an extended definition of a host name parameter for a server could look like:</p><pre><span class="nctnt-pre ncbi-code">NCBI_PARAM_DEF_EX(string, Xyz, Host, "xyz.nih.gov", eParam_NoThread, XYZ_HOST);</span></pre><p>To define an enum:</p><pre><span class="nctnt-pre ncbi-code">NCBI_PARAM_ENUM_ARRAY(type, section, name); // USE THIS AND EITHER:<br />NCBI_PARAM_ENUM_DEF(type, section, name, default_value); // OR:<br />NCBI_PARAM_ENUM_DEF_EX(type, section, name, default_value, flags, env);</span></pre><p>For example, an enum definition could look like:</p><pre><span class="nctnt-pre ncbi-code">NCBI_PARAM_ENUM_ARRAY(EMyEnum, MySection, MyEnumParam)<br />{<br />    {"My_A", eMyEnum_A},<br />    {"My_B", eMyEnum_B},<br />    {"My_C", eMyEnum_C},<br />};<br />NCBI_PARAM_ENUM_DEF(EMyEnum, MySection, MyEnumParam, eMyEnum_B);</span></pre><p>An additional macro for parameter definitions is:</p><ul><li><p><span class="nctnt ncbi-macro">NCBI_PARAM_DEF_IN_SCOPE</span> to define the parameter within a scope.</p></li></ul><p>Another way to conveniently use a configuration parameter is to use the <span class="nctnt ncbi-macro">NCBI_PARAM_TYPE</span> macro to create an instance of a type. The following example illustrates the declaration, definition, typedef, and use of a configuration parameter:</p><pre><span class="nctnt-pre ncbi-code">NCBI_PARAM_DECL(bool, NCBI, ABORT_ON_COBJECT_THROW);<br />NCBI_PARAM_DEF_EX(bool, NCBI, ABORT_ON_COBJECT_THROW, false,<br />                  eParam_NoThread, NCBI_ABORT_ON_COBJECT_THROW);<br />typedef NCBI_PARAM_TYPE(NCBI, ABORT_ON_COBJECT_THROW) TAbortOnCObectThrow;<br /><br />void CObjectException::x_InitErrCode(CException::EErrCode err_code)<br />{<br />    CCoreException::x_InitErrCode(err_code);<br />    static TAbortOnCObectThrow sx_abort_on_throw;<br />    if ( sx_abort_on_throw.Get() ) {<br />        Abort();<br />    }<br />}</span></pre></div><div class="sec" id="ch_core.Methods_for_Using_Pa"><h3><span class="title">Methods for Using Parameters</span></h3><p>Important methods of the <span class="nctnt ncbi-class">CParam</span> class are:</p><div class="table" id="ch_core.T.nc_MethodStaticPurposeGetState"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Method</th><th align="left" valign="top" rowspan="1" colspan="1">Static</th><th align="left" valign="top" rowspan="1" colspan="1">Purpose</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">GetState()</span></td><td align="left" valign="top" rowspan="1" colspan="1">Yes</td><td align="left" valign="top" rowspan="1" colspan="1">Get the current state of the parameter. The state indicates the last source checked when assigning its value. <span class="nctnt highlight">N.B.</span> it specifically does <i>not</i> indicate the origin of the current value. See the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCParamBase.html#0f2898884063b661395c511bcdb1c6ea">EParamState</a> enum for specific values.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">Get()</span></td><td align="left" valign="top" rowspan="1" colspan="1">No</td><td align="left" valign="top" rowspan="1" colspan="1">Get the current parameter value.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">Set()</span></td><td align="left" valign="top" rowspan="1" colspan="1">No</td><td align="left" valign="top" rowspan="1" colspan="1">Set a new parameter value (this instance only).</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">Reset()</span></td><td align="left" valign="top" rowspan="1" colspan="1">No</td><td align="left" valign="top" rowspan="1" colspan="1">Reset the value as if it has not been initialized yet.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">GetDefault()</span></td><td align="left" valign="top" rowspan="1" colspan="1">Yes</td><td align="left" valign="top" rowspan="1" colspan="1">Get the global default value.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">SetDefault()</span></td><td align="left" valign="top" rowspan="1" colspan="1">Yes</td><td align="left" valign="top" rowspan="1" colspan="1">Set a new global default value.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">ResetDefault()</span></td><td align="left" valign="top" rowspan="1" colspan="1">Yes</td><td align="left" valign="top" rowspan="1" colspan="1">Reload the global default value from the environment/registry or reset it to the initial value specified in NCBI_PARAM_DEF.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">GetThreadDefault()</span></td><td align="left" valign="top" rowspan="1" colspan="1">Yes</td><td align="left" valign="top" rowspan="1" colspan="1">Get the thread-local default value if set, otherwise the global default value.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">SetThreadDefault()</span></td><td align="left" valign="top" rowspan="1" colspan="1">Yes</td><td align="left" valign="top" rowspan="1" colspan="1">Set a new thread-local default value.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">ResetThreadDefault()</span></td><td align="left" valign="top" rowspan="1" colspan="1">Yes</td><td align="left" valign="top" rowspan="1" colspan="1">Reset the thread default value as if it has not been set.</td></tr></tbody></table></div><p>Typical uses involve getting the current or default values:</p><pre><span class="nctnt-pre ncbi-code">// get a parameter's default value<br />string bots = NCBI_PARAM_TYPE(CGI,Bots)::GetDefault();<br /><br />// get a parameter's current value<br />typedef NCBI_PARAM_TYPE(READ_FASTA, USE_NEW_IMPLEMENTATION) TParam_NewImpl;<br />TParam_NewImpl new_impl;<br />if (new_impl.Get()) {<br />    // do something<br />}</span></pre></div><div class="sec" id="ch_core.Supporting_Classes"><h3><span class="title">Supporting Classes</span></h3><p>The CParam class is packaged with two supporting classes: <span class="nctnt ncbi-class">CParamException</span> and <span class="nctnt ncbi-class">CParamParser</span>.</p><p><span class="nctnt ncbi-class">CParamException</span> will be thrown by the parameter parser if invalid parameter values are specified in the environment, configuration file, or code.</p><p><span class="nctnt ncbi-class">CParamParser</span> is a templatized helper class that parses parameter literals into parameter values, using its <span class="nctnt ncbi-func">StringToValue()</span> method. [<span class="nctnt highlight">Note:</span> the "String" in this method name refers to the string of characters in the literal being parsed (regardless of the type it represents), not to the <span class="nctnt ncbi-type">std::string</span> type.] A <span class="nctnt ncbi-func">ValueToString()</span> method is also provided for completeness.</p><p><span class="nctnt ncbi-class">CParamParser</span> templates have been pre-defined for string, bool, int, and enum types. If you need to create a configuration parameter that is more complex than these types, then you will need to either instantiate <span class="nctnt ncbi-class">CParamParser</span> for your type or define appropriate <span class="nctnt ncbi-func">operator&lt;&lt;()</span> and <span class="nctnt ncbi-func">operator&gt;&gt;()</span> methods. This will:</p><ul><li><p>enable parsing of the default value specified in the definition of your complex configuration parameter;</p></li><li><p>enable that type to be read from the application registry or environment; and</p></li><li><p>enable that type to be assigned values via the <span class="nctnt ncbi-func">Set*()</span> methods.</p></li></ul><p><span class="nctnt highlight">Note:</span> Defining the appropriate <span class="nctnt ncbi-func">operator&lt;&lt;()</span> and <span class="nctnt ncbi-func">operator&gt;&gt;()</span> methods is preferrable to instantiating <span class="nctnt ncbi-class">CParamParser</span> for your type because:</p><ul><li><p>instantiating <span class="nctnt ncbi-class">CParamParser</span> for your type would make it more difficult to change the <span class="nctnt ncbi-class">CParamParser</span> template, if that should become necessary; and</p></li><li><p><span class="nctnt ncbi-func">operator&lt;&lt;()</span> and <span class="nctnt ncbi-func">operator&gt;&gt;()</span> can be useful in other contexts.</p></li></ul></div></div><div class="sec" id="ch_core.registry"><h2><span class="title">Using the CNcbiRegistry Class</span></h2><p>If for some reason the <span class="nctnt ncbi-class">CParam</span> class cannot be used to <a href="ch_core.html#ch_core.Configuration_Parame">define configuration parameters</a>, the <span class="nctnt ncbi-class">CNcbiRegistry</span> class may be used instead.</p><p>This section provides reference information on the use of the <span class="nctnt ncbi-class">CNcbiRegistry</span> class. For an overview of this class, refer to the <a href="ch_intro.html#ch_intro.intro_reg">introductory chapter</a>. This class is also discussed in the <a href="ch_libconfig.html#ch_libconfig.libconfig_registry">library configuration chapter</a>.</p><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_core.html#ch_core.registry_intro">Working with the Registry class: CNcbiRegistry</a></p></li><li><p><a href="ch_core.html#ch_core.registry_syntax">Syntax of the Registry Configuration File</a></p></li><li><p><a href="ch_core.html#ch_core.ini_search_order">Search Order for Initialization (*.ini) Files</a></p></li><li><p><a href="ch_core.html#ch_core.registry_Eflags">Fine-Tuning Registry Parameters Using IRegistry::EFlags</a></p></li><li><p><a href="ch_core.html#ch_core.registry_mainmethods">Main Methods of CNcbiRegistry</a></p></li><li><p><a href="ch_core.html#ch_core.registry_addmethods">Additional Registry Methods</a></p></li></ul><div class="sec" id="ch_core.registry_intro"><h3><span class="title">Working with the Registry Class: CNcbiRegistry</span></h3><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNcbiRegistry.html">CNcbiRegistry</a> class is used to load, access, modify, and store runtime information read from configuration files. Previously, these files were by convention named <span class="nctnt ncbi-path">.*rc</span> files on Unix-like systems. The convention for all platforms now is to name such files <span class="nctnt ncbi-path">*.ini</span> (where <span class="nctnt ncbi-path">*</span> is by default the application name). An exception to this rule is the system-wide registry, which is named <span class="nctnt ncbi-path">.ncbirc</span> on Unix-like systems and <span class="nctnt ncbi-path">ncbi.ini</span> on Windows systems. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNcbiRegistry.html">CNcbiRegistry</a> class can read and parse configuration files, search and edit retrieved information, and write back to the file.</p><p>The following resources are checked when loading a registry:</p><ul><li><p>the environment</p></li><li><p>the overrides registry</p></li><li><p>the application registry</p></li><li><p>the system registry</p></li><li><p>inherited registries</p></li></ul><p>In addition, registries can be loaded from files programmatically.</p><p>An environment registry is created from configuration parameters specified in the environment. Often, such variables have the form <span class="nctnt ncbi-var">NCBI_CONFIG__&lt;section&gt;__&lt;entry&gt;</span> (note the double underscores) and can have corresponding entries in initialization files, but see the <a href="ch_libconfig.html">library configuration chapter</a> for details on specific parameters. Entries in the environment registry have the highest precedence.</p><p>If the special environment variable <span class="nctnt ncbi-var">NCBI_CONFIG_OVERRIDES</span> is defined, the configuration file it names will be loaded as the overrides registry. This registry will have the next highest precedence after the environment.</p><p>For the application registry, the name of the configuration file can be explicitly set with the <span class="nctnt ncbi-cmd">-conffile</span> command-line argument, set (or disabled) with the <span class="nctnt ncbi-var">conf</span> argument of <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNcbiApplication.html">CNcbiApplication::AppMain()</a>, or implicitly set (or disabled) according to <a href="ch_core.html#ch_core.ini_search_order">search order rules</a>. If the <span class="nctnt ncbi-cmd">-conffile</span> command-line argument is supplied, that path will be used. If the <span class="nctnt ncbi-var">conf</span> argument to <span class="nctnt ncbi-func">AppMain()</span> is supplied, the file will be determined according to <a href="ch_core.html#ch_core.T2">Table 2</a>. Otherwise, the file will be determined according to <a href="ch_core.html#ch_core.ini_search_order">search order rules</a>. The application registry follows the overrides registry in precedence.</p><div class="table" id="ch_core.T2"><div class="caption"><p>Table 2. Location of configuration files</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">conf</th><th align="left" valign="top" rowspan="1" colspan="1">Where to Look for the config File</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><i>empty</i> [default] </td><td align="left" valign="top" rowspan="1" colspan="1">Compose the config file name from the base application name plus <span class="nctnt ncbi-path">.ini</span>. Also try to strip file extensions, e.g., for the application named <span class="nctnt ncbi-app">my_app.cgi.exe</span> try subsequently: <span class="nctnt ncbi-path">my_app.cgi.exe.ini</span>, <span class="nctnt ncbi-path">my_app.cgi.ini</span>, <span class="nctnt ncbi-path">my_app.ini</span>. Using these names, search in directories as described in the "Otherwise" case for non-empty <span class="nctnt ncbi-var">conf</span> (see below). </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">NULL</span></td><td align="left" valign="top" rowspan="1" colspan="1">Do not even try to load the registry at all </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><i>non-empty</i></td><td align="left" valign="top" rowspan="1" colspan="1">If <span class="nctnt ncbi-var">conf</span> contains a path, then try to load from the config file named <span class="nctnt ncbi-var">conf</span> (only and exactly!). If the path is not fully qualified and it starts from <span class="nctnt ncbi-path">../</span> or <span class="nctnt ncbi-path">./</span>, then look for the config file starting from the current working dir. <b>Otherwise</b> (only a basename, without path), the config file will be searched for in the following places (in the order of preference): 1. current work directory; 2. user home directory; 3. directory defined by environment variable <span class="nctnt ncbi-var">NCBI</span>; 4. system directory; 5. program directory.</td></tr></tbody></table></div><p>When the application registry is successfully loaded, you can access it using the method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNcbiApplication.html">CNcbiApplication::GetConfig()</a>. The application will throw an exception if the config file is found, is not empty, and either cannot be opened or contains invalid entries. If the <span class="nctnt ncbi-var">conf</span> argument to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNcbiApplication.html">CNcbiApplication::AppMain()</a> is not <span class="nctnt ncbi-monospace">NULL</span> and the config file cannot be found, then a warning will be posted to the application diagnostic stream.</p><p>System-wide configuration parameters can be defined in the system registry. The system registry will not be loaded if it contains the <span class="nctnt ncbi-monospace">DONT_USE_NCBIRC</span> entry in the <span class="nctnt ncbi-monospace">NCBI</span> section or if the environment variable <span class="nctnt ncbi-var">NCBI_DONT_USE_NCBIRC</span> is defined. See the <a href="ch_core.html#ch_core.ini_search_order">search order</a> section below for details. The system registry follows the application registry in precedence.</p><p>Configuration files may "inherit" entries from other configuration files using the <span class="nctnt ncbi-monospace">.Inherits</span> entry in the <span class="nctnt ncbi-monospace">[NCBI]</span> section. The <span class="nctnt ncbi-monospace">.Inherits</span> entry is a space- and/or comma- delimited list of file names. Files having a <span class="nctnt ncbi-path">.ini</span> extension may be listed in the <span class="nctnt ncbi-monospace">.Inherits</span> entry without the <span class="nctnt ncbi-path">.ini</span> extension. Note that extensionless file names are not supported in the <span class="nctnt ncbi-monospace">.Inherits</span> entry. Inherited registries have the same precedence as the registry that inherited them.</p><p>Registries can be programmatically loaded from files by calling <span class="nctnt ncbi-func">CNcbiRegistry::Read()</span>. <span class="nctnt ncbi-func">CNcbiApplication::LoadConfig()</span> can also be called to "manually" load the application registry - for example, if special flags are required. The precedence for programmatically loaded registries depends on the flags they are loaded with. By default (or if loaded with the <span class="nctnt ncbi-var">IRegistry::fOverride</span> flag) they will have greater precedence that previously loaded registries, but if loaded with the <span class="nctnt ncbi-var">IRegistry::fNoOverride</span> flag, they will not override existing parameters.</p><p>Although registry objects can be instantiated and manipulated independently, they are typically used by the <span class="nctnt ncbi-class">CNcbiApplication</span> class. Specifically, <span class="nctnt ncbi-func">CNcbiApplication::AppMain()</span> attempts to load a registry with entries from all of the above sources (except programmatically loaded registries). <span class="nctnt ncbi-func">AppMain()</span> will look for the system and application registries in multiple locations, and possibly with a modified name, as described in the <a href="ch_core.html#ch_core.ini_search_order">search order</a> section below.</p><p>See the <a href="ch_libconfig.html#ch_libconfig.libconfig_registry">Registry</a> and <a href="ch_libconfig.html#ch_libconfig.Environment">Environment</a> sections of the library configuration chapter for more information on controlling the registry via the environment.</p></div><div class="sec" id="ch_core.registry_syntax"><h3><span class="title">Syntax of the Registry Configuration File</span></h3><p>The configuration file is composed of <span class="nctnt ncbi-monospace">section</span> headers and "<span class="nctnt ncbi-monospace">name=value</span>" strings, which occur within the named sections. It is also possible to include comments in the file, which are indicated by a new line with a leading semicolon. An example configuration file is shown below.</p><pre><span class="nctnt-pre ncbi-code"># Registry file comment (begin of file)<br /># MyProgram.ini<br />; parameters for section1<br />[section1]<br />name1 = value1 and value1.2<br />n-2.3 = "  this value has two spaces at its very beginning and at the end  "<br />name3 = this is a multi\<br />line value<br />name4 = this is a single line ended by back slash\\<br />name5 = all backslashes and \<br />new lines must be \\escaped\\...<br />[ section2.9-bis ]<br />; This is a comment...<br />name2 = value2</span></pre><p>All comments and empty lines are ignored by the registry file parser. Line continuations, as usual, are indicated with a backslash escape. More generally, backslashes are processed as:</p><ul><li><p>[backslash] + [backslash] -- converted into a single [backslash]</p></li><li><p>[backslash] + [space(s)] + [EndOfLine] -- converted to an [EndOfLine]</p></li><li><p>[backslash] + ["] -- converted into a ["]</p></li></ul><p>Character strings with embedded spaces do not need to be quoted, and an unescaped double quote at the very beginning or end of a value is ignored. All other combinations with [backslash] and ["] are invalid.</p><p>The following restrictions apply to the <span class="nctnt ncbi-monospace">section</span> and <span class="nctnt ncbi-monospace">name</span> identifiers occurring in a registry file:</p><ul><li><p>the string must contain only: [a-z], [A-Z], [0-9], [_.-/] characters</p></li><li><p>the interpretation of the string is <b>not</b> case sensitive, e.g., <span class="nctnt ncbi-monospace">PATH == path == PaTh</span></p></li><li><p>all leading and trailing spaces will be truncated</p></li></ul><p>A special syntax is provided for "including" the content of one section into another section:</p><pre><span class="nctnt-pre ncbi-code">.Include = section_name</span></pre><p>For example, this:</p><pre><span class="nctnt-pre ncbi-code">[section-a]<br />;section-a specific entries...<br />a1 = a one<br />.Include = common<br /><br />[section-b]<br />;section-b specific entries...<br />b1 = b one<br />.Include = common<br /><br />[common]<br />;common entries<br />c1 = c one<br />c2 = c two</span></pre><p>is equivalent to:</p><pre><span class="nctnt-pre ncbi-code">[section-a]<br />;section-a specific entries...<br />a1 = a one<br />;common entries<br />c1 = c one<br />c2 = c two<br /><br />[section-b]<br />;section-b specific entries...<br />b1 = b one<br />;common entries<br />c1 = c one<br />c2 = c two</span></pre><p>Another special syntax is provided for "including" other configuration files:</p><pre><span class="nctnt-pre ncbi-code">[NCBI]<br />.Inherits = subregistry_list</span></pre><p>Here, <span class="nctnt ncbi-monospace">subregistry_list</span> is a comma- or space- separated list of one or more subregistry files. Subregistry file names are not required to have a "<span class="nctnt ncbi-monospace">.ini</span>" extension. However if they do, the "<span class="nctnt ncbi-monospace">.ini</span>" can be omitted from the subregistry list. For example, the specification:</p><pre><span class="nctnt-pre ncbi-code">[NCBI]<br />.Inherits = a</span></pre><p>will select "<span class="nctnt ncbi-monospace">a.ini</span>". Subregistries can also define their own subregistries, thus permitting an application to read a tree of configuration files.</p><p>Given a specification of:</p><pre><span class="nctnt-pre ncbi-code">[NCBI]<br />.Inherits = a b</span></pre><p>an entry in "<span class="nctnt ncbi-monospace">a.ini</span>" or any of its subregistries will take priority over an identically named entry in "<span class="nctnt ncbi-monospace">b.ini</span>" or any of its subregistries. This could be used, for example, to retain a default configuration while working with a test configuration, such as in:</p><pre><span class="nctnt-pre ncbi-code">[NCBI]<br />.Inherits = mytest.ini myapp.ini</span></pre><p>Entries in the main configuration file take priority over entries in subregistries.</p><p>Entries defined in a subregistry can be "undefined" by explicitly defining the entry as empty in a higher priority registry file.</p><p>Finally, the environment variable <span class="nctnt ncbi-cmd">NCBI_CONFIG_OVERRIDES</span> can be used to name a configuration file whose entries override any corresponding entries in all the processed registry files.</p></div><div class="sec" id="ch_core.ini_search_order"><h3><span class="title">Search Order for Initialization (*.ini) Files</span></h3><p><span class="nctnt highlight">Note:</span> This section discusses the search order for initialization files, which is only applicable to the application and system initialization files. Please see the <a href="ch_core.html#ch_core.registry_intro">Working with the Registry Class</a> section for a discussion about the other sources of configuration information and the relative precedence of all registry sources.</p><p><span class="nctnt highlight">Note:</span> See <a href="ch_core.html#ch_core.T2">Table 2</a> for rules about how the <span class="nctnt ncbi-var">conf</span> argument to <span class="nctnt ncbi-func">AppMain()</span> affects the search rules for the application initialization file. Also, if the <span class="nctnt ncbi-var">-conffile</span> command-line argument is used, then only that application initialization file is tried.</p><p><span class="nctnt highlight">Note:</span> Several means are available to control loading of the system initialization file. It can be enabled by the <span class="nctnt ncbi-var">IRegistry::fWithNcbirc</span> flag. It can be disabled if (1) it contains the <span class="nctnt ncbi-monospace">DONT_USE_NCBIRC</span> entry in the <span class="nctnt ncbi-monospace">NCBI</span> section, (2) it contains syntax errors or no entries, or (3) if the environment variable <span class="nctnt ncbi-var">NCBI_DONT_USE_NCBIRC</span> is defined.</p><p>With the exceptions noted above, the following rules determine the search order for application and system initialization files. Although application and system initialization files are not typically found in the same place, the same search order rules apply to both (with the above exceptions).</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">If the environment variable <span class="nctnt ncbi-var">NCBI_CONFIG_PATH</span> is set, that will be the only path searched for initialization files.</p></dd><dt>2</dt><dd><p class="no_top_margin">Otherwise, the search order includes the following directories in order:</p><dl class="labeled-list"><dt>a</dt><dd><p class="no_top_margin">If the environment variable <span class="nctnt ncbi-var">NCBI_DONT_USE_LOCAL_CONFIG</span> is <i>not</i> defined then:</p><dl class="labeled-list"><dt>i</dt><dd><p class="no_top_margin">The current working directory ("<span class="nctnt ncbi-path">.</span>").</p></dd><dt>ii</dt><dd><p class="no_top_margin">The user's home directory (if it can be established).</p></dd></dl></dd><dt>b</dt><dd><p class="no_top_margin">The path in the environment variable <span class="nctnt ncbi-var">NCBI</span> (if it is defined).</p></dd><dt>c</dt><dd><p class="no_top_margin">The standard system directory ("<span class="nctnt ncbi-path">/etc</span>" on Unix-like systems, and given by the environment variable <span class="nctnt ncbi-var">SYSTEMROOT</span> on Windows).</p></dd><dt>d</dt><dd><p class="no_top_margin">The directory containing the application, if known (this requires use of <span class="nctnt ncbi-class">CNcbiApplication</span>).</p></dd></dl></dd></dl><p><span class="nctnt highlight">Note:</span> The search ends with the first file found.</p><p>The above rules determine the search order for directories, but there are also rules for initialization file names:</p><p>For the application registry: When the initialization file name is not explicitly specified (e.g. on the command line) then the implicit name will be formed by appending "<span class="nctnt ncbi-path">.ini</span>" to the application name. When the application name contains extensions, multiple names may be tried by sequentially stripping extensions off the application name. For example, if an application name is <span class="nctnt ncbi-path">a.b.c</span> then the sequence of initialization file names tried is: <span class="nctnt ncbi-path">a.b.c.ini</span>, <span class="nctnt ncbi-path">a.b.ini</span>, and finally <span class="nctnt ncbi-path">a.ini</span>.</p><p>On Unix-like systems, if an application <span class="nctnt ncbi-path">dir1/app1</span> is a symlink to <span class="nctnt ncbi-path">dir2/app2</span>, the directory/name search order will be:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-path">./app1.ini</span></p></dd><dt>2</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-path">$NCBI/app1.ini</span></p></dd><dt>3</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-path">~/app1.ini</span></p></dd><dt>4</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-path">dir1/app1.ini</span></p></dd><dt>5</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-path">dir2/app1.ini</span></p></dd><dt>6</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-path">./app2.ini</span></p></dd><dt>7</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-path">$NCBI/app2.ini</span></p></dd><dt>8</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-path">~/app2.ini</span></p></dd><dt>9</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-path">dir1/app2.ini</span></p></dd><dt>10</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-path">dir2/app2.ini</span></p></dd></dl><p>For the system registry: The name <span class="nctnt ncbi-path">.ncbirc</span> is tried on Unix-like systems and <span class="nctnt ncbi-path">ncbi.ini</span> is tried on Windows. <span class="nctnt highlight">Note:</span> NCBI in-house Linux systems have "<span class="nctnt ncbi-path">/etc/.ncbirc</span>" symlinked to "<span class="nctnt ncbi-path">/opt/ncbi/config/.ncbirc</span>" so that applications running on production systems (or with <span class="nctnt ncbi-var">NCBI</span> unset) still pick up standard configuration settings.</p></div><div class="sec" id="ch_core.registry_Eflags"><h3><span class="title"><span class="nctnt ncbi-type">Fine-Tuning Registry Parameters Using IRegistry::EFlags</span></span></h3><p><span class="nctnt highlight">Note:</span> This section deals with concepts not typically needed by most C++ Toolkit users. The functionality of <span class="nctnt ncbi-class">CNcbiRegistry</span> is automatically and transparently provided when you use <span class="nctnt ncbi-class">CNcbiApplication</span>. You probably won't need to read this section unless you're working with an application that edits registry files or explicitly sets registry entry values.</p><p>Each <span class="nctnt ncbi-class">CNcbiRegistry</span> entry has a set of flags that control how it is handled, defined by this enum:</p><pre><span class="nctnt-pre ncbi-code">enum EFlags {<br />    fTransient      = 0x1,   ///&lt; Transient -- not saved by default<br />    fPersistent     = 0x100, ///&lt; Persistent -- saved when file is written<br />    fOverride       = 0x2,   ///&lt; Existing value can be overriden<br />    fNoOverride     = 0x200, ///&lt; Cannot change existing value<br />    fTruncate       = 0x4,   ///&lt; Leading, trailing blanks can be truncated<br />    fNoTruncate     = 0x400, ///&lt; Cannot truncate parameter value<br />    fJustCore       = 0x8,   ///&lt; Ignore auxiliary subregistries<br />    fNotJustCore    = 0x800, ///&lt; Include auxiliary subregistries<br />    fIgnoreErrors   = 0x10,  ///&lt; Continue reading after parse errors<br />    fInternalSpaces = 0x20,  ///&lt; Allow internal whitespace in names<br />    fWithNcbirc     = 0x40,  ///&lt; Include .ncbirc (used only by CNcbiRegistry)<br />    fCountCleared   = 0x80,  ///&lt; Let explicitly cleared entries stand<br />    fSectionCase    = 0x1000,///&lt; Create with case-sensitive section names<br />    fEntryCase      = 0x2000,///&lt; Create with case-sensitive entry names<br />    fCoreLayers     = fTransient | fPersistent | fJustCore,<br />    fAllLayers      = fTransient | fPersistent | fNotJustCore,<br />    fCaseFlags      = fSectionCase | fEntryCase<br />};<br />typedef int TFlags;  ///&lt; Binary OR of "EFlags"</span></pre><p>Some pairs of these flags are mutually exclusive and have a default if neither flag is given:</p><div class="table" id="ch_core.T.nc_flag_pairdefaultftransient_"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Flag Pair</th><th align="left" valign="top" rowspan="1" colspan="1">Default</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">fTransient</span> / <span class="nctnt ncbi-var">fPersistent</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">fPersistent</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">fOverride</span> / <span class="nctnt ncbi-var">fNoOverride</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">fOverride</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">fJustCore</span> / <span class="nctnt ncbi-var">fNotJustCore</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">fJustCore</span></td></tr></tbody></table></div><p>It is not necessary to use the <span class="nctnt ncbi-var">fNoTruncate</span> flag because it represents the default behavior - no values are truncated unless <span class="nctnt ncbi-var">fTruncate</span> is used.</p><p>The flag <span class="nctnt ncbi-var">fWithNcbirc</span> can be passed to the <span class="nctnt ncbi-class">CNcbiRegistry</span> constructor, the <span class="nctnt ncbi-func">CNcbiRegistry::IncludeNcbircIfAllowed()</span> method, or the <span class="nctnt ncbi-func">IRWRegistry::IncludeNcbircIfAllowed()</span> method. If it is set then the system-wide registry is used - see the <a href="ch_core.html#ch_core.ini_search_order">search order section</a> for details on the system-wide registry.</p><p>For example, the following code demonstrates that the bit-wise OR of <span class="nctnt ncbi-var">fTruncate </span>and <span class="nctnt ncbi-var">fNoOverride</span> strips all leading and trailing blanks and does not override an existing value:</p><pre><span class="nctnt-pre ncbi-code">CNcbiRegistry reg;<br />CNcbiRegistry::TFlags flags = CNcbiRegistry::fNoOverride |<br />                              CNcbiRegistry::fTruncate;<br />reg.Set("MySection", "MyName", " Not Overridden  ", flags);<br />reg.Set("MySection", "MyName", " Not Saved ",       flags);<br />cout &lt;&lt; "[MySection]MyName=" &lt;&lt; reg.Get("MySection", "MyName") &lt;&lt; ".\n" &lt;&lt; endl;<br /><br />// outputs "[MySection]MyName=Not Overridden."</span></pre></div><div class="sec" id="ch_core.registry_mainmethods"><h3><span class="title">Main Methods of <span class="nctnt ncbi-class">CNcbiRegistry</span></span></h3><p>The <span class="nctnt ncbi-class">CNcbiRegistry</span> class constructor takes two arguments - an input stream to read the registry from (usually a file), and an optional <span class="nctnt ncbi-type">TFlags</span> argument, where the latter can be used to specify that all of the values should be stored as <span class="nctnt ncbi-monospace">transient</span> rather than in the default mode, which is <span class="nctnt ncbi-monospace">persistent</span>:</p><pre><span class="nctnt-pre ncbi-code">CNcbiRegistry(CNcbiIstream&amp; is, TFlags flags = 0);</span></pre><p>Once the registry has been initialized by its constructor, it is also possible to load additional parameters from other file(s) using the <span class="nctnt ncbi-func">Read()</span> method:</p><pre><span class="nctnt-pre ncbi-code">void Read(CNcbiIstream&amp; is, TFlags flags = 0);</span></pre><p>Valid flags for the <span class="nctnt ncbi-func">Read() </span>method include <span class="nctnt ncbi-var">eTransient </span>and <span class="nctnt ncbi-var">eNoOverride</span>. The default is for all values to be read in as <span class="nctnt ncbi-monospace">persistent</span>, with the capability of overriding any previously loaded value associated with the same name. Either or both of these defaults can be modified by specifying <span class="nctnt ncbi-var">eTransient, eNoOverride</span>, or (<span class="nctnt ncbi-var">eTransient | eNoOverride</span>) as the <span class="nctnt ncbi-var">flags</span> argument in the above expression.</p><p>The <span class="nctnt ncbi-func">Write() </span>method takes as its sole argument, a destination stream to which only the <span class="nctnt ncbi-monospace">persistent</span> configuration parameters will be written.</p><pre><span class="nctnt-pre ncbi-code">bool Write(CNcbiOstream&amp; os) const;</span></pre><p>The configuration parameter values can also be set directly inside your application, using:</p><pre><span class="nctnt-pre ncbi-code">bool Set(const string&amp; section, const string&amp; name,<br />         const string&amp; value, TFlags flags = 0);</span></pre><p>Here, valid flag values include <span class="nctnt ncbi-var">ePersistent, eNoOverride</span>, <span class="nctnt ncbi-var">eTruncate, </span>or any logical combination of these. If <span class="nctnt ncbi-var">eNoOverride</span> is set and there is a previously defined value for this parameter, then the value is not reset, and the method returns <span class="nctnt ncbi-monospace">false</span>.</p><p>The <span class="nctnt ncbi-func">Get()</span> method first searches the set of <span class="nctnt ncbi-monospace">transient</span> parameters for a parameter named <span class="nctnt ncbi-var">name</span>, in section <span class="nctnt ncbi-var">section</span>, and if this fails, continues by searching the set of <span class="nctnt ncbi-monospace">persistent</span> parameters. However, if the <span class="nctnt ncbi-var">ePersistent</span> flag is used, then only the set of <span class="nctnt ncbi-monospace">persistent</span> parameters will be searched. On success, <span class="nctnt ncbi-func">Get()</span> returns the stored value. On failure, the empty string is returned.</p><pre><span class="nctnt-pre ncbi-code">const string&amp; Get(const string&amp; section, const string&amp; name,<br />                  TFlags flags = 0) const;</span></pre></div><div class="sec" id="ch_core.registry_addmethods"><h3><span class="title">Additional Registry Methods</span></h3><p>Four additional note-worthy methods defined in the <span class="nctnt ncbi-class">CNcbiRegistry</span> interface are:</p><pre><span class="nctnt-pre ncbi-code">bool Empty(void) const;<br />void Clear(void);<br />void EnumerateSections(list&lt;string&gt;*sections) const;<br />void EnumerateEntries(const string&amp; section,  list&lt;string&gt;* entries) const;</span></pre><p><span class="nctnt ncbi-func">Empty()</span> returns <span class="nctnt ncbi-monospace">true</span> if the registry is empty. <span class="nctnt ncbi-func">Clear()</span> empties out the registry, discarding all stored parameters. <span class="nctnt ncbi-func">EnumerateSections() </span>writes all registry section names to the list of strings parameter named "sections". <span class="nctnt ncbi-func">EnumerateEntries()</span> writes the list of parameter names in section to the list of strings parameter named "entries".</p></div></div><div class="sec" id="ch_core.stream_wrappers"><h2><span class="title">Portable Stream Wrappers</span></h2><p>Because of differences in the C++ standard stream implementations between different compilers and platforms, the file <span class="nctnt ncbi-func">ncbistre.hpp</span> contains portable aliases for the standard classes. To provide portability between the supported platforms, it is recommended the definitions in <span class="nctnt ncbi-func">ncbistre.hpp</span> be used.</p><p>The <span class="nctnt ncbi-func">ncbistre.hpp</span> defines wrappers for many of the standard stream classes and contains conditional compilation statements triggered by macros to include portable definitions. For example, not all compilers support the newer '#include &lt;iostream&gt;' form. In this case, the older '#include &lt;iostream.h&gt;' is used based on whether the macro <span class="nctnt ncbi-macro">NCBI_USE_OLD_IOSTREAM</span> is defined.</p><p>Instead of using the iostream, istream or ostream, you should use the portable <span class="nctnt ncbi-class">CNcbiIostream</span>, <span class="nctnt ncbi-class">CNcbiIstream</span> and <span class="nctnt ncbi-class">CNcbiOstream</span>. Similarly, instead of using the standard <span class="nctnt ncbi-var">cin</span>, <span class="nctnt ncbi-var">cout</span>, <span class="nctnt ncbi-var">cerr</span> you can use the more portable <span class="nctnt ncbi-var">NcbiCin</span>, <span class="nctnt ncbi-var">NcbiCout</span>, and <span class="nctnt ncbi-var">NcbiCerr</span>.</p><p>The <span class="nctnt ncbi-func">ncbistre.hpp</span> also defines functions that handle platform-specific end of line reads. For example, <span class="nctnt ncbi-func">Endl()</span> represents platform specific end of line, and <span class="nctnt ncbi-func">NcbiGetline()</span> reads from a specified input stream to a string, and <span class="nctnt ncbi-func">NcbiGetlineEOL()</span> reads from a specified input stream to a string taking into account platform specific end of line.</p></div><div class="sec" id="ch_core.diag"><h2><span class="title">Working with Diagnostic Streams (<a href="ch_debug.html#ch_debug.std_cpp_message_post">*</a>)</span></h2><p>This section provides reference information on the use of the diagnostic stream classes. For an overview of the diagnostic stream concepts refer to the <a href="ch_intro.html#ch_intro.intro_diag">introductory chapter</a>.</p><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNcbiDiag.html">CNcbiDiag</a> class implements the functionality of an output stream enhanced with error posting mechanisms similar to those found in the NCBI C Toolkit. A <span class="nctnt ncbi-class">CNcbiDiag </span>object has the look and feel of an output stream; its member functions and friends include output operators and format manipulators. A <span class="nctnt ncbi-class">CNcbiDiag</span> object is not itself a stream, but serves as an interface to a stream which allows multiple threads to write to the same output. Each instance of <span class="nctnt ncbi-class">CNcbiDiag</span> includes the following private data members:</p><ul><li><p>a buffer to store (a single) message text</p></li><li><p>a severity level</p></li><li><p>a set of post flags</p></li></ul><p>Limiting each instance of <span class="nctnt ncbi-class">CNcbiDiag</span> to the storage and handling of a single message ensures that multiple threads writing to the same stream will not have interleaving message texts.</p><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_core.html#ch_core.Where_Diagnostic_Messages_Go">Where Diagnostic Messages Go</a></p></li><li><p><a href="ch_core.html#ch_core.diag_severity">Setting Diagnostic Severity Levels</a></p></li><li><p><a href="ch_core.html#ch_core.diagnostic_messages_filtering">Diagnostic Messages Filtering</a></p></li><li><p><a href="ch_core.html#ch_core.Log_File_Format">Log File Format</a></p><ul><li><p><a href="ch_core.html#ch_core.The_Old_Post_Format">The Old Post Format</a></p></li><li><p><a href="ch_core.html#ch_core.The_New_Post_Format">The New Post Format</a></p></li><li><p><a href="ch_core.html#ch_core.diag_post_flags">Controlling the Appearance of Diagnostic Messages using Post Flags</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.diag_set_stream">Defining the Output Stream</a></p></li><li><p><a href="ch_core.html#ch_core.Tee_Output_to_STDERR">Tee Output to STDERR</a></p></li><li><p><a href="ch_core.html#ch_core.diag_buffering">The Message Buffer</a></p></li><li><p><a href="ch_core.html#ch_core.Request_Exit_Status_Codes">Request Exit Status Codes</a></p><ul><li><p><a href="ch_core.html#ch_core.Standard_HTTPlike_status_codes">Standard (HTTP-like) status codes</a></p></li><li><p><a href="ch_core.html#ch_core.NCBIspecific_status_codes">NCBI-specific status codes</a></p></li></ul></li><li><p><a href="ch_core.html#ch_core.diag_errcodes">Error codes and their Descriptions</a></p></li><li><p><a href="ch_core.html#ch_core.diag_handlers">Defining Custom Handlers using CDiagHandler</a></p></li><li><p><a href="ch_core.html#ch_core.ERR_POST">The ERR_POST and LOG_POST Macros</a></p></li><li><p><a href="ch_core.html#ch_core._TRACE">The _TRACE macro</a></p></li><li><p><a href="ch_core.html#ch_core.Stack_Traces">Stack Traces</a></p><ul><li><p><a href="ch_core.html#ch_core.Printing_a_Stack_Trace">Printing a Stack Trace</a></p></li><li><p><a href="ch_core.html#ch_core.Obtaining_a_Stack_Trace_for_Exce">Obtaining a Stack Trace for Exceptions</a></p></li></ul></li></ul><div class="sec" id="ch_core.Where_Diagnostic_Messages_Go"><h3><span class="title">Where Diagnostic Messages Go</span></h3><p>The following decision tree describes how the destination for diagnostics messages is determined.</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Before the application is constructed (before <span class="nctnt ncbi-func">AppMain()</span> is called), everything goes to:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">(Unix-like systems only) <span class="nctnt ncbi-path">/log/fallback/UNKNOWN.{log|err|trace}</span> -- if available</p></dd><dt>2</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-var">STDERR</span> -- otherwise</p></dd></dl></dd><dt>2</dt><dd><p class="no_top_margin">When the application is ready, and its name is known, but before the configuration file is loaded:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">If <span class="nctnt ncbi-func">AppMain()</span> is passed flags <span class="nctnt ncbi-var">eDS_Default</span> or <span class="nctnt ncbi-var">eDS_ToStdlog</span>, then the diagnostics goes:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">(Unix-like systems only) if <span class="nctnt ncbi-path">/log</span> is present:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">if the application is described in <span class="nctnt ncbi-path">/etc/toolkitrc</span> -- to <span class="nctnt ncbi-path">/log/&lt;token&gt;/appname.{log|err|trace}</span></p></dd><dt>2</dt><dd><p class="no_top_margin">else if environment variable <span class="nctnt ncbi-var">$SERVER_PORT</span> is set -- to <span class="nctnt ncbi-path">/log/$SERVER_PORT/appname.{log|err|trace}</span></p></dd><dt>3</dt><dd><p class="no_top_margin">else (or if failed to switch to one of the above two locations) -- to <span class="nctnt ncbi-path">/log/srv/appname.{log|err|trace}</span></p></dd><dt>4</dt><dd><p class="no_top_margin">or, if failed to switch to that -- to <span class="nctnt ncbi-path">/log/fallback/appname.{ log|err|trace}</span></p></dd></dl></dd><dt>2</dt><dd><p class="no_top_margin">else (or if failed to switch to any of the /log location):</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-var">eDS_ToStdlog</span> -- to <span class="nctnt ncbi-path">&lt;current_working_dir&gt;/appname.{ log|err|trace}</span> (and, if cannot, then continues to go to <span class="nctnt ncbi-var">STDERR</span>)</p></dd><dt>2</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-var">eDS_Default</span> -- continues to go to <span class="nctnt ncbi-var">STDERR</span></p></dd></dl></dd></dl></dd><dt>2</dt><dd><p class="no_top_margin">If <span class="nctnt ncbi-func">AppMain()</span> is passed flags other than <span class="nctnt ncbi-var">eDS_Default</span> or <span class="nctnt ncbi-var">eDS_ToStdlog</span>, then the diagnostics goes to:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-var">eDS_ToStdout</span> -- standard output stream</p></dd><dt>2</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-var">eDS_ToStderr</span> -- standard error stream</p></dd><dt>3</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-var">eDS_ToMemory</span> -- the application memory</p></dd><dt>4</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-var">eDS_Disable</span> -- nowhere</p></dd><dt>5</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-var">eDS_User</span> -- wherever it went before the <span class="nctnt ncbi-func">AppMain()</span> call</p></dd><dt>6</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-var">eDS_ToSyslog</span> -- system log daemon</p></dd></dl></dd></dl></dd><dt>3</dt><dd><p class="no_top_margin">After the configuration file is loaded, and if it has an alternative location for the log files, then switch to logging to that location. See the list of logfile-related <a href="http://www.ncbi.nlm.nih.gov/books/n/toolkit/ch_libconfig#ch_libconfig.libconfig_logfile">configuration parameters</a>.</p></dd></dl><p>The boolean <span class="nctnt ncbi-monospace">TryRootLogFirst</span> argument in the <span class="nctnt ncbi-monospace">[LOG]</span> section of the application's config file changes the order of locations to be tested. If <span class="nctnt ncbi-monospace">TryRootLogFirst</span> is set, the application will try to open the log file under <span class="nctnt ncbi-path">/log</span> first. Only if this fails, then the location specified in the config file will be used.</p><p><span class="nctnt highlight">Note:</span></p><ul><li><p>If the logging destination is switched, then a message containing both the old and new locations is logged to both locations.</p></li><li><p>Before the application configuration is loaded, a copy of all diagnostics is saved in memory. If the log destination is changed by the application configuration, then the saved diagnostics are dumped to the final log destination.</p></li></ul></div><div class="sec" id="ch_core.diag_severity"><h3><span class="title">Setting Diagnostic Severity Levels</span></h3><p>Each diagnostic message has its own severity level (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EDiagSev">EDiagSev</a>), which is compared to a global severity threshold to determine whether or not its message should be posted. Six levels of severity are defined by the <span class="nctnt ncbi-type">EDiagSev</span> enumeration:</p><pre><span class="nctnt-pre ncbi-code">/// Severity level for the posted diagnostics.<br />enum EDiagSev {<br />    eDiag_Info = 0, ///&lt; Informational message<br />    eDiag_Warning,  ///&lt; Warning message<br />    eDiag_Error,    ///&lt; Error message<br />    eDiag_Critical, ///&lt; Critical error message<br />    eDiag_Fatal,    ///&lt; Fatal error -- guarantees exit(or abort)<br />    eDiag_Trace,    ///&lt; Trace message<br />    // Limits<br />    eDiagSevMin = eDiag_Info,  ///&lt; Verbosity level for min. severity<br />    eDiagSevMax = eDiag_Trace  ///&lt; Verbosity level for max. severity<br />};</span></pre><p>The default is to post only those messages whose severity level exceeds the <span class="nctnt ncbi-var">eDiag_Warning</span> level (i.e. <span class="nctnt ncbi-var">eDiag_Error, eDiag_Critical</span>, and <span class="nctnt ncbi-var">eDiag_Fatal</span>). The global severity threshold for posting messages can be reset using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SetDiagPostLevel">SetDiagPostLevel</a><span class="nctnt ncbi-func"> (EDiagSev postSev)</span>. A parallel function, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SetDiagDieLevel">SetDiagDieLevel</a><span class="nctnt ncbi-func"> (EDiagSev dieSev)</span>, defines the severity level at which execution will abort.</p><p>Tracing is considered to be a special, debug-oriented feature, and therefore messages with severity level <span class="nctnt ncbi-var">eDiag_Trace</span> are not affected by these global <span class="nctnt ncbi-monospace">post/die</span> levels. Instead, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SetDiagTrace">SetDiagTrace</a><span class="nctnt ncbi-func"> (EDiagTrace enable, EDiagTrace default)</span> is used to turn tracing on or off. By default, the tracing is off - unless you assign the environment variable <span class="nctnt ncbi-var">DIAG_TRACE</span> to an arbitrary non-empty string or, alternatively, define a <span class="nctnt ncbi-var">DIAG_TRACE</span> entry in the <span class="nctnt ncbi-var">[DEBUG]</span> section of your <a href="ch_core.html#ch_core.registry">registry</a> file.</p><p>The severity level can be set directly in <span class="nctnt ncbi-macro">POST</span> and <span class="nctnt ncbi-macro">TRACE</span> statements, using the severity level manipulators including <span class="nctnt ncbi-var">Info</span>, <span class="nctnt ncbi-var">Warning</span>, <span class="nctnt ncbi-var">Error</span>, <span class="nctnt ncbi-var">Critical</span>, <span class="nctnt ncbi-var">Fatal</span>, and <span class="nctnt ncbi-var">Trace</span>, for example:</p><pre><span class="nctnt-pre ncbi-code">ERR_POST_X(1, Critical &lt;&lt; "Something quite bad has happened.");</span></pre></div><div class="sec" id="ch_core.diagnostic_messages_filtering"><h3><span class="title">Diagnostic Messages Filtering</span></h3><p>Diagnostic messages from the <span class="nctnt ncbi-class">CNcbiDiag</span> and <span class="nctnt ncbi-class">CException</span> classes can be filtered by the source file path; or by the module, class, or function name. Messages from the <span class="nctnt ncbi-class">CNcbiDiag</span> class can also be filtered by error code. If a <span class="nctnt ncbi-class">CException</span> object is created by chaining to a previous exception, then all exceptions in the chain will be checked against the filter and the exception will pass if any exception in the chain passes (even if one of them is suppressed by a negative condition). The filter can be set by the <span class="nctnt ncbi-var">TRACE_FILTER</span> or <span class="nctnt ncbi-var">POST_FILTER</span> entry in the <span class="nctnt ncbi-var">[DIAG]</span> section of the registry file or during runtime through <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SetDiagFilter">SetDiagFilter()</a>. Messages with a severity level of <span class="nctnt ncbi-var">eDiag_Fatal</span> are not filtered; messages with a severity level of <span class="nctnt ncbi-var">eDiag_Trace</span> are filtered by <span class="nctnt ncbi-var">TRACE_FILTER</span>; and all other messages are filtered by <span class="nctnt ncbi-var">POST_FILTER</span>. Filter strings contain filtering conditions separated by a space. An empty filter string means that all messages will appear in the log unfiltered. Filtering conditions are processed from left to right until a condition that matches the message is found. If the message does not match any of the conditions, then the message will be filtered out. Filtering conditions in the string may be preceded by an exclamation mark, which reverses the behavior (so if a message matches the condition it will be suppressed). See <a href="ch_core.html#ch_core.T4">Table 4</a> for filtering condition samples and syntax.</p><div class="table" id="ch_core.T4"><div class="caption"><p>Table 4. Filter String Samples</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Filter</th><th align="left" valign="top" rowspan="1" colspan="1">Description</th><th align="left" valign="top" rowspan="1" colspan="1">Matches</th><th align="left" valign="top" rowspan="1" colspan="1">Non Matches</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-path">/corelib</span></td><td align="left" valign="top" rowspan="1" colspan="1">Log message from source file located in <span class="nctnt ncbi-path">src/corelib</span> or <span class="nctnt ncbi-path">include/corelib</span> or subdirectories</td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-path">src/corelib/ncbidiag.cpp</span></p></li><li><p><span class="nctnt ncbi-path">src/corelib/test/test_ncbiexec.cpp</span></p></li><li><p><span class="nctnt ncbi-path">include/corelib/ncbidiag.hpp</span></p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-path">src/cgi/cgiapp.cpp</span></p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-path">/corelib/test</span></td><td align="left" valign="top" rowspan="1" colspan="1">Log message from source file located in <span class="nctnt ncbi-path">src/corelib/test</span> or <span class="nctnt ncbi-path">include/corelib/test</span> or subdirectories</td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-path">src/corelib/test/test_ncbiexec.cpp</span></p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-path">src/corelib/ncbidiag.cpp</span></p></li><li><p><span class="nctnt ncbi-path">include/corelib/ncbidiag.hpp</span></p></li><li><p><span class="nctnt ncbi-path">src/cgi/cgiapp.cpp</span></p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-path">/corelib/</span></td><td align="left" valign="top" rowspan="1" colspan="1">Log message from source file located in <span class="nctnt ncbi-path">src/corelib</span> or <span class="nctnt ncbi-path">include/corelib</span></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-path">src/corelib/ncbidiag.cpp</span></p></li><li><p><span class="nctnt ncbi-path">include/corelib/ncbidiag.hpp</span></p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-path">src/corelib/test/test_ncbiexec.cpp</span></p></li><li><p><span class="nctnt ncbi-path">src/cgi/cgiapp.cpp</span></p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-lib">corelib</span></td><td align="left" valign="top" rowspan="1" colspan="1">Log message with module name set to "corelib" and any class or function name </td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-lib">corelib</span></p></li><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span></p></li><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-class">CNcbiDiag</span></p></li><li><p><span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li><li><p><span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span></td><td align="left" valign="top" rowspan="1" colspan="1">Log message with module name set to "corelib", class name set to "<span class="nctnt ncbi-class">CNcbiDiag</span>" and any function name</td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span></p></li><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-lib">corelib</span></p></li><li><p><span class="nctnt ncbi-class">CNcbiDiag</span></p></li><li><p><span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li><li><p><span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">::<span class="nctnt ncbi-class">CNcbiDiag</span></td><td align="left" valign="top" rowspan="1" colspan="1">Log message with class name set to "<span class="nctnt ncbi-class">CNcbiDiag</span>" and any module or function name</td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span></p></li><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li><li><p><span class="nctnt ncbi-class">CNcbiDiag</span></p></li><li><p><span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-lib">corelib</span></p></li><li><p><span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">?</td><td align="left" valign="top" rowspan="1" colspan="1">Log message with module name not set and any class or function name</td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-class">CNcbiDiag</span></p></li><li><p><span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li><li><p><span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-lib">corelib</span></p></li><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span></p></li><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-lib">corelib</span>::?</td><td align="left" valign="top" rowspan="1" colspan="1">Log message with module name set to "corelib", class name not set and any function name</td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-lib">corelib</span></p></li><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span></p></li><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li><li><p><span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li><li><p><span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-func">GetModule()</span></td><td align="left" valign="top" rowspan="1" colspan="1">Log message with function name set to "<span class="nctnt ncbi-func">GetModule</span>" and any class or module name</td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li><li><p><span class="nctnt ncbi-class">CNcbiDiag</span>::<span class="nctnt ncbi-func">GetModule()</span></p></li><li><p><span class="nctnt ncbi-func">GetModule()</span></p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p><span class="nctnt ncbi-lib">Corelib</span></p></li><li><p><span class="nctnt ncbi-lib">corelib</span>::<span class="nctnt ncbi-class">CNcbiDiag</span></p></li><li><p><span class="nctnt ncbi-class">CNcbiDiag</span></p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">(20.11)</td><td align="left" valign="top" rowspan="1" colspan="1"> Log messages with error code 20 and subcode 11</td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p>ErrCode(20,11)</p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p>ErrCode(20,10)</p></li><li><p>ErrCode(123,11)</p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"> (20-80.)</td><td align="left" valign="top" rowspan="1" colspan="1">Log messages with error code from 20 to 80 and any subcode</td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p>ErrCode(20,11)</p></li><li><p>ErrCode(20,10)</p></li><li><p>ErrCode(51,1)</p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p>ErrCode(123,11)</p></li></ul></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">(20-80,120,311-400.1-50,60)</td><td align="left" valign="top" rowspan="1" colspan="1">Log messages with error code from 20 to 80, 120, from 311 to 400 and subcode from 1 to 50 and 60</td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p>ErrCode(20,11)</p></li><li><p>ErrCode(321,60)</p></li></ul></td><td align="left" valign="top" rowspan="1" colspan="1"><ul><li><p>ErrCode(20,51)</p></li><li><p>ErrCode(321,61)</p></li></ul></td></tr></tbody></table></div><p>For example:</p><ul><li><p>To log diagnostic messages from source files located in <span class="nctnt ncbi-path">src/corelib</span> with error codes from 101 to 106 and any subcode, use the following filter: “<span class="nctnt ncbi-monospace">/corelib (101-106.)</span>”.</p></li><li><p>To exclude log messages from sources in <span class="nctnt ncbi-path">src/serial</span> and <span class="nctnt ncbi-path">src/dbapi</span>, use this filter: “<span class="nctnt ncbi-monospace">!/serial !/dbapi</span>”.</p></li><li><p>To log messages from sources in <span class="nctnt ncbi-path">src/serial</span> excluding those with error code 802 and subcodes 4 and 10 through 12, and to exclude messages from sources in <span class="nctnt ncbi-path">src/dbapi/driver</span>, use the following filter: “<span class="nctnt ncbi-monospace">/serial !(802.4,10-12) !/dbapi/driver</span>”.</p></li></ul></div><div class="sec" id="ch_core.Log_File_Format"><h3><span class="title">Log File Format</span></h3><p>The format of the log file can be customized. One of the most basic choices is between the "<a href="ch_core.html#ch_core.The_Old_Post_Format">old post format</a>" and the "<a href="ch_core.html#ch_core.The_New_Post_Format">new post format</a>". The old format essentially posts arbitrary strings whereas the new format adds many standard fields, and structures the messages so they can be automatically indexed for rapid searching and/or error statistics.</p><p>The old format is used by default. To use the new format:</p><pre><span class="nctnt-pre ncbi-code">int main(int argc, const char* argv[])<br />{<br />    GetDiagContext().SetOldPostFormat(false); // use the new format<br /><br />    return CMyApp().AppMain(argc, argv);<br />}</span></pre><p>This function should be called before the application's constructor for the setting to be used from the very beginning.</p><p>See also:</p><ul><li><p>the <a href="ch_libconfig.html#ch_libconfig.libconfig_diag">Diagnostic Trace</a> section in the library configuration chapter for details on selecting the format using the environment or registry; and</p></li><li><p>the <a href="ch_core.html#ch_core.ERR_POST">ERR_POST and LOG_POST Macros</a> section for more details on creating the log messages.</p></li></ul><div class="sec" id="ch_core.The_Old_Post_Format"><h4><span class="title">The Old Post Format</span></h4><p>The old format for log messages is simply a message - prefixed with the severity level if it is an error message:</p><pre><span class="nctnt-pre ncbi-monospace">[&lt;severity&gt;: ]&lt;Message&gt;</span></pre></div><div class="sec" id="ch_core.The_New_Post_Format"><h4><span class="title">The New Post Format</span></h4><p>The new format for the application access log and error postings is:</p><pre><span class="nctnt-pre ncbi-monospace">&lt;Common Prefix&gt; &lt;Event:13&gt; &lt;Message&gt;</span></pre><p>The common prefix has the format:</p><pre><span class="nctnt-pre ncbi-monospace">&lt;pid:5&gt;/&lt;tid:3&gt;/&lt;rid:4&gt;/&lt;state:2&gt; &lt;guid:16&gt; &lt;psn:4&gt;/&lt;tsn:4&gt; &lt;time&gt; &lt;host:15&gt; &lt;client:15&gt; &lt;session:24&gt; &lt;application&gt;</span></pre><p><span class="nctnt highlight">Note:</span> Width and padding of standard fields</p><ul><li><p>To make a good visual alignment, most numeric values are printed zero-padded to some minimal width. For example, &lt;<span class="nctnt ncbi-monospace">pid:5</span>&gt; means that number 123 gets printed as "00123", and number 1234567 gets printed as "1234567".</p></li><li><p>The non-numeric fields for which the width is specified (e.g. &lt;<span class="nctnt ncbi-monospace">severity:10</span>&gt;) are padded with spaces and are adjusted to the left.</p></li></ul><p>The fields are:</p><div class="table" id="ch_core.T.nc_fielddescriptiontype_or_for"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Field</th><th align="left" valign="top" rowspan="1" colspan="1">Description</th><th align="left" valign="top" rowspan="1" colspan="1">Type or format</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">pid</td><td align="left" valign="top" rowspan="1" colspan="1">Process ID</td><td align="left" valign="top" rowspan="1" colspan="1">Uint8 (decimal)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">tid</td><td align="left" valign="top" rowspan="1" colspan="1">Thread ID</td><td align="left" valign="top" rowspan="1" colspan="1">Uint8 (decimal)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">rid</td><td align="left" valign="top" rowspan="1" colspan="1">Request ID (e.g. iteration number for a CGI)</td><td align="left" valign="top" rowspan="1" colspan="1">int (decimal)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">state</td><td align="left" valign="top" rowspan="1" colspan="1">Application state code: { <span class="nctnt ncbi-monospace">AB</span> | <span class="nctnt ncbi-monospace">AE</span> | <span class="nctnt ncbi-monospace">RB</span> | <span class="nctnt ncbi-monospace">R</span> | <span class="nctnt ncbi-monospace">RE</span> }</td><td align="left" valign="top" rowspan="1" colspan="1">string</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">guid</td><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=x_CreateUID">Globally unique process ID</a></td><td align="left" valign="top" rowspan="1" colspan="1">Int8 (hexadecimal)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">psn</td><td align="left" valign="top" rowspan="1" colspan="1">Serial number of the posting within the process</td><td align="left" valign="top" rowspan="1" colspan="1">int (decimal)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">tsn</td><td align="left" valign="top" rowspan="1" colspan="1">Serial number of the posting within the thread</td><td align="left" valign="top" rowspan="1" colspan="1">int (decimal)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">time</td><td align="left" valign="top" rowspan="1" colspan="1">Astronomical date and time at which the message was posted</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">YYYY-MM-DD<b>T</b>hh:mm:ss.sss</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">host</td><td align="left" valign="top" rowspan="1" colspan="1">Name of the host where the process runs</td><td align="left" valign="top" rowspan="1" colspan="1">string (UNK_HOST if unknown)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">client</td><td align="left" valign="top" rowspan="1" colspan="1">Client IP address</td><td align="left" valign="top" rowspan="1" colspan="1">valid IP address string (UNK_CLIENT if unknown)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">session</td><td align="left" valign="top" rowspan="1" colspan="1">Session ID</td><td align="left" valign="top" rowspan="1" colspan="1">string (UNK_SESSION if unknown)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">application</td><td align="left" valign="top" rowspan="1" colspan="1">Name of the application (see note below)</td><td align="left" valign="top" rowspan="1" colspan="1">string (UNK_APP if unknown)</td></tr></tbody></table></div><p><span class="nctnt highlight">Note:</span> The application name is set to the executable name (without path and extension) by default. Sometimes however the executable's name can be too generic (like "summary" or "fetch"). To change it use <span class="nctnt ncbi-func">CNcbiApplication::SetProgramDisplayName()</span> function. Better yet, just rename the executable itself. It's a good practice to prefix the application names with something project-specific (like "pc_summary" for PubChem or "efetch" for E-Utils).</p><p>The application state codes are:</p><div class="table" id="ch_core.T.nc_codemeaningabapplication_is"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Code</th><th align="left" valign="top" rowspan="1" colspan="1">Meaning</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">AB</span></td><td align="left" valign="top" rowspan="1" colspan="1">application is starting</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">A</span></td><td align="left" valign="top" rowspan="1" colspan="1">application is running (outside of any request)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">AE</span></td><td align="left" valign="top" rowspan="1" colspan="1">application is exiting</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">RB</span></td><td align="left" valign="top" rowspan="1" colspan="1">request is starting</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">R</span></td><td align="left" valign="top" rowspan="1" colspan="1">request is being processed</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">RE</span></td><td align="left" valign="top" rowspan="1" colspan="1">request is exiting</td></tr></tbody></table></div><p>The normal state transitions are:</p><ul><li><p><span class="nctnt ncbi-monospace">AB</span> --&gt; <span class="nctnt ncbi-monospace">A</span> --&gt; <span class="nctnt ncbi-monospace">AE</span></p></li><li><p><span class="nctnt ncbi-monospace">AB</span> --&gt; <span class="nctnt ncbi-monospace">A</span> --&gt; { <span class="nctnt ncbi-monospace">RB</span> --&gt; <span class="nctnt ncbi-monospace">R</span> --&gt; <span class="nctnt ncbi-monospace">RE</span> } --&gt; <span class="nctnt ncbi-monospace">A</span> --&gt; ... --&gt; { <span class="nctnt ncbi-monospace">RB</span> --&gt; <span class="nctnt ncbi-monospace">R</span> --&gt; <span class="nctnt ncbi-monospace">RE</span> } --&gt; <span class="nctnt ncbi-monospace">A</span> --&gt; <span class="nctnt ncbi-monospace">AE</span></p></li></ul><p>The access log events and messages are:</p><div class="table" id="ch_core.T.nc_log_messageevent__descripti"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Log Message</th><th align="left" valign="top" rowspan="1" colspan="1"></th><th align="left" valign="top" rowspan="1" colspan="1">Event / Description</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">start</span></td><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1">Start of application (see note below)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">stop</span> &lt;<span class="nctnt ncbi-var">exit_code</span>&gt; &lt;<span class="nctnt ncbi-var">timespan</span>&gt; [<span class="nctnt ncbi-monospace">SIG=</span>&lt;<span class="nctnt ncbi-var">exit_signal</span>&gt;]</td><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1">End of application</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><b>where:</b></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">exit_code</span></td><td align="left" valign="top" rowspan="1" colspan="1">Application exit code (zero if not set)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">timespan</span></td><td align="left" valign="top" rowspan="1" colspan="1">Application execution time</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">exit_signal</span></td><td align="left" valign="top" rowspan="1" colspan="1">Signal number, if application exited due to a signal</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">extra</span></td><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1">Arbitrary information (see note below)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">request-start</span></td><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1">Start of request (see note below)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">request-stop</span> &lt;<span class="nctnt ncbi-var">status</span>&gt; &lt;<span class="nctnt ncbi-var">timespan</span>&gt; &lt;<span class="nctnt ncbi-var">bytes_rd</span>&gt; &lt;<span class="nctnt ncbi-var">bytes_wr</span>&gt;</td><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1">End of request</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><b>where:</b></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">status</span></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_core.html#ch_core.Request_Exit_Status_Codes">Exit status of the request</a> (zero if not set)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">timespan</span></td><td align="left" valign="top" rowspan="1" colspan="1">Request execution time (zero if not set)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">bytes_rd</span></td><td align="left" valign="top" rowspan="1" colspan="1">Input data read during the request execution, in bytes (zero if not set)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">bytes_wr</span></td><td align="left" valign="top" rowspan="1" colspan="1">Output data written during the request execution, in bytes (zero if not set)</td></tr></tbody></table></div><p><span class="nctnt highlight">Note:</span> Make your log data more parsable!</p><p>In many cases the logs are collected and stored in the database for analysis. The NCBI log system now implements a special logic to parse (and then index) the user data provided in the request-start and extra log lines. It is therefore recommended that this data be presented in the following format (which is understood by the parser):</p><pre><span class="nctnt-pre ncbi-monospace">tag1=value1&amp;tag2=value2&amp;tag3=value3...</span></pre><p>where all tag and value fields are URL-encoded.</p><p>The format for error and trace messages is:</p><pre><span class="nctnt-pre ncbi-monospace">&lt;severity:10&gt;: &lt;module&gt;(&lt;err_code&gt;.&lt;err_subcode&gt; | &lt;err_text&gt;) "&lt;file&gt;", line &lt;line&gt;: &lt;class&gt;::&lt;func&gt; --- &lt;prefixes&gt; &lt;user_message&gt; &lt;err_code_message&gt; &lt;err_code_explanation&gt;</span></pre><p>The error and trace message fields are:</p><div class="table" id="ch_core.T.nc_fielddescriptionseveritymes"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Field</th><th align="left" valign="top" rowspan="1" colspan="1">Description</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">severity</span></td><td align="left" valign="top" rowspan="1" colspan="1">Message severity = { Trace | Info | Warning | Error | Critical | Fatal | Message[T|I|W|E|C|F] }</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">module</span></td><td align="left" valign="top" rowspan="1" colspan="1">Module where the post originates from (in most cases the module corresponds to a single library)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">err_code</span>, <span class="nctnt ncbi-monospace">err_subcode</span></td><td align="left" valign="top" rowspan="1" colspan="1">Numeric error code and subcode</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">err_text</span></td><td align="left" valign="top" rowspan="1" colspan="1">If the error has no numeric code, sometimes it can be represented as text</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">file</span>, <span class="nctnt ncbi-monospace">line</span></td><td align="left" valign="top" rowspan="1" colspan="1">File name and line number where the posting occured</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">class</span>, <span class="nctnt ncbi-monospace">func</span></td><td align="left" valign="top" rowspan="1" colspan="1">Class and/or function name where the posting occured: {Class:: | Class::Function() | ::Function()}</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">prefixes</span></td><td align="left" valign="top" rowspan="1" colspan="1">User-defined prefixes for the message</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">user_message</span></td><td align="left" valign="top" rowspan="1" colspan="1">The message itself</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">err_code_message</span></td><td align="left" valign="top" rowspan="1" colspan="1">Short error code description</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">err_code_explanation</span></td><td align="left" valign="top" rowspan="1" colspan="1">Detailed explanation of the error code</td></tr></tbody></table></div><p>Example application events (line continuation characters added for clarity):</p><pre><span class="nctnt-pre ncbi-monospace">03960/000/0000/AB 2C2D0F7851AB7E40 0005/0005 2006-09-27T13:41:56.034 \<br />widget3         UNK_CLIENT      UNK_SESSION              cgi_sample.cgi \<br />start<br />03960/000/0000/RB 2C2D0F7851AB7E40 0008/0008 2006-09-27T13:41:56.456 \<br />widget3         192.168.0.2     2C2D0F7851AB7E40_0000SID cgi_sample.cgi \<br />request-start<br />03960/000/0000/RE 2C2D0F7851AB7E40 0010/0010 2006-09-27T13:41:56.567 \<br />widget3         192.168.0.2     2C2D0F7851AB7E40_0000SID cgi_sample.cgi \<br />request-stop  200 0.105005566<br />03960/000/0000/AE 2C2D0F7851AB7E40 0012/0012 2006-09-27T13:41:56.789 \<br />widget3         UNK_CLIENT      UNK_SESSION              cgi_sample.cgi \<br />stop            0 0.149036509</span></pre><p>Example diagnostic message:</p><pre><span class="nctnt-pre ncbi-monospace">03960/000/0000/AB 2C2D0F7851AB7E40 0006/0006 2006-09-27T13:41:56.055 \<br />widget3         UNK_CLIENT      UNK_SESSION             cgi_sample.cgi \<br />Warning:      CGI --- CCgiSampleApplication::Init()<br />03960/000/0000/R  2C2D0F7851AB7E40 0009/0009 2006-09-27T13:41:56.066 \<br />widget3        192.168.0.2     2C2D0F7851AB7E40_0000SID cgi_sample.cgi \<br />Warning:      CGI --- CCgiSampleApplication::ProcessRequest()<br />15176/003/0006/R  2A763B485350C030 0098/0008 2006-10-17T12:59:47.333 \<br />widget3        192.168.0.2     2C2D0F7851AB7E40_0000SID my_app \<br />Error:        TEST "/home/user/c++/src/corelib/test/my_app.cpp", \<br />line 81: CMyApp::Thread_Run() --- Message from thread 3, for request 6</span></pre></div><div class="sec" id="ch_core.diag_post_flags"><h4><span class="title">Controlling the Appearance of Diagnostic Messages using Post Flags</span></h4><p>The post flags define additional information that will be inserted into the output messages and appear along with the message body. The standard format of a message is:</p><pre><span class="nctnt-pre ncbi-code">"&lt;file&gt;", line &lt;line&gt;: &lt;severity&gt;: (&lt;err_code&gt;.&lt;err_subcode&gt;) [&lt;prefix1&gt;::&lt;prefix2&gt;::&lt;prefixN&gt;] &lt;message&gt;\n<br />&lt;err_code_message&gt;\n<br />&lt;err_code_explanation&gt;</span></pre><p>where the presence of each field in the output is controlled by the post flags <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EDiagPostFlag">EDiagPostFlag</a> associated with the particular diagnostic message. The post flags are:</p><pre><span class="nctnt-pre ncbi-code">enum EDiagPostFlag {<br />    eDPF_File               = 0x1, ///&lt; Set by default #if _DEBUG; else not set<br />    eDPF_LongFilename       = 0x2, ///&lt; Set by default #if _DEBUG; else not set<br />    eDPF_Line               = 0x4, ///&lt; Set by default #if _DEBUG; else not set<br />    eDPF_Prefix             = 0x8, ///&lt; Set by default (always)<br />    eDPF_Severity           = 0x10,  ///&lt; Set by default (always)<br />    eDPF_ErrorID            = 0x20,  ///&lt; Module, error code and subcode<br />    eDPF_DateTime           = 0x80,  ///&lt; Include date and time<br />    eDPF_ErrCodeMessage     = 0x100, ///&lt; Set by default (always)<br />    eDPF_ErrCodeExplanation = 0x200, ///&lt; Set by default (always)<br />    eDPF_ErrCodeUseSeverity = 0x400, ///&lt; Set by default (always)<br />    eDPF_Location           = 0x800, ///&lt; Include class and function<br />                                     ///&lt; if any, not set by default<br />    eDPF_PID                = 0x1000,  ///&lt; Process ID<br />    eDPF_TID                = 0x2000,  ///&lt; Thread ID<br />    eDPF_SerialNo           = 0x4000,  ///&lt; Serial # of the post, process-wide<br />    eDPF_SerialNo_Thread    = 0x8000,  ///&lt; Serial # of the post, in the thread<br />    eDPF_RequestId          = 0x10000, ///&lt; fcgi iteration number or request ID<br />    eDPF_Iteration          = 0x10000, ///&lt; @deprecated<br />    eDPF_UID                = 0x20000, ///&lt; UID of the log<br /><br />    eDPF_ErrCode            = eDPF_ErrorID,  ///&lt; @deprecated<br />    eDPF_ErrSubCode         = eDPF_ErrorID,  ///&lt; @deprecated<br />    /// All flags (except for the "unusual" ones!)<br />    eDPF_All                = 0xFFFFF,<br /><br />    /// Default flags to use when tracing.<br />#if defined(NCBI_THREADS)<br />    eDPF_Trace              = 0xF81F,<br />#else<br />    eDPF_Trace              = 0x581F,<br />#endif<br /><br />    /// Print the posted message only; without severity, location, prefix, etc.<br />    eDPF_Log                = 0x0,<br /><br />    // "Unusual" flags -- not included in "eDPF_All"<br />    eDPF_PreMergeLines      = 0x100000, ///&lt; Remove EOLs before calling handler<br />    eDPF_MergeLines         = 0x200000, ///&lt; Ask diag.handlers to remove EOLs<br />    eDPF_OmitInfoSev        = 0x400000, ///&lt; No sev. indication if eDiag_Info<br />    eDPF_OmitSeparator      = 0x800000, ///&lt; No '---' separator before message<br /><br />    eDPF_AppLog             = 0x1000000, ///&lt; Post message to application log<br />    eDPF_IsMessage          = 0x2000000, ///&lt; Print "Message" severity name.<br /><br />    /// Hint for the current handler to make message output as atomic as<br />    /// possible (e.g. for stream and file handlers).<br />    eDPF_AtomicWrite        = 0x4000000,<br /><br />    /// Use global default flags (merge with).<br />    /// @sa SetDiagPostFlag(), UnsetDiagPostFlag(), IsSetDiagPostFlag()<br />    eDPF_Default            = 0x10000000,<br /><br />    /// Important bits which should be taken from the globally set flags<br />    /// even if a user attempts to override (or forgets to set) them<br />    /// when calling CNcbiDiag().<br />    eDPF_ImportantFlagsMask = eDPF_PreMergeLines |<br />                              eDPF_MergeLines |<br />                              eDPF_OmitInfoSev |<br />                              eDPF_OmitSeparator |<br />                              eDPF_AtomicWrite,<br /><br />    /// Use flags provided by user as-is, do not allow CNcbiDiag to replace<br />    /// "important" flags by the globally set ones.<br />    eDPF_UseExactUserFlags  = 0x20000000<br />};</span></pre><p>The default message format displays only the severity level and the message body. This can be overridden inside the constructor for a specific message, or globally, using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SetDiagPostFlag">SetDiagPostFlag()</a> on a selected flag. For example:</p><pre><span class="nctnt-pre ncbi-code">    SetDiagPostFlag(eDPF_DateTime); // set flag globally</span></pre></div></div><div class="sec" id="ch_core.diag_set_stream"><h3><span class="title">Defining the Output Stream</span></h3><p>The logging framework uses a global output stream. The default is to post messages to <span class="nctnt ncbi-var">CERR</span> ouput stream, but the stream destination can be reset at any time using:</p><pre><span class="nctnt-pre ncbi-code">SetDiagStream(CNcbiOstream* os, bool quick_flush,<br />              FDiagCleanup cleanup, void* cleanup_data)</span></pre><p>This function can be called numerous times, thus allowing different sections of the executable to write to different files. At any given time however, all messages will be associated with the same global output stream. Because the messages are completely buffered, each message will appear on whatever stream is active at the time the message actually completes.</p><p>And, of course, you can <a href="ch_core.html#ch_core.diag_handlers">provide</a> (using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SetDiagHandler">SetDiagHandler</a>) your own message posting handler <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDiagHandler.html">CDiagHandler</a>, which does not necessarily write the messages to a standard C++ output stream. To preserve compatibility with old code, SetDiagHandler also continues to accept raw callback functions of type <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=FDiagHandler">FDiagHandler</a>.</p><p>If the output stream is a file, you can optionally split the output into three streams, each written to a separate file:</p><ul><li><p>Application log - standard events (<span class="nctnt ncbi-monospace">start</span>, <span class="nctnt ncbi-monospace">stop</span>, <span class="nctnt ncbi-monospace">request-start</span>, <span class="nctnt ncbi-monospace">request-stop</span> and user defined <span class="nctnt ncbi-monospace">extra</span> events).</p></li><li><p>Error log - all messages with severity <span class="nctnt ncbi-var">Warning</span> and above.</p></li><li><p>Trace log - messages having severity <span class="nctnt ncbi-var">Info</span> and <span class="nctnt ncbi-var">Trace</span> messages.</p></li></ul><p>All three log files have the same name but different extensions: <span class="nctnt ncbi-path">.log</span>, <span class="nctnt ncbi-path">.err</span> and <span class="nctnt ncbi-path">.trace</span>.</p><p>To turn on the log file splitting, call (before the log file initialization):</p><pre><span class="nctnt-pre ncbi-code">int main(int argc, const char* argv[])<br />{<br />    SetSplitLogFile(true);<br /><br />    return CMyApp().AppMain(argc, argv);<br />}</span></pre><p>This function should be called before the application's constructor for the setting to be used from the very beginning.</p></div><div class="sec" id="ch_core.Tee_Output_to_STDERR"><h3><span class="title">Tee Output to STDERR</span></h3><p>Sometimes it is helpful to generate human-readable diagnostics on the console in addition to storing detailed diagnostics in the machine-parsable log files. In these cases, it is likely that both the message severity required to trigger output and the output format should be different for the log file and the console. For example:</p><div class="table" id="ch_core.T.nc_severityformatlog_fileerror"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Destination</th><th align="left" valign="top" rowspan="1" colspan="1">Severity</th><th align="left" valign="top" rowspan="1" colspan="1">Format</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Log File</td><td align="left" valign="top" rowspan="1" colspan="1">Error</td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_core.html#ch_core.The_New_Post_Format">new</a> (machine-parsable)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Console</td><td align="left" valign="top" rowspan="1" colspan="1">Warning</td><td align="left" valign="top" rowspan="1" colspan="1"><a href="ch_core.html#ch_core.The_Old_Post_Format">old</a> (human-readable)</td></tr></tbody></table></div><p>To set up this sort of tee, set these configuration parameters (see the <a href="http://www.ncbi.nlm.nih.gov/books/n/toolkit/ch_libconfig#ch_libconfig.libconfig_diag">library configuration chapter</a> for details):</p><div class="table" id="ch_core.T.nc_configuration_parameterexam"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Configuration Parameter</th><th align="left" valign="top" rowspan="1" colspan="1">Example Value</th><th align="left" valign="top" rowspan="1" colspan="1">Notes</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">DIAG_TEE_TO_STDERR</span></td><td align="left" valign="top" rowspan="1" colspan="1">True</td><td align="left" valign="top" rowspan="1" colspan="1">This turns on the tee.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">DIAG_OLD_POST_FORMAT</span></td><td align="left" valign="top" rowspan="1" colspan="1">False</td><td align="left" valign="top" rowspan="1" colspan="1">This makes the log file use the new format.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">DIAG_POST_LEVEL</span></td><td align="left" valign="top" rowspan="1" colspan="1">Error</td><td align="left" valign="top" rowspan="1" colspan="1">This sets the minimum severity required to post to the log file.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">DIAG_TEE_MIN_SEVERITY</span></td><td align="left" valign="top" rowspan="1" colspan="1">Warning</td><td align="left" valign="top" rowspan="1" colspan="1">This sets the minimum severity required to post to the console.</td></tr></tbody></table></div><p>Alternatively, you can use the <span class="nctnt ncbi-func">Console</span> manipulator to indicate that output should go to the console (in human-readable format):</p><pre><span class="nctnt-pre ncbi-code">ERR_POST_X(1, Console &lt;&lt; "My ERR_POST message.");</span></pre><p><span class="nctnt highlight">Note:</span> Output sent to the console using this manipulator will also go to the log file if the message severity at least meets the severity threshold for the log file. The effect of the manipulator lasts until the next flush, which typically occurs after each post.</p></div><div class="sec" id="ch_core.diag_buffering"><h3><span class="title">The Message Buffer</span></h3><p>Diagnostic messages (i.e. instances of the <span class="nctnt ncbi-class">CNcbiDiag</span> class) have a buffer that is initialized when the message is first instantiated. Additional information can then be appended to the message using the overloaded stream operator <span class="nctnt ncbi-code">&lt;&lt;</span>. Messages can then be terminated explicitly using <span class="nctnt ncbi-class">CNcbiDiag</span>'s stream manipulator <span class="nctnt ncbi-class">Endm</span>, or implicitly, when the <span class="nctnt ncbi-class">CNcbiDiag</span> object exits scope.</p><p>Implicit message termination also occurs as a side effect of applying one of the <a href="ch_core.html#ch_core.diag_severity">severity level manipulators</a>. Whenever the severity level is changed, <span class="nctnt ncbi-class">CNcbiDiag</span> also automatically executes the following two <span class="nctnt ncbi-monospace">manipulators</span>:</p><ul><li><p><span class="nctnt ncbi-class">Endm</span> -- the message is complete and the message buffer will be flushed</p></li><li><p><span class="nctnt ncbi-class">Reset</span> -- empty the contents of the current message buffer</p></li></ul><p>When the message controlled by an instance of <span class="nctnt ncbi-class">CNcbiDiag</span> is complete, <span class="nctnt ncbi-class">CNcbiDiag</span> calls a global callback function (of type <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=FDiagHandler">FDiagHandler</a>) and passes the message (along with its severity level) as the function arguments. The default callback function posts errors to the currently designated output stream, with the action (continue or abort) determined by the severity level of the message.</p></div><div class="sec" id="ch_core.Request_Exit_Status_Codes"><h3><span class="title">Request Exit Status Codes</span></h3><p>This section describes the possible values of the request exit codes used in NCBI. They appear in the application access log as:</p><pre><span class="nctnt-pre ncbi-monospace">request-stop &lt;status&gt; .....</span></pre><p>Request exit status codes are either <a href="ch_core.html#ch_core.Standard_HTTPlike_status_codes">standard</a> or <a href="ch_core.html#ch_core.NCBIspecific_status_codes">NCBI-specific</a>.</p><div class="sec" id="ch_core.Standard_HTTPlike_status_codes"><h4><span class="title">Standard (HTTP-like) status codes</span></h4><p>The NCBI request exit codes must conform to the HTTP status codes: </p><p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</a></p></div><div class="sec" id="ch_core.NCBIspecific_status_codes"><h4><span class="title">NCBI-specific status codes</span></h4><p>If the situation cannot be described using one of the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">standard (HTTP) status codes</a>, then an NCBI specific code should be used.</p><p>The NCBI-specific status codes must be different from the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">standard (HTTP) status codes</a>. At the same time these codes better follow at least the range requirements of the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">standard (HTTP) status codes</a>, that is they better belong to one of the following ranges:</p><div class="table" id="ch_core.T.nc_rangedescription120__199inf"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Range</th><th align="left" valign="top" rowspan="1" colspan="1">Description</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">120 – 199</td><td align="left" valign="top" rowspan="1" colspan="1">Informational/provisional response</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">220 – 299</td><td align="left" valign="top" rowspan="1" colspan="1">Success</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">320 – 399</td><td align="left" valign="top" rowspan="1" colspan="1">Redirection</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">420 – 499</td><td align="left" valign="top" rowspan="1" colspan="1">Bad request (client error)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">520 – 599</td><td align="left" valign="top" rowspan="1" colspan="1">Server Error</td></tr></tbody></table></div><p>So far we have the following NCBI specific status codes:</p><div class="table" id="ch_core.T.nc_valuedescription0unknown_er"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Value</th><th align="left" valign="top" rowspan="1" colspan="1">Description</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">0</td><td align="left" valign="top" rowspan="1" colspan="1">Unknown error</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">555</td><td align="left" valign="top" rowspan="1" colspan="1">NCBI Network Dispatcher refused a request from and outside user which is in its "abusers list"</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">1000 + errno</td><td align="left" valign="top" rowspan="1" colspan="1">Unclassifiable server error when only errno is known (NOTE: the value of errno can be different on different platforms!)</td></tr></tbody></table></div></div></div><div class="sec" id="ch_core.diag_errcodes"><h3><span class="title">Error codes and their Descriptions</span></h3><p>Error codes and subcodes are posted to an output stream only if applicable <a href="ch_core.html#ch_core.diag_post_flags">post flags</a> were set. In addition to error codes, the logging framework can also post text explanations. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDiagErrCodeInfo.html">CDiagErrCodeInfo</a> class is used to find the error message that corresponds to a given error code/subcode. Such descriptions could be specified directly in the program code or placed in a separate message file. It is even possible to use several such files simultaneously. <span class="nctnt ncbi-class">CDiagErrCodeInfo</span> can also read error descriptions from any input stream(s), not necessarily files.</p><div class="sec" id="ch_core.err_msg_file"><h4><span class="title">Preparing an Error Message File</span></h4><p>The error message file contains plain ASCII text data. We would suggest using the <span class="nctnt ncbi-path">.msg</span> extension, but this is not mandatory. For example, the message file for an application named <span class="nctnt ncbi-app">SomeApp</span> might be called <span class="nctnt ncbi-path">SomeApp.msg</span>.</p><p>The message file must contain a line with the keyword <span class="nctnt ncbi-monospace">MODULE</span> in it, followed by the name of the module (in our example <span class="nctnt ncbi-monospace">SomeApp</span>). This line must be placed in the beginning of the file, before any other declarations. Lines with symbol <span class="nctnt ncbi-code">#</span> in the first position are treated as comments and ignored.</p><p>Here is an example of the message file:</p><pre><span class="nctnt-pre ncbi-code"># This is a message file for application "SomeApp"<br />MODULE SomeApp<br /># ------ Code 1 ------<br />$$ NoMemory, 1, Fatal : Memory allocation error<br /># ------ Code 2 ------<br />$$ File, 2, Critical : File error<br />$^ Open, 1 : Error open a specified file<br />This often indicates that the file simply does not exist.<br />Or, it may exist but you do not have permission to access<br />the file in the requested mode.<br />$^ Read, 2, Error : Error read file<br />Not sure what would cause this...<br />$^ Write, 3, Critical<br />This may indicate that the filesystem is full.<br /># ------ Code 3 ------<br />$$ Math, 3<br />$^ Param, 20<br />$^ Range, 3</span></pre><p>Lines beginning with <span class="nctnt ncbi-code">$$</span> define a top-level error code. Similarly, lines beginning with <span class="nctnt ncbi-code">$^</span> define subcodes of the top-level error code. In the above example <span class="nctnt ncbi-monospace">Open</span> is a subcode of <span class="nctnt ncbi-monospace">File</span> top-level error, which means the error with code 2 and subcode 1.</p><p>Both types of lines have similar structure:</p><pre><span class="nctnt-pre ncbi-code">$$/$^ &lt;mnemonic_name&gt;, &lt;code&gt; [, &lt;severity&gt; ] [: &lt;message&gt; ] \n<br />[ &lt;explanation&gt; ]</span></pre><p>where</p><ul><li><p><span class="nctnt ncbi-var">mnemonic_name</span> (<i>required</i>) Internal name of the error code/subcode. This is used as a part of an error name in a program code - so, it should also be a correct C/C++ identifier.</p></li><li><p><span class="nctnt ncbi-var">code</span> (<i>required</i>) Integer identifier of the error.</p></li><li><p><span class="nctnt ncbi-var">severity</span> (<i>optional</i>) This may be supplied to specify the severity level of the error. It may be specified as a severity level string (valid values are <span class="nctnt ncbi-monospace">Info, Warning, Error, Critical, Fatal, Trace</span>) or as an integer in the range from 0 (<span class="nctnt ncbi-var">eDiag_Info</span>) to 5 (<span class="nctnt ncbi-var">eDiag_Trace</span>). While integer values are acceptable, string values are more readable. If the severity level was not specified or could not be recognized, it is ignored, or inherited from a higher level (the severity of a subcode becomes the same as the severity of a top-level error code, which contains this subcode). As long as diagnostic <span class="nctnt ncbi-var">eDPF_ErrCodeUseSeverity</span> flag is set, the severity level specified in the message file overrides the one specified in a program, which allows for runtime customization. In the above example, <span class="nctnt ncbi-monospace">Critical</span> severity level will be used for all <span class="nctnt ncbi-monospace">File</span> errors, except <span class="nctnt ncbi-monospace">Read</span> subcode, which would have <span class="nctnt ncbi-monospace">Error</span> severity level.</p></li><li><p><span class="nctnt ncbi-var">message</span> (<i>optional</i>) Short description of the error. It must be a single-line message. As long as diagnostic <span class="nctnt ncbi-var">eDPF_ErrCodeMessage</span> flag is set, this message is posted as a part of the diagnostic output.</p></li><li><p><span class="nctnt ncbi-var">explanation</span> (<i>optional</i>) Following a top-level error code or a subcode definition string, it may be one or several lines of an explanation text. Its purpose is to provide additional information, which could be more detailed description of the error, or possible reasons of the problem. This text is posted in a diagnostic channel only if <span class="nctnt ncbi-var">eDPF_ErrCodeExplanaton</span> flag was set.</p></li></ul><p>Error message files can be automatically read by setting a configuration parameter. You can either define the <span class="nctnt ncbi-monospace">MessageFile</span> entry in the <span class="nctnt ncbi-monospace">DEBUG</span> section of the application registry, or set the environment variable <span class="nctnt ncbi-var">NCBI_CONFIG__DEBUG__MessageFile</span> (note the double-underscores and character case).</p></div></div><div class="sec" id="ch_core.diag_handlers"><h3><span class="title">Defining Custom Handlers using CDiagHandler</span></h3><p>The user can install his own handler (of type <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDiagHandler.html">CDiagHandler</a>,) using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SetDiagHandler">SetDiagHandler()</a>. CDiagHandler is a simple abstract class:</p><pre><span class="nctnt-pre ncbi-code">class  CDiagHandler<br />{<br />public:<br />    /// Destructor.<br />    virtual ~CDiagHandler(void) {}<br />    /// Post message to handler.<br />    virtual void Post(const SDiagMessage&amp; mess) = 0;<br />};</span></pre><p>where <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SDiagMessage">SDiagMessage</a> is a simple struct defined in <span class="nctnt ncbi-path">ncbidiag.hpp</span> whose data members' values are obtained from the <span class="nctnt ncbi-class">CNcbiDiag</span> object. The transfer of data values occurs at the time that <span class="nctnt ncbi-func">Post</span> is invoked. See also the section on <a href="ch_debug.html#ch_debug.std_cpp_message_post">Message posting</a> for a more technical discussion.</p></div><div class="sec" id="ch_core.ERR_POST"><h3><span class="title">The ERR_POST and LOG_POST Macros</span></h3><p>A family of <span class="nctnt ncbi-macro">ERR_POST*</span> macros and a corresponding family of <span class="nctnt ncbi-macro">LOG_POST*</span> macros are available for routine error posting. Each family has a set of macros:</p><ul><li><p><span class="nctnt ncbi-macro">{ERR|LOG}_POST(msg)</span> – for posting a simple message. <span class="nctnt highlight">Note:</span> these macros are deprecated. Use <span class="nctnt ncbi-macro">{ERR|LOG}_POST_X</span> instead (except for tests) for more flexible error statistics and logging.</p></li><li><p><span class="nctnt ncbi-macro">{ERR|LOG}_POST_X(subcode, msg)</span> – for posting a default error code, a given subcode, and a message. Each call to <span class="nctnt ncbi-macro">{ERR|LOG}_POST_X</span> must use a different subcode for proper error statistics and logging. The default error code is selected by <span class="nctnt ncbi-macro">NCBI_USE_ERRCODE_X</span>. The error code is selected from those defined by <span class="nctnt ncbi-macro">NCBI_DEFINE_ERRCODE_X</span> in the appropriate header file, e.g. <span class="nctnt ncbi-path">include/corelib/error_codes.h</span>.</p></li><li><p><span class="nctnt ncbi-macro">{ERR|LOG}_POST_EX(code, subcode, msg)</span> – for posting a given error code, a given error subcode, and a message. This macro should only be used if you have to use a variable for the subcode, or to specify an error code other than the current default. In all other cases (except for tests), use <span class="nctnt ncbi-macro">{ERR|LOG}_POST_X</span> for more flexible error statistics and logging.</p></li><li><p><span class="nctnt ncbi-macro">{ERR|LOG}_POST_XX(code, subcode, msg)</span> – these macros must be used in place of <span class="nctnt ncbi-macro">{ERR|LOG}_POST_X</span> within header files so that the same error code will be used for header-defined code, regardless of the error codes that including files may use.</p></li></ul><p>The <span class="nctnt ncbi-macro">LOG_POST_*</span> macros just write a string to the log file, and are useful if a human-readable log file is desired. The output from the <span class="nctnt ncbi-macro">ERR_POST_*</span> macros is not easily read by humans, but facilitates automatic indexing for searching and/or error statistics. There are multiple flags to <a href="ch_core.html#ch_core.diag_post_flags">control the appearance of the message</a> generated by the <span class="nctnt ncbi-macro">ERR_POST_*</span> macros.</p><p>The <span class="nctnt ncbi-macro">LOG_POST_*</span> and <span class="nctnt ncbi-macro">ERR_POST_*</span> macros implicitly create a temporary <span class="nctnt ncbi-class">CNcbiDiag</span> object and put the passed "message" into it with a default severity of <span class="nctnt ncbi-var">eDiag_Error</span>. A <a href="ch_core.html#ch_core.diag_severity">severity level manipulator</a> can be applied if desired, to modify the message's severity level. For example:</p><pre><span class="nctnt-pre ncbi-code">long lll = 345;<br />ERR_POST_X(1, "My ERR_POST message, print long: " &lt;&lt; lll);</span></pre><p>would write to the diagnostic stream something like:</p><pre><span class="nctnt-pre ncbi-monospace">Error: (1501.1) My ERR_POST message, print long: 345</span></pre><p>while:</p><pre><span class="nctnt-pre ncbi-code">double ddd = 123.345;<br />ERR_POST_X(1, Warning &lt;&lt; "My ERR_POST message, print double: " &lt;&lt; ddd);</span></pre><p>would write to the diagnostic stream something like:</p><pre><span class="nctnt-pre ncbi-monospace">Warning: (1501.1) My ERR_POST message, print double: 123.345</span></pre><p>See the <a href="ch_core.html#ch_core.Log_File_Format">Log File Format</a> section for more information on controlling the format of diagnostics messages.</p><p><span class="nctnt highlight">Note:</span> Most of the above macros make use of the macro definition <span class="nctnt ncbi-macro">NCBI_USE_ERRCODE_X</span>. This definition must be present in your source code, and must be defined in terms of an existing error code name. By convention, error code names are defined in header file named <span class="nctnt ncbi-path">error_codes.hpp</span> in the relevant directory, for example <span class="nctnt ncbi-path">include/corelib/error_codes.hpp</span>.</p><p>To set up new error codes, pick appropriate names and error code numbers that don't match existing values, and decide how many subcodes you'll need for each error code. For example, the following sets up three error codes to deal with different categories of errors within a library, and specifies the number of subcodes for each category:</p><pre><span class="nctnt-pre ncbi-code">// Note: The following should be in src/app/my_prog/error_codes.hpp.<br />...<br />BEGIN_NCBI_SCOPE<br />...<br />NCBI_DEFINE_ERRCODE_X(MyLib_Cat1, 1501, 5);<br />NCBI_DEFINE_ERRCODE_X(MyLib_Cat2, 1502, 6);<br />NCBI_DEFINE_ERRCODE_X(MyLib_Cat3, 1503, 1);<br />// where:<br />//      MyLib_*   -- the error code names<br />//      1501, etc -- the error code numbers, typically starting at N*100+1<br />//      5, etc    -- how many subcodes you need for the given error code<br />...<br />END_NCBI_SCOPE</span></pre><p>Now you can use the error code in your library's implementation:</p><pre><span class="nctnt-pre ncbi-code">// The following should be in your source files.<br />...<br />// include the relevant error_codes header, for example:<br />#include &lt;include/corelib/error_codes.hpp&gt;<br />...<br />#define NCBI_USE_ERRCODE_X   MyLib_Cat1 // sets the default error code for this file<br />...<br />    ERR_POST_X(5, Critical &lt;&lt; "Your message here."); // uses the default error code</span></pre><p>Generally, the default error code and the <span class="nctnt ncbi-macro">ERR_POST_X</span> macro should be used. If it is necessary to use a non-default error code, that error code and the appropriate subcode may be used with the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ErrCode">ErrCode</a> manipulator in the <span class="nctnt ncbi-macro">ERR_POST</span> macro. For example:</p><pre><span class="nctnt-pre ncbi-code">// use a non-default error code (1501 in this example) and subcode 3<br />ERR_POST(ErrCode(1501, 3) &lt;&lt; "My error message.");</span></pre></div><div class="sec" id="ch_core._TRACE"><h3><span class="title">The _TRACE macro</span></h3><p>The <span class="nctnt ncbi-macro">_TRACE(message)</span> macro is a debugging tool that allows the user to insert trace statements that will only be posted if the code was <a href="ch_debug.html#ch_debug.debug_mode_internal">compiled in debug mode</a>, and provided that the tracing has been turned on. If <span class="nctnt ncbi-var">DIAG_TRACE</span> is defined as an environment variable, or as an entry in the [DEBUG] section of your configuration file (<span class="nctnt ncbi-path">*.ini</span>), the initial state of tracing is <span class="nctnt ncbi-monospace">on</span>. By default, if no such variable or registry entry is defined, tracing is <span class="nctnt ncbi-monospace">off</span>. <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=SetDiagTrace">SetDiagTrace</a><span class="nctnt ncbi-func"> (EDiagTrace enable, EDiagTrace default)</span> is used to turn tracing on/off.</p><p>Just like <span class="nctnt ncbi-macro">ERR_POST</span>, the <span class="nctnt ncbi-macro">_TRACE</span> macro takes a message, and the message will be posted only if tracing has been enabled. For example:</p><pre><span class="nctnt-pre ncbi-code">SetDiagTrace(eDT_Disable);<br />_TRACE("Testing the _TRACE macro");<br />SetDiagTrace(eDT_Enable);<br />_TRACE("Testing the _TRACE macro AGAIN");</span></pre><p>Here, only the second trace message will be posted, as tracing is disabled when the first <span class="nctnt ncbi-macro">_TRACE()</span> macro call is executed.</p></div><div class="sec" id="ch_core.Stack_Traces"><h3><span class="title">Stack Traces</span></h3><p><span class="nctnt ncbi-class">CStackTrace</span> objects have special formatting: a "<span class="nctnt ncbi-monospace">Stack trace:</span>" line is added before the stack trace and standard indentation is used. This formatting is also used when printing the stack trace for exceptions.</p><p>Using stack traces with diagnostics is discussed in the following topics:</p><ul><li><p><a href="ch_core.html#ch_core.Printing_a_Stack_Trace">Printing a Stack Trace</a></p></li><li><p><a href="ch_core.html#ch_core.Obtaining_a_Stack_Trace_for_Exce">Obtaining a Stack Trace for Exceptions</a></p></li></ul><div class="sec" id="ch_core.Printing_a_Stack_Trace"><h4><span class="title">Printing a Stack Trace</span></h4><p>A stack trace can be saved simply by creating a CStackTrace object. Then the object can be posted in an error message, for example:</p><pre><span class="nctnt-pre ncbi-code">ERR_POST_X(1, Error &lt;&lt; "Your message here." &lt;&lt; CStackTrace());</span></pre><p>An example of a stack trace output on Linux:</p><pre><span class="nctnt-pre ncbi-monospace">Error: (1501.1) Your message here.<br />     Stack trace:<br />      ./my_prog ???:0 ncbi::CStackTraceImpl::CStackTraceImpl() offset=0x5D<br />      ./my_prog ???:0 ncbi::CStackTrace::CStackTrace(std::string const&amp;) offset=0x28<br />      ./my_prog ???:0 CMyProg::Run() offset=0xAF3<br />      ./my_prog ???:0 ncbi::CNcbiApplication::x_TryMain(ncbi::EAppMyProgStream, char const*, int*, bool*) offset=0x6C8<br />      ./my_prog ???:0 ncbi::CNcbiApplication::AppMain(int, char const* const*, char const* const*, ncbi::EAppMyProgStream, char const*, std::string const&amp;) offset=0x11BA<br />      ./my_prog ???:0 main offset=0x60<br />      /lib64/tls/libc.so.6 ???:0 __libc_start_main offset=0xEA<br />      ./my_prog ???:0 std::__throw_logic_error(char const*) offset=0x62</span></pre></div><div class="sec" id="ch_core.Obtaining_a_Stack_Trace_for_Exce"><h4><span class="title">Obtaining a Stack Trace for Exceptions</span></h4><p>The stack trace can be saved by <span class="nctnt ncbi-class">CException</span> and derived classes automatically if the exception's severity is equal to or above the level set in the <span class="nctnt ncbi-var">EXCEPTION_STACK_TRACE_LEVEL</span> environment variable or <a href="ch_libconfig.html#ch_libconfig.NCBI">configuration parameter</a>. The default level is <span class="nctnt ncbi-var">eDiag_Critical</span>, so that most exceptions do not save the stack trace (the default exception's severity is <span class="nctnt ncbi-var">eDiag_Error</span>).</p><p>When printing an exception, the diagnostics code checks if a stack trace is available and if so, automatically prints the stack trace along with the exception.</p><p>An example of an exception with a stack trace on Linux:</p><pre><span class="nctnt-pre ncbi-monospace">Error: (106.16) Application's execution failed<br />NCBI C++ Exception:<br />    Error: (CMyException::eMyErrorXyz) Your message here.<br />     Stack trace:<br />      ./my_prog ???:0 ncbi::CStackTraceImpl::CStackTraceImpl() offset=0x5D<br />      ./my_prog ???:0 ncbi::CStackTrace::CStackTrace(std::string const&amp;) offset=0x28<br />      ./my_prog ???:0 ncbi::CException::x_GetStackTrace() offset=0x86<br />      ./my_prog ???:0 ncbi::CException::x_Init(ncbi::CTestCompileInfo const&amp;, std::string const&amp;, ncbi::CException const*, ncbi::ETestSev) offset=0xE9<br />      ./my_prog ???:0 ncbi::CException::CException(ncbi::CTestCompileInfo const&amp;, ncbi::CException const*, ncbi::CException::EErrCode, std::string const&amp;, ncbi::ETestSev) offset=0x119<br />      ./my_prog ???:0 CMyException::CMyException(ncbi::CTestCompileInfo const&amp;, ncbi::CException const*, CMyException::EErrCode, std::string const&amp;, ncbi::ETestSev) offset=0x43<br />      ./my_prog ???:0 CMyTestTest::Run() offset=0xD3A<br />      ./my_prog ???:0 ncbi::CNcbiApplication::x_TryMain(ncbi::EAppTestStream, char const*, int*, bool*) offset=0x6C8<br />      ./my_prog ???:0 ncbi::CNcbiApplication::AppMain(int, char const* const*, char const* const*, ncbi::EAppTestStream, char const*, std::string const&amp;) offset=0x11BA<br />      ./my_prog ???:0 main offset=0x60<br />      /lib64/tls/libc.so.6 ???:0 __libc_start_main offset=0xEA<br />      ./my_prog ???:0 std::__throw_logic_error(char const*) offset=0x62</span></pre></div></div></div><div class="sec" id="ch_core.debug_module_ref"><h2><span class="title">Debug Macros</span></h2><p>A number of debug macros such as <span class="nctnt ncbi-macro">_TRACE</span>, <span class="nctnt ncbi-macro">_TROUBLE</span>, <span class="nctnt ncbi-macro">_ASSERT</span>, <span class="nctnt ncbi-macro">_VERIFY</span>, <span class="nctnt ncbi-macro">_DEBUG_ARG</span> can be used when the <span class="nctnt ncbi-macro">_DEBUG</span> macro is defined.</p><p>These macros are part of CORELIB. However, they are discussed in a separate chapter on <a href="ch_debug.html">Debugging, Exceptions, and Error Handling</a>.</p></div><div class="sec" id="ch_core.exception_handling_ref"><h2><span class="title">Handling Exceptions</span></h2><p>The CORELIB defines an extended exception handling mechanism based on the C++ std::exception, but which considerably extends this mechanism to provide a backlog, history of unfinished tasks, and more meaningful reporting on the exception itself.</p><p>While the extended exception handling mechanism is part of CORELIB, it is discussed in a separate chapter on <a href="ch_debug.html">Debugging, Exceptions, and Error Handling</a>.</p></div><div class="sec" id="ch_core.std_ncbi_types"><h2><span class="title">Defining the Standard NCBI C++ types and their Limits</span></h2><p>The following section provides a reference to the files and limit values used to in the C++ Toolkit to write portable code. An <a href="ch_intro.html#ch_intro.intro_pdef">introduction to the scope of some of these portability definitions</a> is presented the introduction chapter.</p><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_core.html#ch_core.port_header_files">Headers Files containing Portability Definitions</a></p></li><li><p><a href="ch_core.html#ch_core.built_in_integral_types">Built-in Integral Types</a></p></li><li><p><a href="ch_core.html#ch_core.auxiliary_types">Auxiliary Types</a></p></li><li><p><a href="ch_core.html#ch_core.fixed_size_integers">Fixed-size Integer Types</a></p></li><li><p><a href="ch_core.html#ch_core.big_scalar">The "Ncbi_BigScalar" Type</a></p></li><li><p><a href="ch_core.html#ch_core.types_policy">Encouraged and Discouraged Types</a></p></li></ul><div class="sec" id="ch_core.port_header_files"><h3><span class="title">Headers Files containing Portability Definitions</span></h3><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/corelib/ncbitype.h">corelib/ncbitype.h</a> -- definitions of NCBI fixed-size integer types</p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/corelib/ncbi_limits.h">corelib/ncbi_limits.h</a> -- numeric limits for:</p><ul><li><p>NCBI fixed-size integer types</p></li><li><p>built-in integer types</p></li><li><p>built-in floating-point types</p></li></ul></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/corelib/ncbi_limits.hpp">corelib/ncbi_limits.hpp</a> -- temporary (and incomplete) replacement for the Standard C++ Template Library's API</p></li></ul></div><div class="sec" id="ch_core.built_in_integral_types"><h3><span class="title">Built-in Integral Types</span></h3><p>We <a href="ch_core.html#ch_core.types_policy">encourage</a> the use of standard C/C++ types shown in <a href="ch_core.html#ch_core.T5">Table 5</a>, and we state that the following assumptions (no less, no more) on their sizes and limits will be valid for all supported platforms:</p><div class="table" id="ch_core.T5"><div class="caption"><p>Table 5. Standard C/C++ Types</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Name</th><th align="left" valign="top" rowspan="1" colspan="1">Size(bytes)</th><th align="left" valign="top" rowspan="1" colspan="1">Min</th><th align="left" valign="top" rowspan="1" colspan="1">Max</th><th align="left" valign="top" rowspan="1" colspan="1">Note</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">char</span></td><td align="left" valign="top" rowspan="1" colspan="1">1</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_Char</span> (0 or -128)</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_Char</span> (256 or 127)</td><td align="left" valign="top" rowspan="1" colspan="1">It can be either signed or unsigned! Use it wherever you don't care of +/- (e.g. in character strings). </td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">signed char</span></td><td align="left" valign="top" rowspan="1" colspan="1">1</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_SChar</span> (-128)</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_SChar</span> (127)</td><td align="left" valign="top" rowspan="1" colspan="1"></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">unsigned char</span></td><td align="left" valign="top" rowspan="1" colspan="1">1</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_UChar</span> (0)</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UChar</span> (255)</td><td align="left" valign="top" rowspan="1" colspan="1"></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">short, signed short</span></td><td align="left" valign="top" rowspan="1" colspan="1">2 or more</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_Short</span> (-32768 or less)</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_Short</span> (32767 or greater)</td><td align="left" valign="top" rowspan="1" colspan="1">Use <span class="nctnt ncbi-type">"int"</span> if size isn't critical</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">usigned short</span></td><td align="left" valign="top" rowspan="1" colspan="1">2 or more</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_UShort</span> (0)</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UShort</span> (65535 or greater)</td><td align="left" valign="top" rowspan="1" colspan="1">Use <span class="nctnt ncbi-type">"unsigned int"</span> if size isn't critical</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">int</span>, <span class="nctnt ncbi-var">signed int</span></td><td align="left" valign="top" rowspan="1" colspan="1">4 or more</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_Int</span> (-2147483648 or less)</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_Int</span> (2147483647 or greater)</td><td align="left" valign="top" rowspan="1" colspan="1"></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">unsigned int</span></td><td align="left" valign="top" rowspan="1" colspan="1">4 or more</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_UInt</span> (0)</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UInt</span> (4294967295 or greater)</td><td align="left" valign="top" rowspan="1" colspan="1"></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">double</span></td><td align="left" valign="top" rowspan="1" colspan="1">4 or more</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_Double</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_Double</span></td><td align="left" valign="top" rowspan="1" colspan="1"></td></tr></tbody></table><div class="table-wrap-foot"><div class="small" id="ch_core.TF.5"><p>Types <span class="nctnt ncbi-type">"long"</span> and <span class="nctnt ncbi-type">"float"</span> are <a href="ch_core.html#ch_core.types_policy"><b>discouraged</b></a> to use in the portable code.</p></div><div class="small" id="ch_core.TF.6"><p>Type <span class="nctnt ncbi-type">"long long"</span> is <b>prohibited</b> to use in the portable code.</p></div></div></div></div><div class="sec" id="ch_core.auxiliary_types"><h3><span class="title">Auxiliary Types</span></h3><p>Use type <span class="nctnt ncbi-type">"bool"</span> to represent boolean values. It accepts one of { <span class="nctnt ncbi-monospace">false</span>, <span class="nctnt ncbi-monospace">true</span> }.</p><p>Use type <span class="nctnt ncbi-type">"size_t"</span> to represent a size of memory structure, e.g. obtained as a result of <span class="nctnt ncbi-code">sizeof</span> operation.</p><p>Use type <span class="nctnt ncbi-type">"SIZE_TYPE"</span> to represent a size of standard C++ <span class="nctnt ncbi-type">"string"</span> - this is a portable substitution for <span class="nctnt ncbi-type">"std::string::size_type"</span>.</p></div><div class="sec" id="ch_core.fixed_size_integers"><h3><span class="title">Fixed-size Integer Types</span></h3><p>Sometimes it is necessary to use an integer type which:</p><ul><li><p>has a well-known fixed size(and lower/upper limits)</p></li><li><p>be just the same on all platforms(but maybe a byte/bit order, depending on the processor architecture)</p></li></ul><p>NCBI C++ standard headers provide the fixed-size integer types shown in <a href="ch_core.html#ch_core.T6">Table 6</a>:</p><div class="table" id="ch_core.T6"><div class="caption"><p>Table 6. Fixed-integer Types</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Name</th><th align="left" valign="top" rowspan="1" colspan="1">Size(bytes)</th><th align="left" valign="top" rowspan="1" colspan="1">Min</th><th align="left" valign="top" rowspan="1" colspan="1">Max</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">Char, Int1</span></td><td align="left" valign="top" rowspan="1" colspan="1">1</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_I1</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_I1</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">Uchar, Uint1</span></td><td align="left" valign="top" rowspan="1" colspan="1">1</td><td align="left" valign="top" rowspan="1" colspan="1">0</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UI1</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">Int2</span></td><td align="left" valign="top" rowspan="1" colspan="1">2</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_I2</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_I2</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">Uint2</span></td><td align="left" valign="top" rowspan="1" colspan="1">2</td><td align="left" valign="top" rowspan="1" colspan="1">0</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UI2</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">Int4</span></td><td align="left" valign="top" rowspan="1" colspan="1">4</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_I4</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_I4</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">Uint4</span></td><td align="left" valign="top" rowspan="1" colspan="1">4</td><td align="left" valign="top" rowspan="1" colspan="1">0</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UI4</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">Int8</span></td><td align="left" valign="top" rowspan="1" colspan="1">8</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_I8</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_I8</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-type">Uint8</span></td><td align="left" valign="top" rowspan="1" colspan="1">8</td><td align="left" valign="top" rowspan="1" colspan="1">0</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UI8</span></td></tr></tbody></table></div><p>In <a href="ch_core.html#ch_core.T7">Table 7</a>, the <span class="nctnt ncbi-var">"kM*_*"</span> are constants of relevant fixed-size integer type. They are guaranteed to be equal to the appropriate <span class="nctnt ncbi-monospace">preprocessor constants</span> from the old NCBI C headers(<span class="nctnt ncbi-var">"INT*_M*"</span>). Please also note that the mentioned <span class="nctnt ncbi-var">"INT*_M*"</span> are not defined in the C++ headers - in order to discourage their use in the C++ code.</p><div class="table" id="ch_core.T7"><div class="caption"><p>Table 7. Correspondence between the kM*_* constants and the old style INT*_M* constants</p></div><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Constant(NCBI C++)</th><th align="left" valign="top" rowspan="1" colspan="1">Value</th><th align="left" valign="top" rowspan="1" colspan="1">Define(NCBI C)</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_I1</span></td><td align="left" valign="top" rowspan="1" colspan="1">-128</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">INT1_MIN</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_I1</span></td><td align="left" valign="top" rowspan="1" colspan="1">+127</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">INT1_MAX</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UI1</span></td><td align="left" valign="top" rowspan="1" colspan="1">+255</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">UINT1_MAX</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_I2</span></td><td align="left" valign="top" rowspan="1" colspan="1">-32768</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">INT2_MIN</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_I2</span></td><td align="left" valign="top" rowspan="1" colspan="1">+32767</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">INT2_MAX</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UI2</span></td><td align="left" valign="top" rowspan="1" colspan="1">+65535</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">UINT2_MAX</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_I4</span></td><td align="left" valign="top" rowspan="1" colspan="1">-2147483648</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">INT4_MIN</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_I4</span></td><td align="left" valign="top" rowspan="1" colspan="1">+2147483647</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">INT4_MAX</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UI4</span></td><td align="left" valign="top" rowspan="1" colspan="1">+4294967295</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">UINT4_MAX</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMin_I8</span></td><td align="left" valign="top" rowspan="1" colspan="1">-9223372036854775808</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">INT8_MIN</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_I8</span></td><td align="left" valign="top" rowspan="1" colspan="1">+9223372036854775807</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">INT8_MAX</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">kMax_UI8</span></td><td align="left" valign="top" rowspan="1" colspan="1">+18446744073709551615</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">UINT8_MAX</span></td></tr></tbody></table></div></div><div class="sec" id="ch_core.big_scalar"><h3><span class="title">The <span class="nctnt ncbi-type">"Ncbi_BigScalar"</span> Type</span></h3><p>NCBI C++ standard headers also define a special type <span class="nctnt ncbi-type">"Ncbi_BigScalar"</span>. The only assumption that can be made(and used in your code) is that <span class="nctnt ncbi-type">"Ncbi_BigScalar"</span> variable has a size which is enough to hold any integral, floating-point or pointer variable like <span class="nctnt ncbi-type">"Int8"</span>, or <span class="nctnt ncbi-type">"double"("long double")</span>, or <span class="nctnt ncbi-type">"void*"</span>. This type can be useful e.g. to hold a callback data of arbitrary fundamental type; however, in general, the use of this type is discouraged.</p></div><div class="sec" id="ch_core.types_policy"><h3><span class="title">Encouraged and Discouraged Types</span></h3><p>For the sake of code portability and for better compatibility with the third-party and system libraries, one should follow the following set of rules:</p><ul><li><p>Use standard C/C++ integer types <span class="nctnt ncbi-type">"char", "signed char", "unsigned char", "short", "unsigned short", "int", "unsigned int"</span> in <b>any</b> case where the assumptions made for them in <a href="ch_core.html#ch_core.T5">Table 5</a> are enough.</p></li><li><p>It is not recommended to use <span class="nctnt ncbi-type">"long"</span> type unless it is absolutely necessary (e.g. in the lower-level or third-party code), and even if you have to, then try to localize the use of <span class="nctnt ncbi-type">"long"</span> as much as possible.</p></li><li><p>The same(as for <span class="nctnt ncbi-type">"long"</span>) is for the fixed-size types enlisted in <a href="ch_core.html#ch_core.T6">Table 6</a>. If you have to use these in your code, try to keep them inside your modules and avoid mixing them with standard C/C++ types (as in assignments, function arg-by-value passing and in arithmetic expressions) as much as possible.</p></li><li><p>For the policy on other types see in sections <a href="ch_core.html#ch_core.auxiliary_types">"Auxiliary types"</a> and "Floating point types".</p></li></ul></div></div><div class="sec" id="ch_core.smart_ptrs"><h2><span class="title">Understanding Smart Pointers: the <span class="nctnt ncbi-class">CObject</span> and <span class="nctnt ncbi-class">CRef</span> Classes</span></h2><p>This section provides reference information on the use of <span class="nctnt ncbi-class">CRef</span> and <span class="nctnt ncbi-class">CObject</span> classes. For an overview of these classes refer to the <a href="ch_intro.html#ch_intro.intro_cref">introductory chapter</a>.</p><p>The following is a list of topics discussed in this section:</p><ul><li><p><a href="ch_core.html#ch_core.auto_ptr">STL auto_ptrs</a></p></li><li><p><a href="ch_core.html#ch_core.CRef">The CRef Class</a></p></li><li><p><a href="ch_core.html#ch_core.CObject">The CObject Class</a></p></li><li><p><a href="ch_core.html#ch_core.CObjectFor">The CObjectFor class: using smart pointers for standard types</a></p></li><li><p><a href="ch_core.html#ch_core.CRef_usage">When to use CRefs and auto_ptrs</a></p></li><li><p><a href="ch_core.html#ch_core.CRef_pitfalls">CRef Pitfalls</a></p></li></ul><div class="sec" id="ch_core.auto_ptr"><h3><span class="title">STL auto_ptrs</span></h3><p>C programmers are well-acquainted with the advantages and pitfalls of using pointers. As is often the case, the good news is also the bad news:</p><ul><li><p>memory can be dynamically allocated as needed, but may not be deallocated as needed, due to unanticipated execution paths;</p></li><li><p>void pointers allow heterogeneous function arguments of different types, but type information may not be there when you need it.</p></li></ul><p>C++ adds some additional considerations to pointer management: STL containers cannot hold <span class="nctnt ncbi-monospace">reference</span> objects, so you are left with the choice of using either pointers or <span class="nctnt ncbi-monospace">copies</span> of objects. Neither choice is attractive, as pointers can cause memory leaks and the copy constructor may be expensive.</p><p>The idea behind a C++ <span class="nctnt ncbi-monospace">smart pointer</span> is to create a wrapper class capable of holding a pointer. The wrapper class's constructors and destructors can then handle memory management as the object goes in and out of scope. The problem with this solution is that it does not handle multiple pointers to the same resource properly, and it raises the issue of ownership. This is essentially what the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=auto_ptr">auto_ptr</a> offers, but this strategy is only safe to use when the resource maps to a single pointer variable.</p><p>For example, the following code has two very serious problems:</p><pre><span class="nctnt-pre ncbi-code">int* ip = new int(5);<br />{<br />    auto_ptr&lt;int&gt; a1(ip);<br />    auto_ptr&lt;int&gt; a2(ip);<br />}<br />*ip = 10/(*ip);</span></pre><p>The first problem occurs inside the block where the two <span class="nctnt ncbi-class">auto_ptr</span>s are defined. Both are referencing the same variable pointed to by yet another C pointer, and each considers itself to be the owner of that reference. Thus, when the block is exited, the <span class="nctnt ncbi-code">delete[]</span> operation is executed twice for the same pointer.</p><p>Even if this first problem did not occur - for example if only one <span class="nctnt ncbi-class">auto_ptr</span> had been defined - the second problem occurs when we try to dereference <span class="nctnt ncbi-var">ip</span>. The <span class="nctnt ncbi-code">delete</span> operation occurring as the block exits has now freed the dynamic memory to which ip points, so *ip now references unallocated memory.</p><p>The problem with using <span class="nctnt ncbi-class">auto_ptr</span> is that it provides semantics of strict ownership. When an <span class="nctnt ncbi-class">auto_ptr</span> is destructed, it deletes the object it points to, and therefore the object should not be pointed to simultaneously by others. Two or more <span class="nctnt ncbi-class">auto_ptr</span>s should not own the same object; that is, point to the same object. This can occur if two <span class="nctnt ncbi-class">auto_ptr</span>s are initialized to the same object, as seen in the above example where auto pointers <span class="nctnt ncbi-var">a1</span> and <span class="nctnt ncbi-var">a2</span> are both initialized with <span class="nctnt ncbi-var">ip</span>. In using <span class="nctnt ncbi-class">auto_ptr</span>, the programmer must ensure that situations similar to the above do not occur.</p></div><div class="sec" id="ch_core.CRef"><h3><span class="title">The CRef (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCRef.html">*</a>) Class</span></h3><p>These issues are addressed in the NCBI C++ Toolkit by using <span class="nctnt ncbi-monospace">reference-counted</span> smart pointers: a resource cannot be deallocated until <b>all</b> references to it have ceased to exist. The implementation of a smart pointer in the NCBI C++ Toolkit is actually divided between two classes: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCRef.html">CRef</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObject.html">CObject</a>.</p><p>The <span class="nctnt ncbi-class">CRef</span> class essentially provides a pointer interface to a <span class="nctnt ncbi-class">CObject</span>, while the <span class="nctnt ncbi-class">CObject</span> actually stores the data and maintains the reference count to it. The constructor used to create a new <span class="nctnt ncbi-class">CRef</span> pointing to a particular <span class="nctnt ncbi-class">CObject</span> automatically increments the object's reference count. Similarly, the <span class="nctnt ncbi-class">CRef</span> destructor automatically decrements the reference count. In both cases however, the modification of the reference count is implemented by a member function of the <span class="nctnt ncbi-class">CObject</span>. The <span class="nctnt ncbi-class">CRef</span> class itself does not have direct access to the reference count and contains only a single data member - its pointer to a <span class="nctnt ncbi-class">CObject</span>. In addition to the <span class="nctnt ncbi-class">CRef</span> class's constructors and destructors, its interface to the <span class="nctnt ncbi-class">CObject</span> pointer includes access/mutate functions such as:</p><pre><span class="nctnt-pre ncbi-code">bool Empty()<br />bool NotEmpty()<br />CObject* GetPointer()<br />CObject&amp; GetObject()<br />CObject* Release()<br />void Reset(CObject* newPtr)<br />void Reset(void)<br />operator bool()<br />bool operator!()<br />CRefBase&amp; operator=(const CRefBase&amp; ref)</span></pre><p>Both the <span class="nctnt ncbi-func">Release()</span> and <span class="nctnt ncbi-func">Reset()</span> functions set the <span class="nctnt ncbi-class">CRef</span> object's <span class="nctnt ncbi-var">m_ptr</span> to 0, thus effectively removing the reference to its <span class="nctnt ncbi-class">CObject</span>. There are important distinctions between these two functions however. The <span class="nctnt ncbi-func">Release()</span> method removes the reference without destroying the object, while the <span class="nctnt ncbi-func">Reset()</span> method may lead to the destruction of the object if there are no other references to it.</p><p>If the <span class="nctnt ncbi-class">CObject</span>'s internal reference count is 1 at the time <span class="nctnt ncbi-func">Release()</span> is invoked, that reference count will be decremented to 0, and a pointer to the <span class="nctnt ncbi-class">CObject</span> is returned. The <span class="nctnt ncbi-func">Release()</span> method can throw two types of exceptions: (1) a <span class="nctnt ncbi-monospace">null pointer</span> exception if <span class="nctnt ncbi-var">m_ptr</span> is already <span class="nctnt ncbi-monospace">0</span>, and (2) an <span class="nctnt ncbi-monospace">Illegal CObject::ReleaseReference()</span> exception if there are currently other references to that object. An object must be free of all references (but this one) before it can be "released". In contrast, the <span class="nctnt ncbi-func">Reset(void)</span> function simply resets the <span class="nctnt ncbi-class">CRef</span>'s <span class="nctnt ncbi-var">m_ptr</span> to 0, decrements the <span class="nctnt ncbi-class">CObject</span>'s reference count, and, if the <span class="nctnt ncbi-class">CObject</span> has no other references and was dynamically allocated, deletes the <span class="nctnt ncbi-class">CObject</span>.</p><p>Each member function of the <span class="nctnt ncbi-class">CRef</span> class also has a <span class="nctnt ncbi-code">const</span> implementation that is invoked when the pointer is to a <span class="nctnt ncbi-code">const</span> object. In addition, there is also a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCConstRef.html">CConstRef</a> class that parallels the <span class="nctnt ncbi-class">CRef</span> class. Both <span class="nctnt ncbi-class">CRef</span> and <span class="nctnt ncbi-class">CConstRef</span> are implemented as template classes, where the template argument specifies the type of object which will be pointed to. For example, in the section on <a href="ch_ser.html#ch_ser.traverse.html_accessMember">Traversing an ASN.1 Data Structure</a> we examined the structure of the <span class="nctnt ncbi-class">CBiostruc</span> class and found the following type definition</p><pre><span class="nctnt-pre ncbi-code">typedef list&lt; CRef&lt; ::CBiostruc_id &gt; &gt; TId;</span></pre><p>As described there, this <span class="nctnt ncbi-code">typedef</span> defines <span class="nctnt ncbi-type">TId</span> to be a list of pointers to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc__id.html">CBiostruc_id</a> objects. And as you might expect, <span class="nctnt ncbi-class">CBiostruc_id</span> is a specialized subclass of <span class="nctnt ncbi-class">CObject</span>.</p></div><div class="sec" id="ch_core.CObject"><h3><span class="title">The CObject (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObject.html">*</a>) Class</span></h3><p>The <span class="nctnt ncbi-class">CObject</span> class serves as a base class for all objects requiring a reference count. There is little overhead entailed by deriving a new class from this base class, and most objects in the NCBI C++ Toolkit are derived from the <span class="nctnt ncbi-class">CObject</span> class. For example, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCNCBINode.html">CNCBINode</a> is a direct descendant of <span class="nctnt ncbi-class">CObject</span>, and all of the other <span class="nctnt ncbi-type">HTML</span> classes descend either directly or indirectly from <span class="nctnt ncbi-class">CNCBINode</span>. Similarly, all of the ASN.1 classes defined in the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects">include/objects</a> directory, as well as many of the classes defined in the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial">include/serial</a> directory are derived either directly or indirectly from the <span class="nctnt ncbi-class">CObject</span> class.</p><p>The <span class="nctnt ncbi-class">CObject</span> class contains a single private data member, the reference counter, and a set of member functions which provide an interface to the reference counter. As such, it is truly a base class which has no stand-alone utility, as it does not even provide allocation for data values. It is the <span class="nctnt ncbi-monospace">descendant</span> classes, which inherit all the functionality of the <span class="nctnt ncbi-class">CObject</span> class, that provide the necessary richness in representation and allocation required for the widely diverse set of objects implemented in the NCBI C++ Toolkit. Nevertheless, it is often necessary to use smart pointers on simple data types, such as <span class="nctnt ncbi-type">int</span>, <span class="nctnt ncbi-type">string</span> etc. The <span class="nctnt ncbi-class">CObjectFor</span> class, described below, was designed for this purpose.</p></div><div class="sec" id="ch_core.CObjectFor"><h3><span class="title">The CObjectFor (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectFor.html">*</a>) class: using smart pointers for standard types</span></h3><p>The <span class="nctnt ncbi-class">CObjectFor</span> class is derived directly from <span class="nctnt ncbi-class">CObject</span>, and is implemented as a template class whose argument specifies the standard type that will be pointed to. In addition to the reference counter inherited from its parent class, <span class="nctnt ncbi-class">CObjectFor</span> has a private data member of the parameterized type, and a member function <span class="nctnt ncbi-func">GetData()</span> to access it.</p><p>An example program, <a href="ch_demo.html#ch_demo.examples_1_4">smart.cpp</a>, uses the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCRef.html">CRef</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectFor.html">CObjectFor</a> classes, and demonstrates the differences in memory management that arise using <span class="nctnt ncbi-class">auto_ptr</span> and <span class="nctnt ncbi-class">CRef</span>. Using an <span class="nctnt ncbi-class">auto_ptr</span> to reference an <span class="nctnt ncbi-type">int</span>, the program tests whether or not the reference is still accessible after an auxilliary <span class="nctnt ncbi-class">auto_ptr</span> which goes out of scope has also been used to reference it. The same sequence is then tested using <span class="nctnt ncbi-class">CRef</span> objects instead.</p><p>In the first case, the original auto_ptr, <span class="nctnt ncbi-var">orig_ap</span>, becomes <span class="nctnt ncbi-monospace">NULL</span> at the moment when ownership is transferred to <span class="nctnt ncbi-var">copy_ap</span> by the copy constructor. Using <span class="nctnt ncbi-class">CRef</span> objects however, the reference contained in the original <span class="nctnt ncbi-class">CRef</span> remains accessible (via <span class="nctnt ncbi-var">orig</span>) in all blocks where <span class="nctnt ncbi-var">orig</span> is defined. Moreover, the reference itself, i.e. the object pointed to, continues to exist until <b>all</b> references to it have been removed.</p></div><div class="sec" id="ch_core.CRef_usage"><h3><span class="title">When to use CRefs and auto_ptrs</span></h3><p>There is some overhead in using <span class="nctnt ncbi-class">CRef</span> and <span class="nctnt ncbi-class">auto_ptr</span>, and these objects should only be used where needed. Memory leaks are generally caused as a result of unexpected execution paths. For example:</p><pre><span class="nctnt-pre ncbi-code">{<br />    int *num = new int(5);<br />    ComplexFunction (num);<br />    delete num;<br />    ...<br />}</span></pre><p>If <span class="nctnt ncbi-func">ComplexFunction()</span> executes normally, control returns to the block where it was invoked, and memory is freed by the <span class="nctnt ncbi-code">delete</span> statement. Unforeseen events however, may trigger exceptions, causing control to pass elsewhere. In these cases, the <span class="nctnt ncbi-code">delete</span> statement may never be reached. The use of a <span class="nctnt ncbi-class">CRef</span> or an <span class="nctnt ncbi-class">auto_ptr</span> is appropriate for these situations, as they both guarantee that the object will be destroyed when the reference goes out of scope.</p><p>One situation where they may not be required is when a pointer is embedded inside another object. If that object's destructor also handles the deallocation of its embedded objects, then it is sufficient to use a <span class="nctnt ncbi-class">CRef</span> on the containing object only.</p></div><div class="sec" id="ch_core.CRef_pitfalls"><h3><span class="title">CRef Pitfalls</span></h3><div class="sec" id="ch_core.object_destruction"><h4><span class="title">Inadvertent Object Destruction</span></h4><p>When the last reference to a <span class="nctnt ncbi-class">CRef</span> object goes out of scope or the <span class="nctnt ncbi-class">CRef</span> is otherwise marked for garbage collection, the object to which the <span class="nctnt ncbi-class">CRef</span> points is also destroyed. This feature helps to prevent memory leaks, but it also requires care in the use of <span class="nctnt ncbi-class">CRef</span>s within methods and functions.</p><pre><span class="nctnt-pre ncbi-code">class CMy : public CObject<br />{<br />.....<br />};<br />void f(CMy* a)<br />{<br />    CRef b = a;<br />    return;<br />}<br />.....<br />    CMy* a = new CMy();<br />    f(a);<br />    // the object "a" is now destroyed!</span></pre><p>In this example the function <span class="nctnt ncbi-func">f()</span> establishes a local <span class="nctnt ncbi-class">CRef</span> to the <span class="nctnt ncbi-class">CMy</span> object <span class="nctnt ncbi-var">a</span>. On exiting <span class="nctnt ncbi-func">f()</span> the <span class="nctnt ncbi-class">CRef</span><span class="nctnt ncbi-var">b</span> is destroyed, including the implied destruction of the <span class="nctnt ncbi-class">CMy</span> objects <span class="nctnt ncbi-var">a</span>. To avoid this behavior, pass a <span class="nctnt ncbi-class">CRef</span> to the function <span class="nctnt ncbi-func">f()</span> instead of a normal pointer variable:</p><pre><span class="nctnt-pre ncbi-code">CRef a = new CMy();<br />f(a);<br />// the CMy object pointed to by "a" is not destroyed!</span></pre></div></div></div><div class="sec" id="ch_core.atomic_counters"><h2><span class="title">Atomic Counters</span></h2><p>The CORELIB implements efficient atomic counters that are used for <span class="nctnt ncbi-class">CObject</span> reference counts. The classes <span class="nctnt ncbi-class">CAtomicCounter</span> and <span class="nctnt ncbi-class">CMutableAtomicCounter</span> provide respectively a base atomic counter class, and a mutable atomic counter for multithreaded applications. These classes are used to in reference counted <a href="ch_core.html#ch_core.smart_ptrs">smart pointers</a>.</p><p>The <span class="nctnt ncbi-class">CAtomicCounter</span> base class provides the base methods <span class="nctnt ncbi-func">Get()</span>, <span class="nctnt ncbi-func">Set()</span>, <span class="nctnt ncbi-func">Add()</span> for atomic counters:</p><pre><span class="nctnt-pre ncbi-code">class CAtomicCounter<br />{<br />public:<br />    ///&lt; Alias TValue for TNCBIAtomicValue<br />    typedef TNCBIAtomicValue TValue;<br />    /// Get atomic counter value.<br />    TValue Get(void) const THROWS_NONE;<br />    /// Set atomic counter value.<br />    void   Set(TValue new_value) THROWS_NONE;<br />    /// Atomically add value (=delta), and return new counter value.<br />    TValue Add(int delta) THROWS_NONE;<br />    .......<br />};</span></pre><p><span class="nctnt ncbi-macro">TNCBIAtomicValue</span> is defined as a macro and its definition is platform dependent. If threads are not used (Macro <span class="nctnt ncbi-macro">NCBI_NO_THREADS</span> defined), <span class="nctnt ncbi-macro">TNCBIAtomicValue</span> is an <span class="nctnt ncbi-type">unsigned int</span> value. If threads are used, then a number of defines in file "<span class="nctnt ncbi-path">ncbictr.hpp</span>" ensure that a platform specific definition is selected for <span class="nctnt ncbi-macro">TNCBIAtomicValue</span>.</p><p>The <span class="nctnt ncbi-class">CMutableAtomicCounter</span> uses the <span class="nctnt ncbi-class">CAtomicCounter</span> as its internal structure of the atomic counter but declares this counter value as mutable. The <span class="nctnt ncbi-func">Get()</span>, <span class="nctnt ncbi-func">Set()</span>, <span class="nctnt ncbi-func">Add()</span> methods for <span class="nctnt ncbi-class">CMutableAtomicCounter</span> are implemented by calls to the corresponding <span class="nctnt ncbi-func">Get()</span>, <span class="nctnt ncbi-func">Set()</span>, <span class="nctnt ncbi-func">Add()</span> methods for the <span class="nctnt ncbi-class">CAtomicCounter</span>:</p><pre><span class="nctnt-pre ncbi-code">class  CMutableAtomicCounter<br />{<br />public:<br />    typedef CAtomicCounter::TValue TValue; ///&lt; Alias TValue simplifies syntax<br />    /// Get atomic counter value.<br />    TValue Get(void) const THROWS_NONE<br />        { return m_Counter.Get(); }<br />    /// Set atomic counter value.<br />    void   Set(TValue new_value) const THROWS_NONE<br />        { m_Counter.Set(new_value); }<br />    /// Atomically add value (=delta), and return new counter value.<br />    TValue Add(int delta) const THROWS_NONE<br />        { return m_Counter.Add(delta); }<br />private:<br />    ...<br />};</span></pre></div><div class="sec" id="ch_core.portable_dll"><h2><span class="title">Portable mechanisms for loading DLLs</span></h2><p>The <span class="nctnt ncbi-class">CDll</span> class defines a portable way of dynamically loading shared libraries and finding entry points for functions in the library. Currently this portable behavior is defined for Unix-like systems and Windows only. On Unix-like systems, loading of the shared library is implemented using the Unix system call <span class="nctnt ncbi-func">dlopen()</span> and the entry point address obtained using the Unix system call <span class="nctnt ncbi-func">dlsym()</span>. On Windows systems the system call <span class="nctnt ncbi-func">LoadLibraray()</span> is used to load the library, and the system call <span class="nctnt ncbi-func">GetProcAddress()</span> is used to get a function's entry point address.</p><p>All methods of <span class="nctnt ncbi-class">CDll</span> class, except the destructor, throw the exception <span class="nctnt ncbi-monospace">CCoreException::eDll</span> on error.</p><p>You can specify when to load the DLL - when the <span class="nctnt ncbi-class">CDll</span> object is created (loading in the constructor), or by an explicit call to <span class="nctnt ncbi-func">CDll::Load()</span>. You can also specify whether the DLL is unloaded automatically when <span class="nctnt ncbi-class">CDll's</span> destructor is called or if the DLL should remain loaded in memory. This behavior is controlled by arguments to <span class="nctnt ncbi-class">CDll's</span> constructor.</p><p>The following additional topics are described in this section:</p><ul><li><p><a href="ch_core.html#ch_core.CDll_constructor">CDll Constructor</a></p></li><li><p><a href="ch_core.html#ch_core.CDll_basename">CDll Basename</a></p></li><li><p><a href="ch_core.html#ch_core.CDll_methods">Other CDll Methods</a></p></li></ul><div class="sec" id="ch_core.CDll_constructor"><h3><span class="title">CDll Constructor</span></h3><p>The CDll class has four constructors:</p><pre><span class="nctnt-pre ncbi-code">    CDll(const string&amp; name, TFlags flags);</span></pre><p>and</p><pre><span class="nctnt-pre ncbi-code">    CDll(const string&amp; path, const string&amp; name, TFlags flags);</span></pre><p>and</p><pre><span class="nctnt-pre ncbi-code">    CDll(const string&amp; name,<br />         ELoad         when_to_load = eLoadNow,<br />         EAutoUnload   auto_unload  = eNoAutoUnload,<br />         EBasename     treate_as    = eBasename);</span></pre><p>and</p><pre><span class="nctnt-pre ncbi-code">    CDll(const string&amp; path, const string&amp; name,<br />         ELoad         when_to_load = eLoadNow,<br />         EAutoUnload   auto_unload  = eNoAutoUnload,<br />         EBasename     treate_as    = eBasename);</span></pre><p>The first and second constructor forms are the same with the exception that the second constructor uses two parameters - the <span class="nctnt ncbi-var">path</span> and <span class="nctnt ncbi-var">name</span> parameters - to build a path to the DLL, whereas in the first constructor, the <span class="nctnt ncbi-var">name</span> parameter contains the full path to the DLL. The third and fourth forms are likewise similar.</p><p>The first pair of constructors differ from the second pair in that the first two take a single parameter that is a set of flags, whereas the second pair take three separate parameters for flags. The first two are newer, and the last two are provided for backward compatibility.</p><p>The parameter <span class="nctnt ncbi-var">when_to_load</span> is defined as an enum type of <span class="nctnt ncbi-type">ELoad</span> and has the values <span class="nctnt ncbi-monospace">eLoadNow</span> or <span class="nctnt ncbi-monospace">eLoadLater</span>. When <span class="nctnt ncbi-monospace">eLoadNow</span> is passed to the constructor (default value), the DLL is loaded in the constructor; otherwise it has to be loaded via an explicit call to the <span class="nctnt ncbi-func">Load()</span> method.</p><p>The parameter <span class="nctnt ncbi-var">auto_load</span> is defined as an enum type of <span class="nctnt ncbi-type">EAutoLoad</span> and has the values <span class="nctnt ncbi-monospace">eAutoUnload</span> or <span class="nctnt ncbi-monospace">eNoAutoUnload</span>. When <span class="nctnt ncbi-monospace">eAutoUnload</span> is passed to the constructor (default value), the DLL is unloaded in the destructor; otherwise it will remain loaded in memory.</p><p>The parameter <span class="nctnt ncbi-var">treat_as</span> is defined as an enum type of <span class="nctnt ncbi-type">EBasename</span> and has the values <span class="nctnt ncbi-monospace">eBasename</span> or <span class="nctnt ncbi-monospace">eExactName</span>. When <span class="nctnt ncbi-monospace">eBasename</span> is passed to the constructor (default value), the name parameter is treated as a basename if it looks like one; otherwise the exact name or "as is" value is used with no addition of prefix or suffix.</p><p>The parameter <span class="nctnt ncbi-var">flags</span> is defined as an enum type of <span class="nctnt ncbi-type">EFlags</span> and has the values <span class="nctnt ncbi-monospace">fLoadNow</span>, <span class="nctnt ncbi-monospace">fLoadLater</span>, <span class="nctnt ncbi-monospace">fAutoUnload</span>, <span class="nctnt ncbi-monospace">fNoAutoUnload</span>, <span class="nctnt ncbi-monospace">fBaseName</span>, <span class="nctnt ncbi-monospace">fExactName</span>, <span class="nctnt ncbi-monospace">fGlobal</span>, <span class="nctnt ncbi-monospace">fLocal</span>, and <span class="nctnt ncbi-monospace">fDefault</span>. The flags <span class="nctnt ncbi-monospace">fLoadNow</span>, <span class="nctnt ncbi-monospace">fLoadLater</span>, <span class="nctnt ncbi-monospace">fAutoUnload</span>, <span class="nctnt ncbi-monospace">fNoAutoUnload</span>, <span class="nctnt ncbi-monospace">fBaseName</span>, and <span class="nctnt ncbi-monospace">fExactName</span> correspond to the similarly named enum values as described in the above paragraphs. The flag <span class="nctnt ncbi-monospace">fGlobal</span> indicates that the DLL should be loaded as <span class="nctnt ncbi-monospace">RTLD_GLOBAL</span>, while the flag <span class="nctnt ncbi-monospace">fLocal</span> indicates that the DLL should be loaded as <span class="nctnt ncbi-monospace">RTLD_LOCAL</span>. The flag <span class="nctnt ncbi-monospace">fDefault</span> is defined as:</p><pre><span class="nctnt-pre ncbi-code">fDefault = fLoadNow | fNoAutoUnload | fBaseName | fGlobal</span></pre></div><div class="sec" id="ch_core.CDll_basename"><h3><span class="title">CDll Basename</span></h3><p>The DLL name is considered the basename if it does not contain embedded '/', '\', or ':' symbols. Also, in this case, if the DLL name does not match the pattern "lib*.so", "lib*.so.*", or "*.dll" and if <span class="nctnt ncbi-monospace">eExactName</span> flag is not passed to the constructor, then it will be automatically transformed according to the following rules:</p><div class="table" id="ch_core.T.nc_osruleunixlikename__libname"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">OS</th><th align="left" valign="top" rowspan="1" colspan="1">Rule</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Unix-like</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">&lt;name&gt; -&gt; lib&lt;name&gt;.so</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Windows</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">&lt;name&gt; -&gt; &lt;name&gt;.dll</span></td></tr></tbody></table></div><p>If the DLL is specified by its basename, then it will be searched after the transformation described above in the following locations:</p><ul><li><p>Unix:</p><ul><li><p>The directories that are listed in the <span class="nctnt ncbi-var">LD_LIBRARY_PATH</span> environment variable which are analyzed once at the process startup.</p></li><li><p>The directory from which the application loaded</p></li><li><p>Hard-coded (e.g. with `ldconfig' on Linux) paths</p></li></ul></li><li><p>Windows:</p><ul><li><p>The directory from which the application is loaded</p></li><li><p>The current directory</p></li><li><p>The Windows system directory</p></li><li><p>The Windows directory</p></li><li><p>The directories that are listed in the <span class="nctnt ncbi-var">PATH</span> environment variable</p></li></ul></li></ul></div><div class="sec" id="ch_core.CDll_methods"><h3><span class="title">Other CDll Methods</span></h3><p>Two methods mentioned earlier for the <span class="nctnt ncbi-class">CDll</span> class are the <span class="nctnt ncbi-func">Load()</span> and <span class="nctnt ncbi-func">Unload()</span> methods. The <span class="nctnt ncbi-func">Load()</span> method loads the DLL using the name specified in the constructor's DLL <span class="nctnt ncbi-var">name</span> parameter. The <span class="nctnt ncbi-func">Load()</span> method is expected to be used when the DLL is not explictly loaded in the constructor. That is, when the <span class="nctnt ncbi-class">CDll</span> constructor is passed the <span class="nctnt ncbi-monospace">eLoadLater</span> parameter. If the <span class="nctnt ncbi-func">Load()</span> is called more than once without calling <span class="nctnt ncbi-func">Unload()</span> in between, then it will do nothing. The syntax of the <span class="nctnt ncbi-func">Load()</span> methods is</p><pre><span class="nctnt-pre ncbi-code">void Load(void);</span></pre><p>The <span class="nctnt ncbi-func">Unload()</span> method unloads that DLL whose name was specified in the constructor's DLL <span class="nctnt ncbi-var">name</span> parameter. The <span class="nctnt ncbi-func">Unload()</span> method is expected to be used when the DLL is not explicitly unloaded in the destructor. This occurs, when the <span class="nctnt ncbi-class">CDll</span> constructor is passed the <span class="nctnt ncbi-monospace">eNoAutoUnload</span> parameter. If the <span class="nctnt ncbi-func">Unload()</span> is called when the DLL is not loaded, then it will do nothing. The syntax of the <span class="nctnt ncbi-func">Unload()</span> methods is</p><pre><span class="nctnt-pre ncbi-code">void Unload(void);</span></pre><p>Once the DLL is loaded, you can call the DLL's functions by first getting the function's entry point (address), and using this to call the function. The function template <span class="nctnt ncbi-func">GetEntryPoint()</span> method is used to get the entry point address and is defined as:</p><pre><span class="nctnt-pre ncbi-code">template &lt;class TPointer&gt;<br />TPointer GetEntryPoint(const string&amp; name, TPointer* entry_ptr);</span></pre><p>This method returns the entry point's address on success, or NULL on error. If the DLL is not loaded when this method is called, then this method will call <span class="nctnt ncbi-func">Load()</span> to load the DLL which can result in throwing an exception if <span class="nctnt ncbi-func">Load()</span> fails.</p><p>Some sample code illustrating the use of these methods is shown in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/corelib/test/test_ncbidll.cpp">src/corelib/test/test_ncbidll.cpp</a></p></div></div><div class="sec" id="ch_core.CExec"><h2><span class="title">Executing Commands and Spawning Processes using the CExec class</span></h2><p>The <span class="nctnt ncbi-class">CExec</span> defines a portable execute class that can be used to execute system commands and spawn new processes.</p><p>The following topics relating to the <span class="nctnt ncbi-class">CExec</span> class are discussed, next:</p><ul><li><p><a href="ch_core.html#ch_core.system_call">Executing a System Command using the System() Method</a></p></li><li><p><a href="ch_core.html#ch_core.process_modes">Defining Spawned Process Modes (EMode type)</a></p></li><li><p><a href="ch_core.html#ch_core.spawn_process">Spawning a Process using SpawnX() Methods</a></p></li><li><p><a href="ch_core.html#ch_core.wait_method">Waiting for a Process to Terminate using the Wait() method</a></p></li></ul><div class="sec" id="ch_core.system_call"><h3><span class="title">Executing a System Command using the System() Method</span></h3><p>You can use the class-wide <span class="nctnt ncbi-func">CExec::System()</span> method to execute a system command:</p><pre><span class="nctnt-pre ncbi-code">static int System(const char* cmdline);</span></pre><p><span class="nctnt ncbi-func">CExec::System()</span> returns the executed command's exit code and throws an exception if the command failed to execute. If cmdline is a null pointer, <span class="nctnt ncbi-func">CExec::System()</span> checks if the shell (command interpreter) exists and is executable. If the shell is available, <span class="nctnt ncbi-func">System()</span> returns a non-zero value; otherwise, it returns 0.</p></div><div class="sec" id="ch_core.process_modes"><h3><span class="title">Defining Spawned Process Modes (EMode type)</span></h3><p>The spawned process can be created in several modes defined by the enum type <span class="nctnt ncbi-func">EMode</span>. The meanings of the enum values for <span class="nctnt ncbi-func">EMode</span> type are:</p><ul><li><p><span class="nctnt ncbi-monospace">eOverlay</span>: This mode overlays the calling process with new process, destroying the calling process.</p></li><li><p><span class="nctnt ncbi-monospace">eWait</span>: This mode suspends the calling thread until execution of a new process is complete. That is, the called process is called synchronously.</p></li><li><p><span class="nctnt ncbi-monospace">eNoWait</span>: This is the opposite of <span class="nctnt ncbi-monospace">eWait</span>. This mode continues to execute the calling process concurrently with the new called process in an asynchronous fashion.</p></li><li><p><span class="nctnt ncbi-monospace">eDetach</span>: This mode continues to execute the calling process and new process is "detached" and run in background with no access to console or keyboard. Calls to <span class="nctnt ncbi-func">Wait()</span> against new process will fail. This is an asynchronous spawn.</p></li></ul></div><div class="sec" id="ch_core.spawn_process"><h3><span class="title">Spawning a Process using SpawnX() Methods</span></h3><p>A new process can be spawned by calling any of the class-wide methods named <span class="nctnt ncbi-func">SpawnX()</span> which have the form:</p><pre><span class="nctnt-pre ncbi-code">static int SpawnX(const EMode mode,<br />                  const char *cmdname,<br />                  const char *argv,<br />                  ...<br />                  );</span></pre><p>The parameter <span class="nctnt ncbi-var">mode</span> has the meanings discussed in the section <a href="ch_core.html#ch_core.process_modes">Defining Spawned Process Modes (EMode type)</a>. The parameter <span class="nctnt ncbi-var">cmdname</span> is the command-line string to start the process, and parameter <span class="nctnt ncbi-var">argv</span> is the argument vector containing arguments to the process.</p><p>The <span class="nctnt ncbi-func">X</span> in the function name is a one to three letter suffix indicating the type of the spawn function. Each of the letters in the suffix <span class="nctnt ncbi-func">X</span>, for <span class="nctnt ncbi-func">SpawnX()</span> have the following meanings:</p><ul><li><p><span class="nctnt ncbi-monospace">L</span>: The letter "L" as suffix refers to the fact that command-line arguments are passed separately as arguments.</p></li><li><p><span class="nctnt ncbi-monospace">E</span>: The letter "E" as suffix refers to the fact that environment pointer, <span class="nctnt ncbi-var">envp</span>, is passed as an array of pointers to environment settings to the new process. The <span class="nctnt ncbi-monospace">NULL</span> environment pointer indicates that the new process will inherit the parents' process's environment.</p></li><li><p><span class="nctnt ncbi-monospace">P</span>: The letter "P" as suffix refers to the fact that the <span class="nctnt ncbi-var">PATH</span> environment variable is used to find file to execute. Note that on a Unix-like system this feature works in functions without letter "P" in the function name.</p></li><li><p><span class="nctnt ncbi-monospace">V</span>: The letter "V" as suffix refers to the fact that the number of command-line arguments is variable.</p></li></ul><p>Using the above letter combinations as suffixes, the following spawn functions are defined:</p><ul><li><p><span class="nctnt ncbi-func">SpawnL()</span>: In the <span class="nctnt ncbi-func">SpawnL()</span> version, the command-line arguments are passed individually. <span class="nctnt ncbi-func">SpawnL()</span> is typically used when number of parameters to the new process is known in advance.</p></li><li><p><span class="nctnt ncbi-func">SpawnLE()</span>: In the <span class="nctnt ncbi-func">SpawnLE()</span> version, the command-line arguments and environment pointer are passed individually. <span class="nctnt ncbi-func">SpawnLE()</span> is typically used when number of parameters to the new process and individual environment parameter settings are known in advance.</p></li><li><p><span class="nctnt ncbi-func">SpawnLP()</span>: In the <span class="nctnt ncbi-func">SpawnLP()</span> version, the command-line arguments are passed individually and the <span class="nctnt ncbi-var">PATH</span> environment variable is used to find the file to execute. <span class="nctnt ncbi-func">SpawnLP()</span> is typically used when number of parameters to the new process is known in advance but the exact path to the executable is not known.</p></li><li><p><span class="nctnt ncbi-func">SpawnLPE()</span>: In the <span class="nctnt ncbi-func">SpawnLPE()</span> the command-line arguments and environment pointer are passed individually, and the <span class="nctnt ncbi-var">PATH</span> environment variable is used to find the file to execute. <span class="nctnt ncbi-func">SpawnLPE()</span> is typically used when the number of parameters to the new process and individual environment parameter settings are known in advance, but the exact path to the executable is not known.</p></li><li><p><span class="nctnt ncbi-func">SpawnV()</span>: In the <span class="nctnt ncbi-func">SpawnV()</span> version, the command-line arguments are a variable number. The array of pointers to arguments must have a length of 1 or more and you must assign parameters for the new process beginning from 1.</p></li><li><p><span class="nctnt ncbi-func">SpawnVE()</span>: In the <span class="nctnt ncbi-func">SpawnVE()</span> version, the command-line arguments are a variable number. The array of pointers to arguments must have a length of 1 or more and you must assign parameters for the new process beginning from 1. The individual environment parameter settings are known in advance and passed explicitly.</p></li><li><p><span class="nctnt ncbi-func">SpawnVP()</span>: In the <span class="nctnt ncbi-func">SpawnVP()</span> version, the command-line arguments are a variable number. The array of pointers to arguments must have a length of 1 or more and you must assign parameters for the new process beginning from 1. The <span class="nctnt ncbi-var">PATH</span> environment variable is used to find the file to execute.</p></li><li><p><span class="nctnt ncbi-func">SpawnVPE()</span>: In the <span class="nctnt ncbi-func">SpawnVPE()</span> version, the command-line arguments are a variable number. The array of pointers to arguments must have a length of 1 or more and you must assign parameters for the new process beginning from 1. The <span class="nctnt ncbi-var">PATH</span> environment variable is used to find the file to execute, and the environment is passed via an environment vector pointer.</p></li></ul><p>Refer to the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/corelib/ncbiexec.hpp">include/corelib/ncbiexec.hpp</a> file to view the exact form of the <span class="nctnt ncbi-func">SpawnX()</span> function calls.</p><p>Some sample code illustrating the use of these methods is shown in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/corelib/test/test_ncbiexec.cpp">src/corelib/test/test_ncbiexec.cpp</a></p></div><div class="sec" id="ch_core.wait_method"><h3><span class="title">Waiting for a Process to Terminate using the Wait() method</span></h3><p>The <span class="nctnt ncbi-class">CExec</span> class defines a <span class="nctnt ncbi-func">Wait()</span> method that causes a process to wait until the child process terminates:</p><pre><span class="nctnt-pre ncbi-code">static int Wait(const int pid);</span></pre><p>The argument to the <span class="nctnt ncbi-func">Wait()</span> method is the pid (process ID) of the child process on which the caller is waiting to terminate. <span class="nctnt ncbi-func">Wait()</span> returns immediately if the specified child process has already terminated and returns an exit code of the child process, if there are no errors; or a -1, if an error has occurred.</p></div></div><div class="sec" id="ch_core.threads"><h2><span class="title">Implementing Parallelism using Threads and Synchronization Mechanisms</span></h2><p>This section provides reference information on how to add multithreading to your application and how to use basic synchronization objects. For an overview of these concepts refer to the <a href="ch_intro.html#ch_intro.intro_threads">introductory topic on this subject</a>.</p><p>Note that all classes are defined in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/corelib/ncbithr.hpp">include/corelib/ncbithr.hpp</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/corelib/ncbimtx.hpp">include/corelib/ncbimtx.hpp</a>.</p><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_core.html#ch_core.using_threads">Using Threads</a></p></li><li><p><a href="ch_core.html#ch_core.thread_public_methods">CThread class public methods</a></p></li><li><p><a href="ch_core.html#ch_core.thread_protected_methods">CThread class protected methods</a></p></li><li><p><a href="ch_core.html#ch_core.thread_life_cycle">Thread Life Cycle</a></p></li><li><p><a href="ch_core.html#ch_core.referencing_threads">Referencing thread objects</a></p></li><li><p><a href="ch_core.html#ch_core.mutexes">Synchronization</a></p></li><li><p><a href="ch_core.html#ch_core.thread_local_storage">Thread local storage (CTls&lt;&gt; class [*])</a></p></li></ul><div class="sec" id="ch_core.using_threads"><h3><span class="title">Using Threads</span></h3><p><span class="nctnt ncbi-class">CThread</span> class is defined in <span class="nctnt ncbi-path">include/corelib/ncbithr.hpp</span>. The <span class="nctnt ncbi-class">CThread</span> class provides all basic thread functionality: thread creation, launching, termination, and cleanup. To create user-defined thread one needs only to provide the thread's <span class="nctnt ncbi-func">Main()</span> function and, in some cases, create a new constructor to transfer data to the thread object, and override <span class="nctnt ncbi-func">OnExit()</span> method for thread-specific data cleanup. To create a custom thread:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Derive your class from <span class="nctnt ncbi-class">CThread</span>, override <span class="nctnt ncbi-func">Main()</span> and, if necessary, <span class="nctnt ncbi-func">OnExit()</span> methods.</p></dd><dt>2</dt><dd><p class="no_top_margin">Create thread object in your application. You can do this only with <span class="nctnt ncbi-code">new</span> operator, since static or in-stack thread objects are prohibited (see below). The best way to reference thread objects is to use <span class="nctnt ncbi-type">CRef&lt;CThread&gt;</span> class.</p></dd><dt>3</dt><dd><p class="no_top_margin">Call <span class="nctnt ncbi-func">Run()</span> to start the thread execution.</p></dd><dt>4</dt><dd><p class="no_top_margin">Call <span class="nctnt ncbi-func">Detach()</span> to let the thread run independently (it will destroy itself on termination then), or use <span class="nctnt ncbi-func">Join()</span> to wait for the thread termination.</p></dd></dl><p>The code should look like:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;corelib/ncbistd.hpp&gt;<br />#include &lt;corelib/ncbithr.hpp&gt;<br />USING_NCBI_SCOPE;<br />class CMyThread : public CThread<br />{<br />public:<br />    CMyThread(int index) : m_Index(index) {}<br />    virtual void* Main(void);<br />    virtual void OnExit(void);<br />private:<br />    int m_Index;<br />    int* heap_var;<br />};<br />void* CMyThread::Main(void)<br />{<br />    cout &lt;&lt; "Thread " &lt;&lt; m_Index &lt;&lt; endl;<br />    heap_var = new int; // to be destroyed by OnExit()<br />    *heap_var = 12345;<br />    int* return_value = new int; // return to the main thread<br />    *return_value = m_Index;<br />    return return_value;<br />}<br />void CMyThread::OnExit(void)<br />{<br />    delete heap_var;<br />}<br />int main(void)<br />{<br />    CMyThread* thread = new CMyThread(33);<br />    thread-&gt;Run();<br />    int* result;<br />    thread-&gt;Join(reinterpret_cast&lt;void**&gt;(&amp;result));<br />    cout &lt;&lt; "Returned value: " &lt;&lt; *result &lt;&lt; endl;<br />    delete result;<br />    return 0;<br />}</span></pre><p>The above simple application will start one child thread, passing <span class="nctnt ncbi-monospace">33</span> as the <span class="nctnt ncbi-var">index</span> value. The thread prints <span class="nctnt ncbi-monospace">"Thread 33"</span> message, allocates and initializes two integer variables, and terminates. The thread's <span class="nctnt ncbi-func">Main()</span> function returns a pointer to one of the allocated values. This pointer is then passed to <span class="nctnt ncbi-func">Join()</span> method and can be used by another thread. The other integer allocated by <span class="nctnt ncbi-func">Main()</span> is destroyed by <span class="nctnt ncbi-func">OnExit()</span> method.</p><p>It is important not to terminate the program until there are running threads. Program termination will cause all the running threads to terminate also. In the above example <span class="nctnt ncbi-func">Join()</span> function is used to wait for the child thread termination.</p><p>The following subsections discuss the individual classes in more detail.</p></div><div class="sec" id="ch_core.thread_public_methods"><h3><span class="title">CThread (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CThread">*</a>) class public methods</span></h3><p><span class="nctnt ncbi-func">CThread(void)</span> Create the thread object (without running it). <span class="nctnt ncbi-func">bool Run(void)</span> Spawn the new thread, initialize internal <span class="nctnt ncbi-class">CThread</span> data and launch user-provided <span class="nctnt ncbi-func">Main()</span>. The method guarantees that the new thread will start before it returns to the calling function. <span class="nctnt ncbi-func">void Detach(void)</span> Inform the thread that user does not need to wait for its termination. Detached thread will destroy itself after termination. If <span class="nctnt ncbi-func">Detach()</span> is called for a thread, which has already terminated, it will be scheduled for destruction immediately. Only one call to <span class="nctnt ncbi-func">Detach()</span> is allowed for each thread object. <span class="nctnt ncbi-func">void Join(void** exit_data)</span> Wait for the thread termination. <span class="nctnt ncbi-func">Join()</span> will store the <span class="nctnt ncbi-type">void</span> pointer as returned by the user's <span class="nctnt ncbi-func">Main()</span> method, or passed to the <span class="nctnt ncbi-func">Exit()</span> function to the <span class="nctnt ncbi-var">exit_data</span>. Then the thread will be scheduled for destruction. Only one call to <span class="nctnt ncbi-func">Join()</span> is allowed for each thread object. If called more than once, <span class="nctnt ncbi-func">Join()</span> will cause a runtime error. <span class="nctnt ncbi-func">static void Exit(void* exit_data)</span> This function may be called by a thread object itself to terminate the thread. The thread will be terminated and, if already detached, scheduled for destruction. <span class="nctnt ncbi-var">exit_data</span> value is transferred to the <span class="nctnt ncbi-func">Join()</span> function as if it was returned by the <span class="nctnt ncbi-func">Main()</span>. <span class="nctnt ncbi-func">Exit()</span> will also call virtual method <span class="nctnt ncbi-func">OnExit()</span> to execute user-provided cleanup code (if any). <span class="nctnt ncbi-func">bool Discard(void)</span> Schedules the thread object for destruction if it has not been run yet. This function is provided since there is no other way to delete a thread object without running it. On success, return <span class="nctnt ncbi-monospace">true</span>. If the thread has already been run, <span class="nctnt ncbi-func">Discard()</span> do nothing and return <span class="nctnt ncbi-monospace">false</span>. <span class="nctnt ncbi-func">static CThread::TID GetSelf(void)</span> This method returns a unique thread ID. This ID may be then used to identify threads, for example, to track the owner of a shared resource. Since the main thread has no associated <span class="nctnt ncbi-class">CThread</span> object, a special value of 0 (zero) is reserved for the main thread ID.</p></div><div class="sec" id="ch_core.thread_protected_methods"><h3><span class="title">CThread (<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CThread">*</a>) class protected methods</span></h3><p><span class="nctnt ncbi-func">virtual void* Main(void)Main()</span> is the thread's main function (just like an application <span class="nctnt ncbi-func">main()</span> function). This method is not defined in the <span class="nctnt ncbi-class">CThread</span> class. It must be provided by derived user-defined class. The return value is passed to the <span class="nctnt ncbi-func">Join()</span> function (and thus may be used by another thread for some sort of inter-thread communication). <span class="nctnt ncbi-func">virtual void OnExit(void)</span> This method is called (in the context of the thread) just before the thread termination to cleanup thread-specific resources. <span class="nctnt ncbi-func">OnExit()</span> is NOT called by <span class="nctnt ncbi-func">Discard()</span>, since the thread has not been run in this case and there are no thread-specific data to destroy. <span class="nctnt ncbi-func">virtual ~CThread(void)</span> The destructor is protected to avoid thread object premature destruction. For this reason, no thread object can be static or stack-allocated. It is important to declare any <span class="nctnt ncbi-func">CThread</span> derived class destructor as <span class="nctnt ncbi-code">protected</span>.</p></div><div class="sec" id="ch_core.thread_life_cycle"><h3><span class="title">Thread Life Cycle</span></h3><p><a href="ch_core.html#ch_core.F2">Figure 2</a> shows a typical thread life cycle. The figure demonstrates that thread constructors are called from the parent thread. The child thread is spawned by the <span class="nctnt ncbi-func">Run()</span> function only. Then, the user-provided <span class="nctnt ncbi-func">Main()</span> method (containing code created by user) gets executed. The thread's destructor may be called in the context of either parent or child thread depending on the state of the thread at the moment when <span class="nctnt ncbi-func">Join()</span> or <span class="nctnt ncbi-func">Detach()</span> is called.</p><div class="figure" id="ch_core.F2"><div class="graphic"><img src="img/thread_life_cycle.gif" alt="Figure 2. Thread Life Cycle" /></div><div class="caption"><p>Figure 2. Thread Life Cycle</p></div></div><p>There are two possible ways to terminate a thread. By default, after user-provided <span class="nctnt ncbi-func">Main()</span> function return, the <span class="nctnt ncbi-func">Exit()</span> is called implicitly to terminate the thread. User functions can call <span class="nctnt ncbi-func">CThread::Exit()</span> directly. Since <span class="nctnt ncbi-func">Exit()</span> is a static method, the calling function does not need to be a thread class member or have a reference to the thread object. <span class="nctnt ncbi-func">Exit()</span> will terminate the thread in which context it is called.</p><p>The <span class="nctnt ncbi-class">CThread</span> destructor is <span class="nctnt ncbi-code">protected</span>. The same must be true for any user-defined thread class in order to prohibit creation of static or automatic thread objects. For the same reason, a thread object can not be destroyed by explicit <span class="nctnt ncbi-code">delete</span>. All threads destroy themselves on termination, detaching, or joining.</p><p>On thread termination, <span class="nctnt ncbi-func">Exit()</span> checks if the thread has been detached and, if this is true, destroys the thread object. If the thread has not been detached, the thread object will remain "zombie" unless detached or joined. Either <span class="nctnt ncbi-func">Detach()</span> or <span class="nctnt ncbi-func">Join()</span> will destroy the object if the thread has been terminated. One should keep in mind, that it is not safe to use the thread object after a call to <span class="nctnt ncbi-func">Join()</span> or <span class="nctnt ncbi-func">Detach()</span> since the object may happen to be destroyed. To avoid this situation, the <span class="nctnt ncbi-type">CRef&lt;CThread&gt;</span> can be used. The thread object will not be destroyed until there is at least one <span class="nctnt ncbi-class">CRef</span> to the object (although it may be terminated and scheduled for destruction).</p><p>In other words, a thread object will be destroyed when all of the following conditions are satisfied:</p><ul><li><p>the thread has been run and terminated by an implicit or explicit call to <span class="nctnt ncbi-func">Exit()</span></p></li><li><p>the thread has been detached or joined</p></li><li><p>no <span class="nctnt ncbi-class">CRef</span> references the thread object</p></li></ul><p>Which thread will actually destroy a thread object depends on several conditions. If the thread has been detached before termination, the <span class="nctnt ncbi-func">Exit()</span> method will destroy it, provided there are no <span class="nctnt ncbi-class">CRef</span> references to the object. When joined, the thread will be destroyed in the context of a joining thread. If <span class="nctnt ncbi-func">Detach()</span> is called after thread termination, it will destroy the thread in the context of detaching thread. And, finally, if there are several <span class="nctnt ncbi-class">CRef</span> objects referencing the same thread, it will be destroyed after the last <span class="nctnt ncbi-class">CRef</span> release.</p><p>This means that cleaning up thread-specific data can not be done from the thread destructor. One should override <span class="nctnt ncbi-func">OnExit()</span> method instead. <span class="nctnt ncbi-func">OnExit()</span> is guaranteed to be called in the context of the thread before the thread termination. The destructor can be used to cleanup non-thread-local data only.</p><p>There is one more possibility to destroy a thread. If a thread has been created, but does not need to be run, one can use <span class="nctnt ncbi-func">Discard()</span> method to destroy the thread object without running it. Again, the object will not be destroyed until there are <span class="nctnt ncbi-class">CRef</span>s referencing it.</p></div><div class="sec" id="ch_core.referencing_threads"><h3><span class="title">Referencing Thread Objects</span></h3><p>It should be emphasized that regular (C) pointer to a thread object is not reliable. The thread may terminate at unpredictable moment, destroying itself. There is no possibility to safely access thread object after <span class="nctnt ncbi-func">Join()</span> using C pointers. The only solution to this problem is to use <span class="nctnt ncbi-class">CRef</span> class. <span class="nctnt ncbi-class">CThread</span> class provides a mechanism to prevent premature destruction if there are <span class="nctnt ncbi-class">CRef</span> references to the thread object.</p></div><div class="sec" id="ch_core.thread_local_storage"><h3><span class="title">Thread local storage (CTls&lt;&gt; class [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CTls">*</a>])</span></h3><p>The library provides a template class to store thread specific data: <span class="nctnt ncbi-class">CTls&lt;&gt;</span>. This means that each thread can keep its own data in the same TLS object. To perform any kind of cleanup one can provide cleanup function and additional cleanup data when storing a value in the TLS object. The following example demonstrates the usage of TLS:</p><pre><span class="nctnt-pre ncbi-code">CRef&lt; CTls&lt;int&gt; &gt; tls(new CTls&lt;int&gt;);<br />void TlsCleanup(int* p_value, void* /* data */ )<br />{<br />    delete p_value;<br />}<br />...<br />void* CMyThread::Main()<br />{<br />    int* p_value = new int;<br />    *p_value = 1;<br />    tls-&gt;SetValue(p_value, TlsCleanup);<br />    ...<br />    p_value = new int;<br />    *p_value = 2;<br />    tls-&gt;SetValue(p_value, TlsCleanup);<br />    ...<br />    if (*tls-&gt;GetValue() == 2) {<br />        ...<br />    }<br />    ...<br />}</span></pre><p>In the above example the second call to <span class="nctnt ncbi-func">SetValue()</span> will cause the <span class="nctnt ncbi-func">TlsCleanup()</span> to deallocate the first integer variable. To cleanup the last value stored in each TLS, the <span class="nctnt ncbi-func">CThread::Exit()</span> function will automatically call <span class="nctnt ncbi-func">CTls&lt;&gt;::Reset()</span> for each TLS used by the thread.</p><p>By default, all TLS objects are destroyed on program termination, since in most cases it is not guaranteed that a TLS object is not (or will not be) used by a thread. For the same reason the <span class="nctnt ncbi-class">CTls&lt;&gt;</span> destructor is protected, so that no TLS can be created in the stack memory. The best way of keeping TLS objects is to use <span class="nctnt ncbi-class">CRef</span>.</p><p>Calling <span class="nctnt ncbi-func">Discard()</span> will schedule the TLS to be destroyed as soon as there are no <span class="nctnt ncbi-class">CRef</span> references to the object left. The method should be used with care.</p></div><div class="sec" id="ch_core.mutexes"><h3><span class="title">Mutexes</span></h3><p>The <span class="nctnt ncbi-path">ncbimtx.hpp</span> defines platform-independent mutex classes, <span class="nctnt ncbi-class">CMutex</span>, <span class="nctnt ncbi-class">CFastMutex</span>, <span class="nctnt ncbi-class">CMutexGuard</span>, and <span class="nctnt ncbi-class">CFastMutexGuard</span>. These mutex classes are in turn built on the platform-dependent mutex classes <span class="nctnt ncbi-class">SSystemMutex</span> and <span class="nctnt ncbi-class">SSystemFastMutex</span>.</p><p>In addition to the mutex classes, there are a number of classes that can be used for explicit locks such as the <span class="nctnt ncbi-class">CRWLock</span>, <span class="nctnt ncbi-class">CAutoRW</span>, <span class="nctnt ncbi-class">CReadLockGuard</span>, <span class="nctnt ncbi-class">CWriteLockGuard</span> and the platform-dependent read/write lock, <span class="nctnt ncbi-class">CInternalRWLock</span>.</p><p>Finally, there is the <span class="nctnt ncbi-class">CSemaphore</span> class which is an application-wide semaphore.</p><p>These classes are discussed in the subsections that follow:</p><ul><li><p><a href="ch_core.html#ch_core.CMutex">CMutex</a></p></li><li><p><a href="ch_core.html#ch_core.CFastMutex">CFastMutex</a></p></li><li><p><a href="ch_core.html#ch_core.SSystemMutex">SSystemMutex and SSystemFastMutex</a></p></li><li><p><a href="ch_core.html#ch_core.CMutexGuard">CMutexGuard and CFastMutexGuard</a></p></li><li><p><a href="ch_core.html#ch_core.lock_classes">Lock Classes</a></p></li></ul><div class="sec" id="ch_core.CMutex"><h4><span class="title">CMutex</span></h4><p>The <span class="nctnt ncbi-class">CMutex</span> class provides the API for acquiring a mutex. This mutex allows nesting with runtime checks so recursive locks by the same thread is possible. This mutex checks the mutex owner before unlocking. <span class="nctnt ncbi-class">CMutex</span> is slower than <span class="nctnt ncbi-class">CFastMutex</span> and should be used when performance is less important than data protection. If performance is more important than data protection, use <span class="nctnt ncbi-class">CFastMutex</span>, instead.</p><p>The main methods for <span class="nctnt ncbi-class">CMutex</span> operation are <span class="nctnt ncbi-func">Lock()</span>, <span class="nctnt ncbi-func">TryLock()</span> and <span class="nctnt ncbi-func">Unlock()</span>:</p><pre><span class="nctnt-pre ncbi-code">void Lock(void);<br />bool TryLock(void);<br />void Unlock(void);</span></pre><p>The <span class="nctnt ncbi-func">Lock()</span> mutex method is used by a thread to acquire a lock. The lock can be acquired only if the mutex is unlocked; that is, not in use. If a thread has acquired a lock before, the lock counter is incremented. This is called nesting. The lock counter is only decremented when the same thread issues an <span class="nctnt ncbi-func">Unlock()</span>. In other words, each call to <span class="nctnt ncbi-func">Lock()</span> must have a corresponding <span class="nctnt ncbi-func">Unlock()</span> by the same thread. If the mutex has been locked by another thread, then the thread must wait until it is unlocked. When the mutex is unlocked, the waiting thread can acquire the lock. This, then, is like a lock on an unlocked mutex.</p><p>The <span class="nctnt ncbi-func">TryLock()</span> mutex can be used to probe the mutex to see if a lock is possible, and if it is, acquire a lock on the mutex. If the mutex has already been locked, <span class="nctnt ncbi-func">TryLock()</span> returns <span class="nctnt ncbi-monospace">FALSE</span>. If the mutex is unlocked, than <span class="nctnt ncbi-func">TryLock()</span> acquires a lock on the mutex just as <span class="nctnt ncbi-func">Lock()</span> does, and returns <span class="nctnt ncbi-monospace">TRUE</span>.</p><p>The <span class="nctnt ncbi-func">Unlock()</span> method is used to decrease the lock counter if the mutex has been acquired by this thread. When the lock counter becomes zero, then the mutex is completely released (unlocked). If the mutex is not locked or locked by another thread, then the exception CMutexException (eOwner) is thrown.</p><p>The <span class="nctnt ncbi-class">CMutex</span> uses the functionality of <span class="nctnt ncbi-class">CFastMutex</span>. Because <span class="nctnt ncbi-class">CMutex</span> allows nested locks and performs checks of mutex owner it is somewhat slower than <span class="nctnt ncbi-class">CFastMutex</span>, but capable of protecting complicated code, and safer to use. To guarantee for a mutex release, <span class="nctnt ncbi-class">CMutexGuard</span> can be used. The mutex is locked by the <span class="nctnt ncbi-class">CMutexGuard</span> constructor and unlocked by its destructor. Macro <span class="nctnt ncbi-macro">DEFINE_STATIC_MUTEX(id)</span> will define static mutex variable with name <span class="nctnt ncbi-var">id</span>. Macro <span class="nctnt ncbi-macro">DECLARE_CLASS_STATIC_MUTEX(id)</span> will declare static class member of mutex type name <span class="nctnt ncbi-var">id</span>. Macro <span class="nctnt ncbi-macro">DEFINE_CLASS_STATIC_MUTEX(class, id)</span> will define class static mutex variable <span class="nctnt ncbi-var">class::id</span>. The following example demonstrates usage of <span class="nctnt ncbi-var">CMutex</span>, including lock nesting:</p><pre><span class="nctnt-pre ncbi-code">static int Count = 0;<br />DEFINE_STATIC_MUTEX(CountMutex);<br /><br />void Add2(void)<br />{<br />    CMutexGuard guard(CountMutex);<br />    Count += 2;<br />    if (Count &lt; 20) {<br />        Add3();<br />    }<br />}<br /><br />void Add3(void)<br />{<br />    CMutexGuard guard(CountMutex);<br />    Count += 3;<br />    if (Count &lt; 20) {<br />        Add2();<br />    }<br />}</span></pre><p>This example will result in several nested locks of the same mutex with the guaranteed release of each lock.</p><p>It is important not to unlock the mutex protected by a mutex guard. <span class="nctnt ncbi-class">CFastMutexGuard</span> and <span class="nctnt ncbi-class">CMutexGuard</span> both unlock the associated mutex on destruction. It the mutex is already unlocked this will cause a runtime error. Instead of unlocking the mutex directly one can use <span class="nctnt ncbi-func">CFastMutexGuard::Release()</span> or <span class="nctnt ncbi-func">CMutexGuard::Release()</span> method. These methods unlock the mutex and unlink it from the guard.</p><p>In addition to usual <span class="nctnt ncbi-func">Lock()</span> and <span class="nctnt ncbi-func">Unlock()</span> methods, the <span class="nctnt ncbi-class">CMutex</span> class implements a method to test the mutex state before locking it. <span class="nctnt ncbi-func">TryLock()</span> method attempts to acquire the mutex for the calling thread and returns <span class="nctnt ncbi-monospace">true</span> on success (this includes nested locks by the same thread) or <span class="nctnt ncbi-monospace">false</span> if the mutex has been acquired by another thread. After a successful <span class="nctnt ncbi-func">TryLock()</span> the mutex should be unlocked like after regular <span class="nctnt ncbi-func">Lock()</span>.</p></div><div class="sec" id="ch_core.CFastMutex"><h4><span class="title">CFastMutex</span></h4><p>The <span class="nctnt ncbi-class">CFastMutex</span> class provides the API for acquiring a mutex. Unlike <span class="nctnt ncbi-class">CMutex</span>, this mutex does not permit nesting and does not check the mutex owner before unlocking. <span class="nctnt ncbi-class">CFastMutex</span> is, however, faster than <span class="nctnt ncbi-class">CMutex</span> and should be used when performance is more important than data protection. If performance is less important than data protection, use <span class="nctnt ncbi-class">CMutex</span>, instead.</p><p>The main methods for <span class="nctnt ncbi-class">CFastMutex</span> operation are <span class="nctnt ncbi-func">Lock()</span>, <span class="nctnt ncbi-func">TryLock()</span> and <span class="nctnt ncbi-func">Unlock()</span>:</p><pre><span class="nctnt-pre ncbi-code">void Lock(void);<br />bool TryLock(void);<br />void Unlock(void);</span></pre><p>The <span class="nctnt ncbi-func">Lock()</span> mutex method is used by a thread to acquire a lock without any nesting or ownership checks.</p><p>The <span class="nctnt ncbi-func">TryLock()</span> mutex can be used to probe the mutex to see if a lock is possible, and if it is, acquire a lock on the mutex. If the mutex has already been locked, <span class="nctnt ncbi-func">TryLock()</span> returns <span class="nctnt ncbi-monospace">FALSE</span>. If the mutex is unlocked, than <span class="nctnt ncbi-func">TryLock()</span> acquires a lock on the mutex just as <span class="nctnt ncbi-func">Lock()</span> does, and returns <span class="nctnt ncbi-monospace">TRUE</span>. The locking is done without any nesting or ownership checks.</p><p>The <span class="nctnt ncbi-func">Unlock()</span> method is used to unlock the mutex without any nesting or ownership checks.</p><p>The <span class="nctnt ncbi-class">CFastMutex</span> should be used only to protect small and simple parts of code. To guarantee for the mutex release the <span class="nctnt ncbi-class">CFastMutexGuard</span> class may be used. The mutex is locked by the <span class="nctnt ncbi-class">CFastMutexGuard</span> constructor and unlocked by its destructor. To avoid problems with initialization of static objects on different platforms, special macro definitions are intended to be used to declare static mutexes. Macro <span class="nctnt ncbi-macro">DEFINE_STATIC_FAST_MUTEX(id)</span> will define static mutex variable with name <span class="nctnt ncbi-var">id</span>. Macro <span class="nctnt ncbi-macro">DECLARE_CLASS_STATIC_FAST_MUTEX(id)</span> will declare static class member of mutex type with name <span class="nctnt ncbi-var">id</span>. Macro <span class="nctnt ncbi-macro">DEFINE_CLASS_STATIC_FAST_MUTEX(class, id)</span> will define static class mutex variable <span class="nctnt ncbi-var">class::id</span>. The example below demonstrates how to protect an integer variable with the fast mutex:</p><pre><span class="nctnt-pre ncbi-code">void ThreadSafe(void)<br />{<br />    static int Count = 0;<br />    DEFINE_STATIC_FAST_MUTEX(CountMutex);<br />    ...<br />    {{<br />        CFastMutexGuard guard(CountMutex);<br />        Count++;<br />    }}<br />    ...<br />}</span></pre></div><div class="sec" id="ch_core.SSystemMutex"><h4><span class="title">SSystemMutex and SSystemFastMutex</span></h4><p>The <span class="nctnt ncbi-class">CMutex</span> class is built on the platform-dependent mutex class, <span class="nctnt ncbi-class">SSystemMutex</span>. The <span class="nctnt ncbi-class">SSystemMutex</span> is in turn built using the <span class="nctnt ncbi-class">SSystemFastMutex</span> class with additional provisions for keeping track of the thread ownership using the <span class="nctnt ncbi-class">CThreadSystemID</span>, and a counter for the number of in the same thread locks (nested or recursive locks).</p><p>Each of the <span class="nctnt ncbi-class">SSystemMutex</span> and <span class="nctnt ncbi-class">SSystemFastMutex</span> classes have the <span class="nctnt ncbi-func">Lock()</span>, <span class="nctnt ncbi-func">TryLock()</span> and <span class="nctnt ncbi-func">Unlock()</span> methods that are platform specific. These methods are used by the platform independent classes, <span class="nctnt ncbi-class">CMutex</span> and <span class="nctnt ncbi-class">CFastMutex</span> to provide locking and unlocking services.</p></div><div class="sec" id="ch_core.CMutexGuard"><h4><span class="title">CMutexGuard and CFastMutexGuard</span></h4><p>The <span class="nctnt ncbi-class">CMutexGuard</span> and the <span class="nctnt ncbi-class">CFastMutexGuard</span> classes provide platform independent read and write lock guards to the mutexes. These classes are aliased as typedefs TReadLockGuard and TWriteLockGuard in the <span class="nctnt ncbi-class">CMutexGuard</span> and the <span class="nctnt ncbi-class">CFastMutexGuard</span> classes.</p></div><div class="sec" id="ch_core.lock_classes"><h4><span class="title">Lock Classes</span></h4><p>This class implements sharing a resource between multiple reading and writing threads. The following rules are used for locking:</p><ul><li><p>if unlocked, the RWLock can be acquired for either R-lock or W-lock</p></li><li><p>if R-locked, the RWLock can be R-locked by the same thread or other threads</p></li><li><p>if W-locked, the RWLock can not be acquired by other threads (a call to <span class="nctnt ncbi-func">ReadLock()</span> or <span class="nctnt ncbi-func">WriteLock()</span> by another thread will suspend that thread until the RW-lock release).</p></li><li><p>R-lock after W-lock by the same thread is allowed but treated as a nested W-lock</p></li><li><p>W-lock after R-lock by the same thread results in a runtime error</p></li></ul><p>Like <span class="nctnt ncbi-class">CMutex</span>, CRWLock also provides methods for checking its current state: <span class="nctnt ncbi-func">TryReadLock()</span> and <span class="nctnt ncbi-func">TryWriteLock()</span>. Both methods try to acquire the RW-lock, returning <span class="nctnt ncbi-monospace">true</span> on success (the RW-lock becomes R-locked or W-locked) or <span class="nctnt ncbi-monospace">false</span> if the RW-lock can not be acquired for the calling thread.</p><p>The following subsections describe these locks in more detail:</p><ul><li><p><a href="ch_core.html#ch_core.CRWLock">CRWLock</a></p></li><li><p><a href="ch_core.html#ch_core.CAutoRW">CAutoRW</a></p></li><li><p><a href="ch_core.html#ch_core.CReadLockGuard">CReadLockGuard</a></p></li><li><p><a href="ch_core.html#ch_core.CWriteLockGuard">CWriteLockGuard</a></p></li><li><p><a href="ch_core.html#ch_core.CInternalRWLock">CInternalRWLock</a></p></li><li><p><a href="ch_core.html#ch_core.CSemaphore">CSemaphore</a></p></li></ul><div class="sec" id="ch_core.CRWLock"><h5><span class="title">CRWLock</span></h5><p>The <span class="nctnt ncbi-class">CRWLock</span> class allows read-after-write (R-after-W) locks for multiple readers or a single writer with recursive locks. The R-after-W lock is considered to be a recursive Write-lock. The write-after-read (W-after-R) is not permitted and can be caught when <span class="nctnt ncbi-macro">_DEBUG</span> is defined. When <span class="nctnt ncbi-macro">_DEBUG</span> is not defined, it does not always detect the W-after-R correctly, so a deadlock can occur in these circumstances. Therefore, it is important to test your application in the <span class="nctnt ncbi-macro">_DEBUG</span> mode first.</p><p>The main methods in the class API are <span class="nctnt ncbi-func">ReadLock()</span>, <span class="nctnt ncbi-func">WriteLock()</span>, <span class="nctnt ncbi-func">TryReadLock()</span>, <span class="nctnt ncbi-func">TryWriteLock()</span> and <span class="nctnt ncbi-func">Unlock()</span>.</p><pre><span class="nctnt-pre ncbi-code">void ReadLock(void);<br />void WriteLock(void);<br />bool TryReadLock(void);<br />bool TryWriteLock(void);<br />void Unlock(void);</span></pre><p>The <span class="nctnt ncbi-func">ReadLock()</span> is used to acquire a read lock. If a write lock has already been acquired by another thread, then this thread waits until it is released.</p><p>The <span class="nctnt ncbi-func">WriteLock()</span> is used to acquire a write lock. If a read or write lock has already been acquired by another thread, then this thread waits until it is released.</p><p>The <span class="nctnt ncbi-func">TryReadLock()</span> and <span class="nctnt ncbi-func">TryWriteLock()</span> methods are used to try and acquire a read or write lock, respectively, if at all possible. If a lock cannot be acquired, they immediately return with a <span class="nctnt ncbi-monospace">FALSE</span> value and do not wait to acquire a lock like the <span class="nctnt ncbi-func">ReadLock()</span> and <span class="nctnt ncbi-func">WriteLock()</span> methods. If a lock is successfully acquired, a <span class="nctnt ncbi-monospace">TRUE</span> value is returned.</p><p>As expected from the name, the <span class="nctnt ncbi-func">Unlock()</span> method releases the RW-lock.</p></div><div class="sec" id="ch_core.CAutoRW"><h5><span class="title">CAutoRW</span></h5><p>The <span class="nctnt ncbi-class">CAutoRW</span> class is used to provide a Read Write lock that is automatically released by the <span class="nctnt ncbi-class">CAutoRW</span> class' destructor. The locking mechanism is provided by a <span class="nctnt ncbi-class">CRWLock</span> object that is initialized when the <span class="nctnt ncbi-class">CAutoRW</span> class constructor is called.</p><p>An acquired lock can be released by an explicit call to the class <span class="nctnt ncbi-func">Release()</span> method. The lock can also be released by the class destructor. When the destructor is called the lock if successfully acquired and not already released by <span class="nctnt ncbi-func">Release()</span> is released.</p></div><div class="sec" id="ch_core.CReadLockGuard"><h5><span class="title">CReadLockGuard</span></h5><p>The <span class="nctnt ncbi-class">CReadLockGuard</span> class is used to provide a basic read lock guard that can be used by other classes. This class is derived from the <span class="nctnt ncbi-class">CAutoRW</span> class.</p><p>The class constructor can be passed a <span class="nctnt ncbi-class">CRWLock</span> object on which a read lock is acquired, and which is registered to be released by the class destructor. The class's <span class="nctnt ncbi-func">Guard()</span> method can also be called with a <span class="nctnt ncbi-class">CRWLock</span> object and if this is not the same as the already registered <span class="nctnt ncbi-class">CRWLock</span> object, the old registered object is released, and the new <span class="nctnt ncbi-class">CRWLock</span> object is registered and a read lock acquired on it.</p></div><div class="sec" id="ch_core.CWriteLockGuard"><h5><span class="title">CWriteLockGuard</span></h5><p>The <span class="nctnt ncbi-class">CWriteLockGuard</span> class is used to provide a basic write lock guard that can be used by other classes. The <span class="nctnt ncbi-class">CWriteLockGuard</span> class is similar to the <span class="nctnt ncbi-class">CReadLockGuard</span> class except that it provides a write lock instead of a read lock. This class is derived from the <span class="nctnt ncbi-class">CAutoRW</span> class.</p><p>The class constructor can be passed a <span class="nctnt ncbi-class">CRWLock</span> object on which a write lock is acquired, and which is registered to be released by the class destructor. The class's <span class="nctnt ncbi-func">Guard()</span> method can also be called with a <span class="nctnt ncbi-class">CRWLock</span> object and if this is not the same as the already registered <span class="nctnt ncbi-class">CRWLock</span> object, the old registered object is released, and the new <span class="nctnt ncbi-class">CRWLock</span> object is registered and a write lock acquired on it.</p></div><div class="sec" id="ch_core.CInternalRWLock"><h5><span class="title">CInternalRWLock</span></h5><p>The <span class="nctnt ncbi-class">CInternalRWLock</span> class holds platform dependent RW-lock data such as data on semaphores and mutexes. This class is not meant to be used directly by user applications. This class is used by other classes such as the <span class="nctnt ncbi-class">CRWLock</span> class.</p></div><div class="sec" id="ch_core.CSemaphore"><h5><span class="title">CSemaphore</span></h5><p>The <span class="nctnt ncbi-class">CSemaphore</span> class implements a general purpose counting semaphore. The constructor is passed an initial count for the semaphore and a maximum semaphore count.</p><p>When the <span class="nctnt ncbi-func">Wait()</span> method is executed for the semaphore, the counter is decremented by one. If the semaphore's count is zero then the thread waits until it is not zero. A variation on the <span class="nctnt ncbi-func">Wait()</span> method is the <span class="nctnt ncbi-func">TryWait()</span> method which is used to prevent long waits. The <span class="nctnt ncbi-func">TryWait()</span> can be passed a timeout value in seconds and nanoseconds:</p><pre><span class="nctnt-pre ncbi-code">bool TryWait(unsigned int timeout_sec = 0, unsigned int timeout_nsec = 0);</span></pre><p>The <span class="nctnt ncbi-func">TryWait()</span> method can wait for the specified time for the semaphore's count to exceed zero. If that happens, the counter is decremented by one and <span class="nctnt ncbi-func">TryWait()</span> returns <span class="nctnt ncbi-monospace">TRUE</span>; otherwise, it returns <span class="nctnt ncbi-monospace">FALSE</span>.</p><p>The semaphore count is incremented by the <span class="nctnt ncbi-func">Post()</span> method and an exception is thrown if the maximum count is exceeded.</p></div></div></div></div><div class="sec" id="ch_core.files_dirs"><h2><span class="title">Working with File and Directories Using CFile and CDir</span></h2><p>An application may need to work with files and directories. The CORELIB provides a number of portable classes to model a system file and directory. The base class for the files and directories is <span class="nctnt ncbi-class">CDirEntry</span>. Other classes such as <span class="nctnt ncbi-class">CDir</span> and <span class="nctnt ncbi-class">CFile</span> that deal with directories and files are derived form this base class.</p><p>The following sections discuss the file and directory classes in more detail:</p><ul><li><p><a href="ch_core.html#ch_core.system_call">Executing a System Command using the System() Method</a></p></li><li><p><a href="ch_core.html#ch_core.process_modes">Defining Spawned Process Modes (EMode type)</a></p></li><li><p><a href="ch_core.html#ch_core.spawn_process">Spawning a Process using SpawnX() Methods</a></p></li><li><p><a href="ch_core.html#ch_core.wait_method">Waiting for a Process to Terminate using the Wait() method</a></p></li></ul><div class="sec" id="ch_core.CDirEntry"><h3><span class="title">CDirEntry class</span></h3><p>This class models the directory entry structure for the file system and assumes that the path argument has the following form, where any or all components may be missing:</p><pre><span class="nctnt-pre ncbi-path">&lt;dir&gt;&lt;title&gt;&lt;ext&gt;</span></pre><p>where:</p><ul><li><p><span class="nctnt ncbi-path">&lt;dir&gt;</span> -- is the file path ("<span class="nctnt ncbi-path">/usr/local/bin/</span>" or "<span class="nctnt ncbi-path">c:\windows\</span>")</p></li><li><p><span class="nctnt ncbi-path">&lt;title&gt;</span> -- is the file name without ext ("<span class="nctnt ncbi-path">autoexec</span>")</p></li><li><p><span class="nctnt ncbi-path">&lt;ext&gt;</span> -- is the file extension ("<span class="nctnt ncbi-path">.bat</span>" - whatever goes after the last dot)</p></li></ul><p>The supported filename formats are for the Windows, Unix, and Mac file systems.</p><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDirEntry.html">CDirEntry</a> class provides the base methods such as the following for dealing with the components of a path name :</p><ul><li><p><span class="nctnt ncbi-func">GetPath()</span>: Get pathname.</p></li><li><p><span class="nctnt ncbi-func">GetDir()</span>: Get the Directory component for this directory entry.</p></li><li><p><span class="nctnt ncbi-func">GetBase()</span>: Get the base entry name without extension.</p></li><li><p><span class="nctnt ncbi-func">GetName()</span>: Get the base entry name with extension.</p></li><li><p><span class="nctnt ncbi-func">GetExt()</span>: Get the extension name.</p></li><li><p><span class="nctnt ncbi-func">MakePath()</span>: Given the components of a path, combine them to create a path string.</p></li><li><p><span class="nctnt ncbi-func">SplitPath()</span>: Given a path string, split them into its constituent components.</p></li><li><p><span class="nctnt ncbi-func">GetPathSeparator()</span>: Get path separator symbol specific for the platform such as a '\' or '/'.</p></li><li><p><span class="nctnt ncbi-func">IsPathSeparator()</span>: Check character "c" as path separator symbol specific for the platform.</p></li><li><p><span class="nctnt ncbi-func">AddTrailingPathSeparator()</span>: Add a trailing path separator, if needed.</p></li><li><p><span class="nctnt ncbi-func">ConvertToOSPath()</span>: Convert relative "path" on any OS to current OS dependent relative path.</p></li><li><p><span class="nctnt ncbi-func">IsAbsolutePath()</span>: Note that the "path" must be for current OS.</p></li><li><p><span class="nctnt ncbi-func">ConcatPath()</span>: Concatenate the two parts of the path for the current OS.</p></li><li><p><span class="nctnt ncbi-func">ConcatPathEx()</span>: Concatenate the two parts of the path for any OS.</p></li><li><p><span class="nctnt ncbi-func">MatchesMask()</span>: Match "name" against the filename "mask".</p></li><li><p><span class="nctnt ncbi-func">Rename()</span>: Rename entry to specified "new_path".</p></li><li><p><span class="nctnt ncbi-func">Remove()</span>: Remove the directory entry.</p></li></ul><p>The last method on the list, the <span class="nctnt ncbi-func">Remove()</span> method accepts an enumeration type parameter, <span class="nctnt ncbi-type">EDirRemoveMode</span>, which specifies the extent of the directory removal operation - you can delete only an empty directory, only files in a directory but not any subdirectories, or remove the entire directory tree:</p><pre><span class="nctnt-pre ncbi-code">/// Directory remove mode.<br />enum EDirRemoveMode {<br />    eOnlyEmpty,     ///&lt; Remove only empty directory<br />    eNonRecursive,  ///&lt; Remove all files in directory, but not remove<br />                    ///&lt; subdirectories and files in it<br />    eRecursive      ///&lt; Remove all files and subdirectories<br />};</span></pre><p><span class="nctnt ncbi-class">CDirEntry</span> knows about different types of files or directory entries. Most of these file types are modeled after the Unix file system but can also handle the file system types for the Windows platform. The different file system types are represented by the enumeration type <span class="nctnt ncbi-type">EType</span> which is defined as follows :</p><pre><span class="nctnt-pre ncbi-code">/// Which directory entry type.<br />enum EType {<br />    eFile = 0,     ///&lt; Regular file<br />    eDir,          ///&lt; Directory<br />    ePipe,         ///&lt; Pipe<br />    eLink,         ///&lt; Symbolic link     (Unix only)<br />    eSocket,       ///&lt; Socket            (Unix only)<br />    eDoor,         ///&lt; Door              (Unix only)<br />    eBlockSpecial, ///&lt; Block special     (Unix only)<br />    eCharSpecial,  ///&lt; Character special<br />    //<br />    eUnknown       ///&lt; Unknown type<br />};</span></pre><p><span class="nctnt ncbi-class">CDirEntry</span> knows about permission settings for a directory entry. Again, these are modeled after the Unix file system. The different permissions are represented by the enumeration type <span class="nctnt ncbi-type">EMode</span> which is defined as follows :</p><pre><span class="nctnt-pre ncbi-code">/// Directory entry's access permissions.<br />enum EMode {<br />    fExecute = 1,       ///&lt; Execute permission<br />    fWrite   = 2,       ///&lt; Write permission<br />    fRead    = 4,       ///&lt; Read permission<br />    // initial defaults for dirs<br />    fDefaultDirUser  = fRead | fExecute | fWrite,<br />                        ///&lt; Default user permission for dir.<br />    fDefaultDirGroup = fRead | fExecute,<br />                        ///&lt; Default group permission for dir.<br />    fDefaultDirOther = fRead | fExecute,<br />                        ///&lt; Default other permission for dir.<br />    // initial defaults for non-dir entries (files, etc.)<br />    fDefaultUser     = fRead | fWrite,<br />                        ///&lt; Default user permission for file<br />    fDefaultGroup    = fRead,<br />                        ///&lt; Default group permission for file<br />    fDefaultOther    = fRead,<br />                        ///&lt; Default other permission for file<br />    fDefault = 8        ///&lt; Special flag:  ignore all other flags,<br />                        ///&lt; use current default mode<br />};<br />typedef unsigned int TMode;  ///&lt; Binary OR of "EMode"</span></pre><p>The directory entry permissions of read(r), write(w), execute(x), are defined for the "user", "group" and "others" The initial default permission for directories is "rwx" for "user", "rx" for "group" and "rx" for "others". These defaults allow a user to create directory entries while the "group" and "others" can only change to the directory and read a listing of the directory contents. The initial default permission for files is "rw" for "user", "r" for "group" and "r" for "others". These defaults allow a user to read and write to a file while the "group" and "others" can only read the file.</p><p>These directory permissions handle most situations but don't handle all permission types. For example, there is currently no provision for handling the Unix "sticky bit" or the "suid" or "sgid" bits. Moreover, operating systems such as Windows NT/2000/2003 and Solaris use Access Control Lists (ACL) settings for files. There is no provision in <span class="nctnt ncbi-class">CDirEntry</span> to handle ACLs</p><p>Other methods in <span class="nctnt ncbi-class">CDirEntry</span> deal specifically with checking the attributes of a directory entry such as the following methods:</p><ul><li><p><span class="nctnt ncbi-func">IsFile()</span>: Check if directory entry is a file.</p></li><li><p><span class="nctnt ncbi-func">IsDir()</span>: Check if directory entry is a directory.</p></li><li><p><span class="nctnt ncbi-func">GetType()</span>: Get type of directory entry. This returns an <span class="nctnt ncbi-type">EType</span> value.</p></li><li><p><span class="nctnt ncbi-func">GetTime()</span>: Get time stamp of directory entry.</p></li><li><p><span class="nctnt ncbi-func">GetMode()</span>: Get permission mode for the directory entry.</p></li><li><p><span class="nctnt ncbi-func">SetMode()</span>: Set permission mode for the directory entry.</p></li><li><p><span class="nctnt ncbi-func">static void SetDefaultModeGlobal()</span>: Set default mode globally for all <span class="nctnt ncbi-class">CDirEntry</span> objects. This is a class-wide static method and applies to all objects of this class.</p></li><li><p><span class="nctnt ncbi-func">SetDefaultMode()</span>: Set mode for this one object only.</p></li></ul><p>These methods are inherited by the derived classes <span class="nctnt ncbi-class">CDir</span> and <span class="nctnt ncbi-class">CFile</span> that are used to access directories and files, respectively.</p></div><div class="sec" id="ch_core.CFile"><h3><span class="title">CFile class</span></h3><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCFile.html">CFile</a> is derived from the base class, <span class="nctnt ncbi-class">CDirEntry</span>. Besides inheriting the methods discussed in the <a href="ch_core.html#ch_core.CDirEntry">previous section</a>, the following new methods specific to files are defined in the <span class="nctnt ncbi-class">CFile</span> class:</p><ul><li><p><span class="nctnt ncbi-func">Exists()</span>: Check existence for a file.</p></li><li><p><span class="nctnt ncbi-func">GetLength()</span>: Get size of file.</p></li><li><p><span class="nctnt ncbi-func">GetTmpName()</span>: Get temporary file name.</p></li><li><p><span class="nctnt ncbi-func">GetTmpNameEx()</span>: Get temporary file name in a specific directory and having a specified prefix value.</p></li><li><p><span class="nctnt ncbi-func">CreateTmpFile()</span>: Create temporary file and return pointer to corresponding stream.</p></li><li><p><span class="nctnt ncbi-func">CreateTmpFileEx()</span>: Create temporary file and return pointer to corresponding stream. You can additionally specify the directory in which to create the temporary file and the prefix to use for the temporary file name.</p></li></ul><p>The methods <span class="nctnt ncbi-func">CreateTmpFile()</span> and <span class="nctnt ncbi-func">CreateTmpFileEx()</span> allow the creation of either a text or binary file. These two types of files are defined by the enumeration type, <span class="nctnt ncbi-type">ETextBinary</span>, and the methods accept a parameter of this type to indicate the type of file to be created:</p><pre><span class="nctnt-pre ncbi-code">/// What type of temporary file to create.<br />enum ETextBinary {<br />    eText,          ///&lt;Create text file<br />    eBinary         ///&lt; Create binary file<br />};</span></pre><p>Additionally, you can specify the type of operations (read, write) that should be permitted on the temporary files. These are defined by the enumeration type, <span class="nctnt ncbi-type">EAllowRead</span>, and the <span class="nctnt ncbi-func">CreateTmpFile()</span> and <span class="nctnt ncbi-func">CreateTmpFileEx()</span> methods accept a parameter of this type to indicate the type operations that are permitted:</p><pre><span class="nctnt-pre ncbi-code">/// Which operations to allow on temporary file.<br />enum EAllowRead {<br />    eAllowRead,     ///&lt; Allow read and write<br />    eWriteOnly      ///&lt; Allow write only<br />};</span></pre></div><div class="sec" id="ch_core.CDir"><h3><span class="title">CDir class</span></h3><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDir.html">CDir</a> is derived from the base class, <span class="nctnt ncbi-class">CDirEntry</span>. Besides inheriting the methods discussed in the <a href="ch_core.html#ch_core.CDirEntry">CDirEntry section</a>, the following new methods specific to directories are defined in the <span class="nctnt ncbi-class">CDir</span> class:</p><ul><li><p><span class="nctnt ncbi-func">Exists()</span>: Check existence for a directory.</p></li><li><p><span class="nctnt ncbi-func">GetHome()</span>: Get the user's home directory.</p></li><li><p><span class="nctnt ncbi-func">GetCwd()</span>: Get the current working directory.</p></li><li><p><span class="nctnt ncbi-func">GetEntries()</span>: Get directory entries based on a specified mask parameter. Retuns a vector of pointers to <span class="nctnt ncbi-class">CDirEntry</span> objects defined by <span class="nctnt ncbi-type">TEntries</span></p></li><li><p><span class="nctnt ncbi-func">Create()</span>: Create the directory using the directory name passed in the constructor.</p></li><li><p><span class="nctnt ncbi-func">CreatePath()</span>: Create the directory path recursively possibly more than one at a time.</p></li><li><p><span class="nctnt ncbi-func">Remove()</span>: Delete existing directory.</p></li></ul><p>The last method on the list, the <span class="nctnt ncbi-func">Remove()</span> method accepts an enumeration type parameter, <span class="nctnt ncbi-type">EDirRemoveMode</span>, defined in the <a href="ch_core.html#ch_core.CDirEntry">CDirEntry</a> class which specifies the extent of the directory removal operation - you can delete only an empty directory, only files in a directory but not any subdirectories, or remove the entire directory tree.</p></div><div class="sec" id="ch_core.CMemoryFile"><h3><span class="title">CMemoryFile class</span></h3><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCMemoryFile.html">CMemoryFile</a> is derived from the base class, <span class="nctnt ncbi-class">CDirEntry</span>. This class creates a virtual image of a disk file in memory that allow normal file operations to be permitted, but the file operations are actually performed on the image of the file in memory. This can result in considerable improvements in speed when there are many "disk intensive" file operations being performed on a file which is mapped to memory.</p><p>Besides inheriting the methods discussed in the <a href="ch_core.html#ch_core.CDirEntry">CDirEntry section</a>, the following new methods specific to memory mapped are defined in the <span class="nctnt ncbi-class">CMemoryFile </span>class:</p><ul><li><p><span class="nctnt ncbi-func">IsSupported()</span>: Check if memory-mapping is supported by the C++ Toolkit on this platform.</p></li><li><p><span class="nctnt ncbi-func">GetPtr()</span>: Get pointer to beginning of data in the memory mapped file.</p></li><li><p><span class="nctnt ncbi-func">GetSize()</span>: Get size of the mapped area.</p></li><li><p><span class="nctnt ncbi-func">Flush()</span>: Flush by writing all modified copies of memory pages to the underlying file.</p></li><li><p><span class="nctnt ncbi-func">Unmap()</span>: Unmap file if it has already been mapped.</p></li><li><p><span class="nctnt ncbi-func">MemMapAdvise()</span>: Advise on memory map usage.</p></li><li><p><span class="nctnt ncbi-func">MemMapAdviseAddr()</span>: Advise on memory map usage for specified region.</p></li></ul><p>The methods <span class="nctnt ncbi-func">MemMapAdvise()</span> and <span class="nctnt ncbi-func">MemMapAdviseAddr()</span> allow one to advise on the expected usage pattern for the memory mapped file. The expected usage pattern is defined by the enumeration type, <span class="nctnt ncbi-type">EMemMapAdvise</span>, and these methods accept a parameter of this type to indicate the usage pattern:</p><pre><span class="nctnt-pre ncbi-code">/// What type of data access pattern will be used for mapped region.<br />///<br />/// Advises the VM system that the a certain region of user mapped memory<br />/// will be accessed following a type of pattern. The VM system uses this<br />/// information to optimize work with mapped memory.<br />///<br />/// NOTE: Now works on Unix platform only.<br />typedef enum {<br />    eMMA_Normal,  ///&lt; No further special treatment<br />    eMMA_Random,  ///&lt; Expect random page references<br />    eMMA_Sequential,  ///&lt; Expect sequential page references<br />    eMMA_WillNeed,  ///&lt; Will need these pages<br />    eMMA_DontNeed  ///&lt; Don't need these pages<br />} EMemMapAdvise;</span></pre><p>The memory usage advice is implemented on Unix platforms only, and is not supported on Windows platforms.</p></div></div><div class="sec" id="ch_core.string_classes"><h2><span class="title">String APIs</span></h2><p>The <span class="nctnt ncbi-path">ncbistr.hpp</span> file defines a number of useful constants, types and functions for handling string types. Most of the string functions are defined as class-wides static members of the class <span class="nctnt ncbi-class">NStr</span>.</p><p>The following sections provide additional details on string APIs</p><ul><li><p><a href="ch_core.html#ch_core.string_consts">String Constants</a></p></li><li><p><a href="ch_core.html#ch_core.NStr">NStr Class</a></p></li><li><p><a href="ch_core.html#ch_core.UTF_strings">UTF Strings</a></p></li><li><p><a href="ch_core.html#ch_core.pcase">PCase and PNocase</a></p></li></ul><div class="sec" id="ch_core.string_consts"><h3><span class="title">String Constants</span></h3><p>For convenience, two types of empty strings are provided. A C-language style string that terminates with the null character ('\0') and a C++ style empty string.</p><p>The C-language style empty string constants are <span class="nctnt ncbi-macro">NcbiEmptyCStr</span> which is a macro definition for the <span class="nctnt ncbi-var">NCBI_NS_NCBI::kEmptyCStr</span>. So the <span class="nctnt ncbi-var">NcbiEmptyStr</span> and <span class="nctnt ncbi-var">kEmptyCStr</span> are, for all practical purposes, equivalent.</p><p>The C++-language style empty string constants are <span class="nctnt ncbi-macro">NcbiEmptyString</span> and the <span class="nctnt ncbi-macro">kEmptyStr</span> which are macro definitions for the <span class="nctnt ncbi-func">NCBI_NS_NCBI::CNcbiEmptyString::Get()</span> method that returns an empty string. So the <span class="nctnt ncbi-macro">NcbiEmptyString</span> and <span class="nctnt ncbi-macro">kEmptyStr</span> are, for all practical purposes, equivalent.</p><p>The <span class="nctnt ncbi-var">SIZE_TYPE</span> is an alias for the string::size_type, and the <span class="nctnt ncbi-var">NPOS</span> defines a constant that is returned when a substring search fails, or to indicate an unspecified string position.</p></div><div class="sec" id="ch_core.NStr"><h3><span class="title">NStr Class</span></h3><p>The <span class="nctnt ncbi-class">NStr</span> class encapsulates a number of class-wide static methods. These include string concatenation, string conversion, string comparison, string search functions. Most of these string operations should be familiar to developers by name. For details, see the <span class="nctnt ncbi-class">NStr</span> <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classNStr.html#pub-static-methods">static methods documentation</a>.</p></div><div class="sec" id="ch_core.UTF_strings"><h3><span class="title">UTF Strings</span></h3><p>The <span class="nctnt ncbi-class">CStringUTF8</span> class extends the C++ string class and provides support for Unicode Transformation Format-8 (UTF-8) strings.</p><p>This class supports constructors where the input argument is a string reference, char* pointer, and wide string, and wide character pointers. Wide string support exists if the macro <span class="nctnt ncbi-macro">HAVE_WSTRING</span> is defined:</p><pre><span class="nctnt-pre ncbi-code">CStringUTF8(const string&amp; src);<br />CStringUTF8(const char* src);<br />CStringUTF8(const wstring&amp; src);<br />CStringUTF8(const wchar_t* src);</span></pre><p>The <span class="nctnt ncbi-class">CStringUTF8</span> class defines assignment(=) and append-to string (+=) operators where the string assigned or appended can be a <span class="nctnt ncbi-path">CStringUTF8</span> reference, string reference, char* pointer, wstring reference, wchar_t* pointer.</p><p>Conversion to ASCII from <span class="nctnt ncbi-class">CStringUTF8</span> is defined by the <span class="nctnt ncbi-func">AsAscii()</span> method. This method can throw a StringException with error codes 'eFormat' or 'eConvert' if the string has a wrong UTF-8 format or cannot be converted to ASCII.</p><pre><span class="nctnt-pre ncbi-code">string AsAscii(void) const;<br />wstring AsUnicode(void) const</span></pre></div><div class="sec" id="ch_core.pcase"><h3><span class="title">PCase and PNocase</span></h3><p>The <span class="nctnt ncbi-class">PCase</span> and <span class="nctnt ncbi-class">PNocase</span> structures define case-sensitive and case-insensitive comparison functions, respectively. These comparison functions are the <span class="nctnt ncbi-func">Compare()</span>, <span class="nctnt ncbi-func">Less()</span>, <span class="nctnt ncbi-func">Equals()</span>, <span class="nctnt ncbi-func">operator()</span>. The <span class="nctnt ncbi-func">Compare()</span> returns an integer (-1 for less than, 0 for equal to, 1 for greater than). The <span class="nctnt ncbi-func">Less()</span> and <span class="nctnt ncbi-func">Equals()</span> return a TRUE if the first string is less than or equal to the second string. The <span class="nctnt ncbi-func">operator()</span> returns TRUE if the first string is less than the second.</p><p>A convenience template function <span class="nctnt ncbi-func">AStrEquiv</span> is defined that accepts the two classes to be compared as template parameters and a third template parameter that can be the comparison class such as the <span class="nctnt ncbi-class">PCase</span> and <span class="nctnt ncbi-class">PNocase</span> defined above.</p></div></div><div class="sec" id="ch_core.portable_time_class"><h2><span class="title">Portable Time Class</span></h2><p>The <span class="nctnt ncbi-path">ncbitime.hpp</span> defines <span class="nctnt ncbi-class">CTime</span>, the standard Date/Time class that also can be used to represent elapsed time. Please note that the <span class="nctnt ncbi-class">CTime</span> class works for dates after 1/1/1900 and should not be used for elapsed time prior to this date. Also, since <span class="nctnt ncbi-monospace">Mac OS 9</span> does not support the daylight savings flag, <span class="nctnt ncbi-class">CTime</span> does not support daylight savings on this platform.</p><p>The subsections that follow discuss the following topics:</p><ul><li><p><a href="ch_core.html#ch_core.CTime">CTime Class Constructors</a></p></li><li><p><a href="ch_core.html#ch_core.CTimeMethods">Other CTime Methods</a></p></li></ul><div class="sec" id="ch_core.CTime"><h3><span class="title"><span class="nctnt ncbi-class">CTime</span> Class Constructors</span></h3><p>The <span class="nctnt ncbi-class">CTime</span> class defines three basic constructors that accept commonly used time description arguments and some explicit conversion and copy constructors. The basic constructors are the following:</p><ul><li><p>Constructor 1:<br /><span class="nctnt ncbi-code">    CTime(EInitMode            mode = eEmpty,</span><br /><span class="nctnt ncbi-code">          ETimeZone            tz   = eLocal,</span><br /><span class="nctnt ncbi-code">          ETimeZonePrecision   tzp  = eTZPrecisionDefault);</span></p></li><li><p>Constructor 2:<br /><span class="nctnt ncbi-code">    CTime(int year,</span><br /><span class="nctnt ncbi-code">          int month,</span><br /><span class="nctnt ncbi-code">          int day,</span><br /><span class="nctnt ncbi-code">          int hour = 0,</span><br /><span class="nctnt ncbi-code">          int minute = 0,</span><br /><span class="nctnt ncbi-code">          int second = 0,</span><br /><span class="nctnt ncbi-code">          long nanosecond = 0,</span><br /><span class="nctnt ncbi-code">          ETimeZone tz  = Local,</span><br /><span class="nctnt ncbi-code">          ETimeZonePrecision tzp = eTZPrecisionDefault);</span></p></li><li><p>Constructor 3:<br /><span class="nctnt ncbi-code">    CTime(int year,</span><br /><span class="nctnt ncbi-code">          int yearDayNumber,</span><br /><span class="nctnt ncbi-code">          ETimeZone tz = eLocal,</span><br /><span class="nctnt ncbi-code">          ETimeZonePrecision tzp = eTZPrecisionDefault);</span></p></li></ul><p>In Constructor 1, the <span class="nctnt ncbi-type">EInitMode</span> is an enumeration type defined in the <span class="nctnt ncbi-class">CTime</span> class that can be used to specify whether to build the time object with empty time value (<span class="nctnt ncbi-monospace">eEmpty</span>) or current time (<span class="nctnt ncbi-monospace">eCurrent</span>). The <span class="nctnt ncbi-type">ETimeZone</span> is an enumeration type also defined in the <span class="nctnt ncbi-class">CTime</span> class that is used to specify the local time zone (<span class="nctnt ncbi-monospace">eLocal</span>) or GMT (<span class="nctnt ncbi-monospace">eGmt</span>. The <span class="nctnt ncbi-type">ETimeZonePrecision</span> is an enumeration type also defined in the <span class="nctnt ncbi-class">CTime</span> class that can be used to specify the time zone precision to be used for adjusting the daylight savings time. The default value is <span class="nctnt ncbi-monospace">eNone</span>, which means that daylight savings do not affect time calculations.</p><p>Constructor 2 differs from Constructor 1 with respect to how the timestamp is specified. Here the time stamp is explictly specified as the year, month, day, hour, minute, second, and nanosecond values. The other parameters of type <span class="nctnt ncbi-type">ETimeZone</span> and <span class="nctnt ncbi-type">ETimeZonePrecision</span> have the meanings discussed in the previous paragraph.</p><p>Constructor 3 allows the timestamp to be constructed as the Nth day (<span class="nctnt ncbi-var">yearDayNumber</span>) of a year(<span class="nctnt ncbi-var">year</span>). The other parameters of type <span class="nctnt ncbi-type">EtimeZone</span> and <span class="nctnt ncbi-type">ETimeZonePrecision</span> have the meanings discussed in the previous paragraph.</p><p>The explicit conversion constructor allows the conversion to be made from a string representation of time. The default value of the format string is <span class="nctnt ncbi-var">kEmptyStr</span>, which implies that the format string has the format "M/D/Y h:m:s". As one would expect, the format specifiers M, D, Y, h, m, and s have the meanings month, day, year, hour, minute, and second, respectively:</p><pre><span class="nctnt-pre ncbi-code">explicit CTime(const string&amp; str,<br />               const string&amp;        fmt = kEmptyStr,<br />               ETimeZone            tz  = eLocal,<br />               ETimeZonePrecision   tzp = eTZPrecisionDefault);</span></pre><p>There is also a copy constructor defined that permits copy operations for <span class="nctnt ncbi-class">CTime</span> objects.</p></div><div class="sec" id="ch_core.CTimeMethods"><h3><span class="title">Other <span class="nctnt ncbi-class">CTime</span> Methods</span></h3><p>Once the <span class="nctnt ncbi-class">CTime</span> object is constructed, it can be accessed using the <span class="nctnt ncbi-func">SetTimeT()</span> and <span class="nctnt ncbi-func">GetTimeT()</span> methods. The <span class="nctnt ncbi-func">SetTimeT()</span> method is used to set the <span class="nctnt ncbi-class">CTime</span> with the timestamp passed by the <span class="nctnt ncbi-type">time_t</span> parameter. The <span class="nctnt ncbi-func">GetTimeT()</span> method returns the time stored in the <span class="nctnt ncbi-class">CTime</span> object as a <span class="nctnt ncbi-type">time_t</span> value. The <span class="nctnt ncbi-type">time_t</span> value measures seconds since January 1, 1900; therefore, do not use these methods if the timestamp is less than 1900. Also, time formats are in GMT time format.</p><p>A series of methods that set the time using the database formats <span class="nctnt ncbi-type">TDBTimeI</span> and <span class="nctnt ncbi-type">TDBTimeU</span> are also defined. These database time formats contain local time only and are defined as typedefs in <span class="nctnt ncbi-path">ncbitime.hpp</span>. The mutator methods are <span class="nctnt ncbi-func">SetTimeDBI()</span> and <span class="nctnt ncbi-func">SetTimeDBU()</span>, and the accessor methods are <span class="nctnt ncbi-func">GetTimeDBI()</span> and <span class="nctnt ncbi-func">GetTimeDBU()</span>.</p><p>You can set the time to the current time using the <span class="nctnt ncbi-func">SetCurrent()</span> method, or set it to "empty" using the <span class="nctnt ncbi-func">Clear()</span> method. If you want to measure time as days only and strip the hour, minute, and second information, you can use <span class="nctnt ncbi-func">Truncate()</span> method.</p><p>You can get or set the current time format using the <span class="nctnt ncbi-func">GetFormat()</span> and <span class="nctnt ncbi-func">SetFormat()</span> methods.</p><p>You can get and set the individual components of time, such as year, day, month, hour, minute, second, and nanosecond. The accessor methods for these components are named after the component itself, and their meanings are obvious, e.g., <span class="nctnt ncbi-func">Year()</span> for getting the year component, <span class="nctnt ncbi-func">Month()</span> for getting the month component, <span class="nctnt ncbi-func">Day()</span> for getting the day component, <span class="nctnt ncbi-func">Hour()</span> for getting the hour component, <span class="nctnt ncbi-func">Minute()</span> for getting the minute component, <span class="nctnt ncbi-func">Second()</span> for getting the second component, and <span class="nctnt ncbi-func">NanoSecond()</span> for getting the nanosecond component. The corresponding mutator methods for setting the individual components are the same as the accessor, except that they have the prefix "Set" before them. For example, the mutator method for setting the day is <span class="nctnt ncbi-func">SetDay()</span>. A word of caution on setting the individual components: You can easily set the timestamp to invalid values, such as changing the number of days in the month of February to 29 when it is not a leap year, or 30 or 31.</p><p>A number of methods are available to get useful information from a <span class="nctnt ncbi-class">CTime</span> object. To get a day's year number (1 to 366) use <span class="nctnt ncbi-func">YearDayNumber()</span>. To get the week number in a year, use <span class="nctnt ncbi-func">YearWeekNumber()</span>. To get the week number in a month, use <span class="nctnt ncbi-func">MonthWeekNumber()</span>. You can get the day of week (Sunday=0) by using <span class="nctnt ncbi-func">DayOfWeek()</span>, or the number of days in the current month by using <span class="nctnt ncbi-func">DaysInMonth()</span>.</p><p>There are times when you need to add months, days, hours, minutes, or seconds to an existing <span class="nctnt ncbi-class">CTime</span> object. You can do this by using the <span class="nctnt ncbi-func">AddXXX()</span> methods, where the "XXX" is the time component such as "Year", "Month", "Day", "Hour", "Minute", "Second", "NanoSecond" that is to be added to. Be aware that because the number of days in a month can vary, adding months may change the day number in the timestamp. Operator methods for adding to (+=), subtracting from (-=), incrementing (++), and decrementing (--) days are also available.</p><p>If you need to compare two timestamps, you can use the operator methods for equality (==), in-equality (!=), earlier than (&lt;), later than (&gt;), or a combination test, such as earlier than or equal to (&lt;=) or later than or equal to (&gt;=).</p><p>You can measure the difference between two timestamps in days, hours, minutes, seconds, or nanoseconds. The timestamp difference methods have the form <span class="nctnt ncbi-func">DiffXXX()</span>, where "XXX" is the time unit in which you want the difference calculated such as "Day", "Hour", "Minute", "Second", or "NanoSecond". Thus, <span class="nctnt ncbi-func">DiffHour()</span> can be used to calculate the difference in hours.</p><p>There are times when you may need to do a check on the timestamp. You can use <span class="nctnt ncbi-func">IsLeap()</span> to check if the time is in a leap year, or if it is empty by using <span class="nctnt ncbi-func">IsEmpty()</span>, or if it is valid by using <span class="nctnt ncbi-func">IsValid()</span>, or if it is local time by using <span class="nctnt ncbi-func">IsLocalTime()</span>, or if it is GMT time by using <span class="nctnt ncbi-func">IsGmtTime()</span>.</p><p>If you need to work with time zones explicitly, you can use <span class="nctnt ncbi-func">GetTimeZoneFormat()</span> to get the current time zone format, and <span class="nctnt ncbi-func">SetTimeZoneFormat()</span> to change it. You can use <span class="nctnt ncbi-func">GetTimeZonePrecision()</span> to get the current time zone precision and <span class="nctnt ncbi-func">SetTimeZonePrecision()</span> to change it. To get the time zone difference between local time and GMT, use <span class="nctnt ncbi-func">TimeZoneDiff()</span>. To get current time as local time use <span class="nctnt ncbi-func">GetLocalTime()</span>, and as GMT time use <span class="nctnt ncbi-func">GetGmtTime()</span>. To convert current time to a specified time zone, use <span class="nctnt ncbi-func">ToTime()</span>, or to convert to local time use <span class="nctnt ncbi-func">ToLocalTime()</span>.</p><p>Also defined for <span class="nctnt ncbi-class">CTime</span> are assignment operators to assign a <span class="nctnt ncbi-class">CTime</span> object to another <span class="nctnt ncbi-class">CTime</span> and an assignment operator where the right hand side is a time value string.</p></div></div><div class="sec" id="ch_core.template_utils"><h2><span class="title">Template Utilities</span></h2><p>The <span class="nctnt ncbi-path">ncbiutil.hpp</span> file defines a number of useful template functions, classes, and struct definitions that are used in other parts of the library.</p><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_core.html#ch_core.function_objects">Function Objects</a></p></li><li><p><a href="ch_core.html#ch_core.template_functions">Template Functions</a></p></li></ul><div class="sec" id="ch_core.function_objects"><h3><span class="title">Function Objects</span></h3><p>The <span class="nctnt ncbi-class">p_equal_to</span> and <span class="nctnt ncbi-class">pair_equal_to</span> are template function classes that are derived from the standard <span class="nctnt ncbi-class">binary_function</span> base class. The <span class="nctnt ncbi-class">p_equal_to</span> checks for equality of objects pointed to by a pointer and <span class="nctnt ncbi-class">pair_equal_to</span> checks whether a pair's second element matches a given value. Another <span class="nctnt ncbi-class">PPtrLess</span> function class allows comparison of objects pointed to by a smart pointer.</p><p>The <span class="nctnt ncbi-class">CNameGetter</span> template defines the function <span class="nctnt ncbi-func">GetKey()</span>, which returns the name attribute for the template parameter.</p></div><div class="sec" id="ch_core.template_functions"><h3><span class="title">Template Functions</span></h3><p>Defined here are a number of inline template functions that make it easier to perform common operations on map objects.</p><p><span class="nctnt ncbi-func">NotNull()</span> checks for a null pointer value and throws a <span class="nctnt ncbi-class">CCoreException</span>, if a null value is detected. If the pointer value is not null, it is simply returned.</p><p><span class="nctnt ncbi-func">GetMapElement()</span> searches a map object for an element and returns the element, if found. If the element is not found, it returns a default value, which is usually set to 0 (null).</p><p><span class="nctnt ncbi-func">SetMapElement()</span> sets the map element. If the element to be set is null, its existing key is erased.</p><p><span class="nctnt ncbi-func">InsertMapElement()</span> inserts a new map element.</p><p><span class="nctnt ncbi-func">GetMapString()</span> and <span class="nctnt ncbi-func">SetMapString()</span> are similar to the more general <span class="nctnt ncbi-func">GetMapElement()</span> and <span class="nctnt ncbi-func">SetMapElement()</span>, except that they search a map object for a string. In the case of <span class="nctnt ncbi-func">GetMapString()</span>, it returns a string, if found, and an empty string ("") if not found.</p><p>There are three overloads for the <span class="nctnt ncbi-func">DeleteElements()</span> template function. One overload accepts a container (list, vector, set, multiset) of pointers and deletes all elements in the container and clears the container afterwards. The other overloads work with map and multimap objects. In each case, they delete the pointers in the map object and clear the map container afterwards.</p><p>The <span class="nctnt ncbi-func">AutoMap()</span> template function works with a cache pointed to <span class="nctnt ncbi-type">auto_ptr</span>. It retrieves the result from the cache, and if the cache is empty, it inserts a value into the cache from a specified source.</p><p>A <span class="nctnt ncbi-func">FindBestChoice()</span> template function is defined that returns the best choice (lowest score) value in the container. The container and scoring functions are specified as template parameters. The <span class="nctnt ncbi-func">FindBestChoice()</span> in turn uses the <span class="nctnt ncbi-class">CBestChoiceTracker</span> template class, which uses the standard unary_function as its base class. The <span class="nctnt ncbi-class">CBestChoiceTracker</span> contains the logic to record the scoring function and keep track of the current value and the best score.</p></div></div><div class="sec" id="ch_core.misc_types_macros"><h2><span class="title">Miscellaneous Types and Macros</span></h2><p>The <span class="nctnt ncbi-path">ncbimisc.hpp</span> file defines a number of useful enumeration types and macros that are used in other parts of the library.</p><p>The following topics are discussed in this section:</p><ul><li><p><a href="ch_core.html#ch_core.misc_enum_types">Miscellaneous Enumeration Types</a></p></li><li><p><a href="ch_core.html#ch_core.AutoPtr">AutoPtr Class</a></p></li><li><p><a href="ch_core.html#ch_core.ITERATE_macros">ITERATE Macros</a></p></li><li><p><a href="ch_core.html#ch_core.seq_pos_types">Sequence Position Types</a></p></li></ul><div class="sec" id="ch_core.misc_enum_types"><h3><span class="title">Miscellaneous Enumeration Types</span></h3><p>The enum type <span class="nctnt ncbi-type">EOwnership</span> defines the constants <span class="nctnt ncbi-monospace">eNoOwnership</span> and <span class="nctnt ncbi-monospace">eTakeOwnership</span>. These are used to specify relationships between objects.</p><p>The enum type <span class="nctnt ncbi-type">ENullable</span> defines the constants <span class="nctnt ncbi-monospace">eNullable</span> and <span class="nctnt ncbi-monospace">eNotNullable</span>. These are used to specify if a data element can hold a null or not-null value.</p></div><div class="sec" id="ch_core.AutoPtr"><h3><span class="title">AutoPtr Class</span></h3><p>The <span class="nctnt ncbi-path">ncbimisc.hpp</span> file defines an <span class="nctnt ncbi-class">auto_ptr</span> class if the <span class="nctnt ncbi-macro">HAVE_NO_AUTO_PTR</span> macro is undefined. This is useful in replacing the <span class="nctnt ncbi-class">std::auto_ptr</span> of STL for compilers with poor "auto_ptr" implementation. Section <a href="ch_core.html#ch_core.auto_ptr">STL auto_ptrs</a> discusses details on the use of <span class="nctnt ncbi-class">auto_ptr</span>.</p><p>Another class related to the <span class="nctnt ncbi-class">auto_ptr</span> class is the <span class="nctnt ncbi-class">AutoPtr</span> class. The Standard <span class="nctnt ncbi-class">auto_ptr</span> class from STL does not allow the auto_ptr to be put in STL containers such as list, vector, map etc. Because of the nature of how ownership works in an auto_ptr class, the copy constructor and assignment operator of AutoPtr modify the state of the source <span class="nctnt ncbi-class">AutoPtr</span> object as it transfers ownership to the target <span class="nctnt ncbi-class">AutoPtr</span> object.</p><p>A certain amount of flexibility has been provided in terms of how the pointer is to be deleted. This is done by passing a second argument to the <span class="nctnt ncbi-class">AutoPtr</span> template. This second argument allows the passing of a functor object that defines the deletion of the object. You can define "malloc" pointers in <span class="nctnt ncbi-class">AutoPtr</span>, or you can use an <span class="nctnt ncbi-class">ArrayDeleter</span> template class to properly delete an array of objects using "delete[]". By default, the internal pointer will be deleted using the "delete" operator.</p></div><div class="sec" id="ch_core.ITERATE_macros"><h3><span class="title">ITERATE macros</span></h3><p>When working with STL container classes, it is common to use a for-statement to set up a loop to iterate through the elements in a container. For this reason, the <span class="nctnt ncbi-macro">ITERATE</span> and <span class="nctnt ncbi-macro">NON_CONST_ITERATE</span> macros have been defined to sequence through the container elements. These macros are listed here because their code explains more clearly how they work:</p><pre><span class="nctnt-pre ncbi-code">#define ITERATE(Type, Var, Cont) \<br />    for ( Type::const_iterator Var = (Cont).begin(),\<br />          NCBI_NAME2(Var,_end) = (Cont).end(); \<br />          Var != NCBI_NAME2(Var,_end);  ++Var )<br /><br />#define NON_CONST_ITERATE(Type, Var, Cont) \<br />    for ( Type::iterator Var = (Cont).begin();  Var != (Cont).end();  ++Var )</span></pre><p>The difference between the <span class="nctnt ncbi-macro">ITERATE</span> and <span class="nctnt ncbi-macro">NON_CONST_ITERATE</span> macros is that the former uses a constant iterator and the latter uses a non-constant iterator.</p><p>The uppercase versions of these macros are preferred by convention. Lowercase versions of these macros are also defined, but their use has been deprecated.</p></div><div class="sec" id="ch_core.seq_pos_types"><h3><span class="title">Sequence Position Types</span></h3><p>The <span class="nctnt ncbi-type">TSeqPos</span> and and <span class="nctnt ncbi-type">TSignedSeqPos</span> are defined to specify sequence locations and length. <span class="nctnt ncbi-type">TSeqPos</span> is defined as an unsigned int, and <span class="nctnt ncbi-type">TSignedSqPos</span> is a signed int that should be used only when negative values are a possibility for reporting differences between positions, or for error reporting, although exceptions are generally better for error reporting.</p></div></div><div class="sec" id="ch_core.Containers"><h2><span class="title">Containers</span></h2><p>The Container classes are template classes that provide many useful container types. The template parameter refers to the types of objects whose collection is being described. An overview of some of the <a href="ch_core.html#ch_core.template_typename_Co">container classes is presented in the introductory chapter</a> on the C++ Toolkit.</p><p>The following classes are described in this section:</p><ul><li><p><a href="ch_core.html#ch_core.template_typename_Co">template&lt;typename Coordinate&gt; class CRange</a></p></li><li><p><a href="ch_core.html#ch_core._template_typename_Ob_2">template&lt;typename Object, typename Coordinate = int&gt; class CRangeMap</a></p></li><li><p><a href="ch_core.html#ch_core._template_typename_Ob_3">template&lt;typename Object, typename Coordinate = int&gt; class CRangeMultiMap</a></p></li><li><p><a href="ch_core.html#ch_core.class_CIntervalTree">class CIntervalTree</a></p></li></ul><div class="sec" id="ch_core.template_typename_Co"><h3><span class="title">template&lt;typename Coordinate&gt; class CRange</span></h3><p>Class for storing information about some interval (from:to). From and to points are inclusive.</p><div class="sec" id="ch_core._Typedefs_1"><h4><span class="title">Typedefs</span></h4><pre><span class="nctnt-pre ncbi-code">position_type</span></pre><p>synonym of Coordinate.</p></div><div class="sec" id="ch_core._Methods_1"><h4><span class="title">Methods</span></h4><pre><span class="nctnt-pre ncbi-code">CRange();<br />CRange(position_type from, position_type to);</span></pre><p>constructors</p><pre><span class="nctnt-pre ncbi-code">static position_type GetEmptyFrom();<br />static position_type GetEmptyTo();<br />static position_type GetWholeFrom();<br />static position_type GetWholeTo();</span></pre><p>get special coordinate values</p><pre><span class="nctnt-pre ncbi-code">static CRange&lt;position_type&gt; GetEmpty();<br />static CRange&lt;position_type&gt; GetWhole();</span></pre><p>get special interval objects</p><pre><span class="nctnt-pre ncbi-code">bool HaveEmptyBound() const;</span></pre><p>check if any bound have special 'empty' value</p><pre><span class="nctnt-pre ncbi-code">bool HaveInfiniteBound() const;</span></pre><p>check if any bound have special 'whole' value</p><pre><span class="nctnt-pre ncbi-code">bool Empty() const;</span></pre><p>check if interval is empty (any bound have special 'empty' value or left bound greater then right bound)</p><pre><span class="nctnt-pre ncbi-code">bool Regular() const;</span></pre><p>check if interval's bounds are not special and length is positive</p><pre><span class="nctnt-pre ncbi-code">position_type GetFrom() const;<br />position_type GetTo() const;<br />position_type GetLength() const;</span></pre><p>get parameters of interval</p><pre><span class="nctnt-pre ncbi-code">CRange&lt;position_type&gt;&amp; SetFrom();<br />CRange&lt;position_type&gt;&amp; SetTo();</span></pre><p>set bounds of interval</p><pre><span class="nctnt-pre ncbi-code">CRange&lt;position_type&gt;&amp; SetLength();</span></pre><p>set length of interval leaving left bound (from) unchanged</p><pre><span class="nctnt-pre ncbi-code">CRange&lt;position_type&gt;&amp; SetLengthDown();</span></pre><p>set length of interval leaving right bound (to) unchanged</p><pre><span class="nctnt-pre ncbi-code">bool IntersectingWith(CRange&lt;position_type&gt; range) const;</span></pre><p>check if non empty intervals intersect</p><pre><span class="nctnt-pre ncbi-code">bool IntersectingWithPossiblyEmpty(CRange&lt;position_type&gt; range) const;</span></pre><p>check if intervals intersect</p></div></div><div class="sec" id="ch_core._template_typename_Ob_2"><h3><span class="title">template&lt;typename Object, typename Coordinate = int&gt; class CRangeMap</span></h3><p>Class for storing and retrieving data using interval as key. Also allows efficient iteration over intervals intersecting with specified interval. Time of iteration is proportional to amount of intervals produced by iterator. In some cases, algorithm is not so efficient and may slowdown.</p></div><div class="sec" id="ch_core._template_typename_Ob_3"><h3><span class="title">template&lt;typename Object, typename Coordinate = int&gt; class CRangeMultiMap</span></h3><p>Almost the same as <a href="ch_core.html#ch_core._template_typename_Ob_2">CRangeMap</a> but allows several values have the same key interval.</p></div><div class="sec" id="ch_core.class_CIntervalTree"><h3><span class="title">class CIntervalTree</span></h3><p>Class with the same functionality as <a href="ch_core.html#ch_core._template_typename_Ob_2">CRangeMap</a> although with different algorithm. It is faster and its speed is not affected by type of data but it uses more memory (triple as <a href="ch_core.html#ch_core._template_typename_Ob_2">CRangeMap</a>) and, as a result, less efficient when amount of interval in set is quite big. It uses about 140 bytes per interval for 64 bit program so you can calculate if <span class="nctnt ncbi-class">CIntervalTree</span> is acceptable. For example, it becomes less efficient than <a href="ch_core.html#ch_core._template_typename_Ob_2">CRangeMap</a> when total memory becomes greater than processor cache.</p></div></div><div class="sec" id="ch_core.Thread_Pools"><h2><span class="title">Thread Pools</span></h2><p><span class="nctnt ncbi-class">CThreadPool</span> is the main class that implements a pool of threads. It executes any tasks derived from the <span class="nctnt ncbi-class">CThreadPool_Task</span> class. The number of threads in pool is controlled by special holder of this policy: object derived from <span class="nctnt ncbi-class">CThreadPool_Controller</span> (default implementation is <span class="nctnt ncbi-class">CThreadPool_Controller_PID</span> based on Proportional-Integral-Derivative algorithm). All threads executing by <span class="nctnt ncbi-class">CThreadPool</span> are the instances of <span class="nctnt ncbi-class">CThreadPool_Thread</span> class or its derivatives.</p><p>The following classes are discussed in this section:</p><ul><li><p><a href="ch_core.html#ch_core.CTreadPool">CThreadPool</a></p></li><li><p><a href="ch_core.html#ch_core.Class_CThreadPool_Ta">CThreadPool_Task</a></p></li><li><p><a href="ch_core.html#ch_core.Class_CThreadPool_Ta">CThreadPool_Thread</a></p></li><li><p><a href="ch_core.html#ch_core._Class_CThreadPool_Co">CThreadPool_Controller</a></p></li><li><p><a href="ch_core.html#ch_core._Class_CThreadPool_Co">CThreadPool_Controller_PID</a></p></li></ul><div class="sec" id="ch_core.CTreadPool"><h3><span class="title">Class CThreadPool</span></h3><p>Main class implementing functionality of pool of threads. <span class="nctnt ncbi-class">CThreadPool</span> can be created in 2 ways:</p><ul><li><p>with minimum and maximum limits on count of simultaneously working threads and default object controlling the number of threads in pool during <span class="nctnt ncbi-class">CThreadPool</span> lifecycle (instance of <span class="nctnt ncbi-class">CThreadPool_Controller_PID</span>);</p></li><li><p>with custom object controlling the number of threads (instance of class derived from <span class="nctnt ncbi-class">CThreadPool_Controller</span>). This object will control among all other the minimum and maximum limits on count of simultaneously working threads.</p></li></ul><p>Both constructors take additional parameter - maximum number of tasks waiting in the inner <span class="nctnt ncbi-class">CThreadPool</span>’s queue for their execution. When this limit will be reached next call to <span class="nctnt ncbi-func">AddTask()</span> will block until some task from queue is executed and there is free room for new task.</p><p><span class="nctnt ncbi-class">CThreadPool</span> has the ability to execute among ordinary tasks some exclusive ones. After call to <span class="nctnt ncbi-func">RequestExclusiveExecution()</span> all threads in pool will suspend their work (finishing currently executing tasks) and exclusive task will be executed in the special exclusive thread.</p><p>If there’s necessity to implement some special per-thread logic in <span class="nctnt ncbi-class">CThreadPool</span> then class can be derived to override virtual method <span class="nctnt ncbi-func">CreateThread()</span> in which some custom object derived from <span class="nctnt ncbi-class">CThreadPool_Thread</span> can be created.</p></div><div class="sec" id="ch_core.Class_CThreadPool_Ta"><h3><span class="title">Class CThreadPool_Task</span></h3><p>Abstract class derived from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CObject&amp;d=C">CObject</a>, encapsulating task for execution in a <span class="nctnt ncbi-class">CThreadPool</span>. The pure virtual method <span class="nctnt ncbi-func">EStatus Execute(void)</span> is called when some thread in pool becomes free and ready to execute this task. The lifetime of the task is controlled inside pool by <span class="nctnt ncbi-class">CRef</span>&lt;&gt; classes.</p></div><div class="sec" id="ch_core._template__typename_T_1"><h3><span class="title">Class CThreadPool_Thread</span></h3><p>Base class for a thread running inside <span class="nctnt ncbi-class">CThreadPool</span> and executing its tasks. Class can be derived to implement some per-thread functionality in <span class="nctnt ncbi-class">CThreadPool</span>. For this purpose there are protected virtual methods <span class="nctnt ncbi-func">Initialize()</span> and <span class="nctnt ncbi-func">Finalize()</span> which are called at the start and finish of the thread correspondingly. And there are methods <span class="nctnt ncbi-func">GetPool()</span> and <span class="nctnt ncbi-func">GetCurrentTask()</span> for application needs.</p></div><div class="sec" id="ch_core._Class_CThreadPool_Co"><h3><span class="title">Class CThreadPool_Controller</span></h3><p>Abstract base class for implementations of policies of threads creation and deletion inside pool.</p></div><div class="sec" id="ch_core._Class_CThreadPool_Co_1"><h3><span class="title">Class CThreadPool_Controller_PID</span></h3><p>Default object controlling number of threads working in the pool. Implementation is based on Proportional-Integral-Derivative algorithm for keeping in memory just threads that are necessary for efficient work.</p></div></div><div class="sec" id="ch_core.Miscellaneous_Classe"><h2><span class="title">Miscellaneous Classes</span></h2><p>The following classes are discussed in this section. For an overview of these classes see the <a href="ch_intro.html#ch_intro.intro_lightstring">Lightweight Strings</a> and the <a href="ch_intro.html#ch_intro.intro_checksum">Checksum</a> sections in the introductory chapter on the C++ Toolkit.</p><ul><li><p><a href="ch_core.html#ch_core.class_CLightString">class CTempString</a></p></li><li><p><a href="ch_core.html#ch_core.class_CChecksum">class CChecksum</a></p></li></ul><div class="sec" id="ch_core.class_CLightString"><h3><span class="title">class CTempString</span></h3><p>Class <span class="nctnt ncbi-class">CTempString</span> implements a light-weight string on top of a storage buffer whose lifetime management is known and controlled.</p><p><span class="nctnt ncbi-class">CTempString</span> is designed to avoid memory allocation but provide a string interaction interface congruent with std::basic_string&lt;char&gt;.</p><p>As such, <span class="nctnt ncbi-class">CTempString</span> provides a const-only access interface to its underlying storage. Care has been taken to avoid allocations and other expensive operations wherever possible.</p><p><span class="nctnt ncbi-class">CTempString</span> has constructors from std::string and C-style string, which do not copy the string data but keep char pointer and string length.This way the construction and destruction are very efficient.</p><p>Take into account, that the character string array kept by <span class="nctnt ncbi-class">CTempString</span> object must remain valid and unchanged during whole lifetime of the <span class="nctnt ncbi-class">CTempString</span> object.</p><p>It's convenient to use the class <span class="nctnt ncbi-class">CTempString</span> as an argument of API functions so that no allocation or deallocation will take place on of the function call.</p></div><div class="sec" id="ch_core.class_CChecksum"><h3><span class="title">class CChecksum</span></h3><p>Class for CRC32 checksum calculation. It also has methods for adding and checking checkum line in text files.</p></div></div><div class="sec" id="ch_core.Input_Output_Utility"><h2><span class="title">Input/Output Utility Classes</span></h2><p>This section provides reference information on a number of Input/Output Utility classes. For an overview of these classes see the <a href="ch_intro.html#ch_intro.intro_streamsupport">Stream Support section in the introductory chapter</a> on the C++ Toolkit.</p><ul><li><p><a href="ch_core.html#ch_core.class_CIStreamBuffer">class CIStreamBuffer</a></p></li><li><p><a href="ch_core.html#ch_core.class_COStreamBuffer">class COStreamBuffer</a></p></li><li><p><a href="ch_core.html#ch_core.class_CByteSource">class CByteSource</a></p></li><li><p><a href="ch_core.html#ch_core.class_CStreamByteSou">class CStreamByteSource</a></p></li><li><p><a href="ch_core.html#ch_core.class_CFStreamByteSo">class CFStreamByteSource</a></p></li><li><p><a href="ch_core.html#ch_core.class_CFileByteSourc">class CFileByteSource</a></p></li><li><p><a href="ch_core.html#ch_core.class_CMemoryByteSou">class CMemoryByteSource</a></p></li><li><p><a href="ch_core.html#ch_core.class_CByteSourceRea">class CByteSourceReader</a></p></li><li><p><a href="ch_core.html#ch_core.class_CSubSourceColl">class CSubSourceCollector</a></p></li></ul><div class="sec" id="ch_core.class_CIStreamBuffer"><h3><span class="title">class CIStreamBuffer</span></h3><p>Class for additional buffering of standard C++ input streams (sometimes standard C++ iostreams performance quite bad). Uses <a href="ch_core.html#ch_core.class_CByteSource">CByteSource</a> as a data source.</p></div><div class="sec" id="ch_core.class_COStreamBuffer"><h3><span class="title">class COStreamBuffer</span></h3><p>Class for additional buffering of standard C++ output streams (sometimes standard C++ iostreams performance quite bad).</p></div><div class="sec" id="ch_core.class_CByteSource"><h3><span class="title">class CByteSource</span></h3><p>Abstract class for abstract source of byte data (file, stream, memory etc).</p></div><div class="sec" id="ch_core.class_CStreamByteSou"><h3><span class="title">class CStreamByteSource</span></h3><p><a href="ch_core.html#ch_core.class_CByteSource">CByteSource</a> subclass for reading from C++ istream.</p></div><div class="sec" id="ch_core.class_CFStreamByteSo"><h3><span class="title">class CFStreamByteSource</span></h3><p><a href="ch_core.html#ch_core.class_CByteSource">CByteSource</a> subclass for reading from C++ ifstream.</p></div><div class="sec" id="ch_core.class_CFileByteSourc"><h3><span class="title">class CFileByteSource</span></h3><p><a href="ch_core.html#ch_core.class_CByteSource">CByteSource</a> subclass for reading from named file.</p></div><div class="sec" id="ch_core.class_CMemoryByteSou"><h3><span class="title">class CMemoryByteSource</span></h3><p><a href="ch_core.html#ch_core.class_CByteSource">CByteSource</a> subclass for reading from memory buffer.</p></div><div class="sec" id="ch_core.class_CByteSourceRea"><h3><span class="title">class CByteSourceReader</span></h3><p>Abstract class for reading data from <a href="ch_core.html#ch_core.class_CByteSource">CByteSource</a>.</p></div><div class="sec" id="ch_core.class_CSubSourceColl"><h3><span class="title">class CSubSourceCollector</span></h3><p>Abstract class for obtaining piece of <a href="ch_core.html#ch_core.class_CByteSource">CByteSource</a> as separate source.</p></div></div><div class="sec" id="ch_core.Using_the_C_Toolkit_from_a_Third"><h2><span class="title">Using the C++ Toolkit from a Third Party Application Framework</span></h2><p>The NCBI C++ Toolkit includes an API, via <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/corelib/ncbi_toolkit.hpp">corelib/ncbi_toolkit.hpp</a>, that provides an easy way to initialize the NCBI C++ Toolkit internals to use the Toolkit from other application frameworks. This is particularly helpful when those frameworks provide their own logging.</p><p>To initialize the NCBI C++ Toolkit internal infrastructure use the function:</p><pre><span class="nctnt-pre ncbi-code">void  NcbiToolkit_Init<br />   (int                                argc,<br />    const TNcbiToolkit_XChar* const*   argv,<br />    const TNcbiToolkit_XChar* const*   envp        = NULL,<br />    INcbiToolkit_LogHandler*           log_handler = NULL);</span></pre><p>where the parameter meanings are:</p><div class="table" id="ch_core.T.nc_parametermeaningargcargumen"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Parameter</th><th align="left" valign="top" rowspan="1" colspan="1">Meaning</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">argc</span></td><td align="left" valign="top" rowspan="1" colspan="1">Argument count [argc in a regular main(argc, argv)].</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">argv</span></td><td align="left" valign="top" rowspan="1" colspan="1">Argument vector [argv in a regular main(argc, argv)].</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">envp</span></td><td align="left" valign="top" rowspan="1" colspan="1">Environment pointer [envp in a regular main(argc, argv, envp)]; a null pointer (the default) corresponds to the standard system array (environ on most Unix platforms).</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">log_handler</span></td><td align="left" valign="top" rowspan="1" colspan="1">Handler for diagnostic messages that are emitted by the C++ Toolkit code.</td></tr></tbody></table></div><p><span class="nctnt highlight">Note:</span> The <span class="nctnt ncbi-type">TNcbiToolkit_XChar</span> parameter type is used for compatibility with applications that use Unicode under Windows.</p><p>When your application is finished using the NCBI C++ Toolkit, be sure to release the Toolkit resources by calling:</p><pre><span class="nctnt-pre ncbi-code">void  NcbiToolkit_Fini(void);</span></pre><p>The following program illustrates how to forward the NCBI C++ Toolkit logging to another application framework:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;ncbi_pch.hpp&gt;<br />#include &lt;iostream&gt;<br />#include &lt;corelib/ncbi_toolkit.hpp&gt;<br />#include &lt;corelib/ncbifile.hpp&gt;<br /><br />using namespace std;<br />using namespace ncbi;<br /><br />class MyLogHandler : public INcbiToolkit_LogHandler<br />{<br />public:<br />    void Post(const CNcbiToolkit_LogMessage&amp; msg)<br />    {<br />        // This is where you could pass log messages generated by the<br />        // NCBI C++ Toolkit to another application framework, e.g.:<br />        //     some_framework::ERR_POST(msg.Message());<br />        // In this demo, I'll just print out the message.<br />        cout &lt;&lt; "Log message from C++ Toolkit:\n" &lt;&lt; msg.Message() &lt;&lt; endl;<br />    }<br />};<br /><br />int main(int argc,<br />         const TNcbiToolkit_XChar* const* argv,<br />         const TNcbiToolkit_XChar* const* envp)<br />{<br />    // Initialize the NCBI C++ Toolkit application framework.<br />    MyLogHandler    log_handler;<br />    NcbiToolkit_Init(argc,argv,envp,&amp;log_handler);<br /><br />    // Use a part of the NCBI C++ Toolkit that will cause a log message.<br />    // This will cause MyLogHandler::Post() to get called, where the log<br />    // message can get passed to the third party application framework.<br />    CFileAPI::SetLogging(eOn);<br />    CDirEntry baddir(CDirEntry("&lt;bad&gt;"));<br />    baddir.Stat(0);<br /><br />    // Release resources used by the NCBI C++ Toolkit application framework.<br />    NcbiToolkit_Fini();<br /><br />    return 0;<br />}</span></pre><p><span class="nctnt highlight">Note:</span> This API is in the <span class="nctnt ncbi-monospace">ncbi</span> namespace.</p></div></div></div><div class="col four_col last"><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>In this page</h3></div></div><div class="portlet_content"><ul><li><a href="#ch_core.writing_simple_app">Writing a Simple Application</a></li><li><a href="#ch_core.cmd_line_args">Processing Command-Line Arguments</a></li><li><a href="#ch_core.namespace_concat">Namespace, Name Concatenation, and Compiler-specific Macros</a></li><li><a href="#ch_core.Configuration_Parame">Configuration Parameters</a></li><li><a href="#ch_core.registry">Using the CNcbiRegistry Class</a></li><li><a href="#ch_core.stream_wrappers">Portable Stream Wrappers</a></li><li><a href="#ch_core.diag">Working with Diagnostic Streams ()</a></li><li><a href="#ch_core.debug_module_ref">Debug Macros</a></li><li><a href="#ch_core.exception_handling_ref">Handling Exceptions</a></li><li><a href="#ch_core.std_ncbi_types">Defining the Standard NCBI C++ types and their Limits</a></li><li><a href="#ch_core.smart_ptrs">Understanding Smart Pointers: the CObject and CRef Classes</a></li><li><a href="#ch_core.atomic_counters">Atomic Counters</a></li><li><a href="#ch_core.portable_dll">Portable mechanisms for loading DLLs</a></li><li><a href="#ch_core.CExec">Executing Commands and Spawning Processes using the CExec class</a></li><li><a href="#ch_core.threads">Implementing Parallelism using Threads and Synchronization Mechanisms</a></li><li><a href="#ch_core.files_dirs">Working with File and Directories Using CFile and CDir</a></li><li><a href="#ch_core.string_classes">String APIs</a></li><li><a href="#ch_core.portable_time_class">Portable Time Class</a></li><li><a href="#ch_core.template_utils">Template Utilities</a></li><li><a href="#ch_core.misc_types_macros">Miscellaneous Types and Macros</a></li><li><a href="#ch_core.Containers">Containers</a></li><li><a href="#ch_core.Thread_Pools">Thread Pools</a></li><li><a href="#ch_core.Miscellaneous_Classe">Miscellaneous Classes</a></li><li><a href="#ch_core.Input_Output_Utility">Input/Output Utility Classes</a></li><li><a href="#ch_core.Using_the_C_Toolkit_from_a_Third">Using the C++ Toolkit from a Third Party Application Framework</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Download</h3></div></div><div class="portlet_content"><ul><li><a href="pdf/ch_core.pdf">PDF version of this page</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Search</h3></div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input name="__symbol" size="22" style="vertical-align:                                          middle;" onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />   <input value="Search" style="vertical-align: middle;" onclick="javasrcipt:SymbolSearch('toolkit');" type="button" /></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><span title="Search in the C/C++ source code and in this Book">All</span></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" /><span title="Search in the C/C++ source code,  this Book, and Wiki">All</span></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><span title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</span></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><span title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</span></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><span title="Locate the Toolkit library(es) where the symbol is defined">Library</span></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><span title="Locate the Toolkit library(es) where the symbol is defined">Library</span></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Source Browsers</h3></div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li><li class="internal-only">LXR: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident">internal</a></li><li class="internal-only">Doxygen: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml">public</a> / <a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml">internal</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>SVN Source Repository</h3></div></div><div class="portlet_content"><ul><li><a href="http://www.ncbi.nlm.nih.gov/bookshelf/br.fcgi?book=toolkit&amp;part=ch_getcode_svn#ch_getcode_svn.code_retrieval">Server</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++">Web
                            (dev)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++">Web
                            (extra)</a></li><li><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components">Web (prod)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title"><h3>Resources</h3></div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit">Wiki</a></li><li class="internal-only"><a href="http://jira/browse/CXX">JIRA</a></li><li class="internal-only"><a href="http://intranet/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download</a></li><li><a href="pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:CPP-CORE@NCBI.NLM.NIH.GOV"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
