<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <title>A Simple Application Project</title>
</head>
<body bgcolor="#FFFFFF">

<h1>
Writing a Simple Application Project</h1>

<ul>
<li>
<a href="#using">Using the NCBI Application Class</a></li>

<li>
<a href="#creating">Creating the Application Class</a></li>

<li>
<a href="#inside">Inside the Application Class</a></li>
</ul>
This page describes what you will need to know to write the simplest possible
application using the C++ Toolkit. The program simply prints a message
to the screen. Following this exercise however, will introduce you to the
foundation classes of the library.
<p><a NAME="using"></a>
<h3>
Using the NCBI Application Class</h3>
Five fundamental classes form the foundation of the C++ Toolkit:
<ul>
<li>
class <a href="#CNcbiApplication">CNcbiApplication</a></li>

<li>
class <a href="#CNcbiArguments">CNcbiArguments</a>&nbsp; (see also <a href="argdescr.html">CArgDescriptions,
CArgs, ...</a>)</li>

<li>
class <a href="#CNcbiEnvironment">CNcbiEnvironment</a></li>

<li>
class <a href="#CNcbiRegistry">CNcbiRegistry</a></li>

<li>
class <a href="#CNcbiDiag">CNcbiDiag</a></li>
</ul>
<a NAME="CNcbiApplication"></a><i><a href="../docxx/CNcbiApplication.html">CNcbiApplication</a></i>
is an abstract class used to define the basic functionality and behavior
of an NCBI application. Because this application class effectively supercedes
the <i>C</i>-style <i>main()</i> function, minimally, it must provide the
same functionality, i.e.
<ul>
<li>
A mechanism to execute the actual application</li>

<li>
A data structure for holding program command-line arguments ("argv")</li>

<li>
A data structure for holding environmental variables</li>
</ul>
In addition, the application class provides the same features previously
implemented in the C Toolkit, namely:
<ul>
<li>
Mechanisms for specifiying where, when, and how errors should be reported</li>

<li>
Methods for reading, accessing, modifying, and writing information in the
application's registry (configuration) file</li>

<li>
Methods to describe, and then automatically parse, validate and access
program command-line arguments, and to generate the<i>USAGE</i> message</li>
</ul>
The mechansim to execute the application is provided by <i>CNcbiApplication</i>'s
member function <i>Run()</i> - which you must write your own implementation
of. The <i>Run()</i> function will be automatically invoked by <i>CNcbiApplication::AppMain()</i>,
after it has initialized its
<i>CNcbiArguments, CNcbiEnvironment, CNcbiRegistry</i>,
and <i>CNcbiDiag</i> data members.
<p><a NAME="CNcbiArguments"></a>The <i><a href="../docxx/CNcbiArguments.html">CNcbiArguments</a></i>
class provides a data structure for holding the application's command-line
arguments, along with methods for accessing and modifying these. Access
to the agrument values is implemented using the built-in <i>[ ]</i> operator
. For example, the first argument in <i>argv</i> (following the program
name) can be retrieved using the
<i>CNcbiApplication::GetArguments()</i>
method, as:
<br><font color="#008080">&nbsp;&nbsp;&nbsp; string arg1_value = GetArguments()[1];</font>
<br>Here,
<i>GetArguments()</i> returns the <i>CNcbiArguments</i> object,
whose argument values can then be retrieved using the <i>[ ]</i> operator.
Four additional <i>CNcbiArgument</i> member functions support retrieval
and modification of the program name (intitially <i>argv</i>[0]). A helper
class, described in <i><a href="argdescr.html">Parsing, validating, and
accessing command line arguments</a></i>, supports the generation of
<i>USAGE</i>
messages and the imposition of constraints on the values of the input arguments.
<p><a NAME="CNcbiEnvironment"></a>The <i><a href="../docxx/CNcbiEnvironment.html">CNcbiEnvironment</a></i>
class provides a data structure for storing, accessing, and modifying the
environment variables accessed by the C library routine <i>getenv()</i>.
For example, to retrieve the value of environment variable <b>PATH</b>:
<br><font color="#008080">&nbsp;&nbsp;&nbsp; string arg1_value = GetEnvironment().Get("PATH");</font>
<p><a NAME="CNcbiRegistry"></a>The
<i><a href="registry.html">CNcbiRegistry</a></i>
class is used to load, access, modify and store runtime information read
from a configuration file. Previously, these files were by convention named
<i>.*rc</i>
files on
<i>UNIX
</i>systems. The convention for all platforms now is to
name such files
<i>*.ini</i> (where * is by default the application name).
<p><a NAME="CNcbiDiag"></a>The
<i><a href="diag.html">CNcbiDiag
</a></i>class
implements much of the functionality of the NCBI C Toolkit error processing
mechanisms. Each instance of <i>CNcbiDiag</i> has a private buffer to handle
a <i>single</i> message, along with private severity level and post flags
and their associated get/set methods. A CNcbiDiag object has the look and
feel of an output stream; its member functions and friends include output
operators <i>>></i> and format manipulators. The default is to post errors
to <i>stderr</i>, with the action determined by the severity level of the
message, however user can provide another stream to post to, or create
an arbitrary callback to do the job, or just ignore all diagnostics. See
also <i><a href="diag.html">Diagnostic Streams </a></i>in this manual,
as well as the discussion in the Reference Manual section on <i><a href="../libs/err_msg.html#ref_Message">message
posting</a></i>.
<p><a NAME="creating"></a>
<h3>
Creating a Simple Application Class</h3>
<b>Step 1.</b> Define a subclass of the <i>CNcbiApplication </i>class.
<p>Because <i>CNcbiApplication::Run() </i>is defined as a pure virtual
function, the class cannot be used directly. Instead, you must first define
a subclass which inherits from <i>CNcbiApplication</i>, and implementat
<i>Run()
</i>in
the subclass.
<p>Define the subclass in a header file, and in the subclass declaration,
declare
<i>Run()</i> to be a virtual function:
<pre><font color="#008080">// File name: justApp.hpp

#ifndef JUST_APP__HPP
#define JUST_APP__HPP
#include &lt;corelib/ncbiapp.hpp>

BEGIN_NCBI_SCOPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

class CTestApp : public CNcbiApplication
{
public:
&nbsp;&nbsp;&nbsp; virtual int Run(void);
};

END_NCBI_SCOPE

#endif /* JUST_APP__HPP */</font></pre>

<p><br><font color="#000000"><b>Step 2.</b> Define <i>main()</i> in the
<i>*.cpp
</i>file
where you instantiate your application subclass.</font>
<p><font color="#000000">Inside <i>main()</i>, instantiate your application
subclass, and call its inherited function,
<i>AppMain()</i>. This file
is also a good place to put the implementation of the
<i>Run()</i> function.
Enclose the <i>Run() </i>implementation with <i>BEGIN_NCBI_SCOPE
</i>and
<i>END_NCBI_SCOPE
</i>statements,
and precede <i>main() </i>(as well as any other code using the NCBI C++
Toolkit) with a <i>USING_NCBI_SCOPE </i>statement:</font>
<pre><font color="#008080">// file justApp.cpp

#include "justApp.hpp"

BEGIN_NCBI_SCOPE

int CTestApp::Run() {
&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Executing CTestApp::Run()!" &lt;&lt; endl;
&nbsp;&nbsp;&nbsp; return 0;
}

END_NCBI_SCOPE</font></pre>

<pre><font color="#008080"></font></pre>

<pre><font color="#008080">USING_NCBI_SCOPE;

int main(int argc, const char* argv[])&nbsp;
{
&nbsp;&nbsp;&nbsp; CTestApp theTestApp;
&nbsp;&nbsp;&nbsp; return theTestApp.AppMain(argc, argv);
}</font>

</pre>
<font color="#000000"><b>Step 3.</b> Assuming you have done all of this
work in a project directory called "justApp", and have already run the
<i><a href="outside_tree.html">new_project.sh</a></i>
script to create the makefile, you are now ready to build your first application
using:</font>
<center><pre><font color="#000000">make -f Makefile.justApp_app</font></pre></center>
<font color="#000000">The <i>SCOPE</i> statements are actually macros defined
in <i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/include/corelib/ncbistl.hpp">include/corelib/ncbistl.hpp</a></i>:</font>
<pre><font color="#000080">#define BEGIN_NCBI_SCOPE namespace NCBI_NS_NCBI {
#define END_NCBI_SCOPE }
#define USING_NCBI_SCOPE using namespace NCBI_NS_NCBI</font></pre>
<font color="#000000">All code occurring between the <i>BEGIN</i> and <i>END</i>
statements will be added to a namespace called <i>NCBI_NS_NCBI</i>. The
<i>USING</i>
macro allows you to access everything currently defined in the namespace
without requiring the :: scope operator.</font>
<p><font color="#000000">&nbsp;A more elaborate example, <i><a href="applic_cpp.html">applic.cpp</a></i>,
combines the usage of the <i>CNcbiApplication</i> class with the&nbsp;<i>
CArgDescriptions</i>, <i>CArgs, </i>and
<i>CNcbiDiag</i> classes. For a
more realistic usage of these classes, see also the test program, <i><a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/src/objects/asn2asn/asn2asn.cpp">asn2asn.cpp</a></i>.</font>
<p><a NAME="inside"></a>
<h3>
<font color="#000000">Inside the NCBI Application Class</font></h3>
<font color="#000000">To review what we've done so far:</font>
<ol>
<li>
<font color="#000000">We defined a subclass of <i>CNcbiApplication </i>with
an implementation of <i>Run()</i>.</font></li>

<li>
<font color="#000000">We created an instance of this class in <i>main()</i>.</font></li>

<li>
<font color="#000000">In <i>main()</i>, we invoked the class member function
<i>AppMain()</i>,
and passed <i>argc, argv[ ]</i> to it.</font></li>
</ol>
<font color="#000000">Here is a somewhat simplified view of the application
class's definition:</font>
<pre><font color="#008080">class CNcbiApplication
{
public:
&nbsp;&nbsp;&nbsp; int AppMain (int argc, const char **argv, const char **envp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EAppDiagStream diag, const char* config, const string&amp; name);

&nbsp;&nbsp;&nbsp; virtual void Init();
&nbsp;&nbsp;&nbsp; virtual int&nbsp; Run () = 0;
&nbsp;&nbsp;&nbsp; virtual void Exit();

&nbsp;&nbsp;&nbsp; CNcbiArguments&amp;&nbsp;&nbsp; GetArguments();
&nbsp;&nbsp;&nbsp; CNcbiEnvironment&amp; GetEnvironment();
&nbsp;&nbsp;&nbsp; CNcbiRegistry&amp;&nbsp;&nbsp;&nbsp; GetConfig();

protected:
&nbsp;&nbsp;&nbsp; virtual bool SetupDiag_AppSpecific(void);
&nbsp;&nbsp;&nbsp; virtual bool LoadConfig(CNcbiRegistry&amp; reg, const string* conf);
&nbsp;&nbsp;&nbsp; .............
};</font></pre>
<font color="#000000">The protected virtual function <i>SetupDiag_AppSpecific()</i>
can be redefined to setup error posting specific for your application.
<i>SetupDiag_AppSpecific()</i>
will be called inside <i>AppMain()</i> by default if the error posting
has not been setup already. Also, if you pass
<b>diag</b>=<i>eDS_AppSpecific</i>
to <i>AppMain()</i>, then <i>SetupDiag_AppSpecific()</i> will be called
for sure, regardless of the error posting setup that was active before
the <i>AppMain()</i> call.</font>
<p><font color="#000000">The protected virtual function <i>LoadConfig()
</i>reads
the program's <i>.ini </i>configuration file to load the application's
parameters into the registry.&nbsp; The default implementation of <i>LoadConfig()&nbsp;</i>
expects to find a configuration file named
<i>progname.ini</i>, and will
generate a warning to the user if no such file is found.</font>
<p><a NAME="appmain"></a>
<br><font color="#000000">The <i>AppMain() </i>function is also inherited
from the parent class. Although this function accepts up to six arguments,
this example passes only the first two, with missing values supplied by
defaults. The remaining four arguments specify:</font>
<ul>
<li>
<font color="#000000">(#3)&nbsp; a NULL-terminated array of '\0'-terminated
character strings from which the environment variables can be read</font></li>

<li>
<font color="#000000">(#4)&nbsp; how to setup a diagnostic stream for message
posting</font></li>

<li>
<font color="#000000">(#5)&nbsp; the name of a <i>.ini</i> configuration
file (will use program name with suffix <i>.ini&nbsp;</i> by default)</font></li>

<li>
<font color="#000000">(#6)&nbsp; a program name (to be used in lieu of
<i>argv[0]</i>)</font></li>
</ul>
<font color="#000000">I</font><font color="#003300">n order to avoid the
display of a warning message when no configuration file is present, the
<i>.ini</i>
file should be explicitly specified as <i>NULL (zero)</i>, as in:</font>
<center>
<p><i><font color="#008080">AppMain (argc, argv, envp, diag_stream, 0,
progname);</font></i></center>

<p><font color="#000000"><i>AppMain() </i>begins by resetting the internal
data members with the actual values provided by the arguments of <i>main()</i>.
Once these internal data structures have been loaded, <i>AppMain() </i>calls
the virtual functions <i>Init(), Run(), </i>and <i>Exit() </i>in succession
to execute the application.</font>
<p><font color="#000000">The <i>Init() </i>and <i>Exit() </i>virtual functions
are provided as places for developers to add their own methods for specific
applications. As this example does not require any additional initialization/termination,
these two functions simply return. The <i>Run() </i>method prints out the
message defined in <i>justApp.cpp</i> and exits.</font>
<p><font color="#000000">As exemplified here, source files which utilize
the <i>CNcbiApplication</i> class must
<i>#include</i> the header file
where that class is defined, <i>corelib/ncbiapp.hpp</i>, in the
<b><i>include/</i></b>
directory. This header file in turn includes <i>corelib/ncbistd.hpp</i>,
which should <i>always</i> be <i>#include</i>'d.</font>
<p><font color="#000000"><i><a href="../index.html">up&nbsp;</a></i> <i><a href="argdescr.html">next&nbsp;</a></i></font>
<hr>
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>

<tr>
<td>
<address>
<a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address>
</td>
</tr>
</table>

</body>
</html>
