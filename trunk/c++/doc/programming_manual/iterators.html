<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <title>The NCBI C++ Toolkit Iterators</title>
</head>
<body bgcolor="#FFFFFF">

<h1>
The NCBI C++ Toolkit Iterators</h1>

<ul>
 <li><a href="#generic">  <i> STL</i> generic iterators</a></li>
 <li><a href="#typeIt">   <i> CTypeIterator</i> and <i>CTypeConstIterator</i></a></li>
 <li><a href="#cobjType"> <i> CObjectIterator</i> and <i>CObjectConstIterator</i></a></li>
 <li><a href="#stdType">  <i> CStdTypeIterator</i> and <i>CStdTypeConstIterator</i></a></li>
 <li><a href="#typesIt">  <i> CTypesIterator</a></i></li>
 <li><a href="#hier">         Class hierarchies and type iterators </a>
</ul>
<a NAME="generic"></a>
<h3>
<i>STL</i> generic iterators</h3> Iterators are an important cornerstone in the generic
programming paradigm - they serve as intermediaries between generic containers and generic
algorithms.  Different containers have different access properties, and the interface to a
generic algorithm must account for this. This is depicted graphically below, for the
<i>list</i> and <i>vector</i> containers and the <i>sort, find,</i> and <i>merge</i>
algorithms.<p>

<center><img SRC="iters.gif"> </center><p>

<p>The <i>vector</i> class allows <i>input, output, bidirectional,</i> and <i>random
access</i> iterators. In contrast, the <i>list</i> container class does <i>not</i> allow
random access to its elements. This is depicted graphically by one less strand in the
ribbon connector. In addition to the iterators, the generic algorithms may require 
function objects such as <i>less&lt;T&gt;</i> to support the template implementations.

<p>
The STL standard iterators are 
designed to iterate through any STL container of homogeneous elements, e.g., 
<i> vectors, lists, deques, stacks, maps, multimaps, sets, multisets, </i> etc.
A prerequisite however, is that the container must have <i>begin()</i> and
<i> end()</i> functions defined on it as start and end points for the iteration. 
<p>
While these standard iterators are powerful tools for generic programming, they
are of no help in iterating over the elements of <i>aggregate</i> objects - e.g.,
over the heterogeneous data members of a class object. But this is an essential operation in 
processing serialized data structures, and the NCBI C++ Toolkit provides 
additional types of iterators for just this purpose.

<a NAME="typeIt"></a>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CTypeIterator.html">
<h3><i>CTypeIterator</i></a> and
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CTypeConstIterator.html">
<i>CTypeConstIterator</i></h3></a>

Although STL provides a built-in <i>list</i> data structure, it is very common to represent 
a linked list of objects by encoding a <i>next</i> field that embeds an object of the same
type. For example, suppose you had a <i> CPerson </i> class defined as:
<a name = "CPerson">
<font color = "#000080"> <pre>
class CPerson
{ 
public:
    CPerson(void);
    CPerson(string n, string s, CPerson* p);
    virtual ~CPerson(void);

    static const CTypeInfo* GetTypeInfo(void);

    string name, address;
    CPerson *next_door;
};
</pre><font color = black>

Given this definition, one might then define a <i>neighborhood</i> using a single <i>CPerson</i>.
Assuming a function <i>FullerBrushMan(CPerson&)</i> must now be applied to each person in the
neighborhood, this could be implemented using a <i>CTypeIterator</i> as follows:

<font color = "#000080"> <pre>
  CPerson neighborhood("Moe", "123 Main St", 
                       new CPerson("Larry", "127 Main St", 
                                    new CPerson("Curly", "131 Main St", 0)));

  for (CTypeIterator&lt;CPerson&gt; house = Begin(neighborhood); house; ++house ) {
      FullerBrushMan(*house);
  }
</pre><font color = black>

Lets compare the syntax of this new iterator class to the standard iterators:

<font color = "#000080"><pre>
  ContainerType&lt;T&gt; x;
  for (ContainerType&lt;T&gt;::IteratorType i = x.begin(); i != x.end(); ++i) 

  for (CTypeIterator&lt;ObjectType&gt; i = Begin(ObjectName); i; ++i)
</pre><font color = black>

The standard iterator begins by pointing to the first item in the container
(<i>x.begin()</i>), and with each iteration, visits subsequent items until the <i>end</i>
of the container (<i>x.end()</i>) is reached. Similarly, the <i>CTypeIterator</i> begins
by pointing to the first data member of <i>ObjectName</i> that is of type
<i>ObjectType</i>, and with each iteration, visits subsequent data members <i>of the
specified type</i> until the end of the object is reached.  Two important differences are:
(1) all items in the STL container must be of the same type <i>T</i>, and (2) the STL
iterator will visit <i>all</i> items in the container.  In contrast, the
<i>CTypeIterator</i> (1) operates on a class object containing heterogeneous types, and
(2) skips over all data members that are not of the specified type. <p>

How is a generic iterator such as this implemented? The 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=Begin">
<i>Begin()</i></a> expression returns an "object iterator" that is actually an STL <i>pair</i>
consisting of a pointer to the object itself and a data structure containing type
information about the object. On each iteration, a new pair is created consisting of the
current object and in turn, its type information. This allows the iterator to recursively
visit all data members of the specified type at all levels of nesting.
<p>
<i>Begin()</i> is implemented as a template function whose sole argument is an an instance
of a class with a <i>GetTypeInfo()</i> member function. Thus, in order to apply a
<i>CTypeIterator</i> to a newly defined class, you will need to implement
<i>GetTypeInfo()</i> for that class. Two macros are provided to support
this,
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=BEGIN_CLASS_INFO">
<i>BEGIN_CLASS_INFO</i></a> and
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=END_CLASS_INFO">
<i>END_CLASS_INFO</i></a>. For the CPerson example above, the only
code required to implement the <i>GetTypeInfo()</i> member function is:

<font color = "#000080"> <pre>
BEGIN_CLASS_INFO(CPerson)
{
    ADD_STD_M(m_name);
    ADD_STD_M(m_addr);
    ADD_M(m_next_door, POINTER, (CLASS, (CPerson)))->SetOptional();
}
END_CLASS_INFO
</pre><font color = black>

In addition, the class definition must include the static class member function
<i>GetTypeInfo()</i> in the class's public section (see the <i>CPerson</i> class
definition <a href="#CPerson"> above</a>). <p>

In this example the data members visited by the iterator were of the same type as
the object itself, as <i>neighbor</i> is an instance of <i>CPerson</i>. Thus the
first "member" visited is the object itself (<i>*this</i>). This is not
necessary however, as the aggregate object's type information is derived from the
<i>Begin(ObjectName)</i> expresssion, while the type to be visited is defined by
<i>ObjectType</i>. The <i>CTypeConstIterator</i>
parallels the <i>CTypeIterator</i>, and is intended for use with <i>const</i> objects (i.e.
when you want to prohibit modifications to the objects you are iterating over). <p>

<a NAME="cobjType"></a>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CObjectIterator.html">
<h3><i>CObjectIterator</i></a> and 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CObjectConstIterator.html">
<i>CObjectConstIterator</i></h3></a>

All <i>CObject</i>s defined in the NCBI C++
Toolkit have a <i>GetTypeInfo()</i> member function that can be used by
<i>Begin(ObjectName)</i>. In particular, all of the generated serializable objects (in 
<i>include/objects</i>) are derived from <i>CObject</i> and thus, can be iterated over.
No additional code is required to apply a type iterator to a C++ Toolkit object. 
In addition, a special iterator is defined which can automatically distinguish <i>CObject</i>s 
from other class types. The syntax of a <i>CObjectIterator</i> is:
<font color = "#000080"> <pre>
<center> for (CObjectIterator i = Begin(ObjectName); i; ++i) </center></font></pre>

Note that there is no need to specify the object type to iterate over, as the type
<i>CObject</i> is built into the iterator itself. This iterator will recursively visit all
<i>CObject</i>s contained in <i>ObjectName</i> The <i>CObjectConstIterator</i> is
identical to the <i>CObjectIterator</i> but is designed to operate on <i>const</i>
elements.<p>

User-defined classes that are derived from <i>CObject</i>s can also be iterated over.
In order to do so however, you must have implemented the <i>GetTypeInfo()</i> function 
exactly as described above for general objects.

<a NAME="stdType"></a>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CStdTypeIterator.html">
<h3><i>CStdTypeIterator</i></a> and 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CStdTypeConstIterator.html">
<i>CStdTypeConstIterator</i></h3></a>

Similar to the <i>CTypeIterator</i>s, the
<i>CStdTypeIterator</i> and <i>CStdTypeConstIterator</i> classes selectively iterate
over data members of a specified type. But for these iterators, the type must be
a simple C type (<i>int, double, char*, etc.</i>) or an STL type <i>string</i>. 
For example, to iterate over all the string data members in a
<i>CPerson</i> object, we could use:
<font color = "#000080"> <pre>
    for (CStdTypeIterator&lt;string> i = Begin(neighborhood); i; ++i) {
        cout << *i << ' ';
    }
</pre></font>
All of the NCBI C++ Toolkit iterators are <i>recursive</i>. Thus, if <i>neighborhood</i>
has additional embedded objects which also contain <i>string</i>s, all of these data
members will also be visited by the above iterator. In summary, given a hierarchical
structured object containing data elements of a given type at different layers, the
NCBI C++ Toolkit iterators effectively generate a "flat" list of these elements. 
The <i>CStdTypeConstIterator</i> is identical to the <i>CStdTypeIterator</i> but is
designed to operate on <i>const</i> elements.
Further examples of using the <i>CTypeIterator</i> and <i>CStdTypeIterator</i> 
are given in <a href="ctypeiter_cpp.html"><i>ctypeiter.cpp</i></a>. 

<a NAME="typesIt"></a>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CTypesIterator.html">
<h3><i>CTypesIterator</i></h3></a>

Sometimes it is necessary to iterate over a <i>set</i> of types contained inside an
object. The <i>CTypesIterator</i>, as its name suggests, is designed for this purpose.
For example, suppose you have loaded a gene sequence into memory as a <i>CBioseq</i>
(named <i>seq</i>), and want to iterate over all of its references to genes and
organisms. The following sequence of statements defines an iterator that will step through
all of <i>seq</i>'s data members (recursively), stopping only at references to gene and
organism citations:

<font color = "#000080"> <pre>
     CTypesIterator i;			
     Type&lt;CGene_ref>::AddTo(i);		// define the types to stop at
     Type&lt;COrg_ref>::AddTo(i);
         
     for (i = Begin(seq); i; ++i) {
 
	 if (Type&lt;CGene_ref>::Match(i)) {
             CGene_ref* geneRef = Type&lt;CGene_ref>::Get(i);
             ...
         } 
	 else if (Type&lt;COrg_ref>::Match(i) {
             COrg_ref* orgRef = Type&lt;COrg_ref>::Get(i);
             ...
         }
     }
</pre> </font>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/Type.html">
<i>Type</i></a> is a helper template class that simplifies the syntax required
to use the multiple types iterator:
<ul>
<li> <i>Type&lt;TypeName>::AddTo(i)</i> specifies that iterator <i>i</i> should stop at
type <i>TypeName</i>
<li> <i>Type&lt;TypeName>::Match(i)</i> returns <i>True</i> if the specified type  
<i>TypeName</i> is the type currently pointed to by iterator <i>i</i>
<li> <i>Type&lt;TypeName>::Get(i)</i> retrieves
the object currently pointed to by iterator <i>i</i>, 
and type casts it to the specified type <i>TypeName</i>
</ul>
<p>

The <i>Begin(ObjectName)</i> expression is as described for the above
<i>CTypeIterator</i> and <i>CTypeConstIterator</i> classes. 
<p>
<a name="hier"></a>
<h3>Class hierarchies and type iterators </h3>

All of the iterators described in this section are designed to operate on aggregate
objects, stopping only at those data members which are of the specified type. By 
definition, if the aggregate object is itself of the specified type, <i>*this</i> 
will be included in the iteration. Knowledge of the type hierarchy is implicit to
these iterators. Thus if object type <i>B</i> is derived from object type <i>A</i>,
then <i>CTypeIterator&lt;A></i> will visit objects of type <i>B</i> as well as <i>A</i>, 
since <i>B IS-A A</i>. For example, consider the <i>CObjectIterator</i>:

<center><img SRC="iter_hier.gif"> </center><p>

Class <i>A</i> is derived from <i>CObject</i> and contains a <i>CBiostruc (B)</i> 
as well as a simple <i>CObject (C)</i>. By definition, a <i>CObjectIterator</i> will
visit <i>A, B,</i> and <i>C</i>, as well as all of the <i>CObjects</i> contained in
<i>B</i>. In contrast, a <i>CTypeIterator</i> that visits <i>CBiostruc</i>s 
will visit <i>B</i> only.
<p>

<a href="cref.html"><i>previous</i>&nbsp;</a>&nbsp;&nbsp;
<i><a href="../index.html">up&nbsp;</a></i>
<a href="diag.html"> <i> next</i> </a>
</font>
<hr>
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>

</body>
</html>
