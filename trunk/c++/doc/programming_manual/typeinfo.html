<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
    <title>Runtime Object Type Information</title>
  </head>
  <body bgcolor = white>
    <h1> Runtime Object Type Information </h1>

    <ul>
    <li><a href="#introduction"> Introduction</a> 
    <li><a href="#motivation"> Motivation</a> 
    <li><a href="#cobjinfo"> Object information classes: <i>CObjectTypeInfo, CConstObjectInfo</i> and <i>CObjectInfo</i></a> 
    <li><a href="#usage"> Usage of object type information</a>
    </ul>

<a name ="introduction"> <h3>Introduction</h3>
Information about data types is necessary in several contexts, including:
<ol>

 <li> When reading, writing, and processing serialized data, where information about a
 type's internal structure is needed;<p>

 <li> When reading from an arbitrary data file, where data members' 
 external aliases must be used to locate the corresponding class data members
 (e.g. <i>MyXxx</i> may be aliased as <i>my-xxx</i> in the file); <p>

 <li> When using a generalized <a href="iterators.html"><i> C++ type iterator</i></a> to traverse the data
 members of a structured object.  
</ol>

In some cases, the type information might be useful independent of any actual data instances. For
example, a C++ <a href="choice.html"><i>choice</i></a> object may have several choice
variants, but only one of these is actually selected (and therefore, instantiated) at any given
moment. Nevertheless, access to the complete set of choice variant <i>types</i> may be useful. In
other cases, an object may be cast as its more abstract parent type, and passed to a generic
function that must now access (and possibly modify) type-specific data members. In this context, it
is necessary to have access to both the object itself as well as to its type information. <p>

The NCBI C++ Toolkit uses two classes to support these requirements:
<ul>
<li><a href="#ctypeinfo"><i>Type</i> information classes</a> (base class <a
href="../docxx/CTypeInfo.html"><i>CTypeInfo</i> </a>) are intended for internal usage only,
and encode information about a type, devoid of any instances of that type. An object's type
information includes the class layout, inheritance relations, external alias, and various other
attributes such as size and type family, which are independent of specific instances. Each data
member of a class also has its own type information. Thus, in addition to providing information
relevant to the member's occurence in the class (e.g. the member name and offset), the type
information for a <i>class</i> must also provide access to the type information for each of 
its <i>members</i>.<p>

<li><a href="#cobjinfo"> <I>Object</i> information classes</a> (base class <a
href="../docxx/CObjectTypeInfo.html"><i>CObjectTypeInfo</i></a>) include a pointer to the
type information as well as a pointer to the object <i>instance</i> itself, and provide a
safe interface to that object. In situations where type information is used independent of
any concrete object, the <i>object</i> information class simply serves as a wrapper to a <i>type</i>
information object. Where access to an object instance <i>is</i> required, the object pointer
provides direct access to the correctly type-cast instance, and the interface provides methods to
access and/or modify data members of the object.
</ul>

The type information for a class is stored outside any instances of that class, in a statically
created <i>CTypeInfo</i> object.  The <i>CTypeInfo</i> object is then accessed by all instances of
the class via a static <a
href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=GetTypeInfo">
<i>GetTypeInfo()</i></a> class method.  All of the automatically generated classes defined in the
C++ Toolkit's <i>objects</i> directory already have a static <i>GetTypeInfo()</i> member
function. In order to make type information about <i>user-defined</i> classes accessible to your
application, the user-defined classes must also implement a static <i>GetTypeInfo()</i> method, as
described in the section on <a href="usrtypeinfo.html"> <i>User-defined Type Information</i></a>.<p>

Type information is often needed when the object itself has been passed anonymously, or as a pointer
to its parent class. In this case, it is not possible to invoke the <i>GetTypeInfo()</i> method
directly, as the object's exact type is unknown. Using a <i>&lt;static_cast&gt;</i> operator to
enable the member function is also unsafe, as it may open the door to incorrectly associating an
object's pointer with the wrong type information.  For these reasons, the <i>CTypeInfo</i> class is
intended for internal usage only, and it is the <a href="#cobjinfo"> <i>CObjectTypeInfo</i></a> classes
that provide a more safe and friendly user interface to type information.<p>


<a name="motivation"> <h3> Motivation </h3>

We use a simple example to help motivate the use of this <i>type</i> and <i>object</i> information
model. Let us suppose that we would like to have a generic function <i>LoadObject()</i>, which can
populate an object using data read from a flat file. For example, we might like to have:

<center><pre>bool LoadObject (Object& myObj, istream& is); </pre></center>

where <i>myObj</i> is an instance of some subclass of <i>Object</i>. Assuming that the text in the
file is of the form:
<pre>MemberName value
MemberName value
MemberName value
:
</pre>
we would like to find the corresponding data member in <i>myObj</i> for each <i>MemberName</i>, and set
that data member's value accordingly. Unfortunately, <i>myObj</i> cannot directly supply any useful
type information, as the member names we seek are for a specific subclass of <i>Object</i>. Now suppose
that we have an appropriate type information object available for <i>myObj</i>, and consider how
this might be used:
<a name = "example">
<font color="#000080"><pre>
bool LoadObject (TypeInfo& info, Object& myObj, istream& is)
{
    string myName, myValue;

    while (!is.eof()) {
        is >> myName >> myValue;
        void *member = FindMember(info, myObj, myName);
	assignValue(member, myValue);
    }
}</pre></font>

Here, we assume that our type information object, <i>info</i>, stores information about the memory
offset of each data member in <i>myObj</i>, and that such information can be retrieved using some
sort of identifying member name such as <i>myName</i>. This is not too difficult to imagine, and
indeed, this is exactly the type of information and facility provided by the C++ Toolkit's type
information classes. The <i>FindMember()</i> function just needs to return a <i>void</i> pointer to
the appropriate location in memory.  The <i>assignValue()</i> function presents a much greater
challenge however, as its two sole arguments are a <i>void</i> pointer and a <i>string</i>. This
would be fine if the data member was indeed a <i>void</i> pointer, and a <i>string</i> value
was acceptable. In general this is not the case, and stronger methods are clearly needed.<p>

In particular, for each data member encountered, we need to retrieve the type of that member as well
as its location in memory, so as to process <i>myValue</i> appropriately before assigning it. In
addition, we need safer mechanisms for making such "untyped" assignments. Ideally, we would like a
<i>FindMember()</i> function that returns a correctly cast pointer to that data member, along with
its associated type information. This is what the <i>object</i> information classes provide - a
pointer to the object instance as well as a pointer to its static <i>type</i> information. The
interface to the <i>object</i> information class also provides a number of methods such as
<i>GetClassMember(), GetTypeFamily(), SetPrimitiveValue()</i>, etc., to support the type of activity
described above.
 
<a name="cobjinfo"> <h3> Object Information Classes</h3>
<ul><li> <a href= "#objtype"> <i>CObjectTypeInfo</i></a>
    <ul><li> <a href= "#constobj"> <i>CConstObjectInfo</i></a>
        <ul><li> <a href= "#objinfo"> <i>CObjectInfo</i></a>
</ul></ul></ul>

<a name="objtype"><h4><a href= "../docxx/CObjectTypeInfo.html"> <i>CObjectTypeInfo</i></a></h4>
The base class for all <i>object</i> information classes is the <a href=
"../docxx/CObjectTypeInfo.html"> <i>CObjectTypeInfo</i></a> class. This base class is intended for
usage where there is no concrete object being referenced, and all that is required is access to the
type information. A <i>CObjectTypeInfo</i> contains a pointer to a <i>CTypeInfo</i> object, 

Two examples of this kind of application are:
<ul>
<li> When outputting a class description to a file (as in writing an ASN.1 specification)
<li> When translating data in one format on an input stream to a different format
     on an output stream
</ul>

The public constructor for <i>CObjectTypeInfo</i> takes a pointer to a <i>const CTypeInfo</i> object
as its single argument. This is precisely what is returned by the <i>GetTypeInfo()</i> method for serial
objects. Thus, to create a <i>CObjectTypeInfo</i> for the <i>CBioseq</i> class, one might use:

<pre>  CObjectTypeInfo objInfo(CBioseq::GetTypeInfo())</i>


One important use of the object classes defined in <i>include/objects</i> is the hooks and parsing
mechanisms they make available to applications utilizing <a
href="objstream.html"><i>CObject[IO]Stream</i>s</a>. The stream objects specialize in different
formats (such as XML or ASN.1), and must work in concert with the type-specific object classes to
interpret or generate serialized data.  In some cases however, the dynamic memory allocation
required for large objects may be substantial, and it is preferable to avoid instantiating a
concrete object.<p>

In these cases, it is possible to use the <a href="../docxx/CObjectStreamCopier.html">
<i>CObjectStreamCopier</i></a> class, described in <a href="objstream.html"> 
<i>CObject[IO]Streams</i></a>.  Briefly, this class holds two <i>CObject[IO]Stream</i> data members
pointing to the input and output streams, and a set of <i>Copy</i> methods which take a
<i>CTypeInfo</i> argument. Using this class, it is easy to translate files between 
different formats; for example:
<pre>
    auto_ptr<CObjectIStream>  in(CObjectIStream::Open("mydata.xml", eSerial_Xml));
    auto_ptr<CObjectOStream> out(CObjectOStream::Open("mydata.asn", eSerial_AsnBinary));
    CObjectStreamCopier copier(*in, *out);
    copier.Copy (CBioseq_set::GetTypeInfo());
</pre>
copies a <i>CBioseq_set</i> encoded in XML to a new file, reformatted in ASN.1 binary
format.<p>

<a name= "constobj"> <h4><i>CConstObjectInfo</i></h4>
<a name= "objinfo"> <h4><i>CObjectInfo</i></h4>


<a name = "usage"> <h3>Usage of object type information </h3>
We can now re-consider how the <a href="#example"> <i>LoadObject()</i></a> function might actually be
implemented using the <i>CObjectInfo</i> class:

<font color="#000080"><pre>
void SetValue (const CObjectInfo objInfo, string value);

bool LoadObject (CObjectInfo& info, CNcbiIStream& is)
{
     string myName, myValue;
     TMemberIndex MemberIdx;

     while (!is.eof()) {

         is >> myName >> myValue;

         MemberIdx = info.FindMember(myName);
         if (MemberIdx == kInvalidMember) {
            // generate an error message and exit
         }

	 SetValue (info.GetClassMember(MemberIdx), myValue);
     }	 
}
</pre></font>
The <i>CObjectInfo</i> object (<i>info</i>) will contain pointers to the <i>CObject</i> itself as well as to its 
associated <i>CClassTypeInfo</i> object. For each member alias read from the file, we use the <i>FindMember()</i>
method to retrieve its <i>TMemberIndex</i>. This index can then be used to retrieve a <i>CObjectInfo</i> object
for that member, which in turn, can be used to set the actual value of that member in the function <i>SetValue()</i>. 

<font color="#000080"><pre>

void SetValue(const CObjectInfo& obj, string value)
{
    if (obj.GetTypeFamily() == CTypeInfo::eTypePrimitive) {

        switch (obj.GetPrimitiveValueType()) {

	case CPrimitiveTypeInfo::eBool:
            obj.SetPrimitiveValueBool (atoi (value.c_str()));
	    break;

        case CPrimitiveTypeInfo::eChar:
            obj.SetPrimitiveValueChar (value.c_str()[0]);
	    break;

        case CPrimitiveTypeInfo::eInteger:
            if (obj.IsPrimitiveValueSigned()) 
	       obj.SetPrimitiveValueLong(atol(value.c_str()));
	    else
                obj.SetPrimitiveValueULong(atol(value.c_str()));
	    break;

        case CPrimitiveTypeInfo::eReal:
            obj.SetPrimitiveValueDouble(atof(value.c_str());
            break;

        case CPrimitiveTypeInfo::eString:
            obj.SetPrimitiveValueString(value);
	    break;
	}

    else {
        // generate error - can't assign to aggregate object from string
}
</pre></font>

Object information is intended for usage with polymorphic types that are passed to generic methods
that must now operate on their type-specific data members. In addition to user-specific applications
of the type demonstrated in this example, the generic implementations of the <a
href="iterators.html"> <i>C++ type iterators</i></a> and the <a href="objstream.html"><i>CObject[IO]Stream
</i></a> class methods provide excellent examples of how runtime object type information can be
deployed. <p>

The type information object provides safe and accurate information about the object's internal
structure and data members, while the object pointer provides direct access to the correctly
type-cast instance. Using an object information object, the generic function can access both the
type information and the object itself. Thus, the overhead and complexity of managing virtual
methods is avoided without sacrificing either object type-specificity or code genericity.
<p>

To this point we have focused on the encapsulation of type information for C++ <i>class</i> objects -
specifically, those having a static <a href="#cclass"><i>CClassTypeInfo</i></a> object associated
with the static class method, <i>GetTypeInfo()</i>. In the <a href="typeinfo2.html">next</a> section, 
we discuss how these concepts are specialized for <i>choice</i> classes, and generalized for non-class
objects such as C++ enumerations, old style C-structs, STL container instances, primitive data
types and pointer types.
<p>

   </body>
<a href="cref.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="iterators.html"> <i> next</i> </a>
</html>

	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
