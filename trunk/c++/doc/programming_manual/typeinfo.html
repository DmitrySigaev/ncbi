<!--#set var="TITLE" value="Runtime Object Type Information" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->

<h1>Runtime Object Type Information</h1>

<ul>
<li>
<a href="#introduction">Introduction</a></li>

<li>
<a href="#motivation">Motivation</a></li>

<li>
<a href="#cobjinfo">Object information classes: <span class="ncbi_class">CObjectTypeInfo</span>, <span class="ncbi_class">CConstObjectInfo</span>
and <span class="ncbi_class">CObjectInfo</span></a></li>

<li>
<a href="#usage">Usage of object type information</a></li>
</ul>
<p><br>

<a NAME="introduction"></a>
<h3>Introduction</h3>

Run-time information about data types is necessary in several contexts,
including:
<ol>
<li>
When reading, writing, and processing serialized data, where runtime information
about a type's internal structure is needed</li>

<li>
When reading from an arbitrary data source, where data members' external
aliases must be used to locate the corresponding class data members (e.g.
<i>MyXxx</i><!--NCBI_MARK--> may be aliased as <i>my-xxx</i><!--NCBI_MARK--> in the input data file)</li>

<li>
When using a generalized <a href="iterators.html">C++ type iterator</a>
to traverse the data members of an object</li>

<li>
When accessing the object type information per se (without regard
to any particular object instance), e.g. to dump it to a file as ASN.1
or DTD specifications (not <i>data</i><!--NCBI_MARK-->)</li>
</ol>
In the first three cases above, it is necessary to have both the object
itself as well as its runtime type information.&nbsp; This is because
in these contexts, the object is usually passed inside a generic function,
as a pointer to its most base parent type <a href="http://www.ncbi.nlm.nih.gov/IEB/CPP_DOC/docxx/CObject.html">CObject.</a>
The runtime type information is needed here, as there is no other way to
ascertain the actual object's data members. In addition to providing this
information, a runtime type information object provides an interface for
accessing and modifying these data members.
<p>In the last case (4) above, the type information is used independent
of any actual object instances.
<p>The NCBI C++ Toolkit uses two classes to support these requirements:
<ul><a NAME="ctypeinfo"></a>
<li>
<b>Type information classes</b> (base class <a href="../docxx/CTypeInfo.html" class="ncbi_class">>CTypeInfo</a>)
are intended for internal usage only, and they encode information about
a type, devoid of any instances of that type. This information includes
the class layout, inheritance relations, external alias, and various other
attributes such as size, which are independent of specific instances.
Each data member of a class also has its own type information. Thus, in
addition to providing information relevant to the member's occurrence in
the class (e.g. the member name and offset), the type information for a
<span class="ncbi_term">class</span>
must also provide access to the type information for each of its
<span class="ncbi_term">members</span>.</li>

<br>Limited type information is also available for types other than classes,
such as primitive data types, enumerations, containers, and pointers. For
example, the type information for a primitive type specifies that it is
an <span class="ncbi_type">int, float,</span> or <span class="ncbi_type">char</span>, etc., and whether or not that element
is signed. Enumerations are a special kind of primitive type, whose type
information specifies its enumeration values and named elements. Type information
for containers specifies both the type of container and the type of elements
that it holds.
<p><a NAME="ref_ObjectInfo"></a>
<li>
<a href="#cobjinfo">Object  information classes</a> (base class <a href="../docxx/CObjectTypeInfo.html" class="ncbi_class">CObjectTypeInfo</a>)
include a pointer to the type information as well as a pointer to the object
<span class="ncbi_type">instance</span>,
and provide a safe interface to that object. In situations where type information
is used independent of any concrete object, the object information
class simply serves as a wrapper to a type information object. Where
access to an object instance is required, the object pointer provides
direct access to the correctly type-cast instance, and the interface provides
methods to access and/or modify the object itself or members of that object.</li>
</ul>
The C++ Toolkit stores the type information outside any instances of that
type, in a statically created <span class="ncbi_class">CTypeInfo</span> object. For class
objects, this <span class="ncbi_class">CTypeInfo</span> object can be accessed by all instances
of the class via a static <a href="../lxr/ident?i=GetTypeInfo" class="ncbi_func">GetTypeInfo()</a>
class method. Similarly, for primitive types and other constructs that
have no way of associating methods with them per se, a static globally
defined <span class="ncbi_func">GetTypeInfoXxx()</span> function is used to access a static <span class="ncbi_class">CTypeInfo</span>
object. (The <i>Xxx</i><!--NCBI_MARK--> suffix is used here to indicate that a globally
unique name is generated for the function).
<p>All of the automatically generated classes and constructs defined in
the C++ Toolkit's
<a href="../lxr/source/include/objects/" class="ncbi_dir">objects/</a> directory
already have static <span class="ncbi_func">GetTypeInfo()</span> functions implemented for them.
In order to make type information about
<span class="ncbi_term">user-defined</span> classes and
elements also accessible, you will need to implement static <span class="ncbi_func">GetTypeInfo()</span>
functions for these constructs. A number of pre-processor macros are available
to support this activity, and are described in the section on <a href="usrtypeinfo.html">User-defined Type Information</a>.
<p>Type information is often needed when the object itself has been passed
anonymously, or as a pointer to its parent class. In this case, it is not
possible to invoke the <span class="ncbi_func">GetTypeInfo()</span> method directly, as the object's
exact type is unknown. Using a <span class="ncbi_keyword">&lt;static_cast></span> operator to enable
the member function is also unsafe, as it may open the door to incorrectly
associating an object's pointer with the wrong type information. For these
reasons, the <span class="ncbi_class">CTypeInfo</span> class is intended for internal usage only,
and it is the <a href="#cobjinfo" class="ncbi_class">CObjectTypeInfo</a> classes that
provide a more safe and friendly user interface to type information.
<p><br>

<a NAME="motivation"></a>
<h3>Motivation</h3>

We use a simple example to help motivate the use of this <span class="ncbi_term">type</span> and
<span class="ncbi_term">object</span> information model. Let us suppose that we would like to have a generic
function <span class="ncbi_func">LoadObject()</span>, which can populate an object using data read
from a flat file. For example, we might like to have:
<blockquote>
<pre class="ncbi_code">
bool LoadObject(Object&amp; myObj, istream&amp; is);
</pre></blockquote>
where <span class="ncbi_var">myObj</span> is an instance of some subclass of <span class="ncbi_class">Object</span>.
Assuming that the text in the file is of the form:

<blockquote>
<pre class="ncbi_code">
MemberName1 value1
MemberName5 value5
MemberName2 value2
:
</pre>
</blockquote>

we would like to find the corresponding data member in <span class="ncbi_var">myObj</span> for
each <span class="ncbi_var">MemberName</span>, and set that data member's value accordingly. Unfortunately,
<span class="ncbi_var">myObj</span>
cannot directly supply any useful type information, as the member names
we seek are for a specific subclass of <span class="ncbi_class">Object</span>. Now suppose that
we have an appropriate type information object available for
<span class="ncbi_var">myObj</span>,
and consider how this might be used:<a NAME="example"></a>

<blockquote>
<pre class="ncbi_code">
bool LoadObject(TypeInfo&amp; info, Object&amp; myObj, istream&amp; is)
{
    string myName, myValue;

    while ( !is.eof() ) {
        is >> myName >> myValue;
        void* member = FindMember(info, myObj, myName);
        AssignValue(member, myValue);
    }
}
</pre>
</blockquote>

Here, we assume that our type information object, <span class="ncbi_var">info</span>, stores information
about the memory offset of each data member in <span class="ncbi_var">myObj</span>, and that such
information can be retrieved using some sort of identifying member name
such as <span class="ncbi_var">myName</span>. This is not too difficult to imagine, and indeed,
this is exactly the type of information and facility provided by the C++
Toolkit's type information classes. The <span class="ncbi_func">FindMember()</span> function just
needs to return a <span class="ncbi_type">void</span> pointer to the appropriate location in memory.
The <span class="ncbi_func">AssignValue()</span> function presents a much greater challenge however,
as its two sole arguments are a <span class="ncbi_type">void</span> pointer and a <span class="ncbi_class">string</span>.
This would be fine if the data member was indeed a <span class="ncbi_type">void</span> pointer,
and a <span class="ncbi_class">string</span> value was acceptable. In general this is not the case,
and stronger methods are clearly needed.
<p>In particular, for each data member encountered, we need to retrieve
the type of that member as well as its location in memory, so as to process
<span class="ncbi_var">myValue</span>
appropriately before assigning it. In addition, we need safer mechanisms
for making such "untyped" assignments. Ideally, we would like a
<span class="ncbi_func">FindMember()</span>
function that returns a correctly cast pointer to that data member, along
with its associated type information. This is what the <a href="#ref_ObjectInfo">object
information classes</a> provide - a pointer to the object instance
as well as a pointer to its static <span class="ncbi_term">type</span> information. The interface
to the <span class="ncbi_class">object</span> information class also
provides a number of methods such as
<span class="ncbi_func">GetClassMember(), GetTypeFamily(),
SetPrimitiveValue()</span>, etc., to support the type of activity described
above.
<p><br>

<a NAME="cobjinfo"></a>
<h3>Object Information Classes</h3>

<ul>
<li>
<a href="#objtype">CObjectTypeInfo</a></li>
<ul>
<li>
<a href="#constobj">CConstObjectInfo</a></li>
<ul>
<li>
<a href="#objinfo">CObjectInfo</a></li>
</ul>
</ul>
</ul>
<p><br>

<a NAME="objtype"></a>
<h4><a href="../docxx/CObjectTypeInfo.html" class="ncbi_class">CObjectTypeInfo</a></h4>
This is the base class for all <span class="ncbi_term">object</span> information classes. It is
intended for usage where there is no concrete object being referenced,
and all that is required is access to the type information. A <span class="ncbi_class">CObjectTypeInfo</span>
contains a pointer to a low-level <span class="ncbi_class">CTypeInfo</span> object, and functions
as a user-friendly wrapper class.
<p>The constructor for <span class="ncbi_class">CObjectTypeInfo</span> takes a pointer to a <span class="ncbi_ccode">const
CTypeInfo</span> object as its single argument. This is precisely what is
returned by all of the static <span class="ncbi_func">GetTypeInfo()</span> functions. Thus, to
create a <span class="ncbi_class">CObjectTypeInfo</span> for the <span class="ncbi_class">CBioseq</span> class - without
reference to any particular instance of <span class="ncbi_class">CBioseq</span> - one might use:
<center>
<p><span class="ncbi_ccode">CObjectTypeInfo objInfo( CBioseq::GetTypeInfo() );</span></center>

<p>One of the most important methods provided by the <span class="ncbi_class">CObjectTypeInfo</span>
class interface is
<span class="ncbi_func">GetTypeFamily()</span>, which returns an enumerated
value indicating the <span class="ncbi_term">type family</span> for the object of interest. Five
type families are defined by the <a href="../lxr/ident?i=ETypeFamily" class="ncbi_type">ETypeFamily</a>
enumeration:

<blockquote>
<pre class="ncbi_code">
ETypeFamily GetTypeFamily(void) const;
    enum ETypeFamily {
    eTypeFamilyPrimitive,
    eTypeFamilyClass,
    eTypeFamilyChoice,
    eTypeFamilyContainer,
    eTypeFamilyPointer
};
</pre>
</blockquote>

Different queries become appropriate depending on the <span class="ncbi_type">ETypeFamily</span>
of the object. For example, if the object is a container, one might need
to determine the type of container (e.g. whether it is a <span class="ncbi_class">list</span>, <span class="ncbi_class">map</span>
etc.), and the type of element. Similarly, if an object is a primitive
type (e.g. <span class="ncbi_type">int, float, string, </span>etc.), an appropriate query becomes
what the value type is, and in the case of integer-valued types, whether
or not it is signed. Finally, in the case of more complex objects such
as class and choice objects, access to the type information for the individual
data members and choice variants is needed. The following methods are included
in the <span class="ncbi_class">CObjectTypeInfo</span> interface for these purposes:
<ul>
<li>
<span class="ncbi_ccode">GetTypeFamily() == eTypeFamilyPrimitive</span>:</li>

<ul>
<li>
<span class="ncbi_ccode">EPrimitiveValueType GetPrimitiveValueType(void) const;</span></li>

<li>
<span class="ncbi_ccode">bool IsPrimitiveValueSigned(void) const;</span><a NAME="cmemit"></a></li>

<br>&nbsp;</ul>

<li>
<span class="ncbi_ccode">GetTypeFamily() == eTypeFamilyClass</span>:</li>

<ul>
<li>
<span class="ncbi_ccode">CMemberIterator BeginMembers(void) const;</span></li>

<li>
<span class="ncbi_ccode">CMemberIterator FindMember(const string&amp; memberName) const;</span></li>

<li>
<span class="ncbi_ccode">CMemberIterator FindMemberByTag(int memberTag) const;</span><a NAME="cvarit"></a></li>

<br>&nbsp;</ul>

<li>
<span class="ncbi_ccode">GetTypeFamily() == eTypeFamilyChoice</span>:</li>

<ul>
<li>
<span class="ncbi_ccode">CVariantIterator BeginVariants(void) const;</span></li>

<li>
<span class="ncbi_ccode">CVariantIterator FindVariant(const string&amp; memberName) const;</span></li>

<li>
<span class="ncbi_ccode">CVariantIterator FindVariantByTag(int memberTag) const;</span></li>

<br>&nbsp;</ul>

<li>
<span class="ncbi_ccode">GetTypeFamily() == eTypeFamilyContainer</span>:</li>

<ul>
<li>
<span class="ncbi_ccode">EContainerType GetContainerType(void) const;</span></li>

<li>
<span class="ncbi_ccode">CObjectTypeInfo GetElementType(void) const;</span></li>

<br>&nbsp;</ul>

<li>
<span class="ncbi_ccode">GetTypeFamily() == eTypeFamilyPointer</span>:</li>

<ul>
<li>
<span class="ncbi_ccode">CObjectTypeInfo GetPointedType(void) const;</span></li>
</ul>
</ul>
The two additional enumerations referred to here, <a href="../lxr/ident?i=EContainerType" class="ncbi_type">EContainerType</a>
and <a href="../lxr/ident?i=EPrimitiveValueType" class="ncbi_type">EPrimitiveValueType</a>,
are defined, along with <span class="ncbi_type">ETypeFamily</span>, in <a href="../lxr/source/include/serial/serialdef.hpp" class="ncbi_file">include/serial/serialdef.hpp</a>.
<p>Different iterator classes are used for iterating over class data members
versus choice variant types. Thus, if the object of interest is a C++ class
object, then access to the type information for its members can be gained
using a
<span class="ncbi_class">CObjectTypeInfo::CMemberIterator</span>. The <span class="ncbi_func">BeginMembers()</span>
method returns a <span class="ncbi_class">CMemberIterator</span> pointing to the first data member
in the class; the <span class="ncbi_func">FindMember*()</span> methods return a <span class="ncbi_class">CMemberIterator</span>
pointing to a data member whose name or tag matches the input argument.
The <span class="ncbi_class">CMemberIterator</span> class is a forward iterator whose operators
are defined as follows:
<ul>
<li>
the <span class="ncbi_ccode">++</span> operator increments the iterator (makes it point to the next
class member)</li>

<li>
the <span class="ncbi_ccode">()</span> operator tests that the iterator has not exceeded the legitimate
range</li>

<li>
the <span class="ncbi_ccode">*</span> dereferencing operator returns a <span class="ncbi_class">CObjectTypeInfo</span> for
the data member the iterator currently points to</li>
</ul>
Similarly, the <span class="ncbi_func">BeginVariants()</span> and <span class="ncbi_func">FindVariant()</span> methods
allow iteration over the choice variant data types for a choice class,
and the dereferencing operation yields a <span class="ncbi_class">CObjectTypeInfo</span> object
for the choice variant currently pointed to by the iterator.
<p><br>

<a NAME="constobj"></a>
<h4><a href="../docxx/CConstObjectInfo.html">CConstObjectInfo</a></h4>

The <span class="ncbi_class">CConstObjectInfo</span> (derived from <a href="#objtype" class="ncbi_class">CObjectTypeInfo</a>)
adds an interface to access the particular instance of an object
(in addition to the interface inherited from <a href="#objtype">CObjectTypeInfo</a>,
which provides access to type information only). It is intended
for usage with <span class="ncbi_keyword">const</span> instances of the object of interest, and therefore
the interface does not permit any modifications to the object. The constructor
for
<span class="ncbi_class">CConstObjectInfo</span> takes two arguments:


<blockquote>
<pre class="ncbi_code">
CConstObjectInfo(const void* instancePtr, const CTypeInfo* typeinfoPtr);
</pre>
</blockquote>

<p>(Alternatively, the constructor can be invoked with a single STL pair
containing these two objects.)
<p>Each <span class="ncbi_class">CConstObjectInfo</span> contains a pointer to the object's type
information as well as a pointer to an instance of the object. The existence
or validity of this instance can be checked using any of the following
<span class="ncbi_class">CConstObjectInfo</span>
methods and operators:
<ul>
<li>
<span class="ncbi_ccode">bool Valid(void) const;</span></li>

<li>
<span class="ncbi_ccode">operator bool(void) const;</span></li>

<li>
<span class="ncbi_ccode">bool operator!(void) const;</span></li>
</ul>
For <span class="ncbi_term">primitive</span> type objects, the <span class="ncbi_class">CConstObjectInfo</span> interface
provides access to the currently assigned value using <span class="ncbi_func">GetPrimitiveValueXxx()</span>.
Here, <span class="ncbi_var">Xxx</span> may be <span class="ncbi_value">Bool, Char, Long, ULong, Double, String, ValueString</span>,
or <span class="ncbi_value">OctetString</span>. In general, to get a primitive value, one first
applies a <span class="ncbi_keyword">switch</span> statement to the value returned by <span class="ncbi_func">GetPrimitiveValueType()</span>,
and then calls the appropriate <span class="ncbi_func">GetPrimitiveValueXxx()</span> method depending
on the branch followed, e.g.:

<blockquote>
<pre class="ncbi_code">
switch ( obj.GetPrimitiveValueType() ) {

case ePrimitiveValueBool:
    bool b = obj.GetPrimitiveValueBool();
    break;

case ePrimitiveValueInteger:
    if ( obj.IsPrimitiveValueSigned() ) {
       long l = obj.GetPrimitiveValueLong();
    } else {
       unsigned long ul = obj.GetPrimitiveValueULong();
    }
    break;

    //... etc.
}
</pre>
</blockquote>

Member iterator methods are also defined in the <span class="ncbi_class">CConstObjectInfo</span>
class, with a similar interface to that found in the <span class="ncbi_class">CObjectTypeInfo</span>
class. In this case however, the dereferencing operators return a <span class="ncbi_class">CConstObjectInfo</span>
object - not a <span class="ncbi_class">CObjectTypeInfo</span> object - for the current member.
For C++ <span class="ncbi_keyword">class</span> objects, these member functions are:
<ul>
<li>
<span class="ncbi_ccode">CMemberIterator BeginMembers(void) const;</span></li>

<li>
<span class="ncbi_ccode">CMemberIterator FindClassMember(const string&amp; memberName) const;</span></li>

<li>
<span class="ncbi_ccode">CMemberIterator FindClassMemberByTag(int memberTag) const;</span></li>
</ul>
For C++ choice objects, only one variant is ever selected, and only
that choice variant is instantiated. As it does not make sense to define
a <span class="ncbi_ccode">CConstObjectInfo iterator</span> for uninstantiated variants, the method
<span class="ncbi_func">GetCurrentChoiceVariant()</span>
is provided instead. The dereferencing operator (*) can be applied to the
object returned by this method to obtain a
<span class="ncbi_class">CConstObjectInfo</span> for
the variant. Of course, type information for unselected variants can still
be accessed using the <span class="ncbi_class">CObjectTypeInfo</span> methods.
<p>The <span class="ncbi_class">CConstObjectInfo</span> class also defines an element iterator
for container type objects. <span class="ncbi_class">CConstObjectInfo::CElementIterator</span> is
a forward iterator whose interface includes increment and testing operators.
Dereferencing is implemented by the iterator's <span class="ncbi_func">GetElement()</span> method,
which returns a <span class="ncbi_class">CConstObjectInfo</span> for the element currently pointed
to by the iterator.
<p>Finally, for pointer type objects, the type returned by the method
<span class="ncbi_func">GetPointedObject()</span>
is also a <span class="ncbi_class">CConstObjectInfo</span> for the object - not just a <span class="ncbi_class">CObjectTypeInfo</span>.
<p><br>

<a NAME="objinfo"></a>
<h4><a href="../docxx/CObjectInfo.html">CObjectInfo</a></h4>

The <span class="ncbi_class">CObjectInfo</span> class is in turn derived from <span class="ncbi_class">CConstObjectInfo</span>,
and is intended for usage with <span class="ncbi_keyword">mutable</span> instances of the object of
interest. In addition to all of the methods inherited from the parent class,
the interface to this class also provides methods that allow modification
of the object itself or its data members.
<p>For primitive type objects, a set of <span class="ncbi_func">SetPrimitiveValueXxx()</span>
methods are available, complimentary to the <span class="ncbi_func">GetPrimitiveValueXxx()</span>
methods described above. Methods that return member iterator objects are
again reimplemented, and the de-referencing operators now return a
<span class="ncbi_class">CObjectInfo</span>
object for that data member. As the <span class="ncbi_class">CObjectInfo</span> now points to a
<span class="ncbi_keyword">mutable</span> object,
these iterators can be used to set values for the data member.
Similarly, <span class="ncbi_func">GetCurrentChoiceVariant()</span> now returns a <span class="ncbi_class">CObjectInfo</span>,
as does <span class="ncbi_ccode">CObjectInfo::CElementIterator::GetElement()</span>.
<p><br>


<a NAME="usage"></a>
<h3>Usage of object type information</h3>

We can now reconsider how our <a href="#example" class="ncbi_func">LoadObject()</a>
function might be implemented using the <span class="ncbi_class">CObjectInfo</span> class:

<blockquote>
<pre class="ncbi_code">
bool LoadObject(CObjectInfo&amp; info, CNcbiIStream&amp; is)
{
    string alias, myValue;

    while ( !is.eof() ) {
        is >> alias >> myValue;

        CObjectInfo dataMember(*info.FindClassMember(alias));
        if (!dataMember) {
           ERR_POST(ERROR, "Couldn't find member named:" &lt;&lt; alias);
        }
        SetValue(dataMember, myValue);
    }
}
</pre>
</blockquote>

Here, <span class="ncbi_var">info</span> contains pointers to the <span class="ncbi_class">CObject</span> itself as well
as to its associated <span class="ncbi_class">CTypeInfo</span> object. For each member alias read
from the file, we apply <span class="ncbi_ccode">FindClassMember(alias)</span>, and dereference
the returned iterator to retrieve a <span class="ncbi_class">CObjectInfo</span> object for that
member. We then use the operator <span class="ncbi_ccode">()</span> to verify that the member was
located, and if so, use the member's <span class="ncbi_class">CObjectInfo</span> to set a value
in the function <span class="ncbi_func">SetValue()</span>:

<blockquote>
<pre class="ncbi_code">
void SetValue(const CObjectInfo&amp; obj, const string value)
{
    if (obj.GetTypeFamily() == eTypeFamilyPrimitive) {

        switch ( obj.GetPrimitiveValueType() ) {

        case ePrimitiveValueBool:
            obj.SetPrimitiveValueBool (atoi (value.c_str()));
            break;

        case ePrimitiveValueChar:
            obj.SetPrimitiveValueChar (value.c_str()[0]);
            break;

        //... etc
        }
    } else {
        ERR_POST(ERROR, "Attempt to assign non-primitive from string:" &lt;&lt; value);
    }
}
</pre>
</blockquote>

In this example, <span class="ncbi_func">SetValue()</span> can only assign primitive types. More
generally however, the <span class="ncbi_class">CObjectInfo</span> class allows the assignment of
more complex types that are simply not implemented here. Note also that
the arguments to <span class="ncbi_func">SetValue()</span> are <span class="ncbi_keyword">const</span>, even though the function <em>does</em>
modify the value of the data instance pointed to. In particular, the type
<span class="ncbi_ccode">const CObjectInfo</span> should not be confused with the type
<span class="ncbi_class">CConstObjectInfo</span>.
The former specifies that object information construct is non-mutable,
although the instance it points to can be modified. The latter specifies
that the instance itself is non-mutable.
<p>In addition to user-specific applications of the type demonstrated in
this example, the generic implementations of the <a href="iterators.html">C++
type iterators</a> and the <a href="objstream.html">CObject[IO]Stream
</a> class
methods provide excellent examples of how runtime object type information
can be deployed.
<p>As a final example of how type information might be used, we consider
an application whose simple task is to translate a data file on an input
stream to a different format on an output stream. One important use of
the object classes defined in <span class="ncbi_dir">include/objects</span> is the hooks and parsing
mechanisms available to applications utilizing <a href="objstream.html"><span class="ncbi_class">CObject[IO]Stream</span>s</a>.
The stream objects specialize in different formats (such as XML or ASN.1),
and must work in concert with these type-specific object classes to interpret
or generate serialized data. In some cases however, the dynamic memory
allocation required for large objects may be substantial, and it is preferable
to avoid actually instantiating a whole object all at once.
<p>Instead, it is possible to use the 
<a href="../docxx/CObjectStreamCopier.html" class="ncbi_class">CObjectStreamCopier</a>
class, described in <a href="objstream.html" class="ncbi_class">CObject[IO]Streams</a>.
Briefly, this class holds two <span class="ncbi_class">CObject[IO]Stream</span> data members pointing
to the input and output streams, and a set of <span class="ncbi_ccode">Copy</span> methods which
take a
<span class="ncbi_class">CTypeInfo</span> argument. Using this class, it is easy to translate
files between different formats; for example:

<blockquote>
<pre class="ncbi_code">
auto_ptr&lt;CObjectIStream>  in(CObjectIStream::Open("mydata.xml",eSerial_Xml));
auto_ptr&lt;CObjectOStream> out(CObjectOStream::Open("mydata.asn",eSerial_AsnBinary));
CObjectStreamCopier copier(*in, *out);
copier.Copy (CBioseq_set::GetTypeInfo());
</pre>
</blockquote>

copies a <span class="ncbi_class">CBioseq_set</span> encoded in XML to a new file, reformatted in
ASN.1 binary format.
<p><!--a href="cref.html"><i>previous</i>&nbsp;</a-->
<br><i><a href="traverse.html">previous</a></i><!--NCBI_MARK-->&nbsp;&nbsp;&nbsp; <i><a href="../index.html">up</a></i><!--NCBI_MARK-->&nbsp;&nbsp;

<i><a href="usrtypeinfo.html">next</a></i><!--NCBI_MARK-->


<!--#include virtual="../ssi/navlinks.shtml" -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> --></td>

<td ALIGN=RIGHT><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
