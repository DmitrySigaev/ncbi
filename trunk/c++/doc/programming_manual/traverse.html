<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title> Traversing an ASN.1 Data Structure. </title>
</head>
<body BGCOLOR="white">

<h1> Traversing an ASN.1 Data Structure </h1>
<ul>
  <li> <a href="#locateClass"> Locating the Class Definitions </a>
  <li> <a href="#accessMember"> Accessing and Referencing Data Members </a>
  <li> <a href="#example"> Traversing an ASN.1 Biostruc </a>
  <li> <a href="#iterate"> Iterating Over Containers </a>
</ul>

<a name="locateClass"> <h3> Locating the Class Definitions </h3>
In order to traverse an ASN data object, you must first become familiar with 
the class structures and access functions which implement the object. The
example provided here involves an ASN.1 Biostruc type which is implemented
by class <i>CBiostruc.</i> <p>

The first question is: how do I locate the class definitions implementing the object
to be traversed? As mentioned previously, the source browser is of little help in this case, as the
compiled object classes are not registered in the C++ tree.  The <i>include</i> and
<i>src</i> directories are available for browsing however, in <a
href="/netopt/ncbi_tools/c++/include/objects"> <i> $NCBI/c++/include/objects </a> </i>and
<A href = "/netopt/ncbi_tools/c++/src/objects"> <i>$NCBI/c++/src/objects</a></i>. <p>

Because we are using a <i>Biostruc</i>, the first place to search is in the <i>mmdb </i>
include directories.  In the <i>mmdb1</i> directory, we find two header files that look appropriate: 
<a href="/netopt/ncbi_tools/c++/include/objects/mmdb1/Biostruc.hpp"> <i> Biostruc.hpp</i> </a> and
<a href="/netopt/ncbi_tools/c++/include/objects/mmdb1/Biostruc_.hpp"> <i> Biostruc_.hpp</i></a>.
The first file defines the class <i>CBiostruc</i>, which inherits from the class <i>CBiostruc_Base</i>,
defined in the second file.  The <i> base</i>
class is where you must look for the definitions and access functions you will be using. However, it
is the inherited class (defined in <i>CBiostruc.hpp</i>) whose header should be <i>#included</i> in your source files, 
and which should be instantiated by your local program variable. The inherited class's header file 
will include the base header file for you. <p>

The relation between these two files and the classes they define reflects a general design
used in developing the object libraries: the base class files are generated by
<i>datatool</i> according to the ASN.1 specifications in the <i>src</i> directories; the
inherited class files are intended for developers who are extending these classes to
support features above and beyond the ASN.1 specifications. The purpose of this design is
to insulate the developers as much as possible from changes to the underlying
specifications. These inherited classes are not intended however, for the general
programmer's modification, as they entail library dependencies. <p>

<a name="accessMember"> <h3> Accessing and Referencing Data Members </h3>
Removing some of the implementation details of the base class, we find the <i>CBiostruc_Base</i> class 
has essentially the following structure:

<font color = "#000080"> 
<pre>
class CBiostruc_Base : public NCBI_NS_NCBI::CObject
{
public:

    // type definitions 

    typedef NCBI_NS_STD::list< NCBI_NS_NCBI::CRef< ::CBiostruc_id > > TId;
    typedef NCBI_NS_STD::list< NCBI_NS_NCBI::CRef< ::CBiostruc_descr > > TDescr;
    typedef NCBI_NS_STD::list< NCBI_NS_NCBI::CRef< ::CBiostruc_feature_set > > TFeatures;
    typedef NCBI_NS_STD::list< NCBI_NS_NCBI::CRef< ::CBiostruc_model > > TModel;
    typedef ::CBiostruc_graph TChemical_graph;

    // Get() members 

    const TId& GetId(void) const;
    const TDescr& GetDescr(void) const;
    const TChemical_graph& GetChemical_graph(void) const;
    const TFeatures& GetFeatures(void) const;
    const TModel& GetModel(void) const;

    // Set() members

    TId& SetId(void);
    TDescr& SetDescr(void);
    TChemical_graph& SetChemical_graph(void);
    TFeatures& SetFeatures(void);
    TModel& SetModel(void);

private:
    TId m_Id;
    TDescr m_Descr;
    TChemical_graph m_Chemical_graph;
    TFeatures m_Features;
    TModel m_Model;
};
</pre>
<font color = black>
With the exception of the structure's chemical graph, each of the class's private
data members is actually a <i>list</i> of references (pointers), as specified by
the type definitions. Specifically, <i> NCBI_NS_STD</i> is an alias for the <i>std</i>
namespace, so the lists are standard STL list containers whose arguments specify what
type of elements the list will hold. For example, <i>TId</i> is a list of <i>NCBI_NS_NCBI::CRef</i>
objects, where each <i>CRef</i> object points to a <i>CBiostruc_id</i>. 
The <i>CRef</i> class is described in the section on <a href="cref.html"> smart pointers</a>,
and is defined in <a href="/netopt/ncbi_tools/c++/include/corelib/ncbiobj.hpp"> 
<i>corelib/ncbiobj.hpp</i></a>. Briefly, it is a specialization of the STL auto_ptr
class that uses reference counts to determine whether or not an object can be deleted 
when the pointer goes out of scope.<p>

The derefencing operator, when applied to a <i>CRef</i> element of the Biostruc's TId list,
<i>*listElt</i>, will by this definition return a <i>CBiostruc_id</i>.  Because the
<i>CRef</i> class is defined in the <i> NCBI_NS_NCBI</i> namespace, the scope operator is
used to refer to it. The scope operator without a prefix refers to the scope that is "just
one level up" - i.e. the set of prevailing definitions prior to entering the current class
scope. Thus <i>::CBiostruc_id</i> refers to the class definition occurring at the
<i>same</i> level as <i>CBiostruc</i>, while <i>CBiostruc::TId</i>, references the list
type definition we have been discussing here.
<p>
In summary, each of the above <i>list</i> type definitions defines an STL list of 
pointers to the specified innermost <i>::type</i>. Thus the call to <i>GetId()</i>
returns a list which must then be iterated over and dereferenced to get the 
individual id objects. In contrast, the function <i>GetChemicalGraph()</i> returns the
object directly, as it does not involve a list or a <i>CRef</i>. <p>

In general, all objects in the NCBI libraries will have a similar structure: a set of private 
data members and a set of <i> GetXxx()</i> and <i> SetXxx()</i> member functions to access
and modify ("mutate") these data. In addition, most classes, including <i>CBiostruc</i>, have 
<i>IsSetXxx()</i> and <i>ResetXxx()</i> functions to validate and clear the data members
respectively. 

<a name="example"> <h3> Traversing an ASN.1 Biostruc </h3> 
The program <a href="traverse_cpp.html"><i>traverseBS.cpp</i></a> demonstrates
how one might read an ASN.1 data file and iterate over the components of the resulting object. 
This example opens an ASN.1 Biostruc file on a text input stream and stores the information
in a <i>CBiostruc</i>. The overloaded <i>Visit()</i> function is then used to recursively examine
<i>CBiostruc bs</i> and its components.<p>

<a href="traverse_cpp.html#visitBS">
<i>Visit(bs)</i></a> simply calls <i>Visit()</i> on each of its data members, where the data members are
accessed using <i>bs.GetXxx()</i>.  The information needed to write each of these functions -
the data member types and member function signatures - is contained in the respective header
files. For example, consulting <i>Biostruc_.hpp</i>, we learn that the structure's 
descriptor list can be accessed using <i>GetDescr()</i>, and that the type returned is a 
list of pointers to descriptors:
<font color = "#000080">
<pre>
     typedef NCBI_NS_STD::list< NCBI_NS_NCBI::CRef< ::CBiostruc_descr > > TDescr;
     const TDescr& GetDescr(void) const;
</pre>
<font color = black>

Consulting 
<a href="/netopt/ncbi_tools/c++/include/objects/mmdb1/Biostruc_desc_.hpp">
<i>Biostruc_desc_.hpp</i> </a>in turn, we learn that this class has a <i>choice 
state</i> defining the type of value stored there as well as the method that should be
used to access that value. This leads to an implementation of 
<a href="traverse_cpp.html#visitDscr"> <i>Visit(CBiostruc::TDescr DescrList)</i></a>
that uses an iterator over its list argument and a switch statement over the 
current descriptor's choice state. 

<a name="iterate"> <h3>  Iterating Over Containers </h3> 

Most of the <i>Visit()</i> functions implemented here rely on standard STL iterators to
walk through a list of objects. The general syntax for using an iterator is:

<font color = "#000080">
<pre>
  ContainerType ContainerName;

  for (ContainerType::IteratorType i = ContainerName.begin();
       i != ContainerName.end(); ++i ) {

    ObjectType ObjectName = *i;
    // ...
  }
</pre>
<font color = black>

Dereferencing the iterator is required, as the iterator is essentially 
a pointer that traverses consecutive elements of the container.
For example, to iterate over the list of descriptors in the Biostruc, we use
a container of type <i>CBiostruc::TDescr</i>, and an iterator of type <i>const_iterator</i>
to ensure that the data is not mutated in the body of the loop. Because the descriptor
list contains pointers (<i>CRefs</i>) to objects, we will actually need to dereference <i>twice</i>
to get to the objects themselves. 

<font color = "#000080">
<pre>
  for ( CBiostruc::TDescr::const_iterator i = descList.begin();
        i != descList.end(); ++i ) {

    const CBiostruc_descr& thisDescr = **i;
    // ...
  }
</pre>
<font color = black>

In traversing the descriptor list in this example, we handled each type of descriptor with an explicit
case statement. In fact however, we really only visit those descriptors whose types have 
string representations: <i>TName, TPdb_comment</i>, and <i>TOther_comment</i>. The other two 
descriptor types, <i>THistory</i> and <i>TAttribute</i>, are objects that are "visited" 
recursively, but the associated visit functions are not actually implemented (see
<a href="traverse_hpp.html"> traverseBS.hpp</a>). <p>

An alternative to this approach would have been to use an NCBI <i>type iterator</i> 
inside the standard iterator that only visits those
data members of an object satisfying a specified type. For example we
could implement the Visit function on a <i>CBiostruc::TDescr</i> as follows:

<font color = "#000080">
<pre>
void Visit (const CBiostruc::TDescr& descList) { 

    for ( CBiostruc::TDescr::const_iterator i1 = descList.begin();
        i1 != descList.end(); ++i1 ) {

        for ( CStdTypeConstIterator< string > i = ConstBegin(**i1); i; ++i ) {
 	         cout << *i << endl;
        }
    }
}
</pre>
<font color = black>
The type iterators come in two flavors <i>CStdTypeIterators</i> and <i>CObjectTypeIterators</i>.
The standard type iterators operate on STL containers such as lists, vectors, queues, and maps etc,
visiting each item in the container. The object type iterators operate on objects, and iterate 
over the data members of the object's class.

<p>
</body>

<a href="asn.html"> <i> previous</i> </a>

</html>
	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
