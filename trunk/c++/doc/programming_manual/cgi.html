<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title> Developing CGI applications </title>
  </head>
  <body bgcolor = white>
    <h1>Developing CGI applications  </h1>

Although CGI programs are invariably run as web applications with HTML
interfaces, this section of the Programming Manual considers only the CGI side of
the implementation. Similarly, the section on <a href="webpgs.html"> Generating
Web pages</a> discusses only those aspects which concern formatting HTML pages. The
materials covered in these two sections are then brought together in <a href="webcgi.html">
Developing Web-based Applications</a>. 

<ul>
  <li> <a href="#overview"> Overview of the CGI classes </a>
  <li> <a href="#ccgiapp"> The CCgiApplication class </a>
  <li> <a href="#cncbires"> The CNcbiResource and CNcbiCommand classes </a>
  <li> <a href="#ccgires"> The CCgiResponse class </a>
  <li> <a href="#ccgireq"> The CCgiRequest class </a>
  <li> <a href="#ccgicoo"> The CCgiCookie class </a>
  <li> <a href="#ccgictx"> The CCgiContext class </a>
</ul>

<a name="overview"> <h3> Overview of the CGI classes </h3>
Figure 1 illustrates the layered design of the CGI classes. 

<center><img SRC="cgi.gif"> <br> Figure 1</center>

This design is best described by starting with a consideration of the capabilities 
one might need to implement a CGI program, including:

<ul>
  <li> A way to retrieve and store the current values of environment variables
  <li> A means of retrieving and interpreting the client's query request string
  <li> Mechanisms to service and respond to the requested query
  <li> Methods and data structures to obtain, store, modify, and send cookies
  <li> A way to set/reset the context of the application (for Fast-CGI)
</ul>

The <i>CCgiContext</i> class unifies these diverse capabilities under one aggregate
structure. As their names suggest, the <i>CCgiRequest</i> class receives and parses the
request, and the <i>CCgiResponse</i> class outputs a response on
an output stream. All incoming <i>CCgiCookie</i>s are also parsed and stored by the
<i>CCgiRequest</i> object, and the outgoing cookies are sent along with the response
by the <i>CCgiResponse</i> object. The request is actually processed by the application's
<i>CNcbiResource</i>.  The list of <i>CNcbiCommand</i>s stored with that resource object are
scanned to find a matching command, which is then executed. <p>

The <i>CCgiContext</i> object, which is a <i>friend</i> to the <i>CCgiApplication</i>
class, orchestrates this sequence of events in coordination with the application
object. The same application may be run in many different contexts, but the
<i>resource</i> and defined set of <i>commands</i> are invariant. What changes with each
context is the request and its associated response.
<p>

The <i>CCgiApplication</i> class is a specialization of <i>CNcbiApplication</i>.  Figure 2
illustrates the adaptation of the <i>Init()</i> and <i>Run</i> member functions to the
requirements of CGI programming. Although the application is <i>contained</i> in the 
context, it is the application which creates and initializes each context in which it
participates. The program arguments and environmental variables are passed along to 
the context, where they will be stored, thus freeing the application to be restarted
in a new context, as in Fast-CGI. 

<center><img SRC="cgirun.gif"> <br> Figure 2</center><p>

The application's <i>ProcessRequest</i> member function is an abstract function that
must be implemented for each application project. In most cases, this
function will access the query and the environment variables via the <i>CCgiContext</i>, 
using <i>ctx.GetRequest()</i> and <i>ctx.GetConfig()</i>. The application may then
service the request using its resource's <i>HandleRequest()</i> method. The context's 
response object can then be used to send an appropriate response. <p>

These classes are described in more detail below, along with abbreviated synopses of the
class definitions. These are included here to provide a conceptual framework and are not
intended as reference materials. For example, constructor and destructor declarations that
operate on void arguments, and <i>const</i> methods that duplicate <i>non-const</i>
declarations are generally not included here. Certain virtual functions and data members
that have no meaning outside of a web application are also omitted. For complete
definitions, refer to the header files via the source browsers.

<a name="ccgiapp"> 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiApplication.html">
<h3> The CCgiApplication class </h3></a>
As mentioned, the <i>CCgiApplication </i> class implements its own version of 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=Init">
<i>Init()</i></a>, where it instantiates a <i>CNcbiResource</i> object using 
<i>LoadResource()</i>. 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=Run">
<i>Run</i></a> is no longer a pure virtual
function in this subclass, and its implementation now calls <i>CreateContext(),
ProcessRequest()</i>, and <i>CCgiContext::GetResponse()</i>. The <i>CCgiApplication</i> 
class does <i>not</i> have
a <i>CCgiContext</i> data member, since the application object can participate in multiple
<i>CCgiContext</i>s. Instead, a local variable in <i>Run()</i> stores a pointer to the 
context created there. 

<font color = "#000080"> <pre>
class CCgiApplication : public CNcbiApplication
{
    friend class CCgiContext;

public:
    
    void Init(void); 
    void Exit(void); 
    int Run(void);

    virtual int ProcessRequest(CCgiContext&) = 0;
    CNcbiResource& GetResource(void);
    CNcbiResource* LoadResource(void);
    bool RunFastCGI(unsigned def_iter=3);

protected:

    CCgiContext* CreateContext(CNcbiArguments*, CNcbiEnvironment*,
                               CNcbiIstream*, CNcbiOstream*);

private:
    auto_ptr&lt;CNcbiResource> m_resource;
};
</pre></font>

If the program was <i>not</i> compiled as a Fast-CGI application (or the environment does
not support Fast-CGI), then 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=RunFastCGI">
<i> RunFastCGI()</i></a> will return <i>False</i>. Otherwise, the Fast-CGI loop will be
iterated over <i>def_iter</i> times, with the initialization methods and
<i>ProcessRequest()</i> function being executed on each iteration. The value returned by
<i> RunFastCGI()</i> in this case is <i>True</i>.  <i>Run()</i> first calls <i>
RunFastCGI()</i>, and if that returns <i>False</i>, the application is run as a plain CGI
program.

<a name="cncbires">
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CNcbiResource.html">
<h3> The CNcbiResource</a> and 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CNcbiCommand.html">
CNcbiCommand</a> classes </h3>

The resource class is at the heart of the application, and it is here that the program's
functionality is defined. The single argument to the resource class's constructor is a <a
href="applic.html#CNcbiRegistry"><i>CNcbiRegistry</i></a> object, which defines data
paths, resources, and possibly environmental variables for the application. This
information is stored in the resource class's data member, <i>m_config</i>. The only other
data member is a
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=TCmdList">
<i>TCmdList</i></a> (a list of <i>CNcbiCommand</i>s) called <i>m_cmd</i>.

<!-- SKIPPED     virtual const CNcbiResPresentation* GetPresentation(void) const;-->

<font color = "#000080"> <pre>
class CNcbiResource
{
public:

    CNcbiResource(CNcbiRegistry& config);

    // Getters
    CNcbiRegistry&  GetConfig(void);
    const TCmdList& GetCmdList(void) const;
    virtual CNcbiCommand* GetDefaultCommand(void) const = 0;

    void AddCommand(CNcbiCommand* command);
    virtual void HandleRequest(CCgiContext& ctx);

protected:   

    CNcbiRegistry& m_config;  
    TCmdList m_cmd;
};
</pre> </font>

The <i>AddCommand()</i> method is used when a resource is being initialized, to add
commands to the command list.  Given a <i>CCgiRequest</i> object defined in a particular
context <i>ctx</i>, 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=HandleRequest">
<i>HandleRequest(ctx)</i></a> compares entries in the context's request to
commands in <i>m_cmd</i>. All commands requested in the query are then executed (see
below), and the request is considered "handled". If desired, a default command may be
defined by the user by implementing the function <i>GetDefaultCommand()</i> to return the
selected (installed) command.  If a default command has been defined and no entries in the
query match any of the defined commands, <i>HandleRequest()</i> causes this default
command to execute.

<!-- SKIPPED    virtual CNcbiCommand* Clone(void) const = 0; -->
<!-- SKIPPED    virtual CNCBINode* GetLogo(const CCgiContext&) const { return 0; } -->
<!-- SKIPPED    virtual string GetName(void) const = 0; -->
<!-- SKIPPED    virtual string GetLink(CCgiContext& ctx) const = 0; -->

<font color = "#000080"> <pre>
class CNcbiCommand
{
public:

    CNcbiCommand(CNcbiResource& resource);

    virtual bool IsRequested(const CCgiContext& ctx) const;
    virtual void Execute(CCgiContext& ctx) = 0;
    virtual string GetName() const = 0;

protected:

    virtual string GetEntry() const = 0;
    CNcbiResource& GetResource() const { return m_resource; }

private:

    CNcbiResource& m_resource;
};
</pre> </font>

The only data member contained in a CNcbiCommand object is a reference back to the resource it
belongs to. There are however, three member function's which serve to identify each
command and define its execution: <i>GetName(), GetEntry(),</i> and <i>Execute()</i>.
All of these are pure virtual functions that must be defined by the application. <p>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/src/cgi/ncbires.cpp#L202">
<i>IsRequested()</i> </a>takes a <i>CCgiContext</i> as its single argument, and uses
<i>ctx.GetRequest().GetEntries()</i> to obtain a <i>multimap</i> of the <i>key=value</i>
pairs in the query. The multimap is then searched for an entry where <i>key=GetEntry()</i>
and <i>value=GetName()</i>. <i>IsRequested()</i> is called by the resource's <i>HandleRequest()</i>
method, and when <i>IsRequested()</i> returns <i>True</i>, the command's <i>Execute()</i> 
method is invoked. 

<a name="ccgireq"> 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiRequest.html">
<h3> The CCgiRequest class </h3></a>

<i>The CCgiRequest</i> class serves as an interface between the user's query and the CGI
program. The query may have been submitted as part of the command line, as part of a URL
(METHOD=GET), or on the input stream (METHOD=POST). Arguments to the constructor include
the <i>CNcbiArguments, CNcbiEnvironment, CNcbiIstream, </i> and a set of flags. The 
constructor uses the environment passed in to cache network information as "gettable"
properties. These properties include:

<ul>
     // server properties
353     eCgi_ServerSoftware = 0,
354     eCgi_ServerName,
355     eCgi_GatewayInterface,
356     eCgi_ServerProtocol,
357     eCgi_ServerPort,        // see also "GetServerPort()"
358 
359     // client properties
360     eCgi_RemoteHost,
361     eCgi_RemoteAddr,        // see also "GetRemoteAddr()"
362 
363     // client data properties
364     eCgi_ContentType,
365     eCgi_ContentLength,     // see also "GetContentLength()"
366 
367     // request properties
368     eCgi_RequestMethod,
369     eCgi_PathInfo,
370     eCgi_PathTranslated,
371     eCgi_ScriptName,
372     eCgi_QueryString,
373 
374     // authentication info
375     eCgi_AuthType,
376     eCgi_RemoteUser,
377     eCgi_RemoteIdent,
378 
379     // semi-standard properties(from HTTP header)
380     eCgi_HttpAccept,
381     eCgi_HttpCookie,
382     eCgi_HttpIfModifiedSince,
383     eCgi_HttpReferer,
384     eCgi_HttpUserAgent,
385 
386     // # of CCgiRequest-supported standard properties
387     // for internal use only!
388     eCgi_NProperties
389 };  // ECgiProp
390 

    // Startup initialization:
    //   retrieve request's properties and cookies from environment
    //   retrieve request's entries from "$QUERY_STRING"
    // If "$REQUEST_METHOD" == "POST" then add entries from stream "istr"
    // If "$REQUEST_METHOD" is undefined then try to retrieve the request's
    // entries from the 1st cmd.-line argument, and do not use "$QUERY_STRING"
    // and "istr" at all

Flags   // dont handle indexes as regular FORM entries with empty value
        // do not parse $QUERY_STRING
        // own the passed "env" (and destroy them it in destructor)

</pre>
<font color = "#000080"> <pre>
class CCgiRequest {
public:
    typedef int TFlags;

    enum Flags {
        fIndexesNotEntries  = 0x1,
        fIgnoreQueryString  = 0x2,
        fOwnEnvironment     = 0x4
    };

    CCgiRequest(const CNcbiArguments*, const CNcbiEnvironment*, CNcbiIstream*, TFlags);

    static const string& GetPropertyName(ECgiProp prop);    // name (not value)
    const string& GetProperty(ECgiProp prop) const;         // value
    const string& GetRandomProperty(const string& key, bool http=true) const;
    size_t GetContentLength(void) const;
    const CCgiCookies& GetCookies(void) const;
    const TCgiEntries& GetEntries(void) const;
    const TCgiIndexes& GetIndexes(void) const;
    static SIZE_TYPE ParseEntries(const string& str, TCgiEntries& entries);
    static SIZE_TYPE ParseIndexes(const string& str, TCgiIndexes& indexes);

private:

    const CNcbiEnvironment*    m_Env;
    auto_ptr&lt;CNcbiEnvironment> m_OwnEnv;
    TCgiEntries m_Entries;
    TCgiIndexes m_Indexes;
    CCgiCookies m_Cookies;

    const string& x_GetPropertyByName(const string& name) const;    // retrieve/cache the property
};  
</pre> </font>


<a name="ccgires"> 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiResponse.html">
<h3> The CCgiResponse class </h3></a>

<a name="ccgicoo"> 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiCookie.html">
<h3> The CCgiCookie class </h3></a>

<a name="ccgictx">
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiContext.html">
<h3> The CCgiContext class </h3></a>
<p>

   </body>
<a href="exceptions.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="webpgs.html"> <i> next</i> </a>
</html>

	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
