<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title> Developing CGI applications </title>
  </head>
  <body bgcolor = white>
    <h1>Developing CGI applications  </h1>

Although CGI programs are generally run as web applications with HTML
interfaces, this section of the Programming Manual considers only the CGI side of
the implementation. Similarly, the section on <a href="webpgs.html"> Generating
Web pages</a> discusses only those aspects which concern formatting HTML pages. The
materials covered in these two sections are then brought together in <a href="webcgi.html">
Developing Web-based Applications</a>. 

<ul>
  <li> <a href="#overview"> Overview of the CGI classes </a>
  <li> <a href="#ccgiapp"> The CCgiApplication class </a>
  <li> <a href="#cncbires"> The CNcbiResource and CNcbiCommand classes </a>
  <li> <a href="#ccgireq"> The CCgiRequest class </a>
  <li> <a href="#ccgires"> The CCgiResponse class </a>
  <li> <a href="#ccgicoo"> The CCgiCookie class </a>
  <li> <a href="#cookies"> The CCgiCookies class </a>
  <li> <a href="#ccgictx"> The CCgiContext class </a>
</ul>

<a name="overview"> <h3> Overview of the CGI classes </h3>
Figure 1 illustrates the layered design of the CGI classes. 

<center><img SRC="cgi.gif"> <br> Figure 1</center><br>

This design is best described by starting with a consideration of the capabilities 
one might need to implement a CGI program, including:

<ul>
  <li> A way to retrieve and store the current values of environment variables
  <li> A means of retrieving and interpreting the client's query request string
  <li> Mechanisms to service and respond to the requested query
  <li> Methods and data structures to obtain, store, modify, and send cookies
  <li> A way to set/reset the context of the application (for Fast-CGI)
</ul>

The <i>CCgiContext</i> class unifies these diverse capabilities under one aggregate
structure. As their names suggest, the <i>CCgiRequest</i> class receives and parses the
request, and the <i>CCgiResponse</i> class outputs the response on
an output stream. All incoming <i>CCgiCookie</i>s are also parsed and stored by the
<i>CCgiRequest</i> object, and the outgoing cookies are sent along with the response
by the <i>CCgiResponse</i> object. The request is actually processed by the application's
<i>CNcbiResource</i>.  The list of <i>CNcbiCommand</i>s stored with that resource object are
scanned to find a matching command, which is then executed. <p>

The <i>CCgiContext</i> object, which is a <i>friend</i> to the <i>CCgiApplication</i>
class, orchestrates this sequence of events in coordination with the application
object. The same application may be run in many different contexts, but the
<i>resource</i> and defined set of <i>commands</i> are invariant. What changes with each
context is the request and its associated response.
<p>

The <i>CCgiApplication</i> class is a specialization of <i>CNcbiApplication</i>.  Figure 2
illustrates the adaptation of the <i>Init()</i> and <i>Run</i> member functions to the
requirements of CGI programming. Although the application is <i>contained</i> in the 
context, it is the application which creates and initializes each context in which it
participates. The program arguments and environmental variables are passed along to 
the context, where they will be stored, thus freeing the application to be restarted
in a new context, as in Fast-CGI. 

<center><img SRC="cgirun.gif"> <br> Figure 2</center><p>

The application's <i>ProcessRequest</i> member function is an abstract function that
must be implemented for each application project. In most cases, this
function will access the query and the environment variables via the <i>CCgiContext</i>, 
using <i>ctx.GetRequest()</i> and <i>ctx.GetConfig()</i>. The application may then
service the request using its resource's <i>HandleRequest()</i> method. The context's 
response object can then be used to send an appropriate response. <p>

These classes are described in more detail below, along with abbreviated synopses of the
class definitions. These are included here to provide a conceptual framework and are not
intended as reference materials. For example, constructor and destructor declarations that
operate on void arguments, and <i>const</i> methods that duplicate <i>non-const</i>
declarations are generally not included here. Certain virtual functions and data members
that have no meaning outside of a web application are also omitted. For complete
definitions, refer to the header files via the source browsers.

<a name="ccgiapp"> 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiApplication.html">
<h3> The CCgiApplication class </h3></a>
As mentioned, the <i>CCgiApplication </i> class implements its own version of 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=Init">
<i>Init()</i></a>, where it instantiates a <i>CNcbiResource</i> object using 
<i>LoadResource()</i>. 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=Run">
<i>Run</i></a> is no longer a pure virtual
function in this subclass, and its implementation now calls <i>CreateContext(),
ProcessRequest()</i>, and <i>CCgiContext::GetResponse()</i>. The <i>CCgiApplication</i> 
class does <i>not</i> have
a <i>CCgiContext</i> data member, since the application object can participate in multiple
<i>CCgiContext</i>s. Instead, a local variable in <i>Run()</i> stores a pointer to the 
context created there. 

<font color = "#000080"> <pre>
class CCgiApplication : public CNcbiApplication
{
    friend class CCgiContext;

public:
    
    void Init(void); 
    void Exit(void); 
    int Run(void);

    virtual int ProcessRequest(CCgiContext&) = 0;
    CNcbiResource& GetResource(void);
    CNcbiResource* LoadResource(void);
    bool RunFastCGI(unsigned def_iter=3);

protected:

    CCgiContext* CreateContext(CNcbiArguments*, CNcbiEnvironment*,
                               CNcbiIstream*, CNcbiOstream*);

private:
    auto_ptr&lt;CNcbiResource> m_resource;
};
</pre></font>

If the program was <i>not</i> compiled as a Fast-CGI application (or the environment does
not support Fast-CGI), then 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=RunFastCGI">
<i> RunFastCGI()</i></a> will return <i>False</i>. Otherwise, the Fast-CGI loop will be
iterated over <i>def_iter</i> times, with the initialization methods and
<i>ProcessRequest()</i> function being executed on each iteration. The value returned by
<i> RunFastCGI()</i> in this case is <i>True</i>.  <i>Run()</i> first calls <i>
RunFastCGI()</i>, and if that returns <i>False</i>, the application is run as a plain CGI
program.

<a name="cncbires">
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CNcbiResource.html">
<h3> The CNcbiResource</a> and 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CNcbiCommand.html">
CNcbiCommand</a> classes </h3>

The resource class is at the heart of the application, and it is here that the program's
functionality is defined. The single argument to the resource class's constructor is a <a
href="applic.html#CNcbiRegistry"><i>CNcbiRegistry</i></a> object, which defines data
paths, resources, and possibly environmental variables for the application. This
information is stored in the resource class's data member, <i>m_config</i>. The only other
data member is a
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=TCmdList">
<i>TCmdList</i></a> (a list of <i>CNcbiCommand</i>s) called <i>m_cmd</i>.

<!-- SKIPPED     virtual const CNcbiResPresentation* GetPresentation(void) const;-->

<font color = "#000080"> <pre>
class CNcbiResource
{
public:

    CNcbiResource(CNcbiRegistry& config);

    // Getters
    CNcbiRegistry&  GetConfig(void);
    const TCmdList& GetCmdList(void) const;
    virtual CNcbiCommand* GetDefaultCommand(void) const = 0;

    void AddCommand(CNcbiCommand* command);
    virtual void HandleRequest(CCgiContext& ctx);

protected:   

    CNcbiRegistry& m_config;  
    TCmdList m_cmd;
};
</pre> </font>

The <i>AddCommand()</i> method is used when a resource is being initialized, to add
commands to the command list.  Given a <i>CCgiRequest</i> object defined in a particular
context <i>ctx</i>, 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=HandleRequest">
<i>HandleRequest(ctx)</i></a> compares entries in the context's request to
commands in <i>m_cmd</i>. All commands requested in the query are then executed (see
below), and the request is considered "handled". If desired, a default command may be
defined by the user by implementing the function <i>GetDefaultCommand()</i> to return the
selected (installed) command.  If a default command has been defined and no entries in the
query match any of the defined commands, <i>HandleRequest()</i> causes this default
command to execute.

<!-- SKIPPED    virtual CNcbiCommand* Clone(void) const = 0; -->
<!-- SKIPPED    virtual CNCBINode* GetLogo(const CCgiContext&) const { return 0; } -->
<!-- SKIPPED    virtual string GetName(void) const = 0; -->
<!-- SKIPPED    virtual string GetLink(CCgiContext& ctx) const = 0; -->

<font color = "#000080"> <pre>
class CNcbiCommand
{
public:

    CNcbiCommand(CNcbiResource& resource);

    virtual bool IsRequested(const CCgiContext& ctx) const;
    virtual void Execute(CCgiContext& ctx) = 0;
    virtual string GetName() const = 0;

protected:

    virtual string GetEntry() const = 0;
    CNcbiResource& GetResource() const { return m_resource; }

private:

    CNcbiResource& m_resource;
};
</pre> </font>

The only data member contained in a CNcbiCommand object is a reference back to the resource it
belongs to. There are however, three member function's which serve to identify each
command and define its execution: <i>GetName(), GetEntry(),</i> and <i>Execute()</i>.
All of these are pure virtual functions that must be defined by the application. <p>
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/src/cgi/ncbires.cpp#L202">
<i>IsRequested()</i> </a>takes a <i>CCgiContext</i> as its single argument, and uses
<i>ctx.GetRequest().GetEntries()</i> to obtain a <i>multimap</i> of the <i>key=value</i>
pairs in the query. The multimap is then searched for an entry where <i>key=GetEntry()</i>
and <i>value=GetName()</i>. <i>IsRequested()</i> is called by the resource's <i>HandleRequest()</i>
method, and when <i>IsRequested()</i> returns <i>True</i>, the command's <i>Execute()</i> 
method is invoked. 

<a name="ccgireq"> 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiRequest.html">
<h3> The CCgiRequest class </h3></a>

<i>The CCgiRequest</i> class serves as an interface between the user's query and the CGI
program. Arguments to the constructor include a <i>CNcbiArguments</i> object, a
<i>CNcbiEnvironment</i> object, and a <i>CNcbiIstream</i> object. The
constructors themselves do little other than invoke <i>CCgiRequest::x_Init()</i>, where
the actual initialization takes place. <p>

<i>x_Init()</i> begins by examining the environment argument, and if it is <i>NULL</i>,
<i>m_OwnEnv</i> (an <i>auto_ptr</i>) is reset to a dummy environment. Otherwise,
<i>m_OwnEnv</i> is reset to the passed environment, making the request object the
effective owner of that environment. The environment is then used to cache network
information as "gettable" properties. Cached properties include:

<ul>
  <li> server properties such as the server name, gateway interface, and server port

  <li> client properties: the remote host and remote address  

  <li> client data properties: content type and content length

  <li> request properties including the request method, query string, and path information

  <li> authentication information such as the remote user and remote identity

  <li> standard HTTP properties (from the HTTP header) 
</ul>
These properties are keyed to an enumeration named 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/ECgiProp.html">
<i>ECgiProp</i></a>, and can be retrieved using the request object's <i>GetProperty()</i>
member function.  For example, <i>GetProperty(eCgi_HttpCookie)</i> is used to access
cookies from the HTTP Header, and <i> GetProperty(eCgi_RequestMethod)</i> is used to
determine where the query string should be read from. <p>

<font color = "#000080"> <pre>
class CCgiRequest {
public:

    CCgiRequest(const CNcbiArguments*, const CNcbiEnvironment*, CNcbiIstream*, TFlags);

    static const string& GetPropertyName(ECgiProp prop);    
    const string& GetProperty(ECgiProp prop) const;         
    size_t GetContentLength(void) const;
    const CCgiCookies& GetCookies(void) const;
    const TCgiEntries& GetEntries(void) const;
    static SIZE_TYPE ParseEntries(const string& str, TCgiEntries& entries);

private:

    const CNcbiEnvironment*    m_Env;
    auto_ptr&lt;CNcbiEnvironment> m_OwnEnv;
    TCgiEntries m_Entries;
    CCgiCookies m_Cookies;
};  
</pre> </font>
This abbreviated definition of the <i>CCgiRequest</i> class highlights its primary
functionalities:
<ol>
<li> to parse and store the &lt;<i>key=value</i>> pairs contained in the query
string in <i>m_Entries</i>
<li> to parse and store the cookies contained in the HTTP header in 
<i>m_Cookies</i>
</ol>
As implied by the "T" prefix,
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/ident?i=TCgiEntries">
<i>TCgiEntries</i></a> is a type defintion, and defines <i>m_Entries</i> to be an STL
multimap of <i>&lt;string,string></i> pairs. The <i>CCgiCookies</i> class (described 
<a href="#cookies"> below</a>) contains an STL set of <i>CCgiCookie</i>, and implements
an interface to this set.

<a name="ccgires"> 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiResponse.html">
<h3> The CCgiResponse class </h3></a>
<font color = "#000080"> <pre>
class CCgiResponse {
public:

    CCgiResponse(CNcbiOstream* out = 0);

    // Set/query raw type of response
    void SetRawCgi(bool raw);
    bool IsRawCgi(void) const;

    void SetHeaderValue(const string& name, const string& value);
    void SetHeaderValue(const string& name, const tm& value);
    void RemoveHeaderValue(const string& name);
    void SetContentType(const string &type);

    string GetHeaderValue(const string& name) const;
    bool HaveHeaderValue(const string& name) const;
    string GetContentType(void) const;

    CCgiCookies& Cookies(void);		        // Get cookies set

    CNcbiOstream* SetOutput(CNcbiOstream* out); // Set default output stream

    CNcbiOstream* GetOutput(void) const;        // Query output stream

    CNcbiOstream& out(void) const;	        // Conversion to ostream to enable <<

    void Flush() const;			        // Flushes output stream

    CNcbiOstream& WriteHeader(void) const;      // Write HTTP response header
    CNcbiOstream& WriteHeader(CNcbiOstream& out) const;

protected:

    typedef map<string, string> TMap;
    static const string sm_ContentTypeName;
    static const string sm_ContentTypeDefault;
    static const string sm_HTTPStatusDefault;
    bool m_RawCgi;
    CCgiCookies m_Cookies;
    TMap m_HeaderValues;       // Header lines in alphabetical order
    CNcbiOstream* m_Output;    // Default output stream
};
</font></pre>

<a name="ccgicoo"> 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiCookie.html">
<h3> The CCgiCookie class </h3></a>

<a name="cookies"> 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiCookies.html">
<h3> The CCgiCookies class </h3></a>

<a name="ccgictx">
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/doc++/CCgiContext.html">
<h3> The CCgiContext class </h3></a>
<p>

   </body>
<a href="exceptions.html"> <i> previous</i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="webpgs.html"> <i> next</i> </a>
</html>

	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>
