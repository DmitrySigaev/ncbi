<!--#set var="TITLE" value="The CNcbiRegistry Class" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>
The CNcbiRegistry Class</h1>

<ul>
<li>
<a href="#intro">Introduction</a></li>

<li>
<a href="#syntax">Syntax of the configuration file</a></li>

<li>
<i><a href="#eflags">CNcbiRegistry::EFlags</a></i></li>

<li>
<a href="#methods">Additional Methods</a></li>
</ul>

<h3>
<a NAME="intro"></a>Introduction</h3>
<p>
The <i><a href="../docxx/CNcbiRegistry.html">CNcbiRegistry</a></i> class
is used to access, modify and store runtime information read from a configuration
file. Previously, these files were by convention named "<i>.*rc</i>" files
on UNIX systems. The convention for all platforms now is to name such files
"<i>*.ini"</i>, where "*" is by default the application name.&nbsp; Unless
you explicitly override the default behavior, the
<i><a href="applic.html#CNcbiApplication">CNcbiApplication</a></i>
class looks for a configuration file with the default name.&nbsp; You can
override this by calling your application's <i><a href="applic.html#appmain">AppMain()
</a></i>method
with the full set of arguments:
<pre>
AppMain (argc, argv, envp, diag_stream, config_file, progname);
</pre>
</p>

<p>
Here, <i>config_file</i> is a string specifying the name of the file
to be used when loading the registry. If you do not need to use this facility,
you can specify <i>config_file</i> using <i>NcbiEmptyString</i>.&nbsp;
This will eliminate a warning message, positing that no configuration file
was found.
</p>
<p>
As long as the configuration file is specified without a path, the system will
look for it in the following locations:
<ol>
<li>in the current working directory,</li>
<li>in the directory, defined by the environment variable <tt>NCBI</tt>,</li>
<li>in the user's home directory,</li>
<li>in the program directory.</li>
</ol>
</p>


<h1>
<a NAME="syntax"></a></h1>

<h3>
Syntax of the configuration file</h3>
The configuration file is composed of <i>section</i> headers and &lt;<i>name=value</i>>
strings, which occur within the named sections.&nbsp; It is also possible
to include comments in the file,&nbsp; which are indicated by a new line
with a leading semi-colon.&nbsp; Figure 1 shows an example configuration
file.
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote><tt>; MyProgram.ini</tt>
<p><tt>; parameters for section1</tt>
<br><tt><font color="#3366FF">[section1]</font></tt>
<br><tt>name1 = value1 and value1.2</tt>
<br><tt>n-2.3 = "&nbsp; this value has two spaces at its very beginning
and at the end&nbsp; "</tt>
<br><tt>name3 = this is a multi\</tt>
<br><tt>line value</tt>
<br><tt>name4 = this is a single line ended by back slash\\</tt>
<br><tt>name5 = all backslashes and \</tt>
<br><tt>new lines must be \\escaped\\...</tt>
<p><tt><font color="#3366FF">[ section2.9-bis ]</font></tt>
<br><tt>; This is a comment...</tt>
<br><tt>name2 = value2</tt>
<br>&nbsp;</blockquote>
</blockquote>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Figure
1. An example configuration file</blockquote>
</blockquote>
</blockquote>
All comments and empty lines are ignored by the registry file parser.&nbsp;
Line continuations, as usual, are indicated with a backslash escape. More
generally,&nbsp; backslashes are processed as:
<ul>
<li>
[backslash] + [backslash] -- converted into a single [backslash]</li>

<li>
[backslash] + [space(s)] + [EndOfLine] -- converted to an [EndOfLine]</li>

<li>
[backslash] + ["]&nbsp; -- converted into a ["]</li>
</ul>
Character strings with embedded spaces do not need to be quoted,&nbsp;
and an unescaped double quote at the very beginning or end of a value is
ignored. All other combinations with [backslash] and ["] are invalid.
<p>The following restrictions apply to the <i>section</i> and <i>name</i>
identifiers occurring in a registry file:
<ul>
<li>
the string must contain only:&nbsp; [a-z], [A-Z], [0-9], [_.-] characters</li>

<li>
the interpretation of the string is <i>not</i> case-sensitive, e.g. <i>PATH
== path == PaTh</i></li>

<li>
all leading and trailing spaces will be truncated</li>
</ul>

<h3>
<a NAME="transience"></a></h3>

<h3>
<i>CNcbiRegistry::EFlags</i></h3>
In addition to the constructor, which initializes the registry in memory
and loads parameters from a file, the <i>CNcbiRegistry</i> class provides
methods for <i>saving</i> the registry (as a new configuration file), and
<i>reading
in</i> additonal parameters from a secondary file(s).&nbsp; Each &lt;<i>name=value</i>>
pair stored in the registry has three attributes, specifying whether or
not that value is:
<ul>
<li>
<b><i>persistent,</i></b> meaning the value will be written to a file when
the registry is saved</li>

<li>
<b><i>overridable,</i></b> meaning the value can be overridden by a new
value with the same name</li>

<li>
<b><i>truncatable,</i></b> meaning that leading and trailing blanks can
be truncated from the value</li>
</ul>
By default, all of the configuration's parameters are <i>persistent, overridable</i>,
and <i>truncatable</i>.&nbsp; The <i>EFlags</i> enumeration that quantifies
these attributes, and the related <i>typedef</i> <i>TFlags</i>, are defined
as:

<blockquote>
<blockquote>
<blockquote><tt><font color="#005050">&nbsp;&nbsp;&nbsp; enum EFlags {</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
eTransient&nbsp;&nbsp; = 0x1,</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ePersistent&nbsp; = 0x100,</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
eOverride&nbsp;&nbsp;&nbsp; = 0x2,</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
eNoOverride&nbsp; = 0x200,</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
eTruncate&nbsp;&nbsp;&nbsp; = 0x4,</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
eNoTruncate&nbsp; = 0x400</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp;&nbsp; };</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp;&nbsp; typedef int TFlags;</font></tt></blockquote>
</blockquote>
</blockquote>
<i>TFlags</i> is simply used to clarify that an <i>int</i> derived from
a combination (bit-wise <i>OR</i>) of <i>EFlags</i> is expected - not just
an arbitrary "regular" <i>int</i>.&nbsp; Many of <i>CNcbiRegistry</i>'s
methods take an optional <i>TFlags</i> argument, which qualifies the selected
values with respect to these attributes.
<p>For example, the following code excerpt sets the value of registry entry
<i>MyName</i>
in section <i>MySection</i> to <i>"Eugene"</i>.&nbsp; In particular, the
<i>TFlags</i> argument, derived from the bit-wise OR of
<i>eTruncate </i>and
<i>eNoOverride</i>, specifies that (1) all leading and trailing blanks
in the new value should be truncated, and (2) that the new value <b>cannot</b>
be applied to override a previous value if one exists:
<p><tt><font color="#005050">&nbsp;&nbsp; CNcbiRegistry reg(.....);</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp; .....................</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp; reg.Set("MySection", "MyName",
" Eugene&nbsp;&nbsp; ",</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CNcbiRegistry::eNoOverride | CNcbiRegistry::eTruncate);</font></tt>
<p><font color="#000000">The </font><i>CNcbiRegistry </i><font color="#000000">class
constructor takes two arguments - an input stream to read the registry
from (usually a file), and an optional
<i>TFlags</i> argument, where the
latter can be used to specify that all of the values should be stored as
<i>transient</i>
rather than in the default mode, which is <i>persistent</i>:</font>
<center>
<p><tt><font color="#005050">CNcbiRegistry(CNcbiIstream&amp; is, TFlags
flags = 0);</font></tt></center>

<p>Once the registry has been initialized by its constructor, it is also
possible to load additional parameters from other file(s) using the
<i>Read()
</i>method:
<center>
<p><tt><font color="#005050">void Read(CNcbiIstream&amp; is, TFlags flags
= 0);</font></tt></center>

<p>Valid flags for the <i>Read() </i>method include <font color="#000000"><i>eTransient
</i>and<i>
eNoOverride. </i></font>The default is for all&nbsp; values to be read
in as <i>persistent</i>, with the capability of overriding any previously
loaded value associated with the same name.&nbsp; Either or both of these
defaults can be modified by specifying <font color="#000000"><i>eTransient,
eNoOverride,
</i>or (<i>eTransient | eNoOverride</i>) as the <i>flags</i>
argument in the above expression.</font>
<p>The <i>Write() </i>method takes as its sole argument, a destination
stream to which only the <i>persistent</i> configuration parameters will
be written.
<p>Values can also be set directly inside your application, using:
<center>
<p><tt><font color="#005050">&nbsp;&nbsp;&nbsp; bool Set(const string&amp;
section, const string&amp; name,</font></tt>
<br><tt><font color="#005050">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const string&amp; value, TFlags flags = 0);</font></tt></center>

<p>Here, valid flag values include <font color="#000000"><i>ePersistent,
eNoOverride,</i> <i>eTruncate, </i>or any logical combination of these.&nbsp;
If <i>eNoOverride</i> is set and there <i>is</i> a previously defined value
for this parameter, then the value is not reset, and the method returns
<i>false.</i></font>
<p><font color="#000000">The <i>Get()</i> method first searches the set
of <i>transient</i> parameters for a parameter named <i>name</i>, in section
<i>section</i>,
and if this fails,&nbsp; continues by searching the set of <i>persistent</i>
parameters. However, if the <i>ePersistent</i> flag is used, then only&nbsp;
the set of <i>persistent</i> parameters will be searched. On success, <i>Get()
</i>returns
the stored value. On failure, the empty string is returned.</font>
<center>
<p><tt><font color="#005050">const string&amp; Get(const string&amp; section,
const string&amp; name, TFlags flags = 0) const;</font></tt></center>

<h3>
<a NAME="methods"></a></h3>

<h3>
<font color="#000000">Additonal methods</font></h3>
Four additional methods are defined in the interface.
<p><tt><font color="#005050">&nbsp;bool Empty(void) const;</font></tt>
<br><tt><font color="#005050">&nbsp;void Clear(void);</font></tt>
<br><tt><font color="#005050">&nbsp;void EnumerateSections(list&lt;string>*
sections) const;</font></tt>
<br><tt><font color="#005050">&nbsp;void EnumerateEntries(const string&amp;
section,&nbsp; list&lt;string>* entries) const;</font></tt>
<p><i>Empty() </i>returns<i> true </i>if the registry is empty. <i>Clear()
</i>empties
out the registry, discarding all stored parameters. <i>EnumerateSections()&nbsp;</i>
writes all registry section names to <i>sections.&nbsp;</i> <i>EnumerateEntries()&nbsp;</i>
writes the list of parameter names in <i>section </i>to<i> entries.</i>
<p><a href="argdescr.html"><i>previous</i>&nbsp;</a>&nbsp; <i><a href="../index.html">up</a></i>&nbsp;&nbsp;

<i><a href="diag.html">next</a></i>


<!--#include virtual="../ssi/navlinks.shtml" -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td>
<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Diane Zimmerman</a></address>
</td>

<td><!-- <td align=center><i>$Revision$</i></td> --></td>

<td ALIGN=RIGHT><i>$Date$</i></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
