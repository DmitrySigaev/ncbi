<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title>Working within the C++ source tree </title>
</head>
<body BGCOLOR=white>
<h1> Working within the C++ source tree </h1>
Most users will find that working in a <i>checked-out</i> subtree or a private
directory is preferable to working directly in the C++ source tree. There are
two good reasons to avoid doing so:
<ol>
<li> Building your own versions of the extensive libraries can be very time-consuming.
<li> There is no guarantee that the library utilities your private code links to have not
become obsolete.
</ol>

This section is provided for those developers who must work within the source tree.  The
Reference Manual sections provide more complete and technical discussion of
the topics reviewed here, and many links to the relevant sections are provided. This
page is provided as an overview of material presented in the 
<a href="../new_proj.html#ref_Makefile">
Reference Manual</a>.

<ul>
  <li> <a href="#checkout"> Check out the source tree and build the libraries</a> 
  <li> <a href="#makefiles"> The project's directories and makefiles </a>
  <li> <a href="#make_in"> <i>Makefile.in</i></a>
  <li> <a href="#projdefs"> Macro defintions in <i>Makefile.in</i></a>
  <li> <a href="#proj_makes"> Makefile.*.app and Makefile.*.lib</a>
  <li> <a href="#exec">  Executing <i>make</i></a>
  <li> <a href="#config"> The <i>configure</i> scripts</a>
</ul>

<a name="checkout">

<a href="../config.html#ref_Source"><h3> Checkout the source tree and build the
libraries</h3></a> Since you will be working inside the C++ source tree you will first
need to checkout <i>$CVSROOT/internal/c++</i>. If you do not wish to include all of the
subprojects contained in <i>$CVSROOT/internal/c++/internal</i>, you may want to use
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/scripts/cvs_core.sh">
<i>cvs_core.sh</i></a> (provided in the <a
href="../new_proj.html#ref_Checkout"><i>scripts</i></a> directory) for checking out.

Once you have done so, you will need to run one of the configure scripts in the
<i>internal/c++</i> directory.  For example, to configure your environment to work with the
<i>gcc</i> compiler on Solaris, use: <i>./configure</i>.

The <a href="../config.html#ref_Configure"><i>configure script</i></a> is a multi-platform
configuration shell script (generated from <i>configure.in</i> using
<i>autoconf</i>). Here are some pointers to sections in the Reference Manual that will
help you configure the build environment:
<ul>
<li> <a href="../config.html#ref_Wrappers"> Wrapper scripts</a> supporting various platforms
<li> <a href="../config.html#ref_Running"> Optional configuration flags</a>
</ul>

The <i>configure</i> script concludes with a message describing how to build the C++ Toolkit
libraries. If your application will be working with ASN.1 data, use the <i>--with-objects</i> flag
in running the <i>configure</i> script, so as to populate the <i>include/objects</i> and
<i>src/objects</i> subdirectories.

<a name="makefiles">
<h3> The project's directories and makefiles </h3>

To start a new project ("<i>myProj</i>"), you should begin by creating both a <i>src</i>
and an <i>include</i> subtree for that project inside the C++ tree.  In general, all
header files that will be accessed by multiple source modules outside the project
directory should be placed in the <i>include</i> directory. Header files that will be used
solely inside the project's <i>src</i> directory should be placed there, along with the
implementation files. <p>

In addition to the C++ source files, the <i>src</i> subtrees contain <i>meta-makefiles</i>
named <i>Makefile*.in</i>, which are used by the <i>configure</i> script to generate
corresponding <i>makefiles</i> in the <i>build</i> subtrees. Figure 1 shows slices of the
directory structure reflecting the correspondences between the <i>meta-makefiles</i> in the <i>src</i>
subtrees and makefiles in the <i>build</i> subtrees. Figure 2 is a sketch of the entire C++ tree
in which these directories are defined.<p>

Each of the <i>meta-makefiles</i> in the
top-level <i>src</i> tree has a corresponding <i>Makefile*</i> in the top-level of the build
tree. Thus, you will also need to create a <i>meta-makefile</i> in the newly created
<i>src/myProj</i> directory before reconfiguring your build directory to include the new
project. The <i>configure</i> script will then create the corresponding subtree in the
<i>build</i> directory, along with a new <i>Makefile</i> generated from the <i>Makefile.in</i>
you created.

<center><img SRC="make.gif"></center>
<center><img SRC="cpptree2.gif"></center>
<a name="make_in"> <h3> Makefile.in</h3>
The file <i>myProj/Makefile.in</i> should contain macros whose definitions have 
the following interpretation:

<ul> 
<li> <i>LIB_PROJ</i> (optional) - a list of names for library targets
<li> <i>APP_PROJ</i> (optional) - a list of names for application targets
<li> <i>SUB_PROJ</i> (optional) - a list of names for subdirectory targets (used on recursive builds)
<li> <i>USR_PROJ</i> (optional) - a list of names for user-defined makefile targets
</ul>

These macro definitions are used to define the build targets - refer also to the Reference
Manual's description of <a href="../new_proj.html#ref_Makefile"> makefile
targets</a>. Executing <i>make</i> or <i>make all</i> (the default target) will cause all but
the <i>$SUB_PROJ</i> targets to be built. Copies of the resulting  executables will also be
placed in the <i>bin</i> directory at the top of the <i>build</i> tree; libraries are copied
to the <i>lib</i> directory.<p>

Executing <i>make all_r</i> will build targets in the <i>$SUB_PROJ</i> subdirectories as
well. Similarly, <i>make clean</i> removes all object modules, libraries, and executables from
the project's <i>build</i> directory, while <i>make clean_r</i> removes all object files,
libraries, and executables from the subproject directories as well.  Finally, <i>make purge</i>
and <i>make purge_r</i> do the same work as <i>make clean</i> and <i>make clean_r</i>, and then
remove the libraries and executables from the <i>lib</i> and <i>bin</i> directories as well.
<p>
The last two lines in <i>Makefile.in</i> should always be:

<font color=#000080><pre>
srcdir = @srcdir@
include @builddir@/Makefile.meta
</pre></font>

These two lines specify <i>make</i> variable templates using the <i>@var_name@</i> syntax. When
generating the corresponding <i>Makefile</i> in the <i>build</i> directory, the <i>configure</i> script
will substitute each identifier name bearing that notation with full path definitions. 
<p>
Assuming that <i>myProj</i> is used to develop an application named <i>myProj</i>,
<i>myProj/Makefile.in</i> should contain the following:

<font color=#000080><pre>
APP_PROJ = myProj

srcdir = @srcdir@
include @builddir@/Makefile.meta
</pre></font>
The corresponding <i>Makefile</i> in <i>build/myProj</i>
generated by the <i>configure</i> script will then contain:
<font color=#000080><pre># Generated automatically from Makefile.in by configure.

APP_PROJ = myProj

srcdir = /home/zimmerma/internal/c++/src/myProj
include /home/zimmerma/internal/c++/myBuild/build/Makefile.meta
</pre></font>

As demonstrated in this example, the <i>@srcdir@</i> and <i>@builddir@</i> aliases in the
makefile template have been replaced with absolute paths in the generated <i>Makefile</i>,
while the definition of <i>APP_PROJ</i> is copied verbatim. 

<a name="projdefs"> <h3>The project defintions in <i>Makefile.in</i></h3>

For each application (<i>p1, p2, ..., pN</i>) listed in <i><b>APP_PROJ</b></i>, you must have created
a corresponding <a href="#proj_makes"> project makefile</a> named <i>Makefile.p*.app</i> in the
project's source directory.  Similarly, each library (<i>l1, l2, ..., lN</i>) listed in the
<b><i>LIB_PROJ</i></b> macro must have a corresponding <i>Makefile.l*.lib</i>.
<p>

The <i><b>SUB_PROJ</b></i> macro is used to define recursive build targets; items listed here
define the subdirectories rooted in the project's source directory where <i>make</i> should be executed
recursively.  The <i>configure</i> script will create these relative subdirectories inside the
new <i>build</i> project directory, and generate the new subdirectories' makefiles
from the corresponding meta-makefiles in the <i>src</i> subtrees.  A recursive
build can then be invoked by using "<i>make all_r</i>". <p>

The <b><i>USR_PROJ</i></b> macro is provided for the execution of individually defined makefiles which
do not follow the conventions described in this section. In general, executing <i>make</i> in a
build subdirectory causes <i>build/Makefile.meta</i> (located in the top level of the
<i>build</i> tree), to be executed.  For each <i>target_name</i> listed in <i>USR_PROJ</i>,
<i>Makefile.meta</i> first tests to see if <i>Makefile.target_name</i> is available in the
current build directory, and if so, executes:

<font size=2><pre>
   make -f Makefile.target_name builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS)
</pre></font>

Otherwise, <i>Makefile.meta</i> assumes the required makefile is in the project's source
directory, and executes:

<font size=2><pre>
   make -f $(srcdir)/Makefile.target_name builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS)
</pre></font>

In either case, although the target's specific makefile is executed directly, the aliased
<i>srcdir, builddir</i>, and <i>MFLAGS</i> are still available to <i>Makefile.target_name</i>.
Note also that because <i>make</i> is executed directly from a different directory than the one
in which the source files are located, complete paths to those source files must be given in
<i>Makefile.target_name</i>. For example:
<font color=#000080><pre>####### Makefile.progname

include $(NCBI)/ncbi.mk
CC = gcc
INCPATH = $(NCBI_INCDIR)

all: $(srcdir)/progname.c
	$(CC) -o progname $(srcdir)/progname.c

clean:
	rm progname progname.o

purge: clean
</pre></font>
<p>
will cause the C program <i>progname</i> to be built directly from
<i>Makefile.progname</i> using the GCC compiler. The executables and libraries generated
from the targets specified in <i>USR_PROJ</i> are written to the current <i>build</i> 
directory only - they are <i>not</i> copied to the <i>bin</i> or <i>lib</i> directories. <p>

<a name = "exec"> <h3> Executing <i>make</i></h3>
Given these makefile definitions, executing <i>make all_r</i> in the <i>build</i> project
subdirectory causes <i>build/Makefile.meta</i> to be executed, which sets the following chain
of events in motion:

<ul>
 <li> For each <i><b>lib_name</b></i> listed in <i>LIB_PROJ</i>, 
     <i>make -f $(builddir)/Makefile.lib.tmpl</i> is executed. This in turn specifies 
     that <i>$(builddir)/Makefile.mk, $(srcdir)/Makefile.<b>lib_name</b>.lib</i>, and 
     <i>$(builddir)/Makefile.lib</i> should be included in the generated makefile commands
     that actually get executed. The resulting libraries are written to the <i>build</i> subdirectory
     and copied to the <i>lib</i> subtree. <br><br>

 <li> For each <i><b>app_name</b></i> listed in <i>APP_PROJ</i>, 
     <i>make -f $(builddir)/Makefile.app.tmpl</i> is executed. This in turn specifies 
     that <i>$(builddir)/Makefile.mk, $(srcdir)/Makefile.<b>app_name</b>.app</i>, and <i>$(builddir)/Makefile.app</i>
     should be included in the generated makefile commands that actually get executed. 
     The resulting executables are written to the <i>build</i> subdirectory and copied to 
     the <i>bin</i> subtree. <br><br>

 <li> For each <i><b>dir_name</b></i> listed in <i>SUB_PROJ</i> (on <i>make all_r</i>), 
     <i>cd <b>dir_name</b></i> is executed and <i>make all_r</i> is executed. <br>
     The resulting executables are written to the appropriate <i>build</i> subdirectory and 
     copied to the <i>bin</i> subtree. <br><br>

 <li> For each <i><b>proj_name</b></i> listed in <i>USR_PROJ</i>, 
     <i>make -f $(srcdir)/Makefile.<b>proj_name</b></i> is executed, and 
     the resulting libraries and executables are written to the <i>build</i> directory only. 
</ul>
<a name="proj_makes"> <a href="../new_proj.html#ref_MakeProjLib"><h3> Makefile.*.lib and Makefile.*.app</h3> </a>
<i>Makefile.<b>lib_name</b>.lib</i> should contain the following macro definitions:
<ul>
  <li> <i> $(LIBOBJ) </i> - the names of all source files to compile and include in the library
  <li> <i> $(LOBJ) </i> - the names of any pre-compiled object files to include in the library
  <li> <i> $(LIB)</i> - the name of the library being built
</ul>
For an example, see <a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/src/corelib/Makefile.corelib.lib">
Makefile.corelib.lib</a>. <p>
<i>Makefile.<b>app_name</b>.app</i> should contain the following macro definitions:
<ul>
  <li><i> $(OBJ) </i> - the names of the object modules to build and link to the application
  <li><i> $(LIB)</i> - specific libraries in the NCBI C++ Toolkit to include in the linking
  <li><i> $(LIBS) </i> - all other libraries to link to (outside the C++ Toolkit)
  <li><i> $(APP) </i> - the name of the application being built
</ul>
For an example, see 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/src/corelib/test/Makefile.coretest.app">
Makefile.coretest.app</a>. <p>

<a name="config"> <h3>The <i>configure</i> scripts</h3>

A number of compiler-specific wrappers for different platforms are described in the
<a href="http://sunweb.ncbi.nlm.nih.gov:6224/IEB/corelib/cpp/config.html#ref_Wrappers"> Reference Manual</a>.
Each of these wrappers performs some pre-initialization for the tools and flags used in the <i>configure</i>
script before running it. The compiler-specific wrappers are in the 
<a href="http://ray.nlm.nih.gov:6224/intranet/ieb/CPP/lxr/http/source/compilers/">
<i>c++/compilers</i></a> directory.

The <i>configure</i> script serves two very different types of function: (1) it tests the
selected compiler and environment for a multitude of features and generates <i>#include</i> and
<i>#define</i> statements accordingly, and (2) it reads the <i>Makefile.in</i> files in the <i>src</i>
directories and creates the corresponding <i>build</i> subtrees and makefiles accordingly. <p>

Frequently during development it is necessary to make minor adjustments to the <i>Makefile.in</i> files,
such as adding new projects or subprojects to the list of targets. In these contexts
however, the compiler, environment, and source directory structures remain unchanged, and 
<i>configure</i> is actually doing more work than is necessary. In fact, there is even some risk of 
failing to recreate the same configuration environment if the user does not exactly duplicate the
same set of configure flags when re-running <i>configure</i>. In these situations it is preferable
to run an auxilliary script named <a href="../config.html#ref_Reconf"><i>config.status</i></a>, located
at the top level of the <i>build</i> directory in a subdirectory named <i>status</i>. 
<p>
In contrast, changes to the <i>src</i> directory structure, or the addition/deletion of 
<i>Makefile.in</i> files, all require re-running the <i>configure</i> script, as these actions require
the creation/deletion of subdirectories in the <i>build</i> tree and/or the creation/deletion of the 
associated <i>Makefile</i> in those directories.

<p>

</body>
<a href="sub_tree.html"> <i> previous </i> </a>
&nbsp;&nbsp;&nbsp;
<a href="../index.html"> <i> up </i> </a>
</html>


	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:zimmerma@ncbi.nlm.nih.gov">Diane Zimmerman</a></address></td>
		  <!-- <td align=center><i>$Revision$</i></td> -->
		  <td align=right><i>$Date$</i></td>
	 </table>

