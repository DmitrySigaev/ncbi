<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Starting new C++ project</title>
  </head>

  <body>
	 <h1>Starting new C++ project</h1>

	 <ul>
		<li> <a href="#ref_Checkout">
		  Retrieve NCBI C++ source tree from CVS</a>
		<li> <a href="#ref_Structure">
		  CVS tree structure of NCBI C++ projects</a>
		<li> <a href="#ref_Create">
		  Adding CVS directory for a new C++ project</a>
		<li> <a href="#ref_Makefile">
		  Project makefiles and sub-projects</a>
	 <ul>
		<li> <a href="#ref_MakeMeta">
		  <i>Meta-makefiles</i> (to provide multiple and/or recursive builds)</a>
		<li> <a href="#ref_MakeProj">
		  Project makefiles (to build a particular library or application)</a>
	   <ul>
		  <li> <a href="#ref_MakeProjMk">
		    "Configure"-made tools and flags for the whole build tree</a>
		  <li> <a href="#ref_MakeProjLib">
		    Customized makefile to build a  library</a>
		  <li> <a href="#ref_MakeProjApp">
		    Customized makefile to build an application</a>
		  <li> <a href="#ref_MakeProjTarget">
		    Standard build targets(<b>all, clean, purge</b>)
		    in the customized makefiles</a>
	 </ul> </ul>
	 <li> <a href="mkfiles.html">
		A real-life example of the NCBI C++ makefile hierarchy
		(project <i>"corelib/"</i>)</a>
  </ul>

	 <br></br>
	 <a name="ref_Checkout">
	 <h2>Retrieve NCBI C++ source tree from CVS</h2></a>

	 <p>
	 To checkout the whole NCBI C++ source tree from CVS to you local
	 directory(e.g. <b><i>foo/c++/</i></b>) use:
<pre>
cd foo
cvs checkout -d c++ internal/c++
</pre>

	 For the detailed info on CVS see
	 <a href="http://www.cs.utah.edu/csinfo/texinfo/cvs/cvs_toc.html">
		CVS online manual</a> or run commands <i>"man cvs"</i> or <i>"cvs -H"</i> on
	 your workstation.


	 <br></br>
	 <a name="ref_Structure">
	 <h2>CVS tree structure of NCBI C++ projects</h2></a>

	 <p>
	 (For the overall NCBI C++ CVS tree structure see in
	 <a href="config.html#ref_Source">NCBI C++ source code repository</a>.)

	 <p>
	 The standard CVS location for NCBI C++/STL projects is
	 <i><b>"$CVSROOT/internal/c++/"</b></i>. Public header files
	 (<i>*.hpp, *.inl</i>) of all projects are located below
	 the <i><b>"$CVSROOT/internal/c++/include/"</b></i> directory.
	 <i><b>"$CVSROOT/internal/c++/src/"</b></i> directory has just the same
	 hierarchy of subdirectories as <i><b>".../include/"</b></i>, and its
	 very top level contains:

	 <ul>
		<li> Templates of generic makefiles (<b><i>Makefile.*.in</i></b>):
	 <ul>
	   <li> <b><i>Makefile.in</i></b> -- makefile to perform a recursive
		build in all project subdirectories
	   <li> <b><i>Makefile.meta.in</i></b> -- to be included to all makefiles
		that provide both local and recursive builds
	   <li> <b><i>Makefile.lib.in</i></b> -- to be included to all makefiles
		that perform a "standard" library build
	   <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serve as a template for the
		project <i>customized makefiles</i> (<b><i>Makefile.*.lib[.in]</i></b>) that perform
      a "standard" library build
	   <li> <b><i>Makefile.app.in</i></b> -- to be included to all makefiles
		that perform a "standard" application build
	   <li> <b><i>Makefile.lib.tmpl.in</i></b> -- serve as a template for the
		project <i>customized makefiles</i> (<b><i>Makefile.*.app[.in]</i></b>) that perform
      a "standard" application build
		<p>
	 </ul>
	 <li> Project directories, each contains:
	 <ul>
		<li> <b><i>*.cpp</i></b> -- project source files
		<li> <b><i>Makefile.*[.in]</i></b> -- library and application makefiles
		<li> <b><i>Makefile.*.lib[.in], Makefile.*.app[.in]</i></b> --
		<i>customized makefiles</i> to build a library or an application
		<li> <b><i>Makefile.in</i></b> -- a
		<a href="#ref_MakeMeta"><i>meta-makefile</i></a>
      that directs which local projects (described in <i>Makefile.*.in</i>)
      and sub-projects (located in the project subdirectories) must be built
		<li> sub-project directories (if any)
	 </ul> </ul>


	 <br></br>
	 <a name="ref_Create">
	 <h2>Adding source and include CVS directories for a new C++ project</h2></a>

	 <p>
	 To create your new project(e.g. "bar_proj") directories to the
	 NCBI C++ CVS tree(assuming that the whole NCBI C++ has been
	 <a href="#ref_Checkout">checked out</a>
	 to directory <b><i>foo/c++/</i></b>):

	 <pre>
cd foo/c++/include && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
cd foo/c++/src     && mkdir bar_proj && cvs add -m "Project Bar" bar_proj
	 </pre>

	 Now you can <a href="new_mod.html">add</a> and edit your project C++
	 files in there.

	 <p>
	 NOTE: remember to add this new project directory to <i>$(SUB_PROJ)</i>
	 list of the upper level <i>meta-makefile</i> <b><i>"Makefile.in"</i></b> template
	 (e.g., for this particular case, to <b><i>"foo/c++/src/Makefile.in"</i></b>).


	 <br></br> <br></br>
	 <a name="ref_Makefile">
	 <h2>Project makefiles and sub-projects</h2></a>

	 <a name="ref_MakeMeta">
	 <h3><i>Meta-makefiles (to provide multiple and/or recursive builds)</i></h3></a>

	 All projects from the NCBI C++ hierarchy are tied together with a
	 set of <i>meta-makefiles</i> that provide a uniform and easy way to perform
	 both local and recursive build. 

	 A typical <i>meta-makefile</i> template(e.g. "Makefile.in" in the
	 <b><i>foo/c++/src/bar_proj/</i></b> dir) looks like that:
<pre>
LIB_PROJ = bar_l1 bar_l2 ...  # Makefile.bar_l1.lib Makefile.bar_l1.lib ...
APP_PROJ = bar_a1 bar_l2 ...  # Makefile.bar_a1.app Makefile.bar_a1.app ...
USR_PROJ = bar_u1 bar_u2 ...  # Makefile.bar_u1 Makefile.bar_u1 ...
SUB_PROJ = app sub_proj1 sub_proj2

srcdir = @srcdir@
include @builddir@/Makefile.meta
</pre> 
	 The mandatory <i>"srcdir = @srcdir@ ; include @builddir@/Makefile.meta"</i>
	 provide the rules for the following standard targets:
	 <ul>
		<li> <a href="#ref_MakeProjTarget"><b>all</b></a>:
		<ul>
		  <li> build library(ies) using attributes defined in the
		  <i>customized makefiles</i> <b>Makefile.*.lib</b> with the suffixes
        enlisted in macro <b>LIB_PROJ</b>
		  <li> build application(s) using attributes defined in the
		  <i>customized makefiles</i> <b>Makefile.*.app</b> with the suffixes
        enlisted in macro <b>APP_PROJ</b>
		  <li> run <i>"make  -f {Makefile.*} all"</i> for the makefiles with
		  the suffixes enlisted in macro <b>USR_PROJ</b>:
	     <pre>
make -f Makefile.bar_u1 all
make -f Makefile.bar_u2 all
......
	     </pre>
      </ul>
	 <li> <a href="#ref_MakeProjTarget"><b>all_r</b></a> --
	 first do target <b>"all"</b>, then run <i>"make  all_r"</i>
	 in all subdirectories enlisted in <i>$(SUB_PROJ)</i>:
	 <pre>
cd bar_test       &&  make -f Makefile all_r
cd bar_sub_proj1  &&  make -f Makefile all_r
......
	 </pre>
	 <li> <a href="#ref_MakeProjTarget"><b>clean, clean_r</b></a> --
	 just the same, but with targets <b>"clean"</b> and <b>"clean_r"</b>, respectively
	 <li> <a href="#ref_MakeProjTarget"><b>purge, purge_r</b></a> --
	 just the same, but with targets <b>"purge"</b> and <b>"purge_r"</b>,
	 respectively
    </ul>


	 <a name="ref_MakeProj">
	 <h3><i>Project makefiles (to build a particular library or application)</i></h3></a>

	 Just like <b><i>"Makefile.meta.in"</i></b> template is used to ease and
	 standatize the writing of <i>meta-makefiles</i>, so there are templates
	 to help in the creation of "regular" project makefiles to build
	 a library or an application. These auxiliary template makefiles
	 are <b><i>"Makefile.mk.in"</i></b>, <b><i>"Makefile.lib.in"</i></b>,
	 <b><i>"Makefile.app.in"</i></b>, <b><i>"Makefile.lib.tmpl.in"</i></b> and
	 <b><i>"Makefile.app.tmpl.in"</i></b>. The <b><i>configure</i></b>'d versions of
    them are located in the very top of a <i>build tree</i>.

	 <a name="ref_MakeProjMk">
	 <h4><i>"Configure"-made tools and flags for the whole build tree</i></h4></a>

	 Usually, <b><i>"Makefile.mk"</i></b> must be included to the makefiles
    that build libraries and applications -- as it defines a set of
	 makefile macros to be used in the standard project build process:
	 <ul>
		<li> path to the tools (<b>CC, CXX, AR, RANLIB, LINK</b>, etc.)
		<li> set of compiler, linker, etc. flags
		(<b>CFLAGS, CXXFLAGS, LDFLAGS</b>, etc.)
		<li> path to the input (<b>top_srcdir, includedir</b>) and
		output (<b>libdir, bindir</b>, etc.) directories
		<li> command shell (<b>SHELL</b>), suffixes (<b>.SUFFIXES:</b>), etc.
	 </ul>

	 <a name="ref_MakeProjLib">
	 <h4><i>Customized makefile to build a library</i></h4></a>

	 Here is an example of a user makefile (enlisted in the <b>USR_PROJ</b>
	 macro of relevant <i>meta-makefile</i>). It uses
	 <b><i>"Makefile.mk"</i></b> and <b><i>"Makefile.lib"</i></b> templates to build
	 a library; it also illustrates how to alternate macro <b>CXXFLAGS</b>
	 originally defined in <b><i>"Makefile.mk"</i></b>:

	 <pre>
srcdir = @srcdir@
include @builddir@/Makefile.mk

LIB      = p1
OBJ      = p1_src1 p1_src2
CXXFLAGS = -g $(ORIG_CXXFLAGS) -D_DEBUG -DXYZ_P1_PROJECT

include @builddir@/Makefile.lib
	 </pre>

	 And this is an example of a <i>customized makefile</i> (enlisted in the
	 <b>LIB_PROJ</b> macro of relevant <i>meta-makefile</i>) doing just the same:

	 <pre>
LIB      = p1
OBJ      = p1_src1 p1_src2
CXXFLAGS = -g $(ORIG_CXXFLAGS) -D_DEBUG -DXYZ_P1_PROJECT
	 </pre>

	 <a name="ref_MakeProjApp">
	 <h4><i>Customized makefile to build an application</i></h4></a>

	 Here is an example of a user makefile (enlisted in the <b>USR_PROJ</b>
	 macro of relevant <i>meta-makefile</i>). It uses
	 <b><i>"Makefile.mk"</i></b> and <b><i>"Makefile.app"</i></b> templates to build
	 an application; it also illustrates how to alternate macro <b>CPPFLAGS</b>
	 originally defined in <b><i>"Makefile.mk"</i></b>:

	 <pre>
srcdir = @srcdir@
include @builddir@/Makefile.mk

APP = my_app
OBJ = my_main my_obj1 my_obj2
LIB = foo bar
CPPFLAGS = $(ORIG_CPPFLAGS) -DXYZ_MY_APP

include @builddir@/Makefile.app
	 </pre>

	 And this is an example of a <i>customized makefile</i> (enlisted in the
	 <b>APP_PROJ</b> macro of relevant <i>meta-makefile</i>) doing just the same:

	 <pre>
APP = my_app
OBJ = my_main my_obj1 my_obj2
LIB = foo bar
CPPFLAGS = $(ORIG_CPPFLAGS) -DXYZ_MY_APP
	 </pre>


	 <br></br>
	 <a name="ref_MakeProjTarget">
	 <h2>Standard build targets(<b>all, clean, purge</b>)
		in the customized makefiles</h2></a>

	 <ul>
		<li> <b>all</b> -- compile object modules specified in the
		<i>"$(OBJ)"</i> macro, and use them to build library <i>"$(LIB)"</i> or
		application <i>"$(APP)"</i>;  then copy the resultant lib/app to the
		<b>libdir/ bindir</b> directory, respectively
		<li> <b>clean</b> -- remove all object modules and lib/app
		that have been built by <b>all</b>
		<li> <b>purge</b> -- do <b>clean</b>, and then remove the copy
		of lib/app from the <b>libdir/ bindir</b> directory, respectively
	 </ul>

	 The recursive targets <b>all_r, clean_r, purge_r</b> gets processed exactly like
	 <b>all, clean, purge</b>, with no recursion, etc. -- as the
    recursion and multiple build is entirely up to the
	 <a href="#ref_MakeMeta"><i>meta-makefiles</i></a>.


	 <br></br>
	 <hr>
	 <table border=0 width="100%" cellspacing=0>
		<tr>
		  <td><address><a href="mailto:vakatov@ncbi.nlm.nih.gov">Denis Vakatov</a></address></td>
		  <td align=right>($Revision$)</td></tr>
	 </table>
  </body>
</html>
