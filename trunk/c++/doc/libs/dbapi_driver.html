<!--#set var="TITLE" value="NCBI DBAPI Driver Reference" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->


<h1>NCBI DBAPI Driver Reference</h1>


<h2>Contents</h2>

<ul>
    <li> <a href="#ref_DriverOverview">Overview</a> </li>
    <li> <a href="#ref_DriverArch">The driver architecture</a> </li>
    <li> <a href="#ref_SampleProgram">Sample program</a> </li>
    <li> <a href="#ref_Topics">Topics</a> </li>
    <ul>
		<li> <a href="#ref_Errors">Error handling</a> </li>
		<li> <a href="#ref_Context">Driver context and connections</a> </li>
		<li> <a href="#ref_DrvManager">Driver Manager</a> </li>
		<li> <a href="#ref_TextImage">Text and Image Data Handling</a> </li>
		<li> <a href="#ref_Results">Results loop</a> </li>
    </ul>
	 <li><a href="#ref_Drivers">Supported DBAPI drivers</a>
		<ul>
		  <li> <a href="#ref_DriversCTLIB">Sybase CTLIB</a> </li>
		  <li> <a href="#ref_DriversDBLIB">Sybase DBLIB</a> </li>
		  <li> <a href="#ref_DriversMSDBLIB">Microsoft DBLIB</a> </li>
		  <li> <a href="#ref_DriversFTDS">FreeTDS</a> </li>
		  <li> <a href="#ref_DriversODBC">ODBC</a> </li>
		</ul>
	 </li>
</ul>


<p>
<hr>


<a name="ref_DriverOverview"></a>
<h2>
Overview</h2>
The
<a href="../libs.html#ref_TableDBAPI_DRIVER" class="ncbi_term">NCBI DBAPI driver library</a>
describes and implements a set of objects needed to provide a
uniform low-level access to the various relational database management
systems (RDBMS). The basic driver functionality is the same as in most
other RDBMS client APIs. It allows to open a connection to a server, execute
a command (query) on this connection and get the results back. The main
advantage of using the driver is that you don't have to change your own
upper-level code if you need to move from one RDBMS client API to another.
<p>The driver can use two different methods to access the particular RDBMS.
If RDBMS provides a client library for a given computer system (i.e. Sun/Solaris),
then driver utilizes this library. If there is no client library, then
driver connects to RDBMS through a special <span class="ncbi_term">gateway server</span> which
is running on a computer system where such library does exist.

<p>
<hr>


<a name="ref_DriverArch"></a>
<h2>
The driver architecture</h2>
There are two major groups of the driver's objects: the RDBMS independent
objects, and the objects which are specific to a particular RDBMS. The
only RDBMS specific object which user should be aware of is a "Driver Context".
The "Driver Context" is effectively a "Connection" factory. The only way
to make a connection to the server is to call the <span class="ncbi_func">Connect()</span> method
of a "Driver Context" object. So, before doing anything with RDBMS, you
need to create at least one driver context object. All driver contexts
implement the same interface defined in <a href="../docxx/I_DriverContext.html">I_DriverContext</a>
class. If you are working on a library which could be used with various
RDBMS it is a good idea do not create the driver context inside the library,
but take a pointer to
<a href="../lxr/ident?i=I_DriverContext&d=C">I_DriverContext</a>
instead.
<p>
There is no "real" factory for the driver contexts. The reason
for that is it's not always possible to statically link in the same binary the
RDBMS libraries from different vendors. Most of them are written in
C and the name collisions do exist. The
<a href="../lxr/ident?i=C_DriverMgr&d=C">Driver Manager</a> helps to overcome
this problem. It allowes to create a mixture of statically linked and dynamically loaded
drivers and use them together in one executable.
<p>The driver context creates the connection which is RDBMS specific, but
before returning it to the caller it puts it into an "envelope" of RDBMS independent
object <a href="../docxx/CDB_Connection.html">CDB_Connection</a>.
The same is true for the commands and for the results - user gets the pointer
to RDBMS independent "envelope object" instead of the real one. This is
a caller responsibility to delete those objects. The life spans of the
real object and the envelope one are not necessarily the same.
<p>Once you have got the connection object, you could use it as a factory
for the different types of commands. The command object in it's turn serves
as a factory for the results. The connection is always single threaded,
that means that you have to execute the commands and process their results
sequentially one by one. If you need to execute the several commands in
parallel, you can do it using multiple connections.
<p>Another important part of the driver is an error and message handling.
There are two different mechanisms implemented. The first one is exceptions.
All exceptions which could be thrown by the driver are inherited from the
single base class <a href="../docxx/CDB_Exception.html">CDB_Exception</a>.
Driver uses the exception mechanism whenever it's possible, but in many
cases the underlying client library uses the callbacks or handlers to report
the error messages and prevents from throwing the exceptions. The driver
supply a handler's stack mechanism to manage these cases.
<p>To send and to receive the data through the driver you have to use the
driver provided datatypes. The collection of the datatypes includes: <a href="../docxx/CDB_TinyInt.html">one</a>,
<a href="../docxx/CDB_SmallInt.html">two</a>,
<a href="../docxx/CDB_Int.html">four</a>
and <a href="../docxx/CDB_BigInt.html">eight</a>
		byte integers; <a href="../docxx/CDB_Float.html">float</a>
and <a href="../docxx/CDB_Double.html">double</a>;
<a href="../docxx/CDB_Numeric.html">numeric</a>;
<a href="../docxx/CDB_Char.html">char</a>,
<a href="../docxx/CDB_VarChar.html">varchar</a>,
<a href="../docxx/CDB_Binary.html">binary</a>,
<a href="../docxx/CDB_VarBinary.html">varbinary</a>;
<a href="../docxx/CDB_DateTime.html">datetime</a>
and <a href="../docxx/CDB_SmallDateTime.html">smalldatetime</a>;
<a href="../docxx/CDB_Text.html">text</a>
and <a href="../docxx/CDB_Image.html">image</a>.
All datatypes are derived from a single base class <a href="../docxx/CDB_Object.html">CDB_Object</a>.



<p>
<hr>



<a name="ref_SampleProgram"></a>
<h2>
Sample program</h2>
This program opens one connection to the server and selects the database
names and the date when each database was created (assuming that table
"sysdatabases" does exist). In this example the string "XXX" should be
replaced with the real driver name.

<pre class="ncbi_code">
#include &lt;iostream>
#include &lt;dbapi/driver/public.hpp>
#include &lt;dbapi/driver/exception.hpp>

/* Here, XXXlib has to be replaced with the real name, e.g. "ctlib" */
#include &lt;dbapi/driver/XXXlib/interfaces.hpp>


USING_NCBI_SCOPE;

int main()
{

    try { // to be sure that we are catching all driver related exceptions

        // We need to create a driver context first
        // In real program we have to replace CXXXContext with something real
        CXXXContext my_context;

        // connecting to server "MyServer"
        // with user name "my_user_name" and password "my_password"
        CDB_Connection* con = my_context.Connect("MyServer", "my_user_name",
                                                 "my_password", 0);

        // Preparing a SQL query
        CDB_LangCmd* lcmd =
            con->LangCmd("select name, crdate from sysdatabases");

        // Sending this query to a server
        lcmd->Send();

        CDB_Char dbname(64);
        CDB_DateTime crdate;

        // the result loop
        while(lcmd->HasMoreResults()) {
            CDB_Result* r= lcmd->Result();
            // skip all but row result
            if (r == 0  ||  r->ResultType() != eDB_RowResult) {
                delete r;
                continue;
            }

            // printing the names of selected columns
            cout &lt;&lt; r->ItemName(0) &lt;&lt; " \t\t\t"
                 &lt;&lt; r->ItemName(1) &lt;&lt; endl;

            // fetching the rows
            while ( r->Fetch() ) {
                r->GetItem(&amp;dbname); // get the database name
                r->GetItem(&amp;crdate); // get the creation date

                cout &lt;&lt; dbname.Value() &lt;&lt; ' '
                     &lt;&lt; crdate.Value().AsString("M/D/Y h:m")
                     &lt;&lt; endl;
            }
            delete r; // we don't need this result anymore
        }
        delete lcmd; // delete the command
        delete con;  // delete the connection
    }
    catch (CDB_Exception&amp; e) { // printing the error messages
        CDB_UserHandler_Stream myExHandler(&amp;cerr);

        myExHandler.HandleIt(&amp;e);
    }
}
</pre>



<p>
<hr>



<a name="ref_Topics"></a>
<h2>
Topics</h2>

<a name="ref_Errors"></a>
<h3>
Error handling</h3>
The error handling is almost always a pain when you are working with RDBMS.
The different systems implement the different approaches. You could get
the error messages through the return codes, callbacks, handlers and/or
exceptions. These messages could have a different formats. It could be
just integer (error code) or some structure or a set of callback's arguments.
The <span class="ncbi_term">NCBI DBAPI driver</span> intercepts all those error messages in all
different formats and converts them into the objects of
<a href="../docxx/CDB_Exception.html">CDB_Exception</a>
derived types. The following types are used:
<dl>
<dt>
<a href="../docxx/CDB_SqlEx.html">CDB_SQLEx</a></dt>

<dd>
This type is used if error message has come from a SQL server and indicates
an error in SQL query. It could be a wrong table or column name or just
a wrong syntax of SQL query. The message details could be obtained using
the following methods:</dd>

<ul>
<li>
<span class="ncbi_func">OriginatedFrom()</span> - returns a SQL server name</li>

<li>
<span class="ncbi_func">BatchLine()</span> - returns a line number in SQL batch which did generate an
error</li>

<li>
<span class="ncbi_func">Message()</span> - returns the error message itself</li>

<li>
<span class="ncbi_func">Severity()</span> - returns the severity of this message (assigned by SQL server)</li>

<li>
<span class="ncbi_func">ErrCode()</span> - returns the integer code for this message (assigned by SQL
server)</li>

<li>
<span class="ncbi_func">SqlState()</span> - returns a byte string describing an error (it's not useful
most of the time)</li>
</ul>

<dt>
<a href="../docxx/CDB_RPCEx.html">CDB_RPCEx</a></dt>

<dd>
An error message has come while RPC or stored procedure was executed on
a server. The methods to use:</dd>

<ul>
<li>
<span class="ncbi_func">OriginatedFrom()</span> - returns a server name</li>

<li>
<span class="ncbi_func">ProcName()</span> - returns a procedure name</li>

<li>
<span class="ncbi_func">ProcLine()</span> - returns a line number inside the procedure</li>

<li>
<span class="ncbi_func">Message()</span> - returns the error message itself</li>

<li>
<span class="ncbi_func">Severity()</span> - returns the severity of this message (assigned by a server)</li>

<li>
<span class="ncbi_func">ErrCode()</span> - returns the integer code for this message (assigned by a server)</li>
</ul>

<dt>
<a href="../docxx/CDB_DeadlockEx.html">CDB_DeadlockEx</a></dt>

<dd>
To report about deadlock. The methods to use:</dd>

<ul>
<li>
<span class="ncbi_func">OriginatedFrom()</span> - returns a SQL server name</li>

<li>
<span class="ncbi_func">Message()</span> - returns the error message itself</li>
</ul>

<dt>
<a href="../docxx/CDB_DSEx.html">CDB_DSEx</a></dt>

<dd>
Any error which has come from a RDBMS and is not a SQL query or RPC related.
The methods to use:</dd>

<ul>
<li>
<span class="ncbi_func">OriginatedFrom()</span> - returns a server name</li>

<li>
<span class="ncbi_func">Message()</span> - returns the error message itself</li>

<li>
<span class="ncbi_func">Severity()</span> - returns the severity of this message (assigned by a server)</li>

<li>
<span class="ncbi_func">ErrCode()</span> - returns the integer code for this message (assigned by a server)</li>
</ul>

<dt>
<a href="../docxx/CDB_TimeoutEx.html">CDB_TimeoutEx</a></dt>

<dd>
To report about timeout. The methods to use:</dd>

<ul>
<li>
<span class="ncbi_func">OriginatedFrom()</span> - returns a server name</li>

<li>
<span class="ncbi_func">Message()</span> - returns the error message itself</li>
</ul>

<dt>
<a href="../docxx/CDB_ClientEx.html">CDB_ClientEx</a></dt>

<dd>
Any client side error. The methods to use:</dd>

<ul>
<li>
<span class="ncbi_func">OriginatedFrom()</span> - returns the name of method or function which reports
the error</li>

<li>
<span class="ncbi_func">Message()</span> - returns the error message itself</li>

<li>
<span class="ncbi_func">Severity()</span> - returns the severity of this message</li>

<li>
<span class="ncbi_func">ErrCode()</span> - returns the integer code for this message</li>
</ul>
</dl>
Driver uses two ways to deliver the error message object to an application.
If it is possible to throw an exception, then driver throws the
error message object. If not, then driver calls the <a href="../docxx/CDB_UserHandler.html">user's
error handler</a> with a pointer to this object as an argument. It's not
always convenient to process all types of error messages in one error handler.
Some users may want to use a special error message handler inside some
function or block and a default error handler outside. To accommodate these
cases the driver provides a <a href="../lxr/ident?i=CDBHandlerStack&d=C">handler
stack mechanism</a>. The top handler in the stack gets the error message
object first. If it knows how to deal with this message, then it processes
the message and returns <span class="ncbi_value">true</span>. If handler wants to pass this message
to the other handlers, then it returns <span class="ncbi_value">false</span>. So, driver pushing
the error message object through the stack until it gets true from the
handler. The <a href="../docxx/CDB_UserHandler_Stream.html">default
driver's error handler</a> which just printout the error message to stderr
is always on a bottom of the stack. The another tool which user may want
to use for error handling is the <a href="../docxx/CDB_MultiEx.html">CDB_MultiEx</a>
objects. This tool allows to collect the multiple <a href="../docxx/CDB_Exception.html">CDB_Exception</a>
objects into one container and than <em>throw</em> this container as one
object.


<a name="ref_Context"></a>
<h3>
Driver context and connections</h3>
Every program which is going to work with <span class="ncbi_term">NCBI DBAPI driver</span> should
create at least one Driver Context object first. The main purpose of this
object is to be a Connection factory, but it's a good idea to customize
this object a little bit prior to open any connection. The first step is
to setup two message handler stacks. The first one is for error messages
which are not bound to some particular connection or could occur inside
the
<span class="ncbi_func">Connect()</span> method. Use <span class="ncbi_func">PushCntxMsgHandler()</span> to populate
it. The other stack serves as a initial message handler stack for all connections
which will be derived from this context. Use <span class="ncbi_func">PushDefConnMsgHandler()</span>
method to populate this stack. The second step of customization is a time-outs
setting. The <span class="ncbi_func">SetLoginTimeout()</span> and <span class="ncbi_func">SetTimeout()</span> methods do
the job. If you are going to work with text or image objects in your program,
you need to call <span class="ncbi_func">SetMaxTextImageSize()</span> to define the maximal size
for such objects. Objects which exceed this limit could be truncated.

<pre class="ncbi_code">
class CMyHandlerForConnectionBoundErrors : public CDB_UserHandler
{
    virtual bool HandleIt(CDB_Exception* ex);
    ...
};

class CMyHandlerForOtherErrors : public CDB_UserHandler
{
    virtual bool HandleIt(CDB_Exception* ex);
    ...
};

...
int main()
{
    CMyHandlerForConnectionBoundErrors conn_handler;
    CMyHandlerForOtherErrors           other_handler;
    ...
    try { // to be sure that we are catching all driver related exceptions

        // We need to create a driver context first
        // In real program we have to replace CXXXContext with something real
        CXXXContext my_context;
        my_context.PushCntxMsgHandler(&amp;other_handler);
        my_context.PushDefConnMsgHandler(&amp;conn_handler);
        // set timeouts (in seconds) and size limits (in bytes):
        my_context.SetLoginTimeout(10); // for logins
        my_context.SetTimeout(15);      // for client/server communications
        my_context.SetMaxTextImageSize(0x7FFFFFFF); // text/image size limit
        ...
        CDB_Connection* my_con =
            my_context.Connect("MyServer", "my_user_name", "my_password",
                               I_DriverContext::fBcpIn);
        ...
    }
    catch (CDB_Exception&amp; e) {
        other_handler.HandleIt(&amp;e);
    }
}
</pre>

The only way to get a connection to a server in <span class="ncbi_term">NCBI DBAPI driver</span>
is through a <span class="ncbi_func">Connect()</span> method in <a href="../docxx/I_DriverContext.html">driver
context</a>. The first three arguments: server name, user name and password
are obvious. Values for <span class="ncbi_var">mode</span> are constructed by a bitwise-inclusive-OR
of flags defined in EConnectionMode. If <span class="ncbi_var">reusable</span> is <span class="ncbi_value">false</span>,
then driver creates a new connection which will be destroyed as soon as
user delete the correspondent <a href="../lxr/ident?i=CDB_Connection&d=C">CDB_Connection</a>
(the <span class="ncbi_var">pool_name</span> is ignored in this case).
<p>Opening a connection to a server is an expensive operation. If program
opens and closes connections to the same server multiple times it worth
to call the <span class="ncbi_func">Connect()</span> method with <span class="ncbi_var">reusable</span> set to <span class="ncbi_value">true</span>.
In this case driver does not close the connection when the correspondent
CDB_Connection is deleted, but keeps it around in a "recycle bin". Every
time an application calls the <span class="ncbi_func">Connect()</span> method with <span class="ncbi_var">reusable</span>
set to <span class="ncbi_value">true</span>, driver tries to satisfy the request from a "recycle
bin" first and opens a new connection only if it is necessary.
<p>The <span class="ncbi_var">pool_name</span> argument is just an arbitrary string. Application
could use this argument to assign a name to one or more connections (to
create a connection pool) or to invoke a connection by name from this pool.

<pre class="ncbi_code">
    ...
    // Create a pool of four connections (two to one server and two to another)
    // with the default database "DatabaseA"
    CDB_Connection* con[4];
    int i;
    for (i = 4;  i--; ) {
        con[i]= my_context.Connect((i%2 == 0) ? "MyServer1" : "MyServer2",
                                   "my_user_name", "my_password", 0, true,
                                   "ConnectionPoolA");
        CDB_LangCmd* lcmd= con[i]->LangCmd("use DatabaseA");
        lcmd->Send();
        while(lcmd->HasMoreResults()) {
            CDB_Result* r = lcmd->Result();
            delete r;
        }
        delete lcmd;
    }
    // return all connections to a "recycle bin"
    for(i= 0; i &lt; 4; delete con_array[i++]);
    ...

    // in some other part of the program
    // we want to get a connection from "ConnectionPoolA"
    // but we don't want driver to open a new connection if pool is empty
    try {
        CDB_Connection* my_con= my_context.Connect("", "", "", 0, true,
                                                   "ConnectionPoolA");
        // Note that server name, user name and password are empty
        ...
    }
    catch (CDB_Exception&amp; e) {
        // the pool is empty
        ...
    }
</pre>

Application could combine in one pool the connections to the different
servers. This mechanism could also be used to group together the connections
with some particular settings (default database, transaction isolation
level, etc.).

<a name="ref_DrvManager"></a>
<h3>
Driver Manager</h3>
It's not always known upfront which <span class="ncbi_term">NCBI DBAPI driver</span> will be used in
some particular program. Sometimes you want a driver to be a parameter in your
program. Sometimes you need to use two different drivers in one binary but can not
link them statically because of name collisions. Sometimes you just need the driver
contexts factory. The
<a href="../lxr/ident?i=C_DriverMgr&d=C">Driver Manager</a> is intended
to solve these problems.
<p>Let's rewrite our <a href="#ref_SampleProgram">Sample program</a> using the
<span class="ncbi_term">Driver Manager</span>. The original text was.
<pre class="ncbi_code">
#include &lt;iostream>
#include &lt;dbapi/driver/public.hpp>
#include &lt;dbapi/driver/exception.hpp>

/* Here, XXXlib has to be replaced with the real name, e.g. "ctlib" */
#include &lt;dbapi/driver/XXXlib/interfaces.hpp>


USING_NCBI_SCOPE;

int main()
{

    try { // to be sure that we are catching all driver related exceptions

        // We need to create a driver context first
        // In real program we have to replace CXXXContext with something real
        CXXXContext my_context;

        // connecting to server "MyServer"
        // with user name "my_user_name" and password "my_password"
        CDB_Connection* con = my_context.Connect("MyServer", "my_user_name",
                                                 "my_password", 0);
        ...
</pre>

If we use the <span class="ncbi_term">Driver Manager</span> we could allow the driver name to be a program argument.

<pre class="ncbi_code">
#include &lt;iostream>
#include &lt;dbapi/driver/public.hpp>
#include &lt;dbapi/driver/exception.hpp>
#include &lt;dbapi/driver/driver_mgr.hpp> // this is a new header


USING_NCBI_SCOPE;

int main(int argc, const char* argv[])
{
    try { // to be sure that we are catching all driver related exceptions
        C_DriverMgr drv_mgr;
        // We need to create a driver context first
        I_DriverContext* my_context= drv_mgr.GetDriverContext(
                                        (argc &gt; 1)? argv[1] : "ctlib");

        // connecting to server "MyServer"
        // with user name "my_user_name" and password "my_password"
        CDB_Connection* con = my_context-&gt;Connect("MyServer", "my_user_name",
                                                 "my_password", 0);
        ...
</pre>

This fragment creates an instance of <span class="ncbi_term">Driver Manager</span>, dynamically loads driver's library,
implicitly register this driver, creates the driver context and makes a connection to a server.
If you don't want to load some drivers dynamically for any reason, but want to use the <span class="ncbi_term">Driver Manager</span>
as a driver contexts factory, then you need to statically link your program with those libraries and
explicitly registered them using functions from <span class="ncbi_file">dbapi/driver/drivers.hpp</span> header.
<a name="ref_TextImage"></a>
<h3>Text and Image Data Handling</h3>
The <span class="ncbi_type">text</span> and <span class="ncbi_type">image</span> are SQL datatypes which can hold up to
2Gb of data. Because they could be huge, RDBMS keep these values separately
from the other data in the table. In most cases the table itself keeps
just a special pointer to a text/image value and an actual value occupies
a separate disk space. This implicates some difficulties in text/image
data handling.
<p>When you retrieves a large text/image value, you often prefer to "stream"
it into your program and process it chunk by chunk rather than get it as
one piece. Some RDBMS clients allow to stream the text/image values only
if a correspondent column is the only column in select statement.
<p>Let's suppose that you do have a table:
<br>table T (i_val int, t_val text)
<br>And you need to select all i_val, t_val where i_val > 0.
<br>The simplest way is to use a query:
<pre class="ncbi_code"><span class="ncbi_keyword">select</span> i_val, t_val <span class="ncbi_keyword">from</span> T <span class="ncbi_keyword">where</span> i_val > 0</pre>
But it could be expensive. Because two columns are selected, some clients
will put the whole row in a buffer prior to give the access to it to the
user. The better way to do this is to use two selects:
<pre class="ncbi_code"><span class="ncbi_keyword">select</span> i_val <span class="ncbi_keyword">from</span> T <span class="ncbi_keyword">where</span> i_val > 0
<span class="ncbi_keyword">select</span> t_val <span class="ncbi_keyword">from</span> T <span class="ncbi_keyword">where</span> i_val > 0</pre>
Looks ugly, but could save you a lot of memory.
<p>Updating and inserting the text/image data is also not a straightforward
process. For small texts and images it is possible to use just SQL <span class="ncbi_keyword">insert</span>
and <span class="ncbi_keyword">update</span> statements, but it will be inefficient (if possible at
all) for the large ones. The better ways to insert and to update the texts
and images is to use <span class="ncbi_func">SendData()</span> method of <a href="../lxr/ident?i=CDB_Connection&d=C">CDB_Connection</a>
object or to use the
<a href="../lxr/ident?i=CDB_SendDataCmd&d=C">CDB_SendDataCmd</a>
object.
<p>Recommended algorithm for inserting the text/image data:
<ul>
<li>
Using a SQL <span class="ncbi_keyword">insert</span> statement insert a new row into a table. Use
<span class="ncbi_value">""</span> value for each <span class="ncbi_type">text</span> column (<span class="ncbi_value">0x0</span> for <span class="ncbi_term">image</span>
column) you are going to populate. Use <span class="ncbi_value">NULL</span> only if this value is
going to remain <span class="ncbi_value">NULL</span>.</li>

<li>
Using a SQL <span class="ncbi_keyword">select</span> statement select all text/image columns from
this row.</li>

<li>
Fetch the row result and get a I_ITDescriptor for each column</li>

<li>
Finish the results loop</li>

<li>
Use <span class="ncbi_func">SendData()</span> method or <a href="../docxx/CDB_SendDataCmd.html">CDB_SendDataCmd</a>
object to populate the columns.</li>
</ul>
<span class="ncbi_note">Example</span>
<p>Let's suppose that we want to insert a new row into table T described
above.
<pre class="ncbi_code">
CDB_Connection* con;
...
// preparing the query
CDB_LangCmd* lcmd= con->LangCmd("insert T (i_val, t_val) values(100, ' ')\n");
lcmd->More("select t_val from T where i_val = 100");

// Sending this query to a server
lcmd->Send();

I_ITDescriptor* my_descr;

// the result loop
while(lcmd->HasMoreResults()) {
    CDB_Result* r= lcmd->Result();
    // skip all but row result
    if (r == 0  ||  r->ResultType() != eDB_RowResult) {
        delete r;
        continue;
    }
    // fetching the row
    while(r->Fetch()) {
        // read 0 bytes from the text (some clients need this trick)
        r->ReadItem(0, 0);

        my_deskr = r->GetImageOrTextDescriptor();
    }
    delete r; // we don't need this result anymore
}

delete lcmd; // delete the command

CDB_Text my_text;
my_text.Append("This is a text I want to insert");

//sending the text
con->SendData(my_descr, my_text);

delete my_descr; // we don't need this descriptor anymore
...
</pre>

Recommended algorithm for updating the text/image data:
<ul>
<li>
Using a SQL <span class="ncbi_keyword">update</span> statement replace the current value with <span class="ncbi_value">""</span> for text column (<span class="ncbi_value">0x0</span> for image)</li>

<li>
Using a SQL <span class="ncbi_keyword">select</span> statement select all text/image columns you want
to update in this row.</li>

<li>
Fetch the row result and get a I_ITDescriptor for each column</li>

<li>
Finish the results loop</li>

<li>
Use <span class="ncbi_func">SendData()</span> method or <a href="../docxx/CDB_SendDataCmd.html">CDB_SendDataCmd</a>
object to populate the columns.</li>
</ul>
<span class="ncbi_note">Example</span>
<pre class="ncbi_code">
CDB_Connection* con;
...
// preparing the query
CDB_LangCmd* lcmd= con->LangCmd("update T set t_val= ' ' where i_val =  100");
lcmd->More("select t_val from T where i_val = 100");

// Sending this query to a server
lcmd->Send();

I_ITDescriptor* my_descr;

// the result loop
while(lcmd->HasMoreResults()) {
    CDB_Result* r= lcmd->Result();
    // skip all but row result
    if (r == 0  ||  r->ResultType() != eDB_RowResult) {
        delete r;
        continue;
    }
    // fetching the row
    while(r->Fetch()) {
        // read 0 bytes from the text (some clients need this trick)
        r->ReadItem(0, 0);

        my_deskr = r->GetImageOrTextDescriptor();
    }
    delete r; // we don't need this result anymore
}

delete lcmd; // delete the command

CDB_Text my_text;
my_text.Append("This is a text I want to see as an update");

//sending the text
con->SendData(my_descr, my_text);

delete my_descr; // we don't need this descriptor anymore
...
</pre>


<a name="ref_Results"></a>
<h3>
Results loop</h3>
The connection in <span class="ncbi_term">NCBI DBAPI driver</span> is always single threaded.
Application has to retrieve all results from a current command prior to executing a new one.
Not all of the results are always meaningful for the application (i.e. an RPC always
returns a status result regardles of either a procedure has a "<em>return</em> something" statement or not),
but all of them need to be retrieved. The following results loop is recommended for all types of the commands:
<pre class="ncbi_code">
CDB_XXXCmd* cmd; // XXX could be Lang, RPC, etc.
...
while (cmd-&gt;HasMoreResults()) {
        // HasMoreResults() method returns <span class="ncbi_value">true</span>
        // if the Result() method needs to be called.
        // It doesn't guarantee that Result() will return not NULL result

   CDB_Result* res = cmd-&gt;Result();
   if (res == 0)
       continue; // a NULL res doesn't mean that there is no more results

   switch(res-&gt;ResultType()) {
      case eDB_RowResult: // row result
          while(res-&gt;Fetch()) {
             ...
          }
          break;
      case eDB_ParamResult: // Output parameters
          while(res-&gt;Fetch()) {
             ...
          }
          break;
      case eDB_ComputeResult: // Compute result
          while(res-&gt;Fetch()) {
             ...
          }
          break;
      case eDB_StatusResult: // Status result
          while(res-&gt;Fetch()) {
             ...
          }
          break;
      case eDB_CursorResult: // Cursor result
          while(res-&gt;Fetch()) {
             ...
          }
          break;
   }
   delete res;
}
</pre>

If you don't want to process some particular type of result, just skip the <span class="ncbi_ccode">while (res-&gt;Fetch()){...}</span>
in the corresponding <span class="ncbi_keyword">case</span>.

<!-- --------------------------------- -->

<p>
<hr>
<a name="ref_Drivers"></a>
<h2>
Supported DBAPI drivers</h2>

<ul>
    <li> <a href="#ref_DriversCTLIB">Sybase CTLIB</a> </li>
    <li> <a href="#ref_DriversDBLIB">Sybase DBLIB</a> </li>
    <li> <a href="#ref_DriversMSDBLIB">Microsoft DBLIB</a> </li>
    <li> <a href="#ref_DriversFTDS">FreeTDS</a> </li>
    <li> <a href="#ref_DriversODBC">ODBC</a> </li>
</ul>

<p>

<!-- --------------------------------- -->

<a name="ref_DriversCTLIB"></a>
<h4>
Sybase CTLIB</h4>
<p>

<ul>

<li>
Registration function (for the manual, static registration)
<dt><dd>
<a href="../lxr/ident?i=DBAPI_RegisterDriver_CTLIB&d=f" class="ncbi_func">DBAPI_RegisterDriver_CTLIB()</a>
</dd>
</dt></li>

<li>
Driver default name (for the run-time loading from a DLL)
<dt><dd><span class="ncbi_value">"ctlib"</span></dd>
</dt></li>

<li>
Driver library
<dt><dd><span class="ncbi_lib">
dbapi_driver_ctlib
</span></dd>
</dt></li>

<li>
<span class="ncbi_term">Sybase CTLIB</span> libraries and headers used by the driver (UNIX)
<dt><dd><a href="../config.html#ref_Localization" class="ncbi_env">$(SYBASE_LIBS)</a>
</dd>
<dd>
<a href="../config.html#ref_Localization" class="ncbi_env">$(SYBASE_INCLUDE)</a></dd>
</dt></li>

<li>
<span class="ncbi_term">Sybase CTLIB</span> libraries and headers used by the driver (MS Windows)
<dt>
<dd>
You will need Sybase OpenClient package installed on your PC.
</dd>
<dd>
Libraries: LIBCT.LIB LIBCS.LIB LIBBLK.LIB
</dd>
<dd>
In MSVC++, go to <span class="ncbi_menu">"Tools" / "Options..." / "Directories"</span>
and set up the path to Sybase OpenClient libraries and headers
(for example "C:\Sybase\lib" and "C:\Sybase\include" respectively)
</dd>
</dt></li>

<li>
CTLIB-specific header (contains <span class="ncbi_term">non-portable</span> extensions)
<dt><dd>
<a href="../lxr/source/include/dbapi/driver/ctlib/interfaces.hpp" class="ncbi_file">dbapi/driver/ctlib/interfaces.hpp</a>
</dd>
</dt></li>

<li>
CTLIB-specific driver context attributes
<dt>
<dd>
"reuse_context", default = <span class="ncbi_value">"true"</span>
</dd>
<dd>
"version", default = <span class="ncbi_value">"110"</span> (also allowed: <span class="ncbi_value">"100"</span>)
</dd>
</dt>
</li>

<li>
Caveats
<ol>
<li>
Cannot communicate with MS SQL server using any TDS version.
</li>
</ol>
</li>

</ul>




<!-- --------------------------------- -->

<a name="ref_DriversDBLIB"></a>
<h4>
Sybase DBLIB</h4>
<p>

<ul>

<li>
Registration function (for the manual, static registration)
<dt><dd><a href="../lxr/ident?i=DBAPI_RegisterDriver_DBLIB&d=f" class="ncbi_func">DBAPI_RegisterDriver_DBLIB()</a></dd>
</dt></li>

<li>
Driver default name (for the run-time loading from a DLL)
<dt><dd><span class="ncbi_value">"dblib"</span></dd>
</dt></li>

<li>
Driver library
<dt><dd><span class="ncbi_lib">
dbapi_driver_dblib
</span></dd>
</dt></li>

<li>
<span class="ncbi_term">Sybase DBLIB</span> libraries and headers used by the driver (UNIX)
<dt><dd>
<a href="../config.html#ref_Localization" class="ncbi_env">$(SYBASE_DBLIBS)</a>
</dd>
<dd>
<a href="../config.html#ref_Localization" class="ncbi_env">$(SYBASE_INCLUDE)</a>
</dd>
</dt></li>

<li>
<span class="ncbi_term">Sybase DBLIB</span> libraries and headers used by the driver (MS Windows)
<dt>
<dd>
You will need Sybase OpenClient package installed on your PC.
</dd>
<dd>
Libraries: LIBSYBDB.LIB
</dd>
<dd>
In MSVC++, go to <span class="ncbi_menu">"Tools" / "Options..." / "Directories"</span>
and set up the path to Sybase OpenClient libraries and headers
(for example "C:\Sybase\lib" and "C:\Sybase\include" respectively)
</dd>
</dt></li>

<li>
DBLIB-specific header (contains <span class="ncbi_term">non-portable</span> extensions)
<dt><dd>
<a href="../lxr/source/include/dbapi/driver/dblib/interfaces.hpp" class="ncbi_file">
dbapi/driver/dblib/interfaces.hpp</a>
</dd>
</dt></li>

<li>
DBLIB-specific driver context attributes
<dt><dd>
"version", default = <span class="ncbi_value">"46"</span>
(also allowed: <span class="ncbi_value">"100"</span>)
</dd>
</dt></li>

<li>
Caveats
<ol>
<li>
Text/image operations fail when working with MS SQL server,
because MS SQL server sends text/image length in the reverse byte order,
and this cannot be fixed (as it was fixed for
<a href="#ref_DriversFTDS">FreeTDS</a>
) as we do not have access to the DBLIB source code.
</dd>
<li>
DB Library version level <span class="ncbi_value">"100"</span> is recommended for communication with Sybase
server 12.5, because the default version level (<span class="ncbi_value">"46"</span>)
is not working correctly with this server.
</dd>
</ol></li>

</ul>



<!-- --------------------------------- -->

<a name="ref_DriversMSDBLIB"></a>
<h4>
Microsoft DBLIB</h4>
<p>

<ul>

<li>
Registration function (for the manual, static registration)
<dt><dd><a href="../lxr/ident?i=DBAPI_RegisterDriver_MSDBLIB&d=f" class="ncbi_func">DBAPI_RegisterDriver_MSDBLIB()</a>
</dd>
</dt></li>

<li>
Driver default name (for the run-time loading from a DLL)
<dt><dd><span class="ncbi_lib">
"msdblib"
</span></dd>
</dt></li>

<li>
Driver library
<dt><dd><span class="ncbi_lib">
dbapi_driver_msdblib
</span></dd>
</dt></li>

<li>
<span class="ncbi_term">Microsoft DBLIB</span> libraries and headers used by the driver
<dt><dd><span class="ncbi_lib">
NTWDBLIB.LIB
</span></dd>
</dt></li>

<li>
<span class="ncbi_term">Microsoft DBLIB</span>-specific header (contains <span class="ncbi_term">non-portable</span> extensions)
<dt><dd>
<a href="../lxr/source/include/dbapi/driver/msdblib/interfaces.hpp" class="ncbi_file">
dbapi/driver/msdblib/interfaces.hpp</a>
</dd>
</dt></li>

<li>
<span class="ncbi_term">Microsoft DBLIB</span>-specific driver context attributes
<dt><dd>
NONE
</dd>
</dt></li>

<li>
Caveats
<ol>
<li>
On the lower level, the reading of a blob (image or text) cannot be
performed in a pure stream-wise fashion, and therefore the whole blob
has to be read in advance. Actually all contents of all columns get
read up completely as soon as the row is fetched(!).
Although this is hidden from the user code,
however it theoretically can cause memory exhaustion and at least some
performance overhead if the blob is too big.
</dd>
</ol></li>

</ul>




<!-- --------------------------------- -->

<a name="ref_DriversFTDS"></a>
<h4>
FreeTDS</h4>
<p>

<ul>

<li>
Registration function (for the manual, static registration)
<dt><dd>
<a href="../lxr/ident?i=DBAPI_RegisterDriver_FTDS&d=f" class="ncbi_func">
DBAPI_RegisterDriver_FTDS()</a>
</dd>
</dt></li>

<li>
Driver default name (for the run-time loading from a DLL)
<dt><dd><span class="ncbi_lib">
"ftds"
</span></dd>
</dt></li>

<li>
Driver library
<dt><dd><span class="ncbi_lib">
dbapi_driver_ftds
</span></dd>
</dt></li>

<li>
<span class="ncbi_term">FreeTDS</span> libraries and headers used by the driver
<dt><dd>
<a href="../config.html#ref_Localization" class="ncbi_env">
$(FTDS_LIBS)</a>
</dd>
<dd>
<a href="../config.html#ref_Localization" class="ncbi_env">
$(FTDS_INCLUDE)</a>
</dd>
</dt></li>

<li>
<span class="ncbi_term">FreeTDS</span>-specific header (contains <span class="ncbi_term">non-portable</span> extensions)
<dt><dd>
<a href="../lxr/source/include/dbapi/driver/ftds/interfaces.hpp"class="ncbi_file" >
dbapi/driver/ftds/interfaces.hpp</a>
</dd>
</dt></li>

<li>
<span class="ncbi_term">FreeTDS</span>-specific driver context attributes
<dt><dd>
"version", default = <span class="ncbi_value">&lt;DBVERSION_UNKNOWN&gt;</span>
(also allowed: <span class="ncbi_value">"42"</span>, <span class="ncbi_value">"46"</span>, <b>"70"</b>, <b>"100"</b>)
</dd>
</dt></li>

<li>
Caveats
<ol>
<li>
Nobody has ever tried working with any TDS version but the default
(&lt;DBVERSION_UNKNOWN&gt;) one.
</dd>
<li>
Although a slightly modified version of FreeTDS is now part of the
public toolkit, it retains its own license:
the <a href="../lxr/source/src/dbapi/driver/ftds/freetds/doc/COPYING.LIB">
GNU Library General Public License</a>.
</dd>
<li>
The "compute results" functionality (like from SELECT ... AVERAGE ...)
does not work because current FreeTDS implementation cannot decipher
the "compute results" specific result set returned by server.
</dd>
<li>
RPC is implemened via a language call, so it will work only if
the OpenServer it is communicating with has language handler installed
(and it is not installed on some NCBI OpenServers!).
</dd>
<li>
The FreeTDS client library (the one using TDS protocol version 7.0)
was tweaked to work with the MS SQL server and significantly optimized.
However, it will not work with Sybase server.
</dd>
<li>
Another, earlier non-tweaked version of FreeTDS client library
theoretically should be able to work with both MS SQL and SYBASE servers
(using TDS protocol version 4.2), however it was not thoroughly tested
and can be pretty slow.
</dd>
</ol></li>

</ul>

<!-- --------------------------------- -->

<a name="ref_DriversODBC"></a>
<h4>
ODBC</h4>
<p>

<ul>

<li>
Registration function (for the manual, static registration)
<dt><dd>
<a href="../lxr/ident?i=DBAPI_RegisterDriver_ODBC&d=f" class="ncbi_func">
DBAPI_RegisterDriver_ODBC()</a>
</dd>
</dt></li>

<li>
Driver default name (for the run-time loading from a DLL)
<dt><dd><span class="ncbi_value">
"odbc"
</span></dd>
</dt></li>

<li>
Driver library
<dt><dd><span class="ncbi_lib">
dbapi_driver_odbc
</span></dd>
</dt></li>

<li>
<span class="ncbi_term">ODBC</span> libraries and headers used by the driver
<dt><dd><span class="ncbi_lib">
ODBC32.LIB ODBCCP32.LIB ODBCBCP.LIB
</span></dd>
</dt></li>

<li>
<span class="ncbi_term">ODBC</span>-specific header (contains <span class="ncbi_term">non-portable</span> extensions)
<dt><dd>
<a href="../lxr/source/include/dbapi/driver/odbc/interfaces.hpp" class="ncbi_file">
dbapi/driver/odbc/interfaces.hpp</a>
</dd>
</dt></li>

<li>
<span class="ncbi_term">ODBC</span>-specific driver context attributes
<dt><dd>
"version", default = <span class="ncbi_value">"3"</span>
(also allowed: <span class="ncbi_value">"2"</span>)
</dd>
<dd>
"use_dsn", default = <span class="ncbi_value">"false"</span>
 (if you have set this attribute to <b>"true"</b>, you need to define your <span class="ncbi_term">data source</span> using
<span class="ncbi_menu">"Control Panel"/"Administrative Tools"/"Data Sources (ODBC)"</span>)
</dd>
</dt></li>

<li>
Caveats
<ol>
<li>
The <span class="ncbi_func">CDB_Result::GetImageOrTextDescriptor()</span> does not work for ODBC driver. You need to use
<a href="../lxr/ident?i=CDB_ITDescriptor&d=C">CDB_ITDescriptor</a> instead. The other way to deal
with <span class="ncbi_type">texts/images</span> in ODBC is through the <a href="../lxr/ident?i=CDB_CursorCmd&d=C">CDB_CursorCmd</a>
 methods: <span class="ncbi_func">UpdateTextImage</span> and <span class="ncbi_func">SendDataCmd</span>.

<li>
On most NCBI PCs, there is an old header <span class="ncbi_file">odbcss.h</span> (from 4/24/1998)
installed. The symptom is that although everything compiles just fine, however
in the linking stage there are dozens of unresolved symbol errors for ODBC
functions. Ask "pc.systems" to fix this for your PC.
</dd>
</ol></li>

</ul>


<!--#include virtual="../ssi/navlinks.shtml" -->

<table border=0 width="100%" cellspacing=0>
<tr>
<td align=left>
  <address><a href="mailto:cpp-core@ncbi.nlm.nih.gov">Vladimir Soussov, Denis Vakatov</a></address>
</td>
<!-- <td align=center><span class="ncbi_cvs_rev">$Revision$</span></td> -->
<td align=right><span class="ncbi_cvs_date">$Date$</span></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
