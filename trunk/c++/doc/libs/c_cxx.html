<!--#set var="TITLE" value="Using NCBI C and C++ Toolkits together" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1>Using NCBI C and C++ Toolkits together</h1>

<font size=1><u><b>Note</b></u>: Due to security issues, not all links in the public version
of this file could be accessible by outside NCBI users. Unrestricted version of this document is available to
inside NCBI users at:
<a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/libs/c_cxx.html">http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/libs/c_cxx.html</a>.
</font>

<h2>Contents</h2>

<ol>
<ul>
    <li> <a href="#ref_Overview">Overview</a>
    <li> <a href="#ref_SharedSources">Shared Sources</a>
    <ul>
         <li> <a href="#ref_ConnectLib"><tt>CONNECT</tt> Library</a>
         <li> <a href="#ref_ASN"><tt>ASN.1</tt> Specifications</a>
    </ul>
    <li> <a href="#ref_RunTimeResources>Run-Time Resources</a>
    <ul>
         <li> <a href="#ref_LOG"><tt>LOG</tt> and <tt>CNcbiDiag</tt></a>
         <li> <a href="#ref_REG"><tt>REG</tt> and <tt>CNcbiRegistry</tt></a>
         <li> <a href="#ref_LOCK"><tt>MT_LOCK</tt> and <tt>CRWLock</tt></a>
         <li> <a href="#ref_ConnectCxx"><tt>CONNECT</tt> Library in C++ Code</a>
         <ul>
              <li><a href="#ref_SettingLOG">Setting <tt>LOG</tt></a>
              <li><a href="#ref_SettingREG">Setting <tt>REG</tt></a>
              <li><a href="#ref_SettingLOCK">Setting MT-Locking</a>
         </ul>
         <li> <a href="#ref_CToolkitDiag">C Toolkit diagnostics redirection</a>
    </ul>
</ul>
</ol>

<p>
<hr>


<a name="ref_Overview"></a><h2>Overview</h2>

When using both C and C++ Toolkits together in a single application,
it is very important to understand that there are some resources shared between the two.
This document describes how to safely use both Toolkits together,
and how to gain from their cooperation.

<p>
<hr>


<a name="ref_SharedSources"></a><h2>Shared Sources</h2>

To maintain a sort of uniformity and ease in source code maintenance,
<tt>CONNECT</tt> library is the first library of both Toolkits kept
same at the source code level. To provide data interoperability,
<tt>ASN.1</tt> specifications have to be identical in both Toolkits, too.


<a name="ref_ConnectLib"></a><h3><tt>CONNECT</tt> Library</h3>

<a href="../lxr/source/src/connect"><tt>CONNECT</tt></a> library is at the moment the only part of C code
of both Toolkits, which is kept same in its entirety in both Toolkits.
The old API of <tt>CONNECT</tt> library is still supported by means of
simple wrapper code, which is situated in the C Toolkit only.
There is an external <a href="../lxr/source/scripts/internal/c_toolkit/check_sync.sh">safety script</a>,
which periodically (controlled by a <tt>cron</tt> daemon) checks and maintains source file indentity.
Conventionally, all development for <tt>CONNECT</tt> library is done within the C++ Toolkit tree.
When a modified source file is committed to the CVS repository
but is not yet updated in the C Toolkit tree, the safety script detects
the discrepancy, and then could be used to eliminate it by copying
the newer file over. If for some reason the modified version
is mistakenly checked into C Toolkit tree then the safety
script alerts the situation.

<p>
<hr>


<a name="ref_ASN"></a><h3><tt>ASN.1</tt> Specifications</h3>

On a contrary to <tt>CONNECT</tt> library, the <tt>ASN.1</tt> data
specifications are maintained within C Toolkit
source structure, and have to be copied over to C++ Toolkit
tree whenever they are changed. There is the same (as for <tt>CONNECT</tt> library)
<a href="../lxr/source/scripts/internal/c_toolkit/check_sync.sh">safety script</a>,
which keeps "an eye" on those changes, and sends an alert when C++ Toolkit <tt>ASN.1</tt>
specs go out of sync with their C Toolkit counterparts.

<p>
The full set of tools, which maintain identity of both <tt>CONNECT</tt> library and
<tt>ASN.1</tt> specifications can be found in directory
<a href="../lxr/source/scripts/internal/c_toolkit"><b><i>scripts/internal/c_toolkit</i></b></a>.

<p>
<hr>


<a name="ref_RunTimeResources"></a><h2>Run-Time Resources</h2>

Being written with an assumption to be used "as is" in the NCBI C Toolkit and
yet to be in the C++ Toolkit tree, <tt>CONNECT</tt> library could not
use directly all the utility objects offered by the C++ Toolkit such as
message logging <a href="../programming_manual/diag.html"><b><i>CNcbiDiag</i></b></a>,
registry <a href="../programming_manual/registry.html"><b><i>CNcbiRegistry</i></b></a>, and
MT-locks <a href="threads.html#crwlock"><b><i>CRWLock</i></b></a>.
All <a href="../lxr/source/include/connect/ncbi_core.h">these objects</a> were replaced
with helper objects coded entirely in C (as tables of function pointers and data).

<p>
On the other hand, throughout the code <tt>CONNECT</tt> library refers to
predefined objects <tt>CORE_LOG</tt> (so called <i>CORE C logger</i>)and <tt>CORE_REG</tt>
(<i>CORE C registry</i>), which in reality are never initialized by the library, i.e.
they are empty objects, which do nothing. It is an application's
resposibility to replace these dummies with real working
logger and registry. There are two approaches, one for C and another one for C++ application.

<p>
In a C program <a href="../lxr/source/include/connect/ncbi_util.h"><b><i>connect/ncbi_util.h</i></b></a>
module can be used with calls to <a href="../lxr/ident?i=CORE_SetREG"><b><i>CORE_SetREG()</i></b></a>,
<a href="../lxr/ident?i=CORE_SetLOG"><b><i>CORE_SetLOG()</i></b></a> can be used to set up the
logger and the registry, correspondingly. There are even more convenience routines concerning
<tt>CORE_LOG</tt>, like <a href="../lxr/ident?i=CORE_SetLOGFILE"><b><i>CORE_SetLOGFILE()</i></b></a>,
<a href="../lxr/ident?i=CORE_SetLOGFILE_NAME"><b><i>CORE_SetLOGFILE_NAME()</i></b></a>,
which facilitate redirecting logging messages to either a C stream (<tt>FILE*</tt>) or a named file.

<p>
In a C++ program, yet another additional step is necessary of converting <i>native</i> C++ objects
so that they could be used for both <tt>CORE_LOG</tt> and
<tt>CORE_REG</tt> by calls declared in
<a href="../lxr/source/include/connect/ncbi_core_cxx.hpp"><b><i>connect/ncbi_core_cxx.hpp</i></b></a>
as described later in this section.

<a name="ref_LOG"></a><h3><tt>LOG</tt> and <tt>CNcbiDiag</tt></h3>

<tt>CONNECT</tt> library has its own <a href="../lxr/ident?i=LOG">logger</a>, which
has to be set by any of routines declared in
<a href="../lxr/source/include/connect/ncbi_util.h"><b><i>connect/ncbi_util.h</i></b></a>:
<a href="../lxr/ident?i=CORE_SetLOG"><b><i>CORE_SetLOG()</i></b></a>,
<a href="../lxr/ident?i=CORE_SetLOGFILE"><b><i>CORE_SetLOGFILE()</i></b></a> etc.

On the other hand, the interface defined in
<a href="../lxr/source/include/connect/ncbi_core_cxx.hpp"><b><i>connect/ncbi_core_cxx.hpp</i></b></a>
provides the following C++ function to convert a logging stream of the NCBI C++ Toolkit into a <tt>LOG</tt> object:
<pre>
<tt>LOG</tt> <a href="../lxr/ident?i=LOG_cxx2c"><b><i>LOG_cxx2c</i></b></a>&nbsp;<tt>(void)</tt>
</pre>
which creates the <b><i>LOG</i></b> object on top of the corresponding C++ objects <b><i>CNcbiDiag</i></b>,
and then both C and C++ objects could be manipulated interchangeably, causing exactly the same effect on the underlying
logger. An example could be seen in the test program
<a href="../lxr/source/src/connect/test/test_ncbi_conn_stream.cpp"><tt>test_ncbi_conn_stream.cpp</tt></a>.
Then, the returned C handle <b><i>LOG</i></b> can be subsequently used as a <i>CORE</i> logger by means of
<b><i>CORE_SetLOG()</i></b>.

<p>
<hr>


<a name="ref_REG"></a><h3><tt>REG</tt> and <tt>CNcbiRegistry</tt></h3>

<a href="../lxr/source/include/connect/ncbi_core_cxx.hpp"><b><i>connect/ncbi_core_cxx.hpp</i></b></a>
declares the following C++ function to bind C <tt>REG</tt> object to <b><i>CNcbiRegistry</b></i>
used in C++ programs built with the use of the NCBI C++ Toolkit:
<pre>
<tt>REG</tt> <a href="../lxr/ident?i=REG_cxx2c"><b><i>REG_cxx2c</i></b></a>&nbsp;<tt>(CNcbiRegistry* reg, bool pass_ownership = false)</tt>
</pre>
<p>
Similarly to <i>CORE LOG</i> setting, the returned handle can be later used
with <a href="../lxr/ident?i=CORE_SetREG"><b><i>CORE_SetREG()</i></b></a>
declared in <a href="../lxr/source/include/connect/ncbi_util.h"><b><i>connect/ncbi_util.h</i></b></a>
to set up the global registry object (<i>CORE C registry</i>).

<p>
<hr>


<a name="ref_LOCK"></a><h3><tt>MT_LOCK</tt> and <tt>CRWLock</tt></h3>

There is a function
<pre>
<tt>MT_LOCK</tt> <a href="../lxr/ident?i=MT_LOCK_cxx2c"><b><i>MT_LOCK_cxx2c</i></b></a>&nbsp;<tt>(CRWLock* lock, bool pass_ownership = false)</tt>
</pre>
declared in <a href="../lxr/source/include/connect/ncbi_core_cxx.hpp"><b><i>connect/ncbi_core_cxx.hpp</i></b></a>,
which converts an object of class <b><i>CRWLock</i></b> into a C object <b><i>MT_LOCK</i></b>. The latter can
be used as an argument to <a href="../lxr/ident?i=CORE_SetLOCK"><b><i>CORE_SetLOCK()</i></b></a> for
setting the global CORE lock, used by a low level code, written in C. Note that passing 0 as the lock pointer
will effectively create a new internal <tt>CRWLock</tt> object, which will then be converted into <tt>MT_LOCK</tt> and
returned. This object is destroyed then the corresponding <tt>MT_LOCK</tt> is asked to do so.
If the pointer to <tt>CRWLock</tt> is passed non NULL then the second argument can specify whether
resulting <tt>MT_LOCK</tt> acquires the ownership of the lock, thus is able to delete the lock when destructing itself.

<p>
<hr>


<a name="ref_ConnectCxx"></a><h3><tt>CONNECT</tt> Library in C++ Code</h3>

There is <a href="../lxr/source/src/connect/test/test_ncbi_conn_stream.cpp">an example</a> of how to properly setup
<i>CORE logger</i> and <i>CORE ragistry</i> in order for them to use the same data both in C and C++ parts
of both the library and the remaining code of the application.

<p>
Another good source of information is a working application examples found in
<a href="../lxr/source/src/app/id1_fetch"><b><i>src/app/id1_fetch</i></b></a>.

<a name="ref_SettingLOG"></a><h4>Setting <tt>LOG</tt></h4>

To set up the <i>CORE C logger</i> to use the same logging format of messages and destination
as used by <b><i>CNcbiDiag</i></b>, the following sequence of calls may be used:
<pre>
    CORE_SetLOG(LOG_cxx2c());
    SetDiagTrace(eDT_Enable);
    SetDiagPostLevel(eDiag_Info);
    SetDiagPostFlag(eDPF_All);
</pre>

<p>
<hr>


<a name="ref_SettingREG"></a><h4>Setting <tt>REG</tt></h4>

To set the <i>CORE C registry</i> be the same as C++ registry <b><i>CNcbiRegistry</i></b>, the following
call is necessary:
<pre>
    CORE_SetREG(REG_cxx2c(cxxreg, true));
</pre>
here <tt>cxxreg</tt> is a <b><i>CNcbiRegistry</i></b> registry object created and maintained by C++ application.

<p>
<hr>


<a name="ref_SettingLOCK"></a><h4>Setting MT-Locking</h4>

To set up a CORE lock, which is used throughout the low level code, including places of
calls of non-reentrant library calls (if no reentrant counterparts were detected during
configure process), one can place the following statement close to the beginning of the
program:
<pre>
    CORE_SetLOCK(MT_LOCK_cxx2c());
</pre>

Note that the use of this call is extremely important in a multi-threaded environment.

<p>
<hr>


<a name="ref_CToolkitDiag"></a><h3>C Toolkit diagnostics redirection</h3>

In a C/C++ program linked against both NCBI C++ and NCBI C
Toolkits the diagnostics messages (if any) generated by either Toolkit are
not necessarily directed through same route, which may result in lost or garbled messages.
To set the diagnostics destination be the same as <b><i>CNcbiDiag</i></b>'s one, and
thus to guarantee that the messages from both Toolkits will be all stored sequentially and
in the order they were generated, there is a call
<pre>
#include &lt;<a href="../lxr/source/include/ctools/ctools.h">ctools/ctools.h</a>&gt;

void <a href="../lxr/ident?i=SetupCToolkitErrPost">SetupCToolkitErrPost</a>(void);
</pre>
which is put in a specially designated directory
<a href="../lxr/source/include/ctools"><b><i>ctools</i></b></a>
providing back links to the C Toolkit from the C++ Toolkit.

<p>
<hr>
<table border=0 width="100%" cellspacing=0>
<tr>
<td align=left>
  <address><a href="mailto:lavr@ncbi.nlm.nih.gov">Anton Lavrentiev</a></address>
</td>
<!-- <td align=center><i>$Revision$</i></td> -->
<td align=right><i>$Date$</i></td>
</tr>
</table>

<!--#include virtual="../ssi/footer.shtml" -->
