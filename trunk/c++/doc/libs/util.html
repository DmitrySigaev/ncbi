<!--#set var="TITLE" value="Util library" -->
<!--#set var="DOCROOT" value=".." -->
<!--#include virtual="../ssi/header.shtml" -->

<h1><a NAME="top"></a>Util library</h1>

<h2>Containers</h2>

<ul>
<li>
<a href="#CWeakMapKey">CWeakMapKey&lt;typename Object></a></li>

<li>
<a href="#CWeakMap">CWeakMap&lt;typename Object></a></li>

<li>
<a href="#CRange">CRange&lt;typename Coordinate = int></a></li>

<li>
<a href="#CRangeMap">CRangeMap&lt;typename Object, typename Coordinate
= int></a></li>

<li>
<a href="#CRangeMultiMap">CRangeMultimap&lt;typename Object, typename Coordinate
= int></a></li>

<li>
<a href="#CIntervalTree">CIntervalTree</a></li>
</ul>

<h2>I/O classes</h2>

<ul>
<li>
<a href="util_io.html#CIStreamBuffer">CIStreamBuffer</a></li>

<li>
<a href="util_io.html#COStreamBuffer">COStreamBuffer</a></li>

<li>
<a href="util_io.html#CByteSource">CByteSource</a></li>

<ul>
<li>
<a href="util_io.html#CStreamByteSource">CStreamByteSource</a></li>

<li>
<a href="util_io.html#CFStreamByteSource">CFStreamByteSource</a></li>

<li>
<a href="util_io.html#CFileByteSource">CFileByteSource</a></li>

<li>
<a href="util_io.html#CMemoryByteSource">CMemoryByteSource</a></li>
</ul>

<li>
<a href="util_io.html#CByteSourceReader">CByteSourceReader</a></li>

<ul>
<li>
CStreamByteSourceReader</li>

<li>
CFileByteSourceReader</li>

<li>
CSubFileByteSource</li>

<li>
CMemoryByteSourceReader</li>
</ul>

<li>
<a href="util_io.html#CSubSourceCollector">CSubSourceCollector</a></li>

<ul>
<li>
CMemorySourceCollector</li>

<li>
CFileSourceCollector</li>
</ul>
</ul>

<h2>Thread pools</h2>

<ul>
 <li><a href="#CBlockingQueue">CBlockingQueue&lt;typename TRequest></a></li>
 <li><a href="#CStdRequest">CStdRequest</a></li>
 <li><a href="#CThreadInPool">CThreadInPool&lt;typename TRequest></a>
  <ul><li><a href="#CStdThreadInPool">CStdThreadInPool</a></li></ul></li>
 <li><a href="#CPoolOfThreads">CPoolOfThreads&lt;typename TRequest></a>
  <ul><li><a href="#CStdPoolOfThreads">CStdPoolOfThreads</a></li></ul></li>
</ul>

<h2>Other classes</h2>

<ul>
<li>
<a href="#CLightString">CLightString</a></li>

<li>
<a href="#CChecksum">CChecksum</a></li>
</ul>
Exceptions
<ul>
<li>
CIOException</li>

<li>
CEofException</li>
</ul>

<p>&nbsp;</p>
<h1>
Container descriptions</h1>

<hr WIDTH="100%">
<h2>
<a NAME="CWeakMapKey"></a>template&lt;typename Object> class CWeakMapKey</h2>

<pre class="ncbi_code">    #include &lt;util/weakmap.hpp></pre>
This class is used in conjunction with <a href="#CWeakMap">CWeakMap</a>.
<br>
<hr WIDTH="100%">
<h2>
<a NAME="CWeakMap"></a>template&lt;typename Object> class CWeakMap</h2>

<pre class="ncbi_code">    #include &lt;util/weakmap.hpp></pre>
This class is used in conjunction with <a href="#CWeakMapKey">CWeakMapKey</a>.
<br>It is extension for regular maps with additional feature: it automatically
removes elements from map when corresponding key is destructed.
<br>Key is of type <a href="#CWeakMapKey">CWeakMapKey&lt;Object></a>.
<blockquote>
<pre class="ncbi_code">
//  Generic example of usage of these templates:
#include &lt;util/weakmap.hpp>

class CKey
{
public:
    CWeakMapKey&lt;string> m_MapKey;
};

void Test(void)
{
    // declare map object
    CWeakMap&lt;string> map;
    {
        // declare temporary key object
        CKey key;
        // insert string value
        map.insert(key.m_MapKey, "value");
        cout &lt;&lt; map.size();
        // == 1
        cout &lt;&lt; map.empty();
        // == false
    } // end of block: key object is destructed and map forgets about value
    cout &lt;&lt; map.size(); // == 0
    cout &lt;&lt; map.empty(); // == true
};
</pre>
</blockquote>

<h3>typedefs</h3>

<blockquote>
<pre class="ncbi_code">
key_type
mapped_type
value_type
iterator
const_iterator
</pre>

are the same as in standard C++ template map&lt;>.
</blockquote>

<h3>methods</h3>

<blockquote>
<pre class="ncbi_code">
size_t size() const;
bool empty() const;

const_iterator begin() const;
const_iterator end() const;
const_iterator find() const;

iterator begin();
iterator end();
iterator find();
</pre>

are the same as in standard C++ template map&lt;>.
</blockquote>

<blockquote>
<pre class="ncbi_code">
void insert(key_type&amp; key, const mapped_type&amp; value);
void erase(key_type&amp; key);</pre>

do the same as corresponding methods of standard C++ template
map&lt;>.
<br>They differ only in return type.
</blockquote>

<hr WIDTH="100%">
<h2>
<a NAME="CRange"></a>template&lt;typename Coordinate> class CRange</h2>
Class for storing information about some interval (from:to).
<br>From and to points are inclusive.
<br>&nbsp;
<h3>
typedefs</h3>

<blockquote>
<pre class="ncbi_code">position_type</pre>

synonym of Coordinate.
</blockquote>

<h3>
methods</h3>

<blockquote>
<pre class="ncbi_code">CRange();
CRange(position_type from, position_type to);</pre>

constructors

<pre class="ncbi_code">
static position_type GetEmptyFrom();
static position_type GetEmptyTo();
static position_type GetWholeFrom();
static position_type GetWholeTo();</pre>

get special coordinate values

<pre class="ncbi_code">
static CRange&lt;position_type> GetEmpty();
static CRange&lt;position_type> GetWhole();</pre>

get special interval objects

<pre class="ncbi_code">bool HaveEmptyBound() const;</pre>

check if any bound have special 'empty' value

<pre class="ncbi_code">bool HaveInfiniteBound() const;</pre>

check if any bound have special 'whole' value

<pre class="ncbi_code">bool Empty() const;</pre>

check if interval is empty (any bound have special 'empty'
value or left bound greater then right bound)

<pre class="ncbi_code">bool Regular() const;</pre>

check if interval's bounds are not special and length is positive

<pre class="ncbi_code">
position_type GetFrom() const;
position_type GetTo() const;
position_type GetLength() const;</pre>

get parameters of interval

<pre class="ncbi_code">
CRange&lt;position_type>&amp; SetFrom();
CRange&lt;position_type>&amp; SetTo();</pre>

set bounds of interval

<pre class="ncbi_code">CRange&lt;position_type>&amp; SetLength();</pre>

set length of interval leaving left bound (from) unchanged

<pre class="ncbi_code">CRange&lt;position_type>&amp; SetLengthDown();</pre>

set length of interval leaving right bound (to) unchanged

<pre class="ncbi_code">bool IntersectingWith(CRange&lt;position_type> range) const;</pre>

check if non empty intervals intersect

<pre class="ncbi_code">bool IntersectingWithPossiblyEmpty(CRange&lt;position_type> range) const;</pre>

check if intervals intersect
</blockquote>

<hr WIDTH="100%">
<h2>
<a NAME="CRangeMap"></a>template&lt;typename Object, typename Coordinate
= int> class CRangeMap</h2>
Class for storing and retrieving data using interval as key.
Also allows efficient iteration over intervals intersecting with specified
interval.
Time of iteration is proportional to amount of intervals produced by
iterator.
In some cases, algorithm is not so efficient and may slowdown.
<br>
<hr WIDTH="100%">
<h2>
<a NAME="CRangeMultiMap"></a>template&lt;typename Object, typename Coordinate
= int> class CRangeMultiMap</h2>
Almost the same as <a href="#CRangeMap">CRangeMap</a> but allows several
values have the same key interval.
<br>
<hr WIDTH="100%">
<h2>
<a NAME="CIntervalTree"></a>class CIntervalTree</h2>
Class with the same functionality as <a href="#CRangeMap">CRangeMap</a>
but using different algorithm.
It is faster and its speed is not affected by type of data but it uses
more memory (triple as <a href="#CRangeMap">CRangeMap</a>) and, as a result,
less efficient when amount of interval in set is quite big.
It uses about 140 bytes per interval for 64 bit program so you can
calculate if CIntervalTree is acceptable. For example, it becomes less
efficient than <a href="#CRangeMap">CRangeMap</a> when total memory becomes
greater than processor cache.
<br>

<hr WIDTH="100%">
<h1>
Thread pool descriptions</h1>
<hr WIDTH="100%">
<h2>
  <a name="CBlockingQueue"></a>template &lt;typename TRequest> class
  <a href="../lxr/ident?i=CBlockingQueue&d=C">CBlockingQueue</a>
</h2>
A blocking queue is a first-in-first-out container with the special
property that attempting to extract an element from an empty queue
blocks efficiently until more elements are available.  Thread pools
use this class internally to manage requests.
<hr WIDTH="100%">
<h2>
  <a name="CStdRequest"></a>class
  <a href="../lxr/ident?i=CStdRequest&d=C">CStdRequest</a>
</h2>
Abstract class, derived from <a href="../lxr/ident?i=CObject&d=C">CObject</a>,
encapsulating requests to a <a href="#CStdPoolOfThreads">CStdPoolOfThreads</a>.
The pure virtual method <span class="ncbi_func">void Process(void)</span> gets called when a
thread handles the request.
<hr WIDTH="100%">
<h2>
  <a name="CThreadInPool"></a>template &lt;typename TRequest> class
  <a href="../lxr/ident?i=CThreadInPool&d=C">CThreadInPool</a>
</h2>
Abstract class, derived from <a href="../lxr/ident?i=CThread&d=C">CThread</a>,
for the threads in a pool.  Three virtual methods control its behavior:
<blockquote>
<pre class="ncbi_code">
virtual void Init(void) {} // called at beginning of Main()

// Called from Main() for each request this thread handles
virtual void ProcessRequest(const TRequest& req) = 0;

virtual void x_OnExit(void) {} // called by OnExit()
</pre></blockquote>

<hr WIDTH="100%">
<h2>
  <a name="CStdThreadInPool"></a>class
  <a href="../lxr/ident?i=CStdThreadInPool&d=C">CStdThreadInPool</a>
</h2>
A specialization of <span class="ncbi_class">CThreadInPool</span> for CRef&lt;<a href="#CStdRequest">CStdRequest</a>>, which simply
processes each request by calling its <span class="ncbi_func">Process()</span> method.
<hr WIDTH="100%">
<h2>
  <a name="CPoolOfThreads"></a>template &lt;typename TRequest> class
  <a href="../lxr/ident?i=CPoolOfThreads&d=C">CPoolOfThreads</a>
</h2>
Abstract class for a pool of request-handling threads.  The
constructor takes three arguments: the maximum size of the pool, the
maximum size of the queue of pending requests, and an optional
threshold (compared to the difference between the number of unfinished
requests and the number of threads in the pool) indicating when to
create another thread automatically.  Due to some limitations of C++,
the constructor does not create any threads itself; you have to call
<span class="ncbi_func">Spawn()</span> for that.  In addition, <span class="ncbi_func">AcceptRequest()</span> passes
requests to the pool, and the protected pure virtual function
<span class="ncbi_func">NewThread()</span> creates the actual threads.
<hr WIDTH="100%">
<h2>
  <a name="CStdPoolOfThreads"></a>class
  <a href="../lxr/ident?i=CStdPoolOfThreads&d=C">CStdPoolOfThreads</a>
</h2>
A specialization of <span class="ncbi_class">CPoolOfThreads</span> for
CRef&lt;<a href="#CStdRequest">CStdRequest</a>>; its
<span class="ncbi_func">NewThread()</span> method creates objects of class <a
href="#CStdThreadInPool">CStdThreadInPool</a>.  It also introduces a
new method: <span class="ncbi_func">KillAllThreads()</span>, which causes all the threads in
the pool to exit cleanly after finishing all pending requests, and
takes an argument indicating whether to return immediately or to wait
for them to finish.

<hr WIDTH="100%">
<h1>
Other descriptions</h1>
<hr WIDTH="100%">
<h2>
<a NAME="CLightString"></a>class CLightString</h2>
Class for storing information about char strings. Unlike standard C++ string
class it doesn't take ownership over string contents. So, char array containing
string value should exist for whole life of holding CLightString object.
This char array should be deleted (if needed) after CLightString object
destruction by some other mechanism.
<br>Note that for efficiency sort order of CLightString differs from standard.
It compares first by string length, then by string contents, so here is
an example of sorted data:
<blockquote>
<pre class="ncbi_output">
"a"
"z"
"aa"
"az"
"zz"
"aaa"</pre>
</blockquote>
which, if sorted by standard comparison will look like:
<blockquote>
<pre class="ncbi_output">
"a"
"aa"
"aaa"
"az"
"z"
"zz"</pre>
</blockquote>

<hr WIDTH="100%">
<h2>
<a NAME="CChecksum"></a>class CChecksum</h2>
Class for CRC32 checksum calculation.
<br>It also have methods for adding and checking checkum line in text files.


<!--#include virtual="../ssi/navlinks.shtml" -->

<address>
<a href="mailto:cpp-core@ncbi.nlm.nih.gov">Eugene Vasilchenko</a></address>

<br><!-- Created: Mon Jan 29 13:58:54 EST 2001 --><!-- hhmts start -->Last
modified: Mon Jan 29 13:58:56 EST 2001<!-- hhmts end -->

<!--#include virtual="../ssi/footer.shtml" -->
