        <!--#set var="TITLE" value="NCBI C++ Object Manager library" -->
<!--#set var="DOCROOT" value="../.." -->
<!--#include virtual="../../ssi/header.shtml" -->




<div align="Center">
<h1>Object Manager.</h1>
</div>


<h2>Request history and conflict resolution.</h2>


<p>
There are several points of potential ambiguity:
<ol>
  <li>the client request may be incomplete;</li>
  <li>the data in the database may be ambiguous;</li>
  <li>the data stored by the Object Manager in the local cache
    may be out of date (in case the database has been updated during
	the client session);</li>
  <li>the history of requests may create conflicts (when the Object Manager
    is unable to decide what exactly is the meaning of the request).</li>
</ol>
</p>



<h3>Incomplete Seq-id.</h3>
<p>
Biological sequence id
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SDKDOCS/SEQLOC.HTML">Seq-id</a>)
gives a lot of freedom in defining what sequence
the client is interested in. It can be a Gi - a simple integer assigned to a sequence
by the NCBI "ID" database, which in most cases
is unique and univocal (Gi does not change if only annotations are changed),
but is also can be an accession string only (without
version number or release specification). It can specify in what database
the sequence data is stored, or this information could be missing.
</p>

<p>
The Object Manager's interpretation of such requests is kind of arbitrary
(yet reasonable, e.g. only the latest version of a given accession is being chosen).
That is, the sequence could probably be found, but only one sequence, not
the list of "matching" ones. At this point the initial incomplete Seq-id has
been resolved into a complete one. That is, 
the client asked the Scope for a BioseqHandle providing incomplete Seq-id
as the input. Scope resolved it into a specific complete Seq-id and
returned a handle. The client may now ask the handle about its Seq-id.
The returned Seq-id differs from the one provided initially by the client.
</p>


<h3>History of requests.</h3>
<p>
Once the Seq.id has been resolved into a specific Seq.entry, the Object Manager
keeps track of all data requests to this sequence in order to maintain consistency.
That is, it is perfectly possible that few minutes later this same Seq.id could be
resolved into another Seq.entry (the data in the database may change). Still,
from the client point of view, as long as this is the same session, nothing should
happen - the data should not change - if at the moment the sequence has 5 annotations,
then in 5 minutes it also has to have 5 of them.
</p>
<p>
By "session" we mean here the same Scope of resolution. That is, as long as
the data are requested through the same Scope, it is consistent. In another Scope
the data could potentially be different. Another way to make the Scope forget about
previous requests is calling its <tt>ResetHistory</tt> method.
</p>



<h3>Ambiguous requests.</h3>
<p>
It is possible that there are several Seq-entries which contain requested
information. In this case the processing depends on what is actually requested:
sequence data or sequence annotations. Seq.data should be taken from one
source, while annotations - from all of them.
</p>



<h4>Request for seq.data (Bioseq).</h4>
<p>
Examining all its Data Sources, the Scope creates a list of Seq.entries,
which could contain requested data. If the list contains more than one element,
one should choose the "best" one. To resolve this conflict, the Scope again uses
the history of requests:
<ul>
  <li>if one of the selected entries is mentioned in the history,
    it is selected again;</li>
  <li>if more than one entry is found in the history, an exception is being thrown -
    The Scope is unable to decide which one s better;</li>
  <li>if none of selected entries is found in the history, the Scope looks
    for "live" (more recent) entries. If more than entry is marked as "live" -
	the Scope consults with Data Loader (which in turn contacts the database)
	to select the best one.</li>
</ul>
</p>


<h4>Request for seq.annotations.</h4>
<p>
Annotation iterator starts with examining all Data Sources in the Scope
in order to find all top-level seq.entries, which contain annotations
pointing to the given Seq_id.
After that the special  filtering  rules are applied:

<ol>
  <li>If a top-level seq.entry (TSE) contains bio sequence identified by the
    Seq_id, include the TSE into the resulting TSE set. If multiple TSEs contain
    bio sequence, possibly identified by ID (e.g., different versions of the
    same accession, while ID specifies accession only), select the live TSE and
    ignore dead entries. If all TSEs selected are dead, report an error - we
    cannot decide which one is acceptable. (The latest information about the
    ID sequence will always include good annotations for this sequence).</li>
  <li>If multiple TSEs contain bioseqs, possibly identified by ID, and one
    of these TSEs has been recorded in the Scope's history, select this
    TSE    and  ignore other entries. If more than one TSE can be found in the
    Scope's    history,  report an error. (This means, the user has explicitly
    selected   a dead sequence  for his query).</li>
  <li>If a TSE, containing only references to ID (but no bioseqs identified
    by ID) is live, include it into the resulting set. (Live TSE always
    contains      information, which may be used to describe the sequence, even
    if the sequence     itself is already dead).</li>
  <li>From dead TSEs not containing the ID bioseq itself select only those
    found in the scope's history. (Dead TSE means it is not good anymore
    and    should not be used to describe the ID sequence, no matter live or
    dead.  History  record means the user has explicitly selected the dead TSE
    for his  query).</li>
</ol>

The algorithm for selecting TSEs is as follows:

<ol>
  <li>Select all TSEs, containing annotations with references to the ID;</li>
  <li>Find all TSEs from the set selected in (1), containing bioseqs identified
    by ID;</li>
  <li>Check the scope's history for TSEs found in (2). If there is more than
    one match - report an error. If there is one match, select it and ignore
    others, proceed to (5). If there are no matches, proceed to (4).</li>
  <li>Check whether any of the TSEs from the (2) set is live. If there is
    no live TSE and the set contains multiple dead TSEs, report an error.
    Otherwise    select the live or the only dead TSE.</li>
  <li>From the set of TSEs found in (1) exclude all TSEs selected in (2).</li>
  <li>From (5) select live TSEs, include all in the resulting set.</li>
  <li>From (5) select dead TSEs. From the resulting set select TSEs contained
    in the scope's history.</li>
</ol>
</p>



<!--#include virtual="../../ssi/navlinks.shtml" -->

<!-- Begin footer content -->

<!--#include virtual="../../ssi/footer.shtml" -->
