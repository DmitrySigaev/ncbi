        <!--#set var="TITLE" value="NCBI C++ Object Manager library" -->
<!--#set var="DOCROOT" value="../.." -->
<!--#include virtual="../../ssi/header.shtml" -->

<div align="Center">
<h1>Object Manager.</h1>
</div>

<ul>
<li><a href="#White_box_testing">White box testing.</a></li>
  <ul>
    <li><a href="#Basic_tests">1.1. Basic tests.</a></li>
      <ul>
        <li>Creating CScope</li>
        <li>Adding Seq_entry to the scope</li>
        <li>Handling Data loader</li>
      </ul>

    <li><a href="#Bio_sequence_data_handling">1.2.Bio sequence data handling tests.</a></li>
      <ul>
        <li>Bio sequences for testing.</li>
        <li>Test Bio sequence data.</li>
        <li>Scope as an object on the stack.</li>
        <li>Scope as an object on the heap.</li>
        <li>Addign annotations.</li>
        <li>Constructed bio sequences.</li>
        <li>One entry in two scopes.</li>
        <li>Scope history.</li>
      </ul>
  </ul>


<li><a href="#Black_box_testing">Black box testing.</a></li>
  <ul>
    <li><a href="#Functional_tests">2.1.Functional tests</a></li>
	  <ul>
	    <li>Modify existing test program</li>
	    <li>Modify existing id1_fetch application</li>
	    <li>Working with annotations</li>
	    <li>Scope isolation (single thread)</li>
	    <li>Scope isolation (multiple threads)</li>
	  </ul>
    <li><a href="#Stress_tests">2.2.Stress tests</a></li>
    <li><a href="#Performance_tests">2.3.Performance tests</a></li>
    <li><a href="#Recovery_tests">2.4.Recovery tests</a></li>
    <li><a href="#Mutation_tests">2.5.Mutation tests</a></li>
  </ul>
</ul>
<hr>


<h2>Testing.</h2>
<p>
The whole point of testing is to assure software quality. "Quality"
is   highly subjective term - it depends on who the customer is and their
overall   influence in the scheme of things.Testing involves operation of
a software   system under controlled conditions and evaluating the results.
The controlled   conditions should include both normal and abnormal conditions.
Testing should   intentionally attempt to make things go wrong to determine
if things happen   when they shouldn't or things don't happen when they
should.
</p>


<h2>1.<a name="White_box_testing"></a>White box testing.</h2>
<p>
White box testing is based on knowledge of the internal logic of
a  system's    code. Tests are based on coverage of code statements, branches,
paths, conditions.   Two main parts of  white box testing are unit and
integration   testing. These  are constantly updated and summarized in regression
test  programs.
</p>


<h2>2.<a name="Black_box_testing"></a>Black box testing.</h2>
<p>
Black box testing is not based on any knowledge of internal design
or  code.  Tests are based on requirements and functionality. Test cases
include.
</p>

<ul>
  <li>functional - based on functional requirements,</li>
  <li>stress - testing under unusually heavy loads,</li>
  <li>performance - how fast the system reacts to client requests,</li>
  <li>recovery - how the system recovers from crashes, hardware failures etc, and</li>
  <li>mutation testing - how the systems handles incorrect and changing input data.</li>
</ul>


<h2>Test cases.</h2>

<h3>1.1. <a name="Basic_tests"></a>Basic tests.</h3>
<p>
No real bio sequence data.<br>
Assumptions:
</p>

<ul>
  <li>CObjectManager must be created on the heap as a referenced object (in
     CRef container),</li>
  <li>CScope object may be created on the stack (as an automatic object),
     on the heap (using operator new) - both as a referenced object or not,</li>
  <li>CDataLoader object must be created on the heap as a referenced object,</li>
  <li>CSeq_entry object must be created on the heap as a referenced object.</li>
</ul>

<h4>1.1.1 Creating CScope.</h4>
<p>
Create data loader 1 and register it with the object manager  as
a  non-default    one.<br>
Create data loader 2 and register it with the object manager
as  a  default   one.<br>
Create scope 1 as a referenced object on the heap.<br>
Add default data loaders to the scope 1 - only data loader 2
is  added.<br>
Add data loader 1 to the scope 1 - now scope1 has two data loaders.<br>
Create scope 2 as an object on the stack.<br>
Add default data loaders to the scope 2 - only data loader 2
is  added.<br>
Create scope 3 on the heap (NOT as a referenced objects).<br>
Add default data loaders to the scope 3 - only data loader 2
is  added.<br>
Delete scope 3 - data loader 2 is alive.<br>
Both scopes go out of scope - both scopes are deleted, both data
loaders  are alive.<br>
Object manager goes out of scope - both data loaders are deleted.
</p>


<h4>1.1.2. Adding Seq_entry to the scope.</h4>
<p>
Create 3 scope objects, using three described methods.<br>
Create seq_entry object.<br>
Add seq_entry object to all scopes - only one data source must
be  created.<br>
Delete scope on the heap - data source and seq_entry objects are
 alive.<br>
Remaining scopes go out of scope - data source and seq_entry objects
are   deleted.
</p>


<h4>1.1.3. Handling Data loader.</h4>
<p>
Create data loader 1.<br>
Create scope and add default data loaders to it - nothing is added.<br>
Add data loader 1 to scope (by name) - object manager generates
an  exception    saying that such data loader is unknown.<br>
Register data loader 1 with object manager as a non-default one.<br>
Add default data loaders to scope - nothing is added.<br>
Add data loader 1 to scope - the call succeedes.<br>
Revoke data loader 1 - the call must fail, which means data loader
is  in  use.<br>
Delete scope - data loader 1 is still alive.<br>
Revoke data loader 1 - the call succeeds, the data loader is deleted.<br>
Revoke data loader 1 again - object manager generates an exception
saying  that such data loader was not registered.<br>
</p>


<h3>1.2 <a name="Bio_sequence_data_handling"></a>
Bio sequence data handling tests.</h3>
<p>
Artificially created bio sequences.<br>
This includes existing testobjmgr1.cpp and testobjmgr1_mt.cpp programs.
</p>


<h4>1.2.1. Bio sequences for testing.</h4>
<p>
1.2.1.1. Create one top-level Seq_entry with 2 sub-entries. Top-level entry
has one description. Each sub-entry two Seq_ids - local and GI, one description,
two annotations (Seq_feat): for an interval (one of them should be defined
for the "minus" strand) and for the whole sequence. One sub-entry also has
an alignment annotation. Both sequences are continuous.<br>
1.2.1.2. Create one top-level Seq_entry with 2 sub-entries. No descriptions,
no annotations. The point is that these sub-entries have the same Seq_ids
as in 1.2.1.1. - to see how the seq.data is resolved in different scopes.<br>
1.2.1.3. Create one top-level Seq_entry with 3 sub-entries. Top-level entry
has one annotation, which refers both to sub-entry from 1.2.1.1 and to sub-entry
from 1.2.1.3. Each sub-entry has two Seq_ids - local and GI. One sub-entry
is segmented with references to sub-entries from 1.2.1.1 or 1.2.1.2 and to
self. One sub-entry uses another seq data format.<br>
1.2.1.4 Create one top-level Seq_entry, no sub-entries. The entry only contains
references to other sequences - from 1.2.1.1.<br>
</p>


<h4>1.2.2. Test bio sequence data.</h4>
<p>
Input: Scope and seq_id.<br>
Operations:
</p>
<ul>
  <li>investigate SeqMap, verify lengths,</li>
  <li>investigate SeqVector, verify seq.data (as strings),</li>
  <li>investigate SeqMap again - some references may be resolved now - verify lengths,</li>
  <li>enumerate descriptions - verify count,</li>
  <li>enumerate features for the whole sequence - verify count,</li>
  <li>enumerate features for an interval - verify count,</li>
  <li>enumerate alignments for the whole sequence - verify count,</li>
  <li>enumerate alignments for an interval - verify count.</li>
</ul>


<h4>1.2.3. Scope as an object on the stack.</h4>
<p>
Create scope on the stack.<br>
Create Seq_entries 1.2.1.1 and 1.2.1.3.<br>
Run test 1.2.2 against each bio sequence.<br>
</p>


<h4>1.2.4. Scope as an object on the heap.</h4>
<p>
Create scope on the heap.<br>
Create Seq_entries 1.2.1.1 and 1.2.1.3.<br>
Run test 1.2.2 against each bio sequence.
</p>


<h4>1.2.5. Adding annotations.</h4>
<p>
Create Seq_entries 1.2.1.1 and 1.2.1.3.<br>
Add annotation to one sub-entry.<br>
Run test 1.2.2 against each bio sequence verifying that only one sub-entry
changed.
</p>


<h4>1.2.6. Constructed bio sequences.</h4>
<p>
Create Seq_entries 1.2.1.1 and 1.2.1.4 (the latter contains only references
to 1.2.1.1).<br>
Run test 1.2.2 against each constructed bio sequence.
</p>


<h4>1.2.7. One entry in two scopes.</h4>
<p>
Add Seq_entries 1.2.1.1 and 1.2.1.3 in Scope1 and only 1.2.1.3 (which contains
references to 1.2.1.1) in another scope - Scope2.<br>
Now Scope2 contains unresolvable references.<br>
Run test 1.2.2. against Scope2 verifying that references are unresolvable.<br>
Create entries 1.2.1.2 (same Seq_ids as in 1.2.1.1) and add them to Scope2.<br>
Run test 1.2.2. against Scope2 verifying that references are now resolved
and resolved properly.
</p>


<h4>1.2.8. Scope history.</h4>


<h3>2.1 <a name="Functional_tests"></a>Functional tests</h3>


<h4>2.1.1 Modify existing test program
(<a href="#Bio_sequence_data_handling"> 1.2</a>).</h4>
<p>
2.1.1.1. Modify existing bio sequence data handling test program to work
with real data from one of NCBI databases. Make sure it gives "reasonable"
results.<br>
2.1.1.2. Make test application generate output in
<a href="http://www.ncbi.nlm.nih.gov/BLAST/fasta.html">FASTA</a>
format.Compare it with the production FASTA generator.
</p>


<h4>2.1.2 Modify existing id1_fetch application.</h4>
<p>
Modify existing
<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/tools/id1_fetch/id1_fetch.html">id1_fetch</a>
application to use new object manager and data loader. Make sure both
versions  give identical results:<br>
2.1.2.1 Using bio sequences from the
<a href="http://www.ncbi.nlm.nih.gov/dbEST/">Expressed Sequence Tags</a>
database . This data is reasonably stable (that is highly unlikely to
change  at all), so the test should always give known results.<br>
2.1.2.2 Using mRNA
(<a href="http://www.ncbi.nlm.nih.gov/genome/guide/build.html">contig</a>)
bio sequences from the
<a href="http://www.ncbi.nlm.nih.gov/SNP/">Single Nucleotide Polymorphism</a>
database to include variations. Note: this requires SPLIT server - to
be  able to download data pointed to by an external link.
</p>


<h4>2.1.3. Working with annotations.</h4>
<p>
2.1.3.1. Same activity in multiple threads.<br>
2.1.3.2. Slightly different activity in different threads.
</p>


<h4>2.1.4 Scope isolation (single thread)</h4>
<p>
The tests start with two scopes "looking" at the same data.<br>
2.1.4.1. Add data to one of scopes. Make sure the data in scopes are now
different.
</p>


<h4>2.1.5 Scope isolation (multiple threads)</h4>
<p>
These tests start with scopes "looking" at the same data.<br>
2.1.5.1 Add the same data to different scopes working in parallel threads.
Make sure the data is added correctly.<br>
2.1.5.2 Add different data to different scopes working in parallel thread.
Make sure the data is added correctly.
</p>


<h3>2.2 <a name="Stress_tests"></a>Stress tests</h3>
<p>
2.2.1. Straightforward run (single thread) though a large set of bio
sequences   (GI - genbank identifiers) to see if the cache gets cleaned and
memory consumption   is reasonable.<br>
2.2.2. Run through a large set of GIs using several threads, which should
run through these sets randomly in different directions, sometimes ("not
too often") overlapping.<br>
2.2.3. Run two threads: one is "slow", another is "fast". The purpose
of  the second thread is to overflow the memory cache.
</p>


<h3>2.3 <a name="Performance_tests"></a>Performance tests</h3>
<p>
How fast does it work? The test should be done on highly splitted data.<br>
2.3.1.Run GenBank formatter
(<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/tools/id1_fetch/id1_fetch.html">id1_fetch</a>)
on the same GI several (3-7?) times, then run the same job in our test
program
(<a href="#Functional_tests">2.1.2</a>)
in a single and multiple threads on a single and multi-processor computer.
Make sure all threads and all runs produce identical result. What is speed-up
ratio? The test must be done both for simple sequences
(<a href="http://www.ncbi.nlm.nih.gov/dbEST/">EST</a>)
and complex ones
(<a href="http://www.ncbi.nlm.nih.gov/SNP/">SNP</a>).<br>
2.3.2. repeat 2.3.1 with FASTA formatter.
</p>


<h3>2.4 <a name="Recovery_tests"></a>Recovery tests</h3>
<p>
2.4.1. ??
</p>


<h3>2.5 <a name="Mutation_tests"></a>Mutation tests</h3>
<p>
2.5.1. There should be at least two scopes looking at the same bio sequence.
During the work, the data in the database change. This should be adequately
reflected in object manager's data.<br>
2.5.2. Incorrect data? Probably it could be simulated by reading data
from  file.
</p>

<!--#include virtual="../../ssi/navlinks.shtml" -->
<!--#include virtual="../../ssi/footer.shtml" -->
