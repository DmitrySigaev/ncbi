<!-- $Id$ -->
<!--#set var="TITLE" value="NCBI C++ Toolkit:  FAQ" -->
<!--#set var="HEADING" value="NCBI C++ Toolkit FAQ" -->
<!--#set var="DOCROOT" value="." -->
<!--#include virtual="./ssi/header.shtml" -->
<i><h1><font color="#FF0000"><span style="background-color: #FFFFFF">Warning: This HTML page is deprecated</span></font></h1>

All new changes are being made to the Toolkit Book
at the following locations:
<ul>
<li>
<i>Official Release:</i> <a href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">
    C++ Toolkit Book</a>.
</li>
<li>
<i>Development Version:</i> <a href="http://xpubmed0.ncbi.nlm.nih.gov:5701/books/bv.fcgi?call=bv.View..ShowTOC&rid=toolkit.TOC&depth=2">

    C++ Toolkit Book (no search engine, accessible from inside NCBI only)</a>. </li> </ul> The Development Version is the most recent documentation before it becomes an Official Release. While the Development Version is the lastest version, it is accessible only from inside NCBI, and the search engine functionality is currently missing. Also, the location of the Development Version may change without warning! So it is suggested that you use the Official Release, and use the Development Version only when necessary.</p> </i>

<hr>
<!--EOW-->

<hr>

<!-- page contents -->

<ol>
<li>
<a href="#ref_CannotFindSymbol">Linker complains it "cannot find symbol"
in something like:
<span class="ncbi_file">"SunWS_cache/CC_obj_b/bXmZkg3zX5VBJvYgjABX.o"</span></a></li>

<li>
<a href="#ref_CannotFindObjectSymbol">How does one find the libraries to
link when the linker complains of undefined symbols</a></li>

<li>
<a href="#ref_HowMakeDep">MAKE complains it does not know "how to make
target: /home/qqq/c++/WorkShop6-Debug/lib/.seqset.dep"</a></li>

<li>
<a href="#ref_LastResort">Still getting bizarre errors with unresolved
symbols, unfound libraries, etc., and nothing seems to help out much</a></li>

<li>
<a href="#ref_CannotFindGetTypeInfo">The GetTypeInfo() method is not declared
or defined in any of the objects for which it is part of the interface.</a></li>

<li>
<a href="#ref_WhichIncludeFile">Which include file should be used in *.cpp
files, <em>class</em>.hpp or <em>class_</em>.hpp?</a></li>

<li>
<a href="#ref_DBX_Sources">Debugger (DBX) warns it
"cannot find file /home/coremake/c++/foobar.cpp", then it does not show source code</a></li>

<li>
<a href="#ref_AddingUserASN">Creating an out-of-tree application that uses
your own local ASN.1 spec and a pre-built C++ Toolkit</a></li>

<li>
<a href="#ref_AddingASN">How to add new ASN.1 module from the C Toolkit
to the C++ Toolkit?</a></li>

<li>
<a href="#ref_CToCxxASN">Converting ASN.1 object in memory from <span class="ncbi_term">C</span> to <span class="ncbi_term">C++</span> representation (or vice versa)</a></li>

</ol>

<hr>
<h4>
<a NAME="ref_CannotFindSymbol"></a>Linker complains it "cannot find
symbol" in something like:
<span class="ncbi_file">"SunWS_cache/CC_obj_b/bXmZkg3zX5VBJvYgjABX.o"</span></h4>
Go to the relevant build dir, clean and rebuild everything using:

<pre class="ncbi_cmd">
   cd /home/qqq/c++/WorkShop6-Debug/build/FooBar
   make purge_r all_r
</pre>

<p>
<hr>
<h4>
<a NAME="ref_CannotFindObjectSymbol"></a>How does one find the libraries
to link when the linker complains of undefined symbols</h4>
For example, the linker may complain about the symbol <span class="ncbi_func">ncbi::objects::CSeq_id::GetTypeInfo(void)</span>
being undefined. The cause of this problem is that the applicable objects
library has not been linked into the application. You determine the applicable
objects library as follows:
<p>1) Look for the *.hpp file that declares the applicable class (e.g.,
for CSeq_id this will be include/objects/seqloc/Seq_id.hpp). This can be
done by going to the <a href="lxr/ident?i=CSeq_id">source browser</a> and
doing an identifier search on the class name (e.g., CSeq_id) and looking
in the <em>Defined as a class</em> section for the path name.
<p>2) Note the name of the sub directory in which the *.hpp file is located
(in this case the sub directory is seqloc).
<p>3) The name of the library to link is determined from the sub directory
name. In the make file add the library name to the LIB macro (e.g., LIB
= <span class="ncbi_lib">seqloc</span> xncbi) or add -l<em>subdir</em> (e.g., -lseqloc) to the command
line of the link command.
<p>The above describes how to find the libraries for classes in sub directories
of the <span class="ncbi_dir">object/</span> directory. A similar techniques works for other classes
also. However, in a some cases, the library name is a variant on the sub
directory name. These variants are summarized below.
<br><br>
<table>
<tr>
<th ALIGN=LEFT>Directory</th>
<th ALIGN=LEFT width=20>&nbsp;</th>
<th ALIGN=LEFT>Library</th>
</tr>

<tr>
<td>corelib/test</td>
<td>&nbsp;</td>
<td>test_mt</td>
</tr>

<tr>
<td>corelib</td>
<td>&nbsp;</td>
<td>xncbi</td>
</tr>

<tr>
<td>ctools/asn</td>
<td>&nbsp;</td>
<td>xasn</td>
</tr>

<tr>
<td>cgi</td>
<td>&nbsp;</td>
<td>xcgi or xfcgi</td>
</tr>

<tr>
<td>connect</td>
<td>&nbsp;</td>
<td>xconnect</td>
</tr>

<tr>
<td>connect/test</td>
<td>&nbsp;</td>
<td>xconntest</td>
</tr>

<tr>
<td>ctools</td>
<td>&nbsp;</td>
<td>xctools</td>
</tr>

<tr>
<td>html</td>
<td>&nbsp;</td>
<td>xhtml</td>
</tr>

<tr>
<td>objects/alnmgr</td>
<td>&nbsp;</td>
<td>xalnmgr</td>
</tr>

<tr>
<td>objects/objmgr</td>
<td>&nbsp;</td>
<td>xobjmgr</td>
</tr>

<tr>
<td>objects/util</td>
<td>&nbsp;</td>
<td>xobjutil</td>
</tr>

<tr>
<td>serial</td>
<td>&nbsp;</td>
<td>xser</td>
</tr>

<tr>
<td>util</td>
<td>&nbsp;</td>
<td>xutil</td>
</tr>
</table>

<p><span class="ncbi_note">Note:</span> The C++ Toolkit libraries have dependencies on each other. For
example, symbols defined in <span class="ncbi_lib">seqfeat</span> (<span class="ncbi_lib">libseqfeat.a</span>) are referenced
in library <span class="ncbi_lib">mmdb1</span> (<span class="ncbi_lib">libmmdb1.a</span>). In this case you must link
<span class="ncbi_lib">seqfeat</span>
after <span class="ncbi_lib">mmdb1</span>.
<p>There is a <a href="depgraph.html">Library Dependency Graph</a> to help
you figure out dependencies between the NCBI C++ Toolkit libraries.
<p>Most often, difficulties arise when one is linking an application using
these numerous <span class="ncbi_dir">"objects/"</span> libraries. To give you some relieve, here
are some examples involving such libraries. They show the right order of
libraries, as well as which libraries you may actually need. Using this
as a starting point, it's <em>much</em> easier to find the right combination
of libraries:
<ul>
<li>
first, to find and add missing libraries using the generic technique described
above</li>

<li>
then, try to throw out libraries which you believe are not actually needed</li>
</ul>

<pre class="ncbi_cmd">
   LIB = id1 seqset $(SEQ_LIBS) pub medline biblio general \
         xser xconnect xutil xncbi

   LIB = cdd ncbimime mmdb1 mmdb2 mmdb3 cn3d seqset $(SEQ_LIBS) \
         pub medline biblio general xser xconnect xutil xncbi
</pre>

<hr>
<h4>
<a NAME="ref_HowMakeDep"></a>MAKE complains it does not know "how to
make target: /home/qqq/c++/WorkShop6-Debug/lib/.seqset.dep"</h4>
This means that the "<span class="ncbi_lib">lib<em>seqset</em>.a</span>" library is not built. To build
it:
<pre class="ncbi_cmd">
   cd /home/qqq/c++/WorkShop6-Debug/build/objects/seqset
   make
</pre>

<hr>
<h4>
<a NAME="ref_LastResort"></a>Still getting bizarre errors with unresolved
symbols, unfound libraries, etc., and nothing seems to help out much</h4>
As the last resort, try to CVS update, reconfigure, clean and rebuild everything:
<pre class="ncbi_cmd">
   cd /home/qqq/c++/
   cvs -q upd -d
   compilers/WorkShop6.sh 32 ........
   make purge_r
   make all_r
</pre>

<hr>
<h4>
<a NAME="ref_CannotFindGetTypeInfo"></a>The GetTypeInfo() method is not
declared or defined in any of the objects for which it is part of the interface.</h4>
The macro DECLARE_INTERNAL_TYPE_INFO() is used in the *.hpp files to declare
the GetTypeInfo(). There are several macros that are used to implement
GetTypeInfo() methods in *.cpp files. These macros are generally named
and used as follows:

<pre class="ncbi_cmd">
   BEGIN_*_INFO(...)
   {
      ADD_*(...)
      ...
   }
</pre>

See <a href="programming_manual/usrtypeinfo.html">User-defined Type
Information in the Programming Manual</a> for more information.&nbsp;
<p>

<hr>
<h4>
<a NAME="ref_WhichIncludeFile"></a>Which include file should be used in
*.cpp files, <em>class</em>.hpp or <em>class_</em>.hpp?</h4>
Include the <em>class</em>.hpp (file without underscore). Never instantiate
or use a class of the form C*_Base directly. Instead use the C* form which
inherits from the C*_Base class (e.g., don't use CSeq_id_Base directly
-- use CSeq_id instead).&nbsp;
<p>

<hr><!-- **************************************************************** -->
<h4>
<a NAME="ref_DBX_Sources"></a>Debugger (DBX) warns it
"cannot find file /home/coremake/c++/foobar.cpp", then it does not show source code</h4>
This happens when you link to the public C++ Toolkit libraries (from <span class="ncbi_dir">"$NCBI/c++/*/lib/"</span>),
which are built on other hosts and thus hard-coded with the source paths
on these other hosts. All you have to do is to point DBX to the public
sources (at <span class="ncbi_dir">"$NCBI/c++"</span>) by just adding to your DBX resource file
(<span class="ncbi_file">~/.dbxrc</span>) the following lines:

<pre class="ncbi_cmd">
   pathmap /home/coremake/c++ /netopt/ncbi_tools/c++
   pathmap /home/coremake/c++2 /netopt/ncbi_tools/c++
   pathmap /home/coremake/c++3 /netopt/ncbi_tools/c++
   pathmap /j/coremake/c++ /netopt/ncbi_tools/c++
   pathmap /j/coremake/c++2 /netopt/ncbi_tools/c++
   pathmap /j/coremake/c++3 /netopt/ncbi_tools/c++
</pre>

<hr><!-- **************************************************************** -->
<h4>
<a NAME="ref_AddingUserASN"></a>Creating an out-of-tree application that
uses your own local ASN.1 spec and a pre-built C++ Toolkit</h4>

<p>
Lets say you have your ASN.1 specification (call it <span class="ncbi_file">foo.asn</span>)
and now you want to build an application (call its source code
<span class="ncbi_file">foo_main.cpp</span>) which performs serialization of objects described
in <span class="ncbi_file">foo.asn</span>.

To complicate things, lets also assume that your ASN.1 spec depends on
(imports) one of the ASN.1 specs already in the C++ Toolkit, like <span class="ncbi_value">Date</span>
described in the <span class="ncbi_value">NCBI-General</span> module of <span class="ncbi_file">general.asn</span>.

For example, your <span class="ncbi_file">foo.asn</span> could look like:

<pre class="ncbi_cmd">
   NCBI-Foo DEFINITIONS ::=
   BEGIN

   EXPORTS Foo;
   IMPORTS Date FROM NCBI-General;

   Foo ::= SEQUENCE {
       str   VisibleString,
       date  Date
   }

   END
</pre>

Now, lets assume that the pre-built version of the NCBI C++ Toolkit
is available at <span class="ncbi_dir">$NCBI/c++</span>, and that you want to use the Toolkit's
pre-built sources and libraries in your application.

First, generate (using <a href="tools/datatool/datatool.html">datatool</a>)
the serialization sources, and create serialization library:

<pre class="ncbi_cmd">
## Create new project directory, with a model makefile for your
## local ASN.1 serialization library, and copy "foo.asn"

cd ~/tmp
$NCBI/c++/scripts/new_project.sh foo lib
cd foo
cp /bar/bar/bar/foo.asn .

## Using DATATOOL, generate data serialization sources for your
## ASN.1 specs described in "foo.asn":

$NCBI/c++/Release/bin/datatool -oR $NCBI/c++ -m foo.asn \
 -M "objects/general/general.asn" -oA -oc -opc . -oph .

## Adjust in the library makefile "Makefile.foo_lib"

SRC = foo__ foo___

## Build the library

make -f Makefile.foo_lib
</pre>

Then, create and build the application:

<pre class="ncbi_cmd">
## Create new application project, and copy your app.sources

$NCBI/c++/scripts/new_project.sh foo_main app
cd foo_main
cp /bar/bar/bar/foo_main.cpp .


## Adjust in the library makefile "Makefile.foo_main_app"

PRE_LIBS = -L.. -lfoo
cppFLAGS = -I.. $(ORIG_cppFLAGS)

LIB      = xgeneral xser xutil xncbi
LIBS     = $(NCBI_C_LIBPATH) $(NCBI_C_ncbi)

## Build the application

make -f Makefile.foo_app
</pre>


<br>
<hr><!-- **************************************************************** -->
<h4>
<a NAME="ref_AddingASN"></a>How to add new ASN.1 module from the C Toolkit
to the C++ Toolkit?</h4>
<span class="ncbi_note">Caution!</span> If you are not in the C++ core developers group, please do not do it
yourself! -- instead, just send your request to
<a href="mailto:cpp-core@ncbi.nlm.nih.gov" class="ncbi_url">cpp@ncbi.nlm.nih.gov</a>.

<br>Use script
<a href="lxr/source/src/objects/add_asn.sh">src/objects/add_asn.sh</a>
that automates the adding of new ASN.1 spec to the C++ Toolkit. Note that
it does only the "UNIX part" of the job, and you will have to make changes
in the MSVC and MAC projects later, manually.
<p>Adding ASN.1 spec "entrez2" originally located in the C Toolkit,
<span class="ncbi_file">$CVSROOT/distrib/access/entrez2.asn</span>:
<br><span class="ncbi_cmd">$ src/objects/add_asn.sh distrib/access/entrez2.asn,v</span>
<p>Now, to add your new project to the NCBI C++ Toolkit workspace for MS
Visual C++:
<ol>
<li>
Open workspace file <span class="ncbi_file">c++/compilers/msvc_prj/ncbi_cpp.dsw</span> in
the MS Visual C++.</li>

<li>
Create library project <span class="ncbi_proj">"objects_entrez2"</span> containing source files
<span class="ncbi_file">c++/src/objects/entrez2/entrez2__.cpp</span>
and <span class="ncbi_file">c++/src/objects/entrez2/entrez2___.cpp</span>.</li>

<li>
The project file location should be: <span class="ncbi_file">c++/compilers/msvc_prj/objects/entrez2/objects_entrez2.dsp</span></li>

<li>
Add project <span class="ncbi_proj">"objects_entrez2"</span> as a dependency to the utility project
<span class="ncbi_proj">"all_objects_libs"</span>.</li>

<li>
Build project <span class="ncbi_proj">'objects_entrez2'</span>.</li>

<li>
Check-in <span class="ncbi_file">c++/compilers/msvc_prj/objects/entrez2/objects_entrez2.dsp</span>
and <span class="ncbi_file">c++/compilers/msvc_prj/ncbi_cpp.dsw</span>. Consult the <a href="config.html#ref_MsvcProjFiles">"Working
with NCBI C++ project files"</a> guidelines.</li>
</ol>
Here is the list of files affected:
<ul>
<li>
<span class="ncbi_file">c++/scripts/internal/c_toolkit/<em>sync_asn.sh</em></span></li>

<li>
<span class="ncbi_file">c++/src/objects/Makefile</span></li>

<li>
<span class="ncbi_file">c++/src/objects/Makefile.in</span></li>

<li>
<span class="ncbi_file">c++/src/objects/nt_sources.sh</span></li>

<li>
<span class="ncbi_file">c++/src/objects/entrez2/entrez2.module</span> [new file]</li>

<li>
<span class="ncbi_file">c++/src/objects/entrez2/Makefile.in</span> [new file]</li>

<li>
<span class="ncbi_file">c++/src/objects/entrez2/.cvsignore</span> [new file]</li>

<li>
<span class="ncbi_file">c++/include/objects/entrez2/.cvsignore</span>[new file]</li>

<li>
<span class="ncbi_dir">c++/compilers/msvc_prj/objects/entrez2/</span> [new directory]</li>

<li>
<span class="ncbi_file">c++/compilers/msvc_prj/objects/entrez2/objects_entrez2.dsp</span> [new
file]</li>

<li>
<span class="ncbi_file">c++/compilers/msvc_prj/ncbi_cpp.dsw</span></li>
</ul>


<hr>
<h4>
<a NAME="ref_CToCxxASN"></a> Converting ASN.1 object in memory from
<em>C</em> to <em>C++</em> representation (or vice versa)
</h4>

The C++ Toolkit header
<a href="lxr/source/include/ctools/asn_converter.hpp">ctools/asn_converter.hpp</a>
now provides a template class
(<a href="lxr/ident?i=CAsnConverter&d=C"><span class="ncbi_class">CAsnConverter&lt;&gt;</span></a>)
for this exact purpose.

<!--#include virtual="./ssi/navlinks.shtml" -->

<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<script>
<!--
print_author('cpp-core, 'Denis Vakatov', '$Date$', 'ncbi.nlm.nih.gov');
// -->
</script>
</table>

<!--#include virtual="./ssi/footer.shtml" -->
