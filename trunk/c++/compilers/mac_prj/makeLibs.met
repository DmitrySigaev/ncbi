-- C++ libs --property pRootFolderName : "ncbi_cxx" -- name of the toolkit directoryproperty pRootFolderPath : "" -- full path of the parent of the toolkit directory. Optionalproperty pFLTKRootFolder : "" -- full path of the FLTK directory. Optional.property pProjectFileExt : ".mcp"property pCPlusPlusExt : ".cpp"property pStaticLibExt : ".lib"property pPluginExt : ".so"property pDynaLibExt : ".dylib"-- Whether to recreate existing project files.property pAlwaysCreateProjects : false-- But profiling doesn't work for Mach-O Codewarrior projects currently.property pCreateProfiledTargets : false-- Whether to compile anything.property pShouldBuild : true-- Whether to create projects in the specified category.property pCreateObjectLibs : true (* whether to create/compile object libraries *)property pCreateSocketLibs : true (* whether to create/compile socket libs *)property pCreateGuiLibs : trueproperty pStationeryName : "LibraryStationery"property pPluginStationeryName : "PluginStationery"property pDylibStationeryName : "DLLStationery"property pTargetKeyWords : "MSL BSD Debug Final"----  Set Global variables--global gHomeDirglobal gDistribRootglobal gProjectsDirglobal gSourceDirglobal gIncludeDirglobal gRsrcsDirglobal gMakeDirglobal gLibsDirglobal gFLTKRootFolderglobal gProjectDataon ProjectData(projName, features, aFileData)		if (count characters of projName) > 18 then		set projName to characters 1 through 18 of projName as string	end if		tell application "CodeWarrior IDE"				if features does not contain "C" and features does not contain "C++" then			copy "C++" to end of features		end if		set myFeatures to features				return {name:projName, features:myFeatures, rsrcs:{}, settings:Â			{Prefix File:"", ppcProject:{}}, projLibs:{}, dynaLibs:{}, sysPaths:{}, fileData:Â			aFileData}			end tellend ProjectDataon AddProject(projData)	copy projData to end of gProjectDataend AddProjecton AddSimpleProject(projName, features, section)	AddProject(ProjectData(projName, features, {mkFileData(gSourceDir & section)}))end AddSimpleProjecton AddSimpleProjectListFiles(projName, features, section, fileList)	AddProject(ProjectData(projName, features, {mkFileDataListFiles(gSourceDir & section, fileList)}))end AddSimpleProjectListFileson AddSimpleProjectExceptFiles(projName, features, section, fileNotList)	AddProject(ProjectData(projName, features, {mkFileDataExceptFiles(gSourceDir & section, fileNotList)}))end AddSimpleProjectExceptFileson mkFileData(fullPath)	if (fullPath does not end with ":") then set fullPath to fullPath & ":"	return {projPath:fullPath, fileList:GetFileNames(fullPath), fileNotList:{}}end mkFileDataon mkFileDataListFiles(fullPath, fileList)	if (fullPath does not end with ":") then set fullPath to fullPath & ":"	return {projPath:fullPath, fileList:fileList, fileNotList:{}}end mkFileDataListFileson mkFileDataExceptFiles(fullPath, fileNotList)	if (fullPath does not end with ":") then set fullPath to fullPath & ":"	return {projPath:fullPath, fileList:GetFileNames(fullPath), fileNotList:fileNotList}end mkFileDataExceptFileson ObjectData(objName)	-- set projName to "object_" & objName	set projPath to "objects:" & objName	set projFiles to {objName & "__", objName & "___"}		return ProjectData(objName, {}, {mkFileDataListFiles(gSourceDir & projPath, projFiles)})end ObjectDataon AddObject(projName)	AddProject(ObjectData(projName))end AddObjecton GuiFileData(section)	if section does not start with "gui:" then		set section to "gui:" & section	end if	-- Get all the files, minus those whose basename ends with an underscore.	set fileData to mkFileData(gSourceDir & section)	set newFileList to {}	repeat with f in fileList of fileData		if f does not end with ("_" & pCPlusPlusExt) then			copy f as text to end of newFileList		end if	end repeat	set fileList of fileData to newFileList	return fileDataend GuiFileDataon GuiProjectData(projName, features, section)	set fileData to GuiFileData(section)	if features does not contain "fltk" then		copy "fltk" to end of features	end if	return (ProjectData(projName, features, {fileData}))end GuiProjectDataon AddGuiProject(projName, features, section)	AddProject(GuiProjectData(projName, features, section))end AddGuiProjecton AddPlugin(projName, features, section, staticLibs)	if features does not contain "plugin" then set features to features & {"plugin"}	if features does not contain "libdl" then set features to features & {"libdl"}	set projData to GuiProjectData(projName, features, section)	if features contains "fltk" then		set staticLibs to staticLibs & "fltk"	end if	AddProject(DataPlusLibs(projData, staticLibs, {"gui_core"}))end AddPluginon DataPlusSources(dataRec, newSrcs)	repeat with i in newSrcs		copy i to end of fileList of item 1 of fileData of dataRec	end repeat	return dataRecend DataPlusSourceson DataPlusLibs(dataRec, newLibs, newDlls)	repeat with i in newLibs		copy i to end of projLibs of dataRec	end repeat	repeat with i in newDlls		copy i to end of dynaLibs of dataRec	end repeat	return dataRecend DataPlusLibson HideFolder(folderPath)	tell application "Finder"		if exists folder folderPath then			set theName to name of folder folderPath			set name of folder folderPath to ("(" & theName & ")")		end if	end tellend HideFolderon GetFileNames(fullSourcePath)	set theFiles to list folder (fullSourcePath) without invisibles	set theCFiles to EndsWith(theFiles, ".c")	set theCppFiles to EndsWith(theFiles, pCPlusPlusExt)	return theCFiles & theCppFilesend GetFileNameson EndsWith(aList, suffix)	set newList to {}	repeat with f in aList		if (f ends with suffix) then			copy (f as string) to end of newList		end if	end repeat	return newListend EndsWithon SetProjectData()		if pCreateSocketLibs then		-- Not needed or wanted under Mach-O		my HideFolder(gSourceDir & "connect:mitsock")				AddSimpleProjectExceptFiles("xconnect", {}, "connect", Â			{"ncbi_lbsm_ipc.c", "ncbi_lbsm.c", "ncbi_lbsmd.c"})	end if		AddSimpleProjectExceptFiles("xncbi", {}, "corelib", {"test_mt.cpp", "ncbi_os_mac.cpp"})	AddSimpleProject("xalgo", {}, "algo")	AddSimpleProjectExceptFiles("xcgi", {}, "cgi", {"fcgi_run.cpp", "fcgibuf.cpp"})	AddSimpleProject("dbapi", {}, "dbapi")	AddSimpleProject("dbapi_driver", {}, "dbapi:driver")	AddSimpleProject("xhtml", {}, "html")	AddSimpleProjectListFiles("xcser", {}, "serial", {"asntypes.cpp", "serialasn.cpp"})	AddSimpleProjectExceptFiles("xser", {}, "serial", Â		{"asntypes.cpp", "object.cpp", "objstrb.cpp", "rtti.cpp", "serialasn.cpp"})	AddSimpleProject("xutil", {}, "util")		if pCreateObjectLibs then		AddObject("access")		AddObject("biblio")		AddObject("cdd")		AddObject("cn3d")		AddObject("docsum")		AddObject("entrez2")		AddSimpleProjectListFiles("entrez2cli", {}, "objects:entrez2", {"entrez2_client", "entrez2_client_"})		AddObject("entrezgene")		AddObject("featdef")		AddObject("gbseq")		AddObject("general")		AddObject("id1")		AddSimpleProjectListFiles("id1cli", {}, "objects:id1", {"id1_client", "id1_client_"})		AddObject("medlars")		AddObject("medline")		AddObject("mim")		AddObject("mla")		AddSimpleProjectListFiles("mlacli", {}, "objects:mla", {"mla_client", "mla_client_"})		AddObject("mmdb1")		AddObject("mmdb2")		AddObject("mmdb3")		AddObject("ncbimime")		AddObject("objprt")		AddObject("proj")		AddObject("pub")		AddObject("pubmed")		AddProject(DataPlusSources(ObjectData("seq"), {"gencode", "seqport_util"}))		AddObject("seqalign")		AddObject("seqblock")		AddObject("seqcode")		AddObject("seqfeat")		AddObject("seqloc")		AddObject("seqres")		AddObject("seqset")		AddObject("submit")		AddProject(DataPlusSources(ObjectData("taxon1"), {"cache", "ctreecont", "taxon1", "utils"}))		AddObject("tinyseq")				AddSimpleProject("xalnmgr", {}, "objects:alnmgr")		AddSimpleProject("xflat", {}, "objects:flat")		AddSimpleProject("xobjmgr", {}, "objects:objmgr")		AddSimpleProject("xobjutil", {}, "objects:util")		AddSimpleProject("xvalidate", {}, "objects:validator")	end if		-- GUI libs.	if pCreateGuiLibs then		-- GuiProject's automatically have 'fltk' feature.				AddSimpleProject("gui_utils", {"fltk"}, "gui:utils")		AddGuiProject("gui_dlg_entry_form", {}, "dialogs:entry_form")		AddGuiProject("gui_dlg_feature", {}, "dialogs:feature")		AddGuiProject("gui_opengl", {}, "opengl")				-- widgets		AddGuiProject("w_aln_crossaln", {}, "widgets:aln_crossaln")		AddGuiProject("w_aln_dotmatrix", {}, "widgets:aln_dotmatrix")		AddSimpleProjectListFiles("w_flek", {"fltk"}, "gui:widgets:Flek", Â			{"Flv_List.cpp", "Flv_Style.cpp", "Flv_Table.cpp"})		AddGuiProject("w_seq", {}, "widgets:seq")		AddGuiProject("w_seq_icon", {}, "widgets:seq_icon")		AddGuiProject("w_seq_info", {}, "widgets:seq_info")		AddGuiProject("w_table", {}, "widgets:table")		AddGuiProject("w_toplevel", {}, "widgets:toplevel")				-- FLTK library.		set saveCppExt to pCPlusPlusExt		set pCPlusPlusExt to ".cxx"		AddProject(ProjectData("fltk", {"fltklib"}, {mkFileDataExceptFiles(gFLTKRootFolder & "src", Â			{"cmap.cxx", "dump_compose.c", "fl_color_mac.cxx", "fl_color_win32.cxx", Â				"fl_dnd_mac.cxx", "fl_dnd_win32.cxx", "fl_dnd_x.cxx", "fl_draw_image_mac.cxx", Â				"fl_draw_image_win32.cxx", "fl_font_mac.cxx", "fl_font_win32.cxx", "fl_font_x.cxx", Â				"fl_font_xft.cxx", "Fl_get_key_mac.cxx", "Fl_get_key_win32.cxx", "Fl_mac.cxx", Â				"fl_read_image_mac.cxx", "fl_read_image_win32.cxx", "fl_set_fonts_mac.cxx", Â				"fl_set_fonts_win32.cxx", "fl_set_fonts_x.cxx", "fl_set_fonts_xft.cxx", Â				"fl_set_gray.cxx", "Fl_Sys_Menu_Bar.cxx", "Fl_win32.cxx", "scandir_win32.c"})}))		set pCPlusPlusExt to saveCppExt				-- Plugin's automatically have fltk and plugin features.		-- Plugins and DLL's must be after statics and DLL's they depend on.				set SeqObjects to {"seq", "seqalign", "seqblock", "seqcode", "seqfeat", "seqloc", "seqres", "seqset"}		set SomeObjects to {"biblio", "general", "medline", "pub"}		set MostObjects to SeqObjects & SomeObjects & Â			{"dbapi_driver", "id1", "xobjmgr", "xobjutil"}		set XUtils to {"xconnect", "xncbi", "xser", "xutil"}		set UsualStatics to MostObjects & XUtils				-- gui_core ( contains:  xgbplugin, gui_core)		set gui_core_files to {Â			mkFileDataListFiles(gSourceDir & "gui:plugin", {"plugin__", "plugin___"}), Â			GuiFileData("gui:core")}		set gui_core_data to ProjectData("gui_core", {"DLL", "fltk", "libdl"}, gui_core_files)		AddProject(DataPlusLibs(gui_core_data, UsualStatics & {"gui_dlg_entry_form", "gui_opengl", "submit", "w_toplevel", "fltk"}, {}))				AddPlugin("gui_algo_align", {}, "plugins:algo:align", Â			UsualStatics & {"xalgo"})		AddPlugin("gui_algo_basic", {}, "plugins:algo:basic", Â			UsualStatics)		AddPlugin("gui_algo_stdio", {}, "plugins:algo:stdio", Â			{})				AddPlugin("gui_doc_basic", {}, "plugins:doc:basic", Â			UsualStatics & {"submit"})		AddPlugin("gui_doc_table", {}, "plugins:doc:table", Â			UsualStatics)				AddPlugin("gui_view_align", {}, "plugins:view:align", Â			UsualStatics & Â			{"gui_opengl", "gui_utils", "w_aln_crossaln", "w_aln_dotmatrix", "w_flek", "w_seq_info", "xalnmgr"})		AddPlugin("gui_view_graphic", {}, "plugins:view:graphic", Â			UsualStatics & Â			{"gui_dlg_feature", "gui_opengl", "gui_utils", "submit", "w_flek", "w_seq_icon", "w_seq_info"})		AddPlugin("gui_view_sequence", {}, "plugins:view:sequence", Â			UsualStatics & Â			{"gui_opengl", "gui_utils", "submit", "w_seq", "w_seq_icon", "w_seq_info"})		AddPlugin("gui_view_table", {}, "plugins:view:table", Â			UsualStatics & Â			{"gui_utils", "w_flek", "w_table"})		AddPlugin("gui_view_text", {}, "plugins:view:text", Â			UsualStatics & Â			{"gbseq", "gui_dlg_entry_form", "xalnmgr", "xflat", "xgbplugin"})			end if	end SetProjectData--  Set Global variableson IsOSX()	tell application "Finder"		set vers to the version as text		if second character of vers is equal to "." then			set vers to "0" & vers		end if		return vers > 10 or vers = 10	end tellend IsOSXon HomeDir()	tell application "Finder"		return the home as string	end tellend HomeDiron ResolveAlias(pathname)	tell application "Finder"		if exists folder pathname then			-- if pathname does not end with ":" then set pathname to pathname & ":"			return folder pathname as string		end if		if exists alias file pathname then return the original item of alias file pathname as string	end tell	return ""end ResolveAliason ModuleRoot()	set modRoot to ""	try		set modRoot to ResolveAlias(pRootFolderPath & pRootFolderName)	end try	if modRoot is "" then		set modRoot to ResolveAlias(gHomeDir & pRootFolderName)	end if	return modRootend ModuleRooton IsFltkFolder(aFolder, findit)	set aFolder to ResolveAlias(aFolder)	if aFolder is "" then return ""	set pfolder to POSIX path of aFolder	if findit then		set aFltkRoot to do shell script ("ls -1r " & pfolder & "*/src/Fl.cxx | head -1")	else		set aFltkRoot to do shell script ("ls -1r " & pfolder & "src/Fl.cxx | head -1")	end if	if aFltkRoot is "" then return ""	set aFltkRoot to (POSIX file aFltkRoot) as string	set text item delimiters of AppleScript to ":"	set aFltkRoot to (text items 1 thru -3 of aFltkRoot) as string	set text item delimiters of AppleScript to ""	return aFltkRoot & ":"end IsFltkFolderon FLTKRoot()	-- look where specified.	set aFltkRoot to IsFltkFolder(pFLTKRootFolder, false)	if aFltkRoot is "" then		-- look next to the C++ toolkit directory.		set aFltkRoot to IsFltkFolder(pRootFolderPath, true)		if aFltkRoot is "" then			-- look in our home directory.			set aFltkRoot to IsFltkFolder(gHomeDir, true)		end if	end if	if aFltkRoot is "" and pCreateGuiLibs then		set pCreateGuiLibs to false		display dialog "Warning: Can't find FLTK. Not creating Gui libraries." with icon caution	end if	return aFltkRootend FLTKRooton GetMyPath()	set myPath to path to me as string	if myPath contains "Script Editor" then		-- Oops! running under script editor. 'me' is Script Editor not this script.		-- use the location this script is supposed to be in.		return gDistribRoot & "compilers:mac_prj"	else		tell application "Finder"			return container of myPath		end tell	end ifend GetMyPathon SetGlobals()	tell application "Finder"				set gProjectData to {}				set gHomeDir to my HomeDir()		set gDistribRoot to my ModuleRoot()		set gIncludeDir to gDistribRoot & "include:"		set gSourceDir to gDistribRoot & "src:"		set gProjectsDir to gDistribRoot & "compilers:mac_prj:lib:"		set gLibsDir to gProjectsDir		set gRsrcsDir to gDistribRoot & "compilers:mac_prj:"		set gMakeDir to my GetMyPath()		set gFLTKRootFolder to my FLTKRoot()	end tellend SetGlobalson HeaderExists(header, headerDir)	tell application "Finder"		if headerDir is "" then set headerDir to folder gIncludeDir		return exists file header of headerDir	end tellend HeaderExistson IsOlderThan(fileA, fileB)	tell application "Finder"		return (the modification date of fileA < the modification date of fileB)	end tellend IsOlderThanon UpdateRenameHeader(canonicalName, canonicalDir, dotHName, dotHDir)	tell application "Finder"				set needRename to (dotHName is not "")		if not needRename then set dotHName to canonicalName		if dotHDir is "" then set dotHDir to folder gIncludeDir				-- This file is only present if the script was interrupted.		if needRename and my HeaderExists(canonicalName, dotHDir) then			delete file canonicalName of dotHDir		end if				-- The native config file.		-- If it's missing, assume this is a prepared distribution and the header is already up-to-date.		if not my HeaderExists(canonicalName, canonicalDir) then return		set canonicalFile to file canonicalName of canonicalDir				set needCopy to true		if my HeaderExists(dotHName, dotHDir) then			set dotHFile to file dotHName of dotHDir			if my IsOlderThan(dotHFile, canonicalFile) then				delete dotHFile			else				set needCopy to false			end if		end if				if needCopy then			duplicate canonicalFile to dotHDir			if needRename then set name of file canonicalName of dotHDir to dotHName		end if			end tellend UpdateRenameHeaderon UpdateHeader(headerName, headerDir)	UpdateRenameHeader(headerName, headerDir, "", "")end UpdateHeaderon CopyHeaders()	tell application "Finder"				set confFolder to folder "compilers" of folder (my ModuleRoot())		set prefixFolder to folder "mac_prj" of confFolder				my UpdateRenameHeader("ncbiconf.mac", confFolder, "ncbiconf.h", "")		if pCreateGuiLibs then			my UpdateRenameHeader("fltk-config.h", prefixFolder, "config.h", folder gFLTKRootFolder)		end if				my UpdateHeader("debug.pfx", prefixFolder)		my UpdateHeader("release.pfx", prefixFolder)		my UpdateHeader("Carbon-debug.pfx", prefixFolder)		my UpdateHeader("Carbon-release.pfx", prefixFolder)		my UpdateHeader("Carbon-debugMSL.pfx", prefixFolder)		my UpdateHeader("Carbon-releaseMSL.pfx", prefixFolder)		my UpdateHeader("ncbi_mslextras.h", prefixFolder)			end tellend CopyHeaderson SetAccessPath(aPath, isRecursive, isUserPath)	tell application "CodeWarrior IDE"		if (aPath does not end with ":") then set aPath to aPath & ":"				set aPath to POSIX path of aPath		set pathsToAdd to {{name:aPath, recursive:isRecursive, origin:root relative, root:"OS X Volume", format:Unix Path}}		if isUserPath then			Set Preferences of panel "Access Paths" to {User Paths:pathsToAdd}		else			Set Preferences of panel "Access Paths" to {System Paths:pathsToAdd}		end if	end tellend SetAccessPathon SetupTarget(proj, targetIndex)	tell application "CodeWarrior IDE"				set targetName to name of target targetIndex of project document 1		set targetAPI to "Mach-O"		if targetName contains "Carbon" then			return -- we are not supporting Carbon Libs.		end if				if targetName contains "Debug" then			set targetDebug to true			if pCreateProfiledTargets then				set targetProfile to true			else				set targetProfile to false			end if		else -- if targeName contains "Final" then			set targetDebug to false			set targetProfile to false		end if				set libtype to "BSD"		if targetName contains "MSL" then			set libtype to "MSL"		end if				-- NOTE: no Profile targets. if pCreateProfiledTargets, we make the debug targets also profile-able.		-- and currently MW doesn't let you profile Mach-O targets!				set the current target of project document 1 to target targetIndex of project document 1				-- initialize variables		set projRsrcs to {}		set projFeatures to {}		set sysPaths to {}				-- Grab the fields of our project record and store them in local variables.		set projName to proj's name		set projSettings to proj's settings		try			set projFeatures to proj's features		end try		try			set sysPaths to proj's sysPaths		end try		try			set projRsrcs to proj's rsrcs		end try		set projLibs to proj's projLibs		set dynaLibs to proj's dynaLibs		set projFileData to proj's fileData				-- Figure out what our output file and input libraries will be named.		set fileNameSuffix to ""				if libtype is "MSL" then			set fileNameSuffix to "_" & libtype		end if				-- Debug or not.		if not targetDebug then			set fileNameSuffix to fileNameSuffix & "_O" -- for Optimized.		else			set fileNameSuffix to fileNameSuffix & "_D"		end if				-- non debug targets get different output names.		set targetFilename to projName & fileNameSuffix				-- make sure target files have the right extension.		if projFeatures contains "DLL" then			set targetFilename to targetFilename & pDynaLibExt		else if projFeatures contains "plugin" then			set targetFilename to "lib" & targetFilename & pPluginExt		else			set targetFilename to targetFilename & pStaticLibExt		end if				-- Get Preference Panel names.		if targetAPI is "Mach-O" then			set targetPanelName to "PPC Mac OS X Project"			set codeGenPanelName to "PPC CodeGen Mach-O"		end if				-- Set the name of the output file (the application)		Set Preferences of panel targetPanelName to {File Name:targetFilename}				if projFeatures contains "DLL" then			Set Preferences of panel targetPanelName to {Install Path:(POSIX path of gProjectsDir)}		end if		-- If we have any per-project override settings, set them.		if (count ppcProject of projSettings) > 0 then			Set Preferences of panel targetPanelName to ppcProject of projSettings		end if				if projFeatures contains "fltk" or projFeatures contains "fltklib" then			my SetAccessPath(gFLTKRootFolder & "FL:", false, true)			my SetAccessPath(gFLTKRootFolder, false, false)		end if				-- Are we assuming a .c or a .cpp extension?		if projFeatures contains "C++" then			set fileExtension to pCPlusPlusExt		else			set fileExtension to ".c"		end if			end tell		-- Add source files	repeat with group in projFileData		set projPath to projPath of group -- projPath is absolute,  not relative.		my SetAccessPath(projPath, true, true) -- add this folder to the access paths, as a recursive user path.				set fileList to group's fileList				set filesToAdd to {}		repeat with i in fileList			if i does not contain "." then set i to i & fileExtension			try -- ignore it if the file doesn't exist.								-- NOTE: if the following line is within a tell "Codewarrior" block then				--  the following Add Files command will fail.				copy alias (projPath & i) to end of filesToAdd			end try		end repeat				tell application "CodeWarrior IDE"			Add Files filesToAdd						-- Take out source files that do not belong.			set fileNotList to group's fileNotList			Remove Files fileNotList		end tell	end repeat		my SetAccessPath(gDistribRoot & "include:", true, false)		tell application "CodeWarrior IDE"				-- take care of debugging and profiling settings		if targetDebug then			set the debug of every target file of target targetIndex Â				of project document 1 to true		end if				-- Add user libraries.		set filesToAdd to {}		repeat with i in projLibs			copy gLibsDir & i & fileNameSuffix & pStaticLibExt to end of filesToAdd		end repeat		repeat with i in dynaLibs			copy gLibsDir & i & fileNameSuffix & pDynaLibExt to end of filesToAdd		end repeat				if projFeatures contains "libdl" then			copy "/usr/lib/libdl.a" to end of filesToAdd		end if				try			Add Files filesToAdd		on error errmsg number errnum			-- ignore errors when none of those libraries exist.			-- happens when populating a target when we haven't built any of the libraries for that target spec.			if errnum is not 9393 then error errmsg number errnum		end try				-- Add resources.		set filesToAdd to {}		repeat with i in projRsrcs			copy gRsrcsDir & i to end of filesToAdd		end repeat				Add Files filesToAdd				Reset File Paths			end tellend SetupTargeton CreateFolder(folderPath)	set text item delimiters of AppleScript to ":"	-- strip off disk name.	set folderPath to (rest of text items of folderPath) as string	set pathSoFar to ""	tell application "Finder"		repeat with f in (text items of folderPath)			set longerPath to pathSoFar & ":" & f			if not (exists folder (longerPath)) then				make new folder at folder (pathSoFar) with properties {name:f}			end if			set pathSoFar to longerPath		end repeat	end tell	set text item delimiters of AppleScript to ""end CreateFolderon CreateProject(proj)	tell application "CodeWarrior IDE"		try			get proj's name		on error			return		end try				set projFilename to proj's name & pProjectFileExt		set projPathname to gProjectsDir & projFilename		if pAlwaysCreateProjects or not (exists file projPathname of application "Finder") then						try				close (the first project document whose name is projFilename)			end try						set stationeryName to my GetStationeryName(proj)						try				tell application "Finder" to delete file (gProjectsDir & ".DS_Store")			end try			Create Project projPathname from stationery alias stationeryName			if the name of window 1 is "Project Messages" then				close first window -- "close window 1" becomes "Close Window 1" (different event)			end if						repeat with i from 1 to (count targets of project document 1)				my SetupTarget(proj, i)			end repeat			set the current target of project document 1 to target 1 of project document 1						Close Project		end if	end tellend CreateProjecton CreateAndBuildAllProjects()	CreateFolder(gProjectsDir)	set targetSpecs to GetTargetSpecs()		repeat with proj in gProjectData		CreateProject(proj)		if pShouldBuild then			try				set projName to proj's name			on error				return			end try			BuildProject(projName, targetSpecs)		end if	end repeat	end CreateAndBuildAllProjects(*	a target spec is a string of words "MSL Debug", all of which appear on our list of keywords.	Convert a Build file name to a target spec by filtering out non-keywords.	Each Build file creates another target spec.	A project target must match one of the target specs to compile.	To match, a target's name must contain each of the words in the target spec.	An empty target spec matches everything.	An empty list of target specs (no Build files) matches nothing, but		we make sure that won't happen.*)on GetTargetSpecs()	set theFiles to list folder (gMakeDir) without invisibles	set targetSpecs to {}	repeat with f in theFiles		if (f begins with "Build ") then			set targetSpecs to targetSpecs & MakeTargetSpec(f)		end if	end repeat	-- no Build files? match everything.	if (count items of targetSpecs) is 0 then		set targetSpecs to {""}	end if	return targetSpecsend GetTargetSpecson MakeTargetSpec(f)	set tspec to ""	repeat with w in (words of f)		if pTargetKeyWords contains w then			set tspec to tspec & w & " "		end if	end repeat	return tspecend MakeTargetSpecon OkaytoBuild(targetName, targetSpecs)	repeat with ts in targetSpecs		if MatchSpec2Target(ts, targetName) then return true	end repeat	return falseend OkaytoBuildon MatchSpec2Target(targSpec, targName)	repeat with w in (words of targSpec)		if w is not in targName then return false	end repeat	return trueend MatchSpec2Targeton BuildProject(projName, targetSpecs)	tell application "CodeWarrior IDE"		open (gProjectsDir & projName & pProjectFileExt)		if the name of window 1 is "Project Messages" then			close first window -- "close window 1" becomes "Close Window 1" (different event)		end if		repeat with i from 1 to (count targets of project document 1)			-- do we want to build this target?			set thisTarget to name of target i of project document 1			if my OkaytoBuild(thisTarget, targetSpecs) then								set the current target of project document 1 to target i of project document 1				Make Project				-- If there were compiler warnings, then a compiler window will be in front.				-- For whatever reason, this causes the next "set the current target..." to fail.				-- So check for the window and close it.				if the name of window 1 is "Errors & Warnings" then					close first window -- "close window 1" becomes "Close Window 1" (different event)				end if			end if		end repeat		set the current target of project document 1 to target 1 of project document 1		Close Project	end tellend BuildProjecton GetStationeryName(proj)	if proj's features contains "DLL" then		set stationeryDir to gProjectsDir & pDylibStationeryName & ":"		set stationeryName to pDylibStationeryName & pProjectFileExt	else if proj's features contains "plugin" then		set stationeryDir to gProjectsDir & pPluginStationeryName & ":"		set stationeryName to pPluginStationeryName & pProjectFileExt	else		set stationeryDir to gProjectsDir & pStationeryName & ":"		set stationeryName to pStationeryName & pProjectFileExt	end if		CreateFolder(stationeryDir)	tell application "Finder"		-- does the Library Stationery already exist?		if not (exists file (stationeryDir & stationeryName)) then			-- copy it.			duplicate file (stationeryName) of folder gRsrcsDir to folder stationeryDir		end if	end tell	my CleanupFolder(stationeryDir, stationeryName)	try		tell application "Finder" to delete file (stationeryDir & ".DS_Store")	end try		return (stationeryDir & stationeryName)end GetStationeryName-- Delete everything in the folder 'thePath' except the saveFile.on CleanupFolder(thePath, saveFile)	repeat with f in list folder (thePath) with invisibles		if (f as string is not saveFile) then			try				tell application "Finder" to delete folder (thePath & f)			end try			try				tell application "Finder" to delete file (thePath & f)			end try		end if	end repeatend CleanupFolderon CleanupFiles(thePath)	-- get rid of all the files and folders starting with 'trashme' in thePath	repeat with f in list folder (thePath) without invisibles		if ((f as string) begins with "trashme") then			try				tell application "Finder" to delete folder (thePath & f)			end try			try				tell application "Finder" to delete file (thePath & f)			end try		end if	end repeat	-- delete the stationery folders.	try		tell application "Finder" to delete folder (gProjectsDir & pStationeryName)		tell application "Finder" to delete folder (gProjectsDir & pPluginStationeryName)		tell application "Finder" to delete folder (gProjectsDir & pDylibStationeryName)	end tryend CleanupFileson SignalCompletion()	beepend SignalCompletionwith timeout of 60000 seconds		if not my IsOSX() then		error "Only supported on Mac OSX systems. Sorry!"	end if	SetGlobals()	SetProjectData()	CopyHeaders()		tell application "CodeWarrior IDE" to activate		CreateAndBuildAllProjects()		CleanupFiles(gProjectsDir)		SignalCompletion()	end timeout