

-- C++ libs --

property pRootFolderName : "ncbi_cxx" -- name of the toolkit directory
property pRootFolderPath : "" -- full path of the parent of the toolkit directory. Optional
property pFLTKRootFolder : "" -- full path of the FLTK directory. Optional.
property pBdbRootFolder : "" -- full path of the BDB source folder. Optional.
property pSqliteRootFolder : "" -- full path of the Sqlite source folder. Optional
property pDLRootFolder : "sw:" -- root folder for the dlcompat library & header file. Usually sw: or usr:.

property pSaveContinueOnErrors : false
-- true if we want to save compilation errors in a file and continue.
-- false if we want to stop on an error.

property pProjectFileExt : ".mcp"
property pAppExt : ".app"
property pCPlusPlusExt : ".cpp"
property pStaticLibExt : ".lib"
property pPluginExt : ".so"
property pDynaLibExt : ".dylib"

-- Whether to recreate existing project files.
property pAlwaysCreateProjects : false

-- whether to refresh the files and libraries in existing projects
property pUpdateExistingProjects : true

-- Whether to have the projects use CVS or not.
property pProjectsCVSEnabled : true

-- But profiling doesn't work for Mach-O Codewarrior projects currently.
property pCreateProfiledTargets : false

-- Whether to compile anything.
property pShouldBuild : true

-- Whether to create projects in the specified category.
property pCreateCoreLibs : true
property pCreateSocketLibs : true (* whether to create/compile socket libs *)
property pCreateObjectLibs : true (* whether to create/compile object libraries *)
property pCreateObjToolsLibs : true
property pCreateGuiLibs : true
property pCreatePluginLibs : true

property pStationeryName : "LibraryStationery"
property pPluginStationeryName : "PluginStationery"
property pDylibStationeryName : "DLLStationery"

property pTargetKeyWords : {"BSD", "MSL", "Final", "Debug"}
property pDefaultTargets : {"BSD", "Debug"}

--
--  Set Global variables
--

global gHomeDir
global gDistribRoot
global gProjectsDir
global gPluginsDir
global gSourceDir
global gIncludeDir
global gRsrcsDir
global gMakeDir
global gLibsDir
global gFLTKRootFolder
global gBdbRootFolder
global gSqliteSrcFolder -- where sqlite source is located.
global gSqliteRootFolder -- sqlite install folder.  (not source).


global gProjectData

on ProjectData(projName, features, aFileData)
	
	if (count characters of projName) > 25 then
		set projName to characters 1 through 25 of projName as string
	end if
	
	tell application "CodeWarrior IDE"
		
		if features does not contain "C" and features does not contain "C++" then
			copy "C++" to end of features
		end if
		set myFeatures to features
		
		return {name:projName, features:myFeatures, rsrcs:{}, settings:Â
			{Prefix File:"", ppcProject:{}}, projLibs:{}, dynaLibs:{}, sysPaths:{}, fileData:Â
			aFileData}
		
	end tell
end ProjectData

on AddProject(projData)
	copy projData to end of gProjectData
end AddProject

on AddSimpleProject(projName, features, section)
	AddProject(ProjectData(projName, features, {mkFileData(gSourceDir & section)}))
end AddSimpleProject

on AddSimpleProjectListFiles(projName, features, section, fileList)
	AddProject(ProjectData(projName, features, {mkFileDataListFiles(gSourceDir & section, fileList)}))
end AddSimpleProjectListFiles

on AddSimpleProjectExceptFiles(projName, features, section, fileNotList)
	AddProject(ProjectData(projName, features, {mkFileDataExceptFiles(gSourceDir & section, fileNotList)}))
end AddSimpleProjectExceptFiles

on mkFileData(fullPath)
	if (fullPath does not end with ":") then set fullPath to fullPath & ":"
	return {projPath:fullPath, fileList:GetFileNames(fullPath), fileNotList:{}}
end mkFileData

on mkFileDataListFiles(fullPath, fileList)
	if (fullPath does not end with ":") then set fullPath to fullPath & ":"
	return {projPath:fullPath, fileList:fileList, fileNotList:{}}
end mkFileDataListFiles

on mkFileDataExceptFiles(fullPath, fileNotList)
	if (fullPath does not end with ":") then set fullPath to fullPath & ":"
	set theFileList to GetFileNames(fullPath)
	set theRealFileList to {}
	repeat with f in theFileList
		if fileNotList does not contain f then
			copy f to the end of theRealFileList
		end if
	end repeat
	return {projPath:fullPath, fileList:theRealFileList, fileNotList:fileNotList}
end mkFileDataExceptFiles

on ObjectFileData(objName, extraFileList)
	set projPath to "objects:" & objName
	set projFiles to {objName & "__", objName & "___"} & extraFileList
	return mkFileDataListFiles(gSourceDir & projPath, projFiles)
end ObjectFileData

on ObjectsFileData(nameList)
	set fileData to {}
	repeat with f in nameList
		copy ObjectFileData(f, {}) to end of fileData
	end repeat
	return fileData
end ObjectsFileData

on ObjectData(objName, extraFileList)
	return ProjectData(objName, {}, {ObjectFileData(objName, extraFileList)})
end ObjectData

on AddObject(projName)
	AddProject(ObjectData(projName, {}))
end AddObject

on GuiFileData(section)
	if section does not start with "gui:" then
		set section to "gui:" & section
	end if
	-- Get all the files, minus those whose basename ends with an underscore.
	set fileData to mkFileData(gSourceDir & section)
	set newFileList to {}
	repeat with f in fileList of fileData
		if f does not end with ("_" & pCPlusPlusExt) then
			copy f as string to end of newFileList
		end if
	end repeat
	set fileList of fileData to newFileList
	return fileData
end GuiFileData

on GuiFileDataExcept(section, notFiles)
	if section does not start with "gui:" then
		set section to "gui:" & section
	end if
	-- Get all the files, minus those whose basename ends with an underscore.
	set fileData to mkFileDataExceptFiles(gSourceDir & section, notFiles)
	set newFileList to {}
	repeat with f in fileList of fileData
		if f does not end with ("_" & pCPlusPlusExt) then
			copy f as string to end of newFileList
		end if
	end repeat
	set fileList of fileData to newFileList
	return fileData
end GuiFileDataExcept

on GuiFileDataList(section, fileList)
	if section does not start with "gui:" then
		set section to "gui:" & section
	end if
	return mkFileDataListFiles(gSourceDir & section, fileList)
end GuiFileDataList

on GuiProjectData(projName, features, section)
	if features does not contain "fltk" then
		copy "fltk" to end of features
	end if
	return (ProjectData(projName, features, {GuiFileData(section)}))
end GuiProjectData

on AddGuiProject(projName, features, section)
	AddProject(GuiProjectData(projName, features, section))
end AddGuiProject

on AddPlugin(projName, features, section, staticLibs)
	if features does not contain "plugin" then set features to features & {"plugin"}
	set projData to GuiProjectData(projName, features, section)
	AddProject(DataPlusLibs(projData, staticLibs, {"gui_core"}))
end AddPlugin

on DataPlusSources(dataRec, newSrcs)
	repeat with i in newSrcs
		copy i to end of fileList of item 1 of fileData of dataRec
	end repeat
	return dataRec
end DataPlusSources

on DataPlusLibs(dataRec, newLibs, newDlls)
	repeat with i in newLibs
		copy i to end of projLibs of dataRec
	end repeat
	repeat with i in newDlls
		copy i to end of dynaLibs of dataRec
	end repeat
	return dataRec
end DataPlusLibs

on HideFolder(folderPath)
	tell application "Finder"
		if exists folder folderPath then
			set theName to name of folder folderPath
			set name of folder folderPath to ("(" & theName & ")")
		end if
	end tell
end HideFolder

on GetFileNames(fullSourcePath)
	set theFiles to list folder (fullSourcePath) without invisibles
	set theCFiles to EndsWith(theFiles, ".c")
	set theCppFiles to EndsWith(theFiles, pCPlusPlusExt)
	return theCFiles & theCppFiles
end GetFileNames

on EndsWith(aList, suffix)
	set newList to {}
	repeat with f in aList
		if (f ends with suffix) then
			copy (f as string) to end of newList
		end if
	end repeat
	return newList
end EndsWith

on SetProjectData()
	
	if pCreateCoreLibs then
		AddSimpleProjectExceptFiles("xncbi", {"libdl"}, "corelib", {"test_mt.cpp", "ncbi_os_mac.cpp"})
		AddSimpleProjectExceptFiles("xcgi", {}, "cgi", {"fcgi_run.cpp", "fcgibuf.cpp"})
		AddSimpleProject("dbapi", {}, "dbapi")
		AddSimpleProject("dbapi_driver", {}, "dbapi:driver")
		AddSimpleProject("xhtml", {}, "html")
		AddSimpleProjectListFiles("xcser", {}, "serial", {"asntypes.cpp", "serialasn.cpp"})
		AddSimpleProjectExceptFiles("xser", {}, "serial", Â
			{"asntypes.cpp", "object.cpp", "objstrb.cpp", "rtti.cpp", "serialasn.cpp"})
		
		AddSimpleProject("xutil", {}, "util")
		AddSimpleProject("regexp", {}, "util:regexp")
		AddSimpleProject("ximage", {}, "util:image")
		AddSimpleProjectExceptFiles("z", {}, "util:compress:zlib", Â
			{"example.c", "maketree.c", "minigzip.c"})
		AddSimpleProjectListFiles("bz2", {}, "util:compress:bzip2", Â
			{"blocksort.c", "huffman.c", "crctable.c", "randtable.c", "compress.c", "decompress.c", "bzlib.c"})
		AddSimpleProject("xcompress", {}, "util:compress")
		AddSimpleProjectListFiles("tables", {}, "util:tables", {"raw_scoremat.c"})
		AddSimpleProject("sequtil", {}, "util:sequtil")
		
		AddSimpleProject("bdb", {"bdb"}, "bdb")
		
		AddSimpleProject("xalgoalign", {}, "algo:align")
		AddSimpleProject("xalgoseq", {}, "algo:sequence")
		AddSimpleProject("xalgognomon", {}, "algo:gnomon")
		set xblastfiles to {Â
			mkFileDataExceptFiles(gSourceDir & "algo:blast:api", {"db_blast.cpp"}), Â
			mkFileData(gSourceDir & "algo:blast:core") Â
				}
		AddProject(ProjectData("xblast", {}, xblastfiles))
		AddSimpleProject("blast", {}, "algo:blast:core")
		
		AddSimpleProject("xsqlite", {"sqlite"}, "sqlite")
		
		set libdbFiles to {Â
			mkFileData(gBdbRootFolder & "btree"), Â
			mkFileDataExceptFiles(gBdbRootFolder & "common", {"util_arg.c"}), Â
			mkFileData(gBdbRootFolder & "crypto"), Â
			mkFileData(gBdbRootFolder & "crypto:mersenne"), Â
			mkFileData(gBdbRootFolder & "crypto:rijndael"), Â
			mkFileData(gBdbRootFolder & "db"), Â
			mkFileData(gBdbRootFolder & "dbm"), Â
			mkFileData(gBdbRootFolder & "dbreg"), Â
			mkFileData(gBdbRootFolder & "env"), Â
			mkFileData(gBdbRootFolder & "fileops"), Â
			mkFileData(gBdbRootFolder & "hash"), Â
			mkFileData(gBdbRootFolder & "hmac"), Â
			mkFileData(gBdbRootFolder & "hsearch"), Â
			mkFileData(gBdbRootFolder & "lock"), Â
			mkFileData(gBdbRootFolder & "log"), Â
			mkFileData(gBdbRootFolder & "mp"), Â
			mkFileDataListFiles(gBdbRootFolder & "mutex", {"mutex.c", "mut_pthread.c"}), Â
			mkFileData(gBdbRootFolder & "os"), Â
			mkFileData(gBdbRootFolder & "qam"), Â
			mkFileData(gBdbRootFolder & "rep"), Â
			mkFileData(gBdbRootFolder & "txn"), Â
			mkFileData(gBdbRootFolder & "xa")}
		AddProject(ProjectData("libdb", {"bdblib"}, libdbFiles))
	end if
	
	if pCreateSocketLibs then
		-- Not needed or wanted under Mach-O
		-- my HideFolder(gSourceDir & "connect:mitsock")
		
		AddSimpleProjectExceptFiles("xconnect", {}, "connect", Â
			{"ncbi_lbsm_ipc.c", "ncbi_lbsm.c", "ncbi_lbsmd.c", "threaded_server.cpp"})
		AddSimpleProjectListFiles("xthrserv", {}, "connect", {"threaded_server.cpp"})
	end if
	
	if pCreateObjectLibs then
		AddObject("access")
		AddObject("biblio")
		AddSimpleProjectListFiles("xnetblast", {}, "objects:blast", {"blast__", "blast___"})
		AddSimpleProjectListFiles("xnetblastcli", {}, "objects:blast", {"blastclient", "blastclient_"})
		AddObject("blastdb")
		AddObject("cdd")
		AddObject("cn3d")
		AddObject("docsum")
		AddObject("entrez2")
		AddSimpleProjectListFiles("entrez2cli", {}, "objects:entrez2", {"entrez2_client", "entrez2_client_"})
		AddObject("entrezgene")
		AddObject("featdef")
		AddObject("gbseq")
		AddObject("general")
		AddObject("id1")
		AddSimpleProjectListFiles("id1cli", {}, "objects:id1", {"id1_client", "id1_client_"})
		AddObject("id2")
		AddObject("medlars")
		AddObject("medline")
		AddObject("mim")
		AddObject("mla")
		AddSimpleProjectListFiles("mlacli", {}, "objects:mla", {"mla_client", "mla_client_"})
		AddProject(ProjectData("mmdb", {}, ObjectsFileData({"mmdb1", "mmdb2", "mmdb3"})))
		AddObject("mmdb1")
		AddObject("mmdb2")
		AddObject("mmdb3")
		AddObject("ncbimime")
		AddObject("objprt")
		AddObject("proj")
		AddObject("pub")
		AddObject("pubmed")
		AddObject("scoremat")
		-- combine in seq: seq, seqalign, seqblock, seqfeat, seqloc, seqres
		set seqFileData to {Â
			ObjectFileData("seq", {"gencode", "seqport_util"}), Â
			ObjectFileData("seqalign", {}), Â
			ObjectFileData("seqblock", {}), Â
			ObjectFileData("seqfeat", {}), Â
			ObjectFileData("seqloc", {}), Â
			ObjectFileData("seqres", {})}
		AddProject(ProjectData("seq", {}, seqFileData))
		
		AddObject("seqset")
		AddObject("seqcode")
		AddObject("submit")
		AddProject(ObjectData("taxon1", {"cache", "ctreecont", "taxon1", "utils"}))
		AddObject("tinyseq")
	end if
	
	if pCreateObjToolsLibs then
		AddSimpleProject("xobjmgr", {}, "objmgr")
		AddSimpleProject("xobjutil", {}, "objmgr:util")
		AddSimpleProject("xalnmgr", {}, "objtools:alnmgr")
		AddSimpleProject("xcddalignview", {}, "objtools:cddalignview")
		AddSimpleProject("xflat", {}, "objtools:flat")
		AddSimpleProject("lds", {}, "objtools:lds")
		AddSimpleProject("lds_admin", {}, "objtools:lds:admin")
		AddSimpleProject("xvalidate", {}, "objtools:validator")
		AddSimpleProject("xobjmanip", {}, "objtools:manip")
		AddSimpleProject("xobjread", {}, "objtools:readers")
		AddSimpleProject("xformat", {}, "objtools:format")
		
		AddSimpleProject("ncbi_xloader_lds", {}, "objtools:data_loaders:lds")
		AddSimpleProject("ncbi_xloader_table", {}, "objtools:data_loaders:table")
		-- AddSimpleProject("ncbi_xloader_blastdb", {}, "objtools:data_loaders:blastdb") 	-- needs bsd? ctools?
		AddSimpleProject("xloader_cdd", {}, "objtools:data_loaders:cdd")
	end if
	
	-- GUI libs.
	if pCreateGuiLibs then
		-- GuiProject's automatically have 'fltk' feature.
		
		AddGuiProject("gui_utils", {}, "utils")
		-- AddGuiProject("gui_config", {}, "config")
		AddProject(ProjectData("gui_config", {"fltk"}, Â
			{GuiFileDataList("config", {"feat_config.cpp", "settings_set.cpp", "feat_color.cpp", "feat_config_list.cpp", "feat_show.cpp", "theme_set.cpp", "config___.cpp", "config__.cpp"})}))
		
		AddGuiProject("gui_dlg_entry_form", {}, "dialogs:entry_form")
		AddGuiProject("gui_multi_col_dlg", {}, "dialogs:col")
		AddGuiProject("gui_dlg_registry", {}, "dialogs:registry")
		AddGuiProject("gui_dlg_progress", {}, "dialogs:progress")
		AddGuiProject("gui_dlg_config", {}, "dialogs:config")
		-- AddGuiProject("gui_dlg_feature", {}, "dialogs:feature") -- empty
		-- AddGuiProject("gui_dlg_general", {}, "dialogs:general") -- currently empty?
		AddGuiProject("gui_opengl", {}, "opengl")
		AddGuiProject("gui_graph", {}, "graph")
		AddGuiProject("gui_print", {}, "print")
		
		-- widgets
		AddGuiProject("w_fltk", {}, "widgets:fl")
		AddGuiProject("w_gl", {}, "widgets:gl")
		AddGuiProject("w_aln_crossaln", {}, "widgets:aln_crossaln")
		AddGuiProject("w_aln_dotmatrix", {}, "widgets:aln_dotmatrix")
		-- AddGuiProject("w_aln_multi", {}, "widgets:aln_multiple")
		AddProject(ProjectData("w_aln_multi", {"fltk"}, Â
			{GuiFileDataExcept("widgets:aln_multiple", {"alnmulti_base_pane.cpp", "alnmulti_edit_pane.cpp"})}))
		AddGuiProject("w_aln_data", {}, "widgets:aln_data")
		AddGuiProject("w_aln_text", {}, "widgets:aln_textaln")
		AddGuiProject("w_flu", {}, "widgets:FLU")
		AddGuiProject("w_seq_graphic", {}, "widgets:seq_graphic")
		AddGuiProject("w_toplevel", {}, "widgets:toplevel")
		AddGuiProject("w_fltable", {}, "widgets:Fl_Table")
		AddGuiProject("w_hit_matrix", {}, "widgets:hit_matrix")
		AddGuiProject("w_taxtree", {}, "widgets:tax_tree")
		-- AddGuiProject("w_flek", {}, "widgets:Flek") -- use w_fltk instead.
		-- AddGuiProject("w_seq", {}, "widgets:seq") -- empty
		--AddGuiProject("w_seq_icon", {}, "widgets:seq_icon") -- empty
		--AddGuiProject("w_seq_info", {}, "widgets:seq_info") -- empty
		-- AddGuiProject("w_table", {}, "widgets:table") -- merged into w_fltk
		
		-- FLTK library.
		set saveCppExt to pCPlusPlusExt
		set pCPlusPlusExt to ".cxx"
		AddProject(ProjectData("fltk", {"fltklib"}, {mkFileDataExceptFiles(gFLTKRootFolder & "src", Â
			{"cmap.cxx", "dump_compose.c", "fl_color_mac.cxx", "fl_color_win32.cxx", Â
				"fl_dnd_mac.cxx", "fl_dnd_win32.cxx", "fl_dnd_x.cxx", "fl_draw_image_mac.cxx", Â
				"fl_draw_image_win32.cxx", "fl_font_mac.cxx", "fl_font_win32.cxx", "fl_font_x.cxx", Â
				"fl_font_xft.cxx", "Fl_get_key_mac.cxx", "Fl_get_key_win32.cxx", "Fl_mac.cxx", Â
				"fl_read_image_mac.cxx", "fl_read_image_win32.cxx", "fl_set_fonts_mac.cxx", Â
				"fl_set_fonts_win32.cxx", "fl_set_fonts_x.cxx", "fl_set_fonts_xft.cxx", Â
				"fl_set_gray.cxx", "Fl_Sys_Menu_Bar.cxx", "Fl_win32.cxx", "scandir_win32.c"})}))
		set pCPlusPlusExt to saveCppExt
		
	end if
	
	if pCreatePluginLibs then
		
		-- Plugin's automatically have fltk and plugin features.
		-- Plugins and DLL's must be after statics and DLL's they depend on.
		
		set SeqObjects to {"seq", "seqcode", "seqset", "sequtil"}
		set SomeObjects to {"biblio", "general", "medline", "pub", "entrez2", "entrez2cli"}
		set MostObjects to SeqObjects & SomeObjects & Â
			{"dbapi_driver", "id1", "id2", "xobjmgr", "xobjutil"}
		set ObjTools to {"xconnect", "xncbi", "xser", "xutil", "xobjread", "xalnmgr", "regexp", "tables"}
		set LdsLibs to {"bdb", "lds", "lds_admin", "libdb"}
		set CompressLibs to {"z", "bz2", "xcompress"}
		set UsualStatics to MostObjects & ObjTools
		
		-- gui_core ( contains:  xgbplugin, gui_core)
		set gui_core_files to {Â
			GuiFileDataList("gui:plugin", {"plugin__.cpp", "plugin___.cpp"}), Â
			GuiFileData("gui:core")}
		set gui_core_data to ProjectData("gui_core", {"DLL", "fltk", "libdl"}, gui_core_files)
		
		AddProject(DataPlusLibs(gui_core_data, UsualStatics & LdsLibs & CompressLibs & {"gui_dlg_entry_form", "gui_utils", "gui_config", "gui_dlg_config", "gui_opengl", "ximage", "submit", "w_toplevel", "w_fltk", "w_flu", "w_fltable", "gui_print", "fltk"}, {}))
		
		-- PLUGINS --
		
		-- Basic/Required plugins
		AddPlugin("gui_doc_basic", {}, "plugins:doc:basic", Â
			{"xflat", "ncbi_xloader_lds", "gbseq"})
		AddPlugin("gui_ncbi_init", {}, "plugins:algo:init", {"ncbi_xloader_lds"})
		AddPlugin("gui_algo_basic", {}, "plugins:algo:basic", Â
			{"xalgoseq", "gui_multi_col_dlg", "xloader_cdd", "cdd", "scoremat", "cn3d", "mmdb"})
		
		-- Algorithm plugins
		AddPlugin("gui_algo_align", {}, "plugins:algo:align", {"xalgoalign", "scoremat", "xblast", "xnetblast", "xnetblastcli", "gui_dlg_progress"})
		AddPlugin("gui_algo_validator", {}, "plugins:algo:validator", {"xvalidate"})
		AddProject(DataPlusLibs(ProjectData("gui_algo_external", Â
			{"plugin", "fltk", "libdl"}, Â
			{mkFileData(gSourceDir & "gui:plugins:algo:external"), Â
				mkFileDataListFiles(gSourceDir & "gui:plugins:algo:basic", {"output_dlg.cpp"})}), Â
			{"xalgoseq", "xcgi"}, {"gui_core"}))
		AddPlugin("gui_algo_gnomon", {}, "plugins:algo:gnomon", Â
			{"xalgognomon", "gui_multi_col_dlg"})
		-- AddPlugin("gui_algo_blast", {}, "plugins:algo:blast", {"xblast"}) -- empty.
		-- AddPlugin("gui_net_blast", {}, "plugins:algo:net_blast", {"scoremat", "xalgoalign", "xnetblast", "xnetblastcli"}) - empty
		-- AddPlugin("gui_algo_external", {}, "plugins:algo:external", {"xalgoseq", "xcgi"})
		
		-- Document plugins
		--  
		AddPlugin("gui_doc_table", {"sqlitelib"}, "plugins:doc:table", Â
			{"xsqlite", "ncbi_xloader_table", "xobjmanip"})
		
		-- View plugins
		AddPlugin("gui_view_align", {}, "plugins:view:align", Â
			{"w_aln_crossaln", "w_aln_dotmatrix", "w_aln_multi", "w_aln_data", "gui_graph", "w_gl", "w_hit_matrix", "w_seq_graphic"})
		AddPlugin("gui_view_graphic", {}, "plugins:view:graphic", Â
			{"gui_dlg_feature", "w_seq_graphic", "w_gl"})
		-- AddPlugin("gui_view_sequence", {}, "plugins:view:sequence",  {}) -- empty
		
		AddPlugin("gui_view_table", {}, "plugins:view:table", Â
			{})
		AddPlugin("gui_view_text", {}, "plugins:view:text", Â
			{"gbseq", "xflat", "xformat", "taxon1", "w_taxtree"})
		AddPlugin("gui_view_validator", {}, "plugins:view:validator", {"gbseq", "xvalidate"})
		
	end if
	
end SetProjectData


--  Set Global variables

on IsOSX()
	tell application "Finder"
		set vers to the version as text
		if second character of vers is equal to "." then
			set vers to "0" & vers
		end if
		return vers > 10 or vers = 10
	end tell
end IsOSX

on HomeDir()
	tell application "Finder"
		return the home as string
	end tell
end HomeDir

on ResolveAlias(pathname)
	tell application "Finder"
		if exists folder pathname then
			-- if pathname does not end with ":" then set pathname to pathname & ":"
			return folder pathname as string
		end if
		if exists alias file pathname then return the original item of alias file pathname as string
	end tell
	return ""
end ResolveAlias

on ModuleRoot()
	set modRoot to ""
	try
		set modRoot to ResolveAlias(pRootFolderPath & pRootFolderName)
	end try
	if modRoot is "" then
		set modRoot to ResolveAlias(gHomeDir & pRootFolderName)
	end if
	return modRoot
end ModuleRoot

-- number of directories in a Posix path.
on PathLength(aPath)
	set {stid, text item delimiters of AppleScript} to {text item delimiters of AppleScript, "/"}
	set n to length of (text items of aPath)
	set text item delimiters of AppleScript to stid
	return n
end PathLength

on IsSpecialFolder(aFolder, findit, filePattern)
	set aFolder to ResolveAlias(aFolder)
	if aFolder is "" then return ""
	set pfolder to POSIX path of aFolder
	if findit then
		set aRootFolder to do shell script ("ls -1r " & pfolder & "*/" & filePattern & " | head -1")
	else
		set aRootFolder to do shell script ("ls -1r " & pfolder & filePattern & " | head -1")
	end if
	if aRootFolder is "" then return ""
	set aRootFolder to (POSIX file aRootFolder) as string
	set lastDirIndex to (PathLength(filePattern) + 1)
	set text item delimiters of AppleScript to ":"
	set aRootFolder to (text items 1 thru -lastDirIndex of aRootFolder) as string
	set text item delimiters of AppleScript to ""
	return aRootFolder & ":"
end IsSpecialFolder

on FindSpecialFolder(default, pattern)
	-- look where specified.
	set aSpecialFolder to IsSpecialFolder(default, false, pattern)
	if aSpecialFolder is "" then
		-- look next to the C++ toolkit directory.
		set aSpecialFolder to IsSpecialFolder(pRootFolderPath, true, pattern)
	end if
	if aSpecialFolder is "" then
		-- look IN the C++ toolkit directory.
		set aSpecialFolder to IsSpecialFolder(gDistribRoot, true, pattern)
	end if
	if aSpecialFolder is "" then
		-- look in our home directory.
		set aSpecialFolder to IsSpecialFolder(gHomeDir, true, pattern)
	end if
	return aSpecialFolder
end FindSpecialFolder

on FindSqlite()
	set gSqliteSrcFolder to my FindSpecialFolder(pSqliteRootFolder, "src/sqlite.h.in")
	if gSqliteSrcFolder is "" then
		return ""
	end if
	set sqliteLibsFolder to (gLibsDir & "sqlite:")
	return sqliteLibsFolder
end FindSqlite


on BuildSqlite()
	if gSqliteSrcFolder is "" then
		return
	end if
	
	CreateFolder(gLibsDir)
	-- shell script command name
	set makeCommand to "sh " & POSIX path of (gMakeDir & "makesqlite")
	-- command arguments:
	-- source directory
	set makeCommand to makeCommand & " " & (POSIX path of gSqliteSrcFolder)
	-- build directory
	set makeCommand to makeCommand & " " & (POSIX path of (gLibsDir & "sqlite-build"))
	-- install directory
	set sqliteLibsFolder to (gLibsDir & "sqlite:")
	set makeCommand to makeCommand & " " & (POSIX path of sqliteLibsFolder)
	
	try
		do shell script makeCommand without altering line endings
	on error errmsg number errnum
		if pSaveContinueOnErrors then
			-- copy results into an error file.
			set sqliteErrFileName to gProjectsDir & "sqlitelib.errs"
			try
				tell application "Finder" to delete file sqliteErrFileName
			end try
			set sqliteErrFile to open for access sqliteErrFileName with write permission
			write errmsg to sqliteErrFile
			close access sqliteErrFile
		else
			-- display results and stop.
			error "Errors building sqlite: " & return & errmsg number errnum
		end if
	end try
	-- return the standard output of the script which should be the install directory.
	return
end BuildSqlite


on GetMyPath()
	set myPath to path to me as string
	if myPath contains "Script Editor" or Â
		myPath contains "osascript" or Â
		myPath contains "Smile.app" then
		-- Oops! running under script editor. 'me' is Script Editor not this script.
		-- use the location this script is supposed to be in.
		return gDistribRoot & "compilers:mac_prj:"
	else
		tell application "Finder"
			return (container of myPath as string) & ":"
		end tell
	end if
end GetMyPath

on SetGlobals()
	tell application "Finder"
		
		set gProjectData to {}
		
		set gHomeDir to my HomeDir()
		set gDistribRoot to my ModuleRoot()
		set gIncludeDir to gDistribRoot & "include:"
		set gSourceDir to gDistribRoot & "src:"
		set gProjectsDir to gDistribRoot & "compilers:mac_prj:lib:"
		set gPluginsDir to gDistribRoot & "compilers:mac_prj:plugins:"
		set gLibsDir to gProjectsDir
		set gRsrcsDir to gDistribRoot & "compilers:mac_prj:"
		set gMakeDir to my GetMyPath()
		set gFLTKRootFolder to my FindSpecialFolder(pFLTKRootFolder, "src/Fl.cxx")
		if gFLTKRootFolder is "" and pCreateGuiLibs then
			set pCreateGuiLibs to false
			set pCreatePluginLibs to false
			display dialog "Warning: Can't find FLTK. (download from www.fltk.org into your home directory or C++ toolkit directory). Not creating Gui libraries." with icon caution
		end if
		set gBdbRootFolder to my FindSpecialFolder(pBdbRootFolder, "dbinc/db_int.in")
		if gBdbRootFolder is "" then
			display dialog "Can't find bdb. (download from http://www.sleepycat.com/ into your home directory or C++ toolkit directory). Some libraries will fail to build." with icon caution
		end if
		set gSqliteRootFolder to my FindSqlite()
		if gSqliteRootFolder is "" then
			display dialog "Can't find sqlite. (download from http://www.sqlite.org/ into your home or C++ toolkit directory). Some plugins may fail to build." with icon caution
		end if
	end tell
end SetGlobals

on HeaderExists(header, headerDir)
	tell application "Finder"
		if headerDir is "" then set headerDir to folder gIncludeDir
		return exists file header of headerDir
	end tell
end HeaderExists

on IsOlderThan(fileA, fileB)
	tell application "Finder"
		return (the modification date of fileA < the modification date of fileB)
	end tell
end IsOlderThan

on UpdateRenameHeader(canonicalName, canonicalDir, dotHName, dotHDir)
	tell application "Finder"
		
		set needRename to (dotHName is not "")
		if not needRename then set dotHName to canonicalName
		if dotHDir is "" then set dotHDir to folder gIncludeDir
		
		-- This file is only present if the script was interrupted.
		if needRename and my HeaderExists(canonicalName, dotHDir) then
			delete file canonicalName of dotHDir
		end if
		
		-- The native config file.
		-- If it's missing, assume this is a prepared distribution and the header is already up-to-date.
		if not my HeaderExists(canonicalName, canonicalDir) then return
		set canonicalFile to file canonicalName of canonicalDir
		
		set needCopy to true
		if my HeaderExists(dotHName, dotHDir) then
			set dotHFile to file dotHName of dotHDir
			if my IsOlderThan(dotHFile, canonicalFile) then
				delete dotHFile
			else
				set needCopy to false
			end if
		end if
		
		if needCopy then
			duplicate canonicalFile to dotHDir
			if needRename then set name of file canonicalName of dotHDir to dotHName
		end if
		
	end tell
end UpdateRenameHeader

on UpdateHeader(headerName, headerDir)
	UpdateRenameHeader(headerName, headerDir, "", "")
end UpdateHeader

on CopyHeaders()
	tell application "Finder"
		
		set confFolder to folder "compilers" of folder (my ModuleRoot())
		set prefixFolder to folder "mac_prj" of confFolder
		
		-- my UpdateRenameHeader("ncbiconf.mac", confFolder, "ncbiconf.h", "")
		if gFLTKRootFolder is not "" then
			my UpdateRenameHeader("fltk-config.h", prefixFolder, "config.h", folder gFLTKRootFolder)
		end if
		
		my UpdateHeader("db.h", prefixFolder)
		my UpdateHeader("db_int.h", prefixFolder)
		my UpdateHeader("db_config.h", prefixFolder)
		
		my UpdateHeader("debug.pfx", prefixFolder)
		my UpdateHeader("release.pfx", prefixFolder)
		my UpdateHeader("Carbon-debug.pfx", prefixFolder)
		my UpdateHeader("Carbon-release.pfx", prefixFolder)
		my UpdateHeader("Carbon-debugMSL.pfx", prefixFolder)
		my UpdateHeader("Carbon-releaseMSL.pfx", prefixFolder)
		my UpdateHeader("ncbi_mslextras.h", prefixFolder)
		
	end tell
end CopyHeaders

on AppendAccessPath(aPath, isRecursive, isUserPath)
	tell application "CodeWarrior IDE"
		if (aPath does not end with ":") then set aPath to aPath & ":"
		
		set aPath to POSIX path of aPath
		set pathsToAdd to {{name:aPath, recursive:isRecursive, origin:root relative, root:"OS X Volume", format:Unix Path}}
		if isUserPath then
			Set Preferences of panel "Access Paths" to {User Paths:pathsToAdd}
		else
			Set Preferences of panel "Access Paths" to {System Paths:pathsToAdd}
		end if
	end tell
end AppendAccessPath

on PushAccessPath(aPath, isRecursive, isUserPath)
	tell application "CodeWarrior IDE"
		if (aPath does not end with ":") then set aPath to aPath & ":"
		
		set aPath to POSIX path of aPath
		set pathToAdd to {name:aPath, recursive:isRecursive, origin:root relative, root:"OS X Volume", format:Unix Path}
		if isUserPath then
			set newPaths to Get Preferences of {User Paths} from panel "Access Paths"
			copy pathToAdd to beginning of User Paths of newPaths
			Set Preferences of panel "Access Paths" to {User Paths:{}}
			Set Preferences of panel "Access Paths" to newPaths
		else
			set newPaths to Get Preferences of {System Paths} from panel "Access Paths"
			copy pathToAdd to beginning of System Paths of newPaths
			Set Preferences of panel "Access Paths" to {System Paths:{}}
			Set Preferences of panel "Access Paths" to newPaths
		end if
	end tell
end PushAccessPath

on SetupTarget(proj, targetIndex)
	tell application "CodeWarrior IDE"
		
		set targetName to name of target targetIndex of project document 1
		set targetAPI to "Mach-O"
		if targetName contains "Carbon" then
			return -- we are not supporting Carbon Libs.
		end if
		
		if targetName contains "Debug" then
			set targetDebug to true
			if pCreateProfiledTargets then
				set targetProfile to true
			else
				set targetProfile to false
			end if
		else -- if targeName contains "Final" then
			set targetDebug to false
			set targetProfile to false
		end if
		
		set libtype to "BSD"
		if targetName contains "MSL" then
			set libtype to "MSL"
		end if
		
		-- NOTE: no Profile targets. if pCreateProfiledTargets, we make the debug targets also profile-able.
		-- and currently MW doesn't let you profile Mach-O targets!
		
		set the current target of project document 1 to target targetIndex of project document 1
		
		-- initialize variables
		set projRsrcs to {}
		set projFeatures to {}
		set sysPaths to {}
		
		-- Grab the fields of our project record and store them in local variables.
		set projName to proj's name
		set projSettings to proj's settings
		try
			set projFeatures to proj's features
		end try
		try
			set sysPaths to proj's sysPaths
		end try
		try
			set projRsrcs to proj's rsrcs
		end try
		set projLibs to proj's projLibs
		set dynaLibs to proj's dynaLibs
		set projFileData to proj's fileData
		
		-- Figure out what our output file and input libraries will be named.
		set fileNameSuffix to ""
		
		if libtype is "MSL" then
			set fileNameSuffix to "_" & libtype
		end if
		
		-- Debug or not.
		if not targetDebug then
			set fileNameSuffix to fileNameSuffix & "_O" -- for Optimized.
		else
			set fileNameSuffix to fileNameSuffix & "_D"
		end if
		
		-- non debug targets get different output names.
		set targetFilename to projName & fileNameSuffix
		
		-- make sure target files have the right extension.
		if projFeatures contains "DLL" then
			set targetFilename to targetFilename & pDynaLibExt
		else if projFeatures contains "plugin" then
			set targetFilename to "lib" & targetFilename & pPluginExt
		else
			set targetFilename to targetFilename & pStaticLibExt
		end if
		
		-- Get Preference Panel names.
		if targetAPI is "Mach-O" then
			set targetPanelName to "PPC Mac OS X Project"
			set codeGenPanelName to "PPC CodeGen Mach-O"
		end if
		
		-- Set the name of the output file (the application)
		Set Preferences of panel targetPanelName to {File Name:targetFilename}
		
		if projFeatures contains "DLL" then
			Set Preferences of panel targetPanelName to {Install Path:(POSIX path of gProjectsDir)}
		end if
		-- If we have any per-project override settings, set them.
		if (count ppcProject of projSettings) > 0 then
			Set Preferences of panel targetPanelName to ppcProject of projSettings
		end if
		
		if projFeatures contains "fltk" or projFeatures contains "fltklib" then
			my AppendAccessPath(gFLTKRootFolder & "FL:", false, true)
			my AppendAccessPath(gFLTKRootFolder, false, false)
		end if
		if projFeatures contains "bdblib" then
			my AppendAccessPath(gDistribRoot & "include:", false, true)
			my AppendAccessPath(gBdbRootFolder, true, true)
		end if
		if projFeatures contains "bdb" then
			my PushAccessPath(gDistribRoot & "include:", false, false)
		end if
		if projFeatures contains "sqlite" then
			my AppendAccessPath(gSqliteRootFolder & "include:", false, false)
		end if
		if projFeatures contains "sqlitelib" then
			my AppendAccessPath(gSqliteRootFolder & "lib:", false, false)
		end if
		
		-- Are we assuming a .c or a .cpp extension?
		if projFeatures contains "C++" then
			set fileExtension to pCPlusPlusExt
		else
			set fileExtension to ".c"
		end if
		
	end tell
	
	-- Add source files
	repeat with group in projFileData
		set projPath to projPath of group -- projPath is absolute,  not relative.
		my AppendAccessPath(projPath, true, true) -- add this folder to the access paths, as a recursive user path.
		
		set fileList to group's fileList
		
		set filesToAdd to {}
		repeat with i in fileList
			if i does not contain "." then set i to i & fileExtension
			try -- ignore it if the file doesn't exist.
				
				-- NOTE: if the following line is within a tell "Codewarrior" block then
				--  the following Add Files command will fail.
				copy alias (projPath & i) to end of filesToAdd
				-- Set the file's type so CW will have less problems with it.
				tell application "Finder"
					set file type of file (projPath & i) to "TEXT"
					set creator type of file (projPath & i) to "CWIE"
				end tell
			end try
		end repeat
		
		tell application "CodeWarrior IDE"
			Add Files filesToAdd
			
			-- Take out source files that do not belong.
			set fileNotList to group's fileNotList
			Remove Files fileNotList
		end tell
	end repeat
	
	my AppendAccessPath(gDistribRoot & "include:", true, false)
	
	tell application "CodeWarrior IDE"
		
		-- take care of debugging and profiling settings
		if targetDebug then
			set the debug of every target file of target targetIndex Â
				of project document 1 to true
		end if
		
		-- Add user libraries.
		set filesToAdd to {}
		repeat with i in projLibs
			if exists file (gLibsDir & i & fileNameSuffix & pStaticLibExt) of application "Finder" then
				copy (gLibsDir & i & fileNameSuffix & pStaticLibExt) to end of filesToAdd
			end if
		end repeat
		repeat with i in dynaLibs
			if exists file (gLibsDir & i & fileNameSuffix & pDynaLibExt) of application "Finder" then
				copy (gLibsDir & i & fileNameSuffix & pDynaLibExt) to end of filesToAdd
			end if
		end repeat
		
		if projFeatures contains "libdl" then
			my PushAccessPath(pDLRootFolder & "include", false, false)
			if projFeatures contains "DLL" or projFeatures contains "plugin" then
				my PushAccessPath(pDLRootFolder & "lib", false, false)
				copy (POSIX path of pDLRootFolder) & "lib/libdl.a" to end of filesToAdd
			end if
		end if
		
		--try
		Add Files filesToAdd
		--on error errmsg number errnum
		-- ignore errors when none of those libraries exist.
		-- happens when populating a target when we haven't built any of the libraries for that target spec.
		--if errnum is not 9393 then error errmsg number errnum
		--end try
	end tell
	
	-- add sqlite libraries.
	if projFeatures contains "sqlitelib" and Â
		projFeatures contains "DLL" or projFeatures contains "plugin" then
		set filesToAdd to {}
		copy "/usr/lib/libcc_dynamic.a" to end of filesToAdd
		copy gSqliteRootFolder & "lib:libsqlite.a" to end of filesToAdd
		-- display dialog filesToAdd
		tell application "CodeWarrior IDE"
			Add Files filesToAdd
		end tell
	end if
	
	-- Add resources.
	set filesToAdd to {}
	repeat with i in projRsrcs
		copy gRsrcsDir & i to end of filesToAdd
	end repeat
	
	tell application "CodeWarrior IDE"
		Add Files filesToAdd
		
		Reset File Paths
	end tell
end SetupTarget


on GetTargetFiles(i)
	tell application "CodeWarrior IDE"
		-- get the target
		if (i > (count of targets of project document 1)) then
			return {}
		end if
		-- get references to all the targets files
		set atarget to get target i of project document 1
		set trefs to (target files of atarget whose linked is true)
	end tell
	set tfiles to {}
	if ((count of trefs) ­ 0) then
		repeat with tf in trefs
			-- get locations of the targets files (as file objects)
			tell application "CodeWarrior IDE"
				set f to (location of tf)
			end tell
			tell application "Finder"
				-- convert the file's to strings (colon style paths)
				try
					copy f as string to end of tfiles
				on error errmsg number errnum
					-- file in target but does not exist.
					if errnum ­ -2753 then -- variable not defined.
						error errmsg number errnum
					end if
				end try
			end tell
		end repeat
	end if
	return tfiles
end GetTargetFiles

on UpdateTarget(proj, targetIndex)
	tell application "CodeWarrior IDE"
		
		set targetName to name of target targetIndex of project document 1
		
		if targetName contains "Debug" then
			set targetDebug to true
		else -- if targeName contains "Final" then
			set targetDebug to false
		end if
		
		set libtype to "BSD"
		if targetName contains "MSL" then
			set libtype to "MSL"
		end if
		
		set the current target of project document 1 to target targetIndex of project document 1
		
		-- initialize variables
		set projFeatures to {}
		
		-- Grab the fields of our project record and store them in local variables.
		try
			set projFeatures to proj's features
		end try
		set projLibs to proj's projLibs
		set dynaLibs to proj's dynaLibs
		set projFileData to proj's fileData
		
		-- Figure out what our output file and input libraries will be named.
		set fileNameSuffix to ""
		
		if libtype is "MSL" then
			set fileNameSuffix to "_" & libtype
		end if
		
		-- Debug or not.
		if not targetDebug then
			set fileNameSuffix to fileNameSuffix & "_O" -- for Optimized.
		else
			set fileNameSuffix to fileNameSuffix & "_D"
		end if
		
		-- Are we assuming a .c or a .cpp extension?
		if projFeatures contains "C++" then
			set fileExtension to pCPlusPlusExt
		else
			set fileExtension to ".c"
		end if
		
	end tell
	
	-- Update source files
	set targetFileList to my GetTargetFiles(targetIndex)
	repeat with group in projFileData
		set projPath to projPath of group -- projPath is absolute,  not relative.
		
		set fileList to group's fileList
		
		set filesToAdd to {}
		
		repeat with i in fileList
			if i does not contain "." then set i to i & fileExtension
			set fileFullPath to projPath & i
			set found to targetFileList contains fileFullPath
			if (not found) then
				--try -- ignore it if the file doesn't exist.
				
				-- NOTE: if the following line is within a tell "Codewarrior" block then
				--  the following Add Files command will fail.
				
				copy alias fileFullPath to end of filesToAdd
				--end try
			end if
		end repeat
		
		tell application "CodeWarrior IDE"
			if ((count of filesToAdd) is not 0) then
				--display dialog filesToAdd
				Add Files filesToAdd
				set targetFileList to my GetTargetFiles(targetIndex)
			end if
			
			-- Take out source files that do not belong.
			set fileNotList to group's fileNotList
			Remove Files fileNotList
		end tell
	end repeat
	
	-- Update libraries
	set filesToAdd to {}
	repeat with i in projLibs
		set i to gLibsDir & i & fileNameSuffix & pStaticLibExt
		set found to targetFileList contains i
		if (not found) and (exists file (i) of application "Finder") then
			copy (i) to end of filesToAdd
		end if
	end repeat
	
	repeat with i in dynaLibs
		set i to gLibsDir & i & fileNameSuffix & pDynaLibExt
		set found to targetFileList contains i
		if (not found) and (exists file (i) of application "Finder") then
			copy (i) to end of filesToAdd
		end if
	end repeat
	
	
	tell application "CodeWarrior IDE"
		if ((count of filesToAdd) is not 0) then
			Add Files filesToAdd
			-- set targetFileList to my GetTargetFiles(targetIndex)
		end if
		
		Reset File Paths
		
	end tell
	
end UpdateTarget

on CreateFolder(folderPath)
	set text item delimiters of AppleScript to ":"
	-- strip off disk name.
	set folderPath to (rest of text items of folderPath) as string
	set pathSoFar to ""
	tell application "Finder"
		repeat with f in (text items of folderPath)
			set longerPath to pathSoFar & ":" & f
			if not (exists folder (longerPath)) then
				make new folder at folder (pathSoFar) with properties {name:f}
			end if
			set pathSoFar to longerPath
		end repeat
	end tell
	set text item delimiters of AppleScript to ""
end CreateFolder

on CreateProject(proj)
	tell application "CodeWarrior IDE"
		try
			get proj's name
		on error
			return
		end try
		
		set projFilename to proj's name & pProjectFileExt
		set projPathname to gProjectsDir & projFilename
		set openedProject to false
		if pAlwaysCreateProjects or not (exists file projPathname of application "Finder") then
			
			try
				close (the first project document whose name is projFilename)
			end try
			
			set stationeryName to my GetStationeryName(proj)
			
			try
				tell application "Finder" to delete file (gProjectsDir & ".DS_Store")
			end try
			Create Project projPathname from stationery alias stationeryName
			set openedProject to false
			if the name of window 1 is "Project Messages" then
				close first window -- "close window 1" becomes "Close Window 1" (different event)
			end if
			
			repeat with i from 1 to (count targets of project document 1)
				my SetupTarget(proj, i)
			end repeat
		else if pUpdateExistingProjects then
			-- project already exists. Make sure it has all right files.
			open (projPathname)
			set openedProject to false
			if the name of window 1 is "Project Messages" then
				close first window -- "close window 1" becomes "Close Window 1" (different event)
			end if
			repeat with i from 1 to (count targets of project document 1)
				my UpdateTarget(proj, i)
			end repeat
		end if
		if openedProject then
			if pProjectsCVSEnabled then
				--try
				Set Preferences of panel "VCS Setup" to {VCS Active:true, Connection Method:"mwCVS"}
				--end try
			end if
			set the current target of project document 1 to target 1 of project document 1
			Close Project
		end if
	end tell
end CreateProject

on CreateAndBuildAllProjects()
	CreateFolder(gProjectsDir)
	CreateFolder(gPluginsDir)
	CleanupFiles(gProjectsDir)
	set targetSpecs to GetTargetSpecs()
	
	my BuildSqlite()
	
	tell application "CodeWarrior IDE" to activate
	
	repeat with proj in gProjectData
		CreateProject(proj)
		if pShouldBuild then
			try
				set projName to proj's name
			on error
				return
			end try
			BuildProject(projName, targetSpecs)
		end if
	end repeat
	
end CreateAndBuildAllProjects

(*
	a target spec is a string of words "MSL Debug", all of which appear on our list of keywords.
	Convert a Build file name to a target spec by filtering out non-keywords.
	Each Build file creates another target spec.
	A project target must match one of the target specs to compile.
	To match, a target's name must contain each of the words in the target spec.
	An empty target spec matches everything.
	An empty list of target specs (no Build files) matches nothing, but
		we make sure that won't happen.
*)

on GetTargetSpecs()
	set theFiles to (list folder gMakeDir without invisibles)
	set targetSpecs to {}
	repeat with f in theFiles
		if (f begins with "Build ") then
			set targetSpecs to targetSpecs & MakeTargetSpec(f)
		end if
	end repeat
	-- no Build files? Ask what to build.
	if (count items of targetSpecs) is 0 then
		set targetSpecs to {AskForTargetSpec()}
	end if
	return targetSpecs
end GetTargetSpecs

on AskForTargetSpec()
	try
		choose from list pTargetKeyWords default items pDefaultTargets Â
			with prompt "Choose Target types to compile:" cancel button name "Build All" with multiple selections allowed
	on error errmsg number errnum
		if errnum is -1713 then -- no user interaction allowed.
			set targ to pDefaultTargets -- build defaults
		else
			error errmsg number errnum
		end if
	end try
	set targ to result
	if targ is false then -- cancel hit.
		return "" -- build all
	end if
	set {stid, text item delimiters of AppleScript} to {text item delimiters of AppleScript, " "}
	set targ to targ as string
	set text item delimiters of AppleScript to stid
	return targ
end AskForTargetSpec

on MakeTargetSpec(f)
	set tspec to ""
	repeat with w in (words of f)
		if pTargetKeyWords contains w then
			set tspec to tspec & w & " "
		end if
	end repeat
	return tspec
end MakeTargetSpec

on OkaytoBuild(targetName, targetSpecs)
	repeat with ts in targetSpecs
		if MatchSpec2Target(ts, targetName) then return true
	end repeat
	return false
end OkaytoBuild

on MatchSpec2Target(targSpec, targName)
	repeat with w in (words of targSpec)
		if w is not in targName then return false
	end repeat
	return true
end MatchSpec2Target


on BuildProject(projName, targetSpecs)
	tell application "CodeWarrior IDE"
		open (gProjectsDir & projName & pProjectFileExt)
		if the name of window 1 is "Project Messages" then
			close first window -- "close window 1" becomes "Close Window 1" (different event)
		end if
		repeat with i from 1 to (count targets of project document 1)
			-- do we want to build this target?
			set thisTarget to name of target i of project document 1
			if my OkaytoBuild(thisTarget, targetSpecs) then
				
				set the current target of project document 1 to target i of project document 1
				if pSaveContinueOnErrors then
					try
						Make Project
					on error errmsg number errnum
						if (errnum = 5) then
							set errFileName to (gProjectsDir & projName & "-" & i & ".errs")
							Save Error Window As (file errFileName)
							close first window
						else
							error errmsg number errnum
						end if
					end try
				else -- stop on any error.
					Make Project
				end if
				-- If there were compiler warnings, then a compiler window will be in front.
				-- For whatever reason, this causes the next "set the current target..." to fail.
				-- So check for the window and close it.
				if the name of window 1 is "Errors & Warnings" then
					close first window -- "close window 1" becomes "Close Window 1" (different event)
				end if
			end if
		end repeat
		set the current target of project document 1 to target 1 of project document 1
		Close Project
	end tell
end BuildProject


on GetStationeryName(proj)
	if proj's features contains "DLL" then
		set stationeryDir to gProjectsDir & pDylibStationeryName & ":"
		set stationeryName to pDylibStationeryName & pProjectFileExt
	else if proj's features contains "plugin" then
		set stationeryDir to gProjectsDir & pPluginStationeryName & ":"
		set stationeryName to pPluginStationeryName & pProjectFileExt
	else
		set stationeryDir to gProjectsDir & pStationeryName & ":"
		set stationeryName to pStationeryName & pProjectFileExt
	end if
	
	CreateFolder(stationeryDir)
	tell application "Finder"
		-- does the Library Stationery already exist?
		if not (exists file (stationeryDir & stationeryName)) then
			-- copy it.
			duplicate file (stationeryName) of folder gRsrcsDir to folder stationeryDir
		end if
	end tell
	return (stationeryDir & stationeryName)
end GetStationeryName

on CleanupFiles(thePath)
	-- get rid of all the files and folders starting with 'trashme' in thePath
	repeat with f in list folder (thePath) without invisibles
		if ((f as string) begins with "trashme") then
			try
				tell application "Finder" to delete folder (thePath & f)
			end try
			try
				tell application "Finder" to delete file (thePath & f)
			end try
		end if
	end repeat
	-- delete the stationery folders.
	try
		tell application "Finder" to delete folder (thePath & pStationeryName)
	end try
	try
		tell application "Finder" to delete folder (thePath & pPluginStationeryName)
	end try
	try
		tell application "Finder" to delete folder (thePath & pDylibStationeryName)
	end try
end CleanupFiles

on SignalCompletion()
	beep
end SignalCompletion

with timeout of 60000 seconds
	
	if not my IsOSX() then
		error "Only supported on Mac OSX systems. Sorry!"
	end if
	SetGlobals()
	SetProjectData()
	CopyHeaders()
	
	CreateAndBuildAllProjects()
	
	CleanupFiles(gProjectsDir)
	
	SignalCompletion()
	
end timeout

