/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  Douglas J. Slotta
 *
 * File Description:
 *   Utility functions for Unimod
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using the following specifications:
 *   'unimod.dtd'.
 */

// standard includes
#include <ncbi_pch.hpp>
#include <corelib/ncbi_limits.h>
#include <math.h>

// generated includes
#include <algo/ms/formats/unimod/Unimod.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

BEGIN_unimod_SCOPE // namespace ncbi::objects::unimod::

// destructor
CUnimod::~CUnimod(void)
{
}


CRef<CMod> CUnimod::FindMod(int modnum) {
    if (m_modMap.empty()) {
        //m_modMap = new TModMap();
    
        const CModifications::TMod& mods = this->GetModifications().GetMod();
        ITERATE(CModifications::TMod, mod, mods) {
            int id = (*mod)->GetAttlist().GetRecord_id();
            m_modMap.insert( TModPair(id, *mod) );
        }
    }

    TModMap::iterator aMod;
    
    aMod = m_modMap.find(modnum);

    if (aMod != m_modMap.end()) {
        return aMod->second;
    }
    return null;
}

void CUnimod::ResetModMap() {
    m_modMap.clear();
}

bool CompMonoMass(CRef<CMod> a, CRef<CMod> b) {
    return (a->GetDelta().GetAttlist().GetMono_mass() < 
        b->GetDelta().GetAttlist().GetMono_mass());
}

bool CompAvgMass(CRef<CMod> a, CRef<CMod> b) {
    return (a->GetDelta().GetAttlist().GetAvge_mass() < 
        b->GetDelta().GetAttlist().GetAvge_mass());
}

void CUnimod::SetUseAverageMass(bool val) {
    CModifications::TMod::iterator begin, end;
    if (val) {
        m_useAverageMass = true;        
        m_comp = CompAvgMass;
    } else {
        m_useAverageMass = false;   
        m_comp = CompMonoMass;
    }

    begin = SetModifications().SetMod().begin();
    end = SetModifications().SetMod().end();
    sort(begin, end, *m_comp);
}

double CUnimod::GetModMass(CRef<CMod> mod) {
    if (m_useAverageMass) {
        return mod->GetDelta().GetAttlist().GetAvge_mass();
    } else {
        return mod->GetDelta().GetAttlist().GetMono_mass();    
    }
}

void CUnimod::SetModMass(CRef<CMod> mod, double mass) {
    if (m_useAverageMass) {
        mod->SetDelta().SetAttlist().SetAvge_mass(mass);
    } else {
        mod->SetDelta().SetAttlist().SetMono_mass(mass);
    }
}


CRef<CMod> CUnimod::MatchMod(double dmass, string name, string residues, double maxError) {
    CModifications::TMod::iterator begin, end, lower, upper, curMod;
    
    begin = SetModifications().SetMod().begin();
    end = SetModifications().SetMod().end();
    CRef<CMod> unkMod(new CMod);
    SetModMass(unkMod, dmass);
    lower = lower_bound(begin, end, unkMod, *m_comp);
    upper = upper_bound(begin, end, unkMod, *m_comp);
    if (lower==upper && (*lower)->isResidueSubset(residues)) {
        return (*lower);
    }
    double dmass_low, dmass_high;
    
    CRef<CMod> unkMod_low(new CMod);
    dmass_low = dmass - (dmass * maxError);
    SetModMass(unkMod_low, dmass_low);
    lower = lower_bound(begin, end, unkMod_low, *m_comp);

    CRef<CMod> unkMod_high(new CMod);
    dmass_high = dmass + (dmass * maxError);
    SetModMass(unkMod_high, dmass_high);
    upper = upper_bound(begin, end, unkMod_high, *m_comp);

    CRef<CMod> bestMod(new CMod);
    bestMod->SetAttlist().SetRecord_id(0);
    size_t bestDist = kMax_Int;
    double smallDev = kMax_Float;

    bool useEditDistance;
    if (name.length() > 0) useEditDistance = true;
    else useEditDistance = false;

    for (curMod = lower; curMod < upper; curMod++) {
        if ((*curMod)->isResidueSubset(residues)) {
            if (useEditDistance) {
                size_t ans = (*curMod)->name_distance(name);
            
                if (ans < bestDist) {
                    bestDist = ans;
                    bestMod = *curMod;
                }
            } else {
                double dev = fabs(dmass - GetModMass(*curMod));
                if (dev < smallDev) {
                    smallDev = dev;
                    bestMod = *curMod;
                }
            }
        }        
    }
    
    return bestMod;
}

END_unimod_SCOPE // namespace ncbi::objects::unimod::

END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/* Original file checksum: lines: 57, chars: 1721, CRC32: 30ce977a */
