/*  $Id$
* ===========================================================================
*
*                            PUBLIC DOMAIN NOTICE
*               National Center for Biotechnology Information
*
*  This software/database is a "United States Government Work" under the
*  terms of the United States Copyright Act.  It was written as part of
*  the author's official duties as a United States Government employee and
*  thus cannot be copyrighted.  This software/database is freely available
*  to the public for use. The National Library of Medicine and the U.S.
*  Government have not placed any restriction on its use or reproduction.
*
*  Although all reasonable efforts have been taken to ensure the accuracy
*  and reliability of the software and data, the NLM and the U.S.
*  Government do not and cannot warrant the performance or results that
*  may be obtained by using this software or data. The NLM and the U.S.
*  Government disclaim all warranties, express or implied, including
*  warranties of performance, merchantability or fitness for any particular
*  purpose.
*
*  Please cite the author in any work or product based on this material.
*
* ===========================================================================
*
* Author:  Michael Kornbluh, NCBI
*          (initial skeleton generated by script written by Pavel Ivanov)
*
* File Description:
*   Does misc tests on the CFastaReader that aren't already covered by
*   test_fasta_round_trip, etc.
*
*
* ===========================================================================
*/

#include <ncbi_pch.hpp>

#include <corelib/ncbi_system.hpp>
#include <corelib/ncbiapp.hpp>

// This header must be included before all Boost.Test headers if there are any
#include <corelib/test_boost.hpp>

#include <corelib/rwstream.hpp>
#include <corelib/stream_utils.hpp>
#include <corelib/ncbimisc.hpp>

#include <objects/seqset/Seq_entry.hpp>

#include <objtools/readers/fasta.hpp>

#include <objects/misc/sequence_macros.hpp>

#include <objmgr/seq_vector.hpp>

// for places where we don't care if it throws or not
#define IGNORE_ANY_THROWS(_body) try { ((_body), true); } catch(...) { }

USING_NCBI_SCOPE;
USING_SCOPE(objects);

namespace {

    // represents information about one test of the CFastaReader warning system
    struct SWarningTest {

        // Each SWarningTest has one SOneWarningsInfo for each
        // possible type of warning.
        // The index into warnings_expected must equal the m_eType
        // of that one.  m_eType is also for readability of array
        struct SOneWarningsInfo {
            enum EAppears {
                // start with 1 so that 0 is invalid and we catch it
                eAppears_MustNot = 1,
                eAppears_Must
            };

            CFastaReader::CWarning::EType m_eType;
            EAppears m_eAppears;
            int      m_iLineNumExpected; // 0 if doesn't appear or doesn't matter
        };
    
        string                m_sName; // easier than array index for humans to understand
        SOneWarningsInfo      m_warnings_expected[CFastaReader::CWarning::eType_NUM];
        CFastaReader::TFlags  m_fFastaFlags;
        string                m_sInputFASTA;
    };

    const static CFastaReader::TFlags kDefaultFastaReaderFlags = 
        CFastaReader::fAssumeNuc | 
        CFastaReader::fForceType;

    // list of FASTA warning tests
    const SWarningTest fasta_warning_test_arr[] = {
        { 
            "test case of no warnings",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah \n"
            "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "title too long",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_Must,    1 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ ABCDEFGHIJ\n"
            "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "nucs in title",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_Must,    1 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
            "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "too many ambig on first line",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_Must,    2 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah\n"
            "ACGTACGTACGTNNNNNNNNNNNNNNNTUYYYYYYYYYYYYYYYYYYYYYYYYYYTACGT\n"
        },

        {
            "invalid residue on first line",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_Must,    0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah\n"
            "ACEACGTAEEEACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "invalid residue on subsequent line",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_Must,    0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah\n"
            "ACGACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
            "ACEACGTACGTACGTAEETACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "amino acids in title",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_Must,    0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_Must,    1 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },

            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\n"
        },

        {
            "trigger as many warnings as possible",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_Must, 1 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_Must, 1 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_Must, 2 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_Must, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_Must, 1 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah [topology=linear] ACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTAC\n"
            "ACGACNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNGTEACGTACGTACGT\n"
        },

        {
            "invalid residue on multiple lines",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_Must,    0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah\n"
            "ACACEACGTACGTACGTEEEETACGTACGTACGTACGTACGTACGTA\n"
            "ACEACGTACGTACGTAEETACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "Make sure it reads modifiers if requested",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
                // Note: non-default flags
                CFastaReader::fAddMods | kDefaultFastaReaderFlags, // CFastaReader flags
                "> blah [topology=linear]\n"
                "ACACAACGTACGTACGTAAAATACGTACGTACGTACGTACGTACGTA\n"
                "ACAACGTACGTACGTAAATACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "Test unexpected mods on line other than first line",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_Must,    4 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
                kDefaultFastaReaderFlags, // CFastaReader flags
                ">blah \n"
                "ACACAACGTACGTACGTAAAATACGTACGTACGTACGTACGTACGTA\n"
                "ACAACGTACGTACGTAAATACGTACGTACGTACGTACGTACGTACGT\n"
                ">blahblah [topology=linear]\n"
                "TCACAACGTACGTACGTAAAATACGTACGTACGTACGTACGTACGTA\n"
                "ACAACGTACGTACGTAAATACGTACGTACGTACGTACGTACGTACGT\n"
                ">blahblah2 \n"
                "GCACAACGTACGTACGTAAAATACGTACGTACGTACGTACGTACGTA\n"
                "ACAACGTACGTACGTAAATACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "Test that we get a no-residues warning (1 seq).",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_Must,    1 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
                kDefaultFastaReaderFlags, // CFastaReader flags
                ">blah \n"
        },

        {
            "Test that we get a no-residues warning (multiple seqs).",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_Must,    3 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
                kDefaultFastaReaderFlags, // CFastaReader flags
                ">blah \n"
                "ACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
                ">blah2 \n"
                ">blah3 \n"
                "ACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "Test that having no residues is fine if the right flag is set.",

            {
                { CFastaReader::CWarning::eType_TitleTooLong,                SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_NucsInTitle,                 SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_TooManyAmbigOnFirstLine,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_InvalidResidue,              SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_AminoAcidsInTitle,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ModsFoundButNotExpected,     SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedSeqMissing,          SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_GapModsFoundButNoneExpected, SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExtraGapModsFound,           SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 },
                { CFastaReader::CWarning::eType_ExpectedGapModsMissing,      SWarningTest::SOneWarningsInfo::eAppears_MustNot, 0 }
            },
                kDefaultFastaReaderFlags | CFastaReader::fNoSeqData, // CFastaReader flags
                ">blah \n"
                ">blah2 \n"
                ">blah3 \n"
        }
    };
}

// Test that the right warnings appear under the right conditions
BOOST_AUTO_TEST_CASE(TestWarnings)
{
    // IF THIS FAILS, IT MEANS YOU NEED TO UPDATE THE TESTS!
    // ( this is here because the tests may need to be adjusted if
    //   the number of possible warnings changes. )
    BOOST_REQUIRE_EQUAL( CFastaReader::CWarning::eType_NUM, 10 );

    // sanity test the tests
    for( size_t warn_test_idx = 0; 
        warn_test_idx < ArraySize(fasta_warning_test_arr); 
        ++warn_test_idx )
    {
        for( size_t iTestNum = 0; 
            iTestNum < CFastaReader::CWarning::eType_NUM; 
            ++iTestNum ) 
        {
            const SWarningTest::SOneWarningsInfo & one_warning_info = 
                fasta_warning_test_arr[warn_test_idx].m_warnings_expected[iTestNum];

            // index must equal the EType
            BOOST_REQUIRE_EQUAL( one_warning_info.m_eType, iTestNum );
            BOOST_REQUIRE( 
                one_warning_info.m_eAppears == 
                    SWarningTest::SOneWarningsInfo::eAppears_Must ||
                one_warning_info.m_eAppears == 
                    SWarningTest::SOneWarningsInfo::eAppears_MustNot );

            // expected line num should be 0 if the warning isn't supposed to appear,
            // but this isn't a show-stopper.
            BOOST_CHECK( one_warning_info.m_eAppears == 
                    SWarningTest::SOneWarningsInfo::eAppears_Must ||
                    one_warning_info.m_iLineNumExpected == 0 );
        }
    }

    for( size_t warn_test_idx = 0; 
        warn_test_idx < ArraySize(fasta_warning_test_arr); 
        ++warn_test_idx )
    {
        const SWarningTest & warning_test = fasta_warning_test_arr[warn_test_idx];

        cout << endl;
        cout << "Running test case '" << warning_test.m_sName << "'" << endl;

        // this will hold warnings found
        CRef<CFastaReader::TWarningRefVec> pWarningRefVec( 
            new CFastaReader::TWarningRefVec );

        // create fasta reader
        CStringReader fastaStringReader( warning_test.m_sInputFASTA );
        CRStream fastaRStream( &fastaStringReader );
        CFastaReader fasta_reader( fastaRStream, warning_test.m_fFastaFlags );
        fasta_reader.SetWarningOutput( pWarningRefVec );

        // do the parsing
        BOOST_CHECK_NO_THROW( fasta_reader.ReadSet() );

        // make sure exactly the warnings that were supposed to appeared
        typedef map<CFastaReader::CWarning::EType, int> TMapWarningTypeToLineNum;
        TMapWarningTypeToLineNum mapWarningTypeToLineNum;

        // load the warnings that were seen into warningsSeenFromThisTest
        ITERATE( CFastaReader::TWarningRefVec::TObjectType, 
            warning_load_it, pWarningRefVec->GetData() ) 
        {
            // check if it already exists and has a different line num
            TMapWarningTypeToLineNum::const_iterator find_iter =
                mapWarningTypeToLineNum.find((*warning_load_it)->GetType());
            BOOST_CHECK_MESSAGE(
                ( find_iter == mapWarningTypeToLineNum.end() ) || 
                    ( find_iter->second == (*warning_load_it)->GetLineNum() ), 
                "On warning check " << warning_test.m_sName << '('
                << warn_test_idx << "): "
                << "Multiple warnings on different lines of type "
                << CFastaReader::CWarning::GetStringOfType(
                (*warning_load_it)->GetType()) );
            mapWarningTypeToLineNum.insert( 
                TMapWarningTypeToLineNum::value_type(
                    (*warning_load_it)->GetType(),
                    (*warning_load_it)->GetLineNum() ) );
        }

        // make sure we have exactly the warnings we're expecting
        for( size_t warning_check_idx = 0;
            warning_check_idx < ArraySize(warning_test.m_warnings_expected);
            ++warning_check_idx )
        {
            const SWarningTest::SOneWarningsInfo & one_warning_info = 
                warning_test.m_warnings_expected[warning_check_idx];
            const CFastaReader::CWarning::EType eExpectedType = 
                one_warning_info.m_eType;
            const bool bWarningShouldAppear = ( 
                one_warning_info.m_eAppears == SWarningTest::SOneWarningsInfo::eAppears_Must );
            const int iExpectedLineNum = one_warning_info.m_iLineNumExpected;

            // check whether warning does actually appear and
            // what line it's on
            bool bWarningDoesAppear = false;
            int  iWarningLineNum    = 0;
            TMapWarningTypeToLineNum::const_iterator find_iter =
                mapWarningTypeToLineNum.find( eExpectedType ); 
            if( find_iter != mapWarningTypeToLineNum.end() ) {
                bWarningDoesAppear = true;
                iWarningLineNum    = find_iter->second;
            }

            // check if warning does appear if it's supposed to,
            // or that it doesn't appear if it isn't supposed to
            BOOST_CHECK_MESSAGE( 
                bWarningShouldAppear == bWarningDoesAppear,
                "On warning check " << warning_test.m_sName << '('
                << warn_test_idx << "): "
                << "Type " << CFastaReader::CWarning::GetStringOfType(
                eExpectedType) << ": should "
                << (bWarningShouldAppear ? "": "not ") << "appear but "
                << "it does" << (bWarningDoesAppear ? "" : " not") );

            // check that line numbers match
            if( bWarningShouldAppear && bWarningDoesAppear &&
                iExpectedLineNum > 0 ) 
            {
                BOOST_CHECK_MESSAGE(
                    iExpectedLineNum == iWarningLineNum,
                    "On warning check " << warning_test.m_sName << '('
                    << warn_test_idx << "): "
                    << "Type " << CFastaReader::CWarning::GetStringOfType(
                    eExpectedType) << ": "
                    << "Line num of warning should be " << iExpectedLineNum
                    << ", but it's " << iWarningLineNum);
            }
        }
    }
}

namespace {

    typedef vector<CFastaReader::CWarning::EType> TWarnVec;

    // returns empty reference on error
    // (should never let exceptions escape)
    CRef<CBioseq> s_ParseFasta( const string & sFasta,
        CFastaReader::TFlags fFlags,
        const string & sExpectedExceptionErrCode = kEmptyStr,
        const TWarnVec & pExpectedWarningTypes = TWarnVec() )
    {
        CRef<CBioseq> pRetvalBioseq;
        string sErrCodeThatOccurred;
        CAutoInitRef<CFastaReader::TWarningRefVec> pWarningRefVec;

        try {
            CMemoryLineReader line_reader( sFasta.c_str(), sFasta.length() );
            CFastaReader fasta_reader( line_reader, fFlags );

            fasta_reader.SetWarningOutput( Ref(&*pWarningRefVec) );

            CRef<CSeq_entry> pEntry = fasta_reader.ReadOneSeq();
            BOOST_REQUIRE(pEntry->IsSeq());
            pRetvalBioseq.Reset( & pEntry->SetSeq() );
        } catch(const CException & ex ) {
            sErrCodeThatOccurred = ex.GetErrCodeString();
        } catch(...) {
            sErrCodeThatOccurred = "UNKNOWN";
        }

        // extract the warning codes
        TWarnVec pWarningTypes;
        ITERATE( CFastaReader::TWarningRefVec::TObjectType, 
            warn_it, pWarningRefVec->GetData() ) 
        {
            pWarningTypes.push_back( (*warn_it)->GetType());
        }

        // check warnings
        BOOST_CHECK_EQUAL_COLLECTIONS(
            pExpectedWarningTypes.begin(), 
            pExpectedWarningTypes.end(),
            pWarningTypes.begin(),
            pWarningTypes.end() );

        // check error
        BOOST_CHECK_EQUAL( sExpectedExceptionErrCode, sErrCodeThatOccurred );

        return pRetvalBioseq;
    }

    // returns NULL if not found.  Does NOT do boost checks
    CConstRef<CSeq_literal> s_GetFirstGapSeqLiteral(
        CConstRef<CBioseq> pBioseq)
    {
        try {
            const CDelta_ext::Tdata & delta_data =
                pBioseq->GetInst().GetExt().GetDelta().Get();
            ITERATE(CDelta_ext::Tdata, delta_it, delta_data) {
                const CSeq_literal & seq_literal = 
                    (*delta_it)->GetLiteral();
                if( ! seq_literal.IsSetSeq_data() || 
                    FIELD_IS_SET_AND_IS(seq_literal, Seq_data, Gap) ) 
                {
                    return ConstRef(&seq_literal);
                }
            }
        } catch(...) {
            // do nothing, we will return NULL
        }
        return CConstRef<CSeq_literal>();
    }

    // kludge to work around the inability to have templated typedefs
    template<typename TType>
    class TRefStd : public CConstRef<CObjectFor<TType> > { };

    // turns even a literal into a reference
    template<typename TType>
    TRefStd<TType> s_RefStd(const TType & value )
    {
        TRefStd<TType> pAnswer;
        pAnswer.Reset( new CObjectFor<TType>(value) );
        return pAnswer;
    }

    // lets us have nullable non-CObject data
    template<typename TType>
    TRefStd<TType> s_RefOrNull(
        bool bReturnNonNull,
        const TType & valueIfNonNull )
    {
        if( bReturnNonNull ) {
            return s_RefStd(valueIfNonNull);
        }
        return TRefStd<TType>();
    }

    template<typename TType>
    vector<TType> s_VecOfOne(
        const TType & value)
    {
        vector<TType> answerVec;
        answerVec.push_back(value);
        return answerVec;
    }

    // The given bioseq should have exactly one gap
    // The TRefStd's are NULL for "should be unset"
    void s_CheckOnlyBioseqGap(
                CConstRef<CBioseq> pBioseq,
                TRefStd<TSeqPos> pNumDeltasExpected,
                TRefStd<TSeqPos>  pGapLenExpected,
                TRefStd<CInt_fuzz::ELim> pLimExpected,
                TRefStd<CSeq_gap::EType> pGapTypeExpected,
                TRefStd< vector<CLinkage_evidence::EType> > pLinkEvidsExpected )
    {
        // check number of deltas
        const CDelta_ext::Tdata * pDeltaData = NULL;
        IGNORE_ANY_THROWS(
            pDeltaData = & pBioseq->GetInst().GetExt().GetDelta().Get());
        if( pNumDeltasExpected ) {
            if( pDeltaData ) {
                NCBITEST_CHECK_EQUAL(pDeltaData->size(), *pNumDeltasExpected);
            } else {
                BOOST_ERROR("no delta-ext's");
            }
        } else {
            NCBITEST_CHECK( ! pDeltaData );
        }

        // find the one gap seq-literal
        CConstRef<CSeq_literal> pGapLiteral;
        if( pDeltaData ) {
            ITERATE(CDelta_ext::Tdata, delta_it, *pDeltaData) {
                const CSeq_literal & seq_literal = 
                    (*delta_it)->GetLiteral();
                if( ! seq_literal.IsSetSeq_data() || 
                    FIELD_IS_SET_AND_IS(seq_literal, Seq_data, Gap) ) 
                {
                    // it's a gap
                    BOOST_REQUIRE_MESSAGE( ! pGapLiteral, 
                        "There should be only one gap" );
                    pGapLiteral.Reset( & seq_literal );
                }
            }
        }

        // check gap len
        if( pGapLenExpected ) {
            NCBITEST_CHECK_EQUAL( pGapLiteral->GetLength(), *pGapLenExpected );
        } else {
            NCBITEST_CHECK( ! pGapLiteral->IsSetLength() );
        }

        // check fuzz
        if( pLimExpected ) {
            NCBITEST_CHECK_EQUAL(
                pGapLiteral->GetFuzz().GetLim(), CInt_fuzz::eLim_unk);
        } else {
            BOOST_CHECK( ! pGapLiteral || ! pGapLiteral->IsSetFuzz() );
        }

        // extract CSeq_gap, if any
        CConstRef<CSeq_gap> pSeqGap;
        IGNORE_ANY_THROWS(
            pSeqGap.Reset( & pGapLiteral->GetSeq_data().GetGap() ) );

        if( pGapTypeExpected ) {
            NCBITEST_CHECK_EQUAL(pSeqGap->GetType(), *pGapTypeExpected);
        } else {
            NCBITEST_CHECK( ! pSeqGap || ! pSeqGap->IsSetType() );
        }

        // check linkage and linkage-evidence
        if( pLinkEvidsExpected && pLinkEvidsExpected->GetData().empty() ) {
            // consider empty and unset to be the same thing
            // for our expected array and our actual array
            pLinkEvidsExpected.Reset();
        }
        if( pLinkEvidsExpected ) {
            NCBITEST_CHECK_EQUAL( pSeqGap->GetLinkage(), 
                CSeq_gap::eLinkage_linked );
        } else {
            NCBITEST_CHECK( ! pSeqGap || 
                ! FIELD_EQUALS(*pSeqGap, Linkage, CSeq_gap::eLinkage_linked) );
        }
        const CSeq_gap::TLinkage_evidence * pLinkEvidObjs = NULL;
        IGNORE_ANY_THROWS(
            pLinkEvidObjs = & pSeqGap->GetLinkage_evidence() );
        if( pLinkEvidsExpected ) {
            vector<CLinkage_evidence::EType> vecLinkEvids;
            if( pLinkEvidObjs ) {
                ITERATE(CSeq_gap::TLinkage_evidence, evid_obj_it, *pLinkEvidObjs) {
                    BOOST_CHECK_NO_THROW(
                        vecLinkEvids.push_back( 
                            static_cast<CLinkage_evidence::EType>(
                                (*evid_obj_it)->GetType() ) ) );
                }
            }
            BOOST_CHECK_EQUAL_COLLECTIONS(
                pLinkEvidsExpected->GetData().begin(), 
                pLinkEvidsExpected->GetData().end(),
                vecLinkEvids.begin(), vecLinkEvids.end());
        } else {
            NCBITEST_CHECK( ! pLinkEvidObjs || 
                pLinkEvidObjs->empty() );
        }
    }
}

BOOST_AUTO_TEST_CASE(TestTitleRemovedIfEmpty)
{
    static const string kFastaWhereAllModsRemoved = 
        ">Seq1 [topology=circular]\n"
        "ACGTACGTACGTACGTACGTACGTACGTACGTACGT\n";
    CRef<CBioseq> pBioseq = s_ParseFasta( kFastaWhereAllModsRemoved,
        CFastaReader::fAddMods );
    BOOST_REQUIRE(pBioseq);

    FOR_EACH_SEQDESC_ON_BIOSEQ(desc_it, *pBioseq) {
        BOOST_CHECK( ! (*desc_it)->IsTitle() );
    }
}

BOOST_AUTO_TEST_CASE(TestProteinSeqGapChar)
{
    static const string kFastaWithProtGap = 
        ">Dobi [organism=Canis familiaris] [breed=Doberman pinscher]\n"
        "MMMTGCMTGGGTMMMMGTMGTMGMMGMGMMGGCTTTTMGCCCMGMMGTMMTMCCCMTGTTTTCMGCMTTM\n"
        "GGMMMMMGGGCTGTTG\n"
        ">?unk100\n"
        "TGGMTGMCMGMMMCCTTGTTGGTCCMMMMTGCMMMCCCMGMTKGTMMGMCCMTTTTMMMMGCMTTGGGTC\n"
        "TTMGMMMTMGGGCMMCMCMGMMCMMMMMT\n"
        ">?234\n"
        "MMMMMTMMMMGCMTTMGTMGMMMTTTGTMCMGMMCTGGMMMMGGMMGGMMMMMTTTCMMMMMTTGGGCCT\n";

    CFastaReader::TFlags fFastaReaderFlags =
        CFastaReader::fAddMods | 
        CFastaReader::fAssumeProt |
        CFastaReader::fUseIupacaa;

    // test with and without nosplit
    ITERATE_BOTH_BOOL_VALUES(bSetNoSplit) {
        cout << "Trying with" << (bSetNoSplit ? "" : "out") << " CFastaReader::fNoSplit" << endl;
        BOOST_CHECK(s_ParseFasta( kFastaWithProtGap, 
            fFastaReaderFlags | (bSetNoSplit ? CFastaReader::fNoSplit : 0)));
    }
}

// Make sure [protein=whatever] doesn't work
// on nuc sequences but does work on prots.
// Also, "[gene=...]" becomes a feature on a nuc,
// but is an xref on a prot
BOOST_AUTO_TEST_CASE(TestGeneAndProtein)
{
    {{
        static const string kFastaNuc = 
            ">Seq1 [gene=some_gene] [protein=foo]\n"
            "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTAC\n";

        CRef<CBioseq> pBioseq = s_ParseFasta(
            kFastaNuc, CFastaReader::fAddMods );
        BOOST_REQUIRE(pBioseq);

        bool bFoundGene = false;

        CTypeConstIterator<CSeqFeatData> seqfeatdat_ci(Begin(*pBioseq));
        for( ; seqfeatdat_ci; ++seqfeatdat_ci ) {
            BOOST_REQUIRE( ! seqfeatdat_ci->IsProt() );
            if( FIELD_IS_AND_IS_SET(*seqfeatdat_ci, Gene, Locus) && 
                seqfeatdat_ci->GetGene().GetLocus() == "some_gene" )
            {
                bFoundGene = true;
            }
        }

        BOOST_CHECK(bFoundGene);
    }}

    {{
        static const string kFastaProt =
            ">Seq1 [gene=some_gene] [protein=foo]\n"
            "MALWMHLLTVLALLALWGPNTNQAFVSRHLCGSNLVETLYSVCQDDGFFYIPKDRRELED\n";

        CRef<CBioseq> pBioseq = s_ParseFasta(
            kFastaProt, CFastaReader::fAddMods );
        BOOST_REQUIRE(pBioseq);

        bool bHasProt = false;
        CTypeConstIterator<CSeq_feat> seqfeat_ci(Begin(*pBioseq));
        for( ; seqfeat_ci; ++seqfeat_ci ) {
            BOOST_CHECK( ! FIELD_IS_SET_AND_IS(*seqfeat_ci, Data, Gene) );
            if( FIELD_IS_SET_AND_IS(*seqfeat_ci, Data, Prot) ) {
                bHasProt = true;
                NCBITEST_CHECK( RAW_FIELD_IS_EMPTY_OR_UNSET(*seqfeat_ci, Xref) );
            }
        }
        BOOST_CHECK(bHasProt);
    }}
}

BOOST_AUTO_TEST_CASE(TestGapMods)
{
    const string kPreGapNucs = 
        "GATTACAACGTGATTACAACGTGATTACAACGTGATTACAACGTGATTACAACGTGATTACA";
    const string kPostGapNucs[2] = {
        "TCGACCCACGCGTCCGGAGAAGTTTTTCACCTACTGGAACCCGCCTAGGGTACGGGAAAC",
        "AGGTGCCCTCCAAAACGAGAGCGCGAACTGCAGCCTACGTCCCACTGCAGCTCAGGAGCA"
    };

    const string kLinesBeforeGap = 
        ">Seq1\n" +
        kPreGapNucs + "\n";
    const string kLinesAfterGap = 
        kPostGapNucs[0] + "\n" +
        kPostGapNucs[1] + "\n";

    // the 2 above, plus a gap line added in-between
    const TSeqPos kNumDeltasExpected = 3;

    // arbitrary gap length to use when the length doesn't matter
    const TSeqPos kArbGapLen = 42;

    const CFastaReader::TFlags kDefaultFastaFlags = 
        CFastaReader::fParseGaps;

    // test that numbers other than "100" will work
    // (no values provided should imply [gap-type=unknown][linkage-evidence=unspecified])
    // (and test that negative or zero fails)
    ITERATE_BOTH_BOOL_VALUES(bIsUnknown) {
        const int arrGapLensToTry[] = {-250, -8, 0, 1, 20, 84, 100, 158, 2093};
        ITERATE_0_IDX(gapLenIdx, ArraySize(arrGapLensToTry) ) {
            const int iGapLen = arrGapLensToTry[gapLenIdx];
            const string sDataToRead = kLinesBeforeGap + ">?" + 
                ( bIsUnknown ? "unk" : "") + 
                NStr::NumericToString(iGapLen) + "\n" + kLinesAfterGap;

            cerr << "Testing with " << (bIsUnknown ? "unknown" : "known") 
                 << " gap size of " << iGapLen << endl;

            // non-positive gap sizes should create a format error
            const char * pchExpectedError = ( 
                iGapLen <= 0 ? "eFormat" : "" );

            CRef<CBioseq> pBioseq = s_ParseFasta(
                sDataToRead, kDefaultFastaFlags, pchExpectedError );

            // non-positive gap sizes should create a format error
            if( iGapLen <= 0 ) {
                BOOST_CHECK( ! pBioseq );
                continue;
            }

            s_CheckOnlyBioseqGap(
                pBioseq,
                s_RefStd(kNumDeltasExpected),
                s_RefStd( static_cast<TSeqPos>(iGapLen) ),
                s_RefOrNull(bIsUnknown, CInt_fuzz::eLim_unk),
                TRefStd<CSeq_gap::EType>(),
                TRefStd<vector<CLinkage_evidence::EType> >() );
        }
    }

    // test possible gap types
    const CFastaReader::TGapTypeMap & gapTypeMap =
        CFastaReader::GetNameToGapTypeInfoMap();

    ITERATE_BOTH_BOOL_VALUES(bPutLinkEvidInInput) {
        ITERATE( CFastaReader::TGapTypeMap, gap_type_text_it, gapTypeMap )
        {
            const char *pchGapType = gap_type_text_it->first;
            const CFastaReader::SGapTypeInfo & gapTypeInfo =
                gap_type_text_it->second;

            // build the data we're reading;
            CNcbiOstrstream fasta_in_strm;
            fasta_in_strm << kLinesBeforeGap
            << ">?unk" << kArbGapLen
            << " [gap-type=" << pchGapType << ']';
            if( bPutLinkEvidInInput ) {
                fasta_in_strm << " [linkage-evidence=pcr]";
            }
            fasta_in_strm << '\n';
            fasta_in_strm << kLinesAfterGap;

            // print what we're doing here
            cerr << "Testing gap-type " << pchGapType << "("
                 << (bPutLinkEvidInInput ? "with" : "without" ) 
                 << " a linkage-evidence)" << endl;

            TWarnVec expectedWarningsVec;
            if( bPutLinkEvidInInput ) 
            {
                if( gapTypeInfo.m_eLinkEvid == CFastaReader::eLinkEvid_Forbidden ) {
                    expectedWarningsVec.push_back(
                        CFastaReader::CWarning::eType_GapModsFoundButNoneExpected);
                } else if( gapTypeInfo.m_eLinkEvid == CFastaReader::eLinkEvid_UnspecifiedOnly ) {
                    expectedWarningsVec.push_back(
                        CFastaReader::CWarning::eType_ExtraGapModsFound);
                }
            } else {
                if(gapTypeInfo.m_eLinkEvid == CFastaReader::eLinkEvid_Required ) 
                {
                    expectedWarningsVec.push_back(
                        CFastaReader::CWarning::eType_ExpectedGapModsMissing);
                }
            }

            CRef<CBioseq> pBioseq =
                s_ParseFasta(
                    CNcbiOstrstreamToString(fasta_in_strm),
                    kDefaultFastaFlags,
                    kEmptyStr,
                    expectedWarningsVec);
              
            // add checking function
            s_CheckOnlyBioseqGap(
                pBioseq,
                s_RefStd(kNumDeltasExpected),
                s_RefStd(kArbGapLen),
                s_RefStd(CInt_fuzz::eLim_unk),
                s_RefStd(gapTypeInfo.m_eType),
                s_RefOrNull(gapTypeInfo.m_eLinkEvid != CFastaReader::eLinkEvid_Forbidden,                 
                    s_VecOfOne(
                        gapTypeInfo.m_eLinkEvid == CFastaReader::eLinkEvid_Required &&
                            bPutLinkEvidInInput ?
                        CLinkage_evidence::eType_pcr :
                        CLinkage_evidence::eType_unspecified)) );
        }
    }

    // test interaction with "unspecified"
    ITERATE( CFastaReader::TGapTypeMap, gap_type_text_it, gapTypeMap )
    {
        const char *pchGapType = gap_type_text_it->first;
        const CFastaReader::SGapTypeInfo & gapTypeInfo = gap_type_text_it->second;

        // build the data we're reading;
        CNcbiOstrstream fasta_in_strm;
        fasta_in_strm << kLinesBeforeGap
            << ">?unk" << kArbGapLen
            << " [gap-type=" << pchGapType << ']'
            << " [linkage-evidence=unspecified]\n"
            << kLinesAfterGap;

        // print what we're doing here
        cerr << "Testing gap-type " << pchGapType << " with 'unspecified'" << endl;

        TWarnVec expectedWarningsVec;
        switch( gapTypeInfo.m_eLinkEvid ) {
        case CFastaReader::eLinkEvid_UnspecifiedOnly:
            // no problem
            break;
        case CFastaReader::eLinkEvid_Required:
            expectedWarningsVec.push_back(
                CFastaReader::CWarning::eType_ExpectedGapModsMissing);
            break;
        case CFastaReader::eLinkEvid_Forbidden:
            expectedWarningsVec.push_back(
                CFastaReader::CWarning::eType_GapModsFoundButNoneExpected);
            break;
        default:
            BOOST_FAIL("Unknown CFastaReader::ELinkEvid: " 
                << static_cast<int>(gapTypeInfo.m_eLinkEvid) );
            break;
        }

        CRef<CBioseq> pBioseq =
            s_ParseFasta(
            CNcbiOstrstreamToString(fasta_in_strm),
            kDefaultFastaFlags,
            kEmptyStr,
            expectedWarningsVec);

        // add checking function
        s_CheckOnlyBioseqGap(
            pBioseq,
            s_RefStd(kNumDeltasExpected),
            s_RefStd(kArbGapLen),
            s_RefStd(CInt_fuzz::eLim_unk),
            s_RefStd(gapTypeInfo.m_eType),
            s_RefOrNull(
                gapTypeInfo.m_eLinkEvid != CFastaReader::eLinkEvid_Forbidden, 
                s_VecOfOne(CLinkage_evidence::eType_unspecified)) );
    }

    // test format errors after gap length
    {
        const char * arrBadGapMods[] = {
            // bogus mod key
            " [foo=baz]",
            // bogus gap type
            " [gap-type=foo]",
            // bogus linkage-evidence
            " [gap-type=between scaffolds] [linkage-evidence=foo]",
            // extra junk on gap line (even if good mods)
            " extra junk",
            " [gap-type=short arm] extra junk",
            " [gap-type=short arm] extra junk [linkage-evidence=map]",
            // conflicting gap types
            " [gap-type=short arm] [gap-type=heterochromatin]"
        };
        ITERATE_0_IDX( ii, ArraySize(arrBadGapMods) ) {
            const string sDataToRead = kLinesBeforeGap +
                ">?unk" + NStr::NumericToString(kArbGapLen) +
                arrBadGapMods[ii] + "\n" + kLinesAfterGap;

            CRef<CBioseq> pBioseq =
                s_ParseFasta(
                sDataToRead,
                kDefaultFastaFlags,
                "eFormat");

            BOOST_CHECK( ! pBioseq );
        }
    }

    // test multiple linkage evidences (both approaches)
    {
        // all ways should give the same result
        const char * arrLinkageEvidences[] = {
            // shouldn't matter if all in one semi-colon-separated mod
            // or split across multiple ones
            "[linkage-evidence=pcr;strobe;map]",
            "[linkage-evidence=pcr][linkage-evidence=strobe][linkage-evidence=map]",
            "[linkage-evidence=pcr;strobe][linkage-evidence=map]",
            "[linkage-evidence=pcr][linkage-evidence=strobe;map]",
            // dups should be ignored
            "[linkage-evidence=pcr;strobe;pcr;map]",
            "[linkage-evidence=pcr][linkage-evidence=strobe][linkage-evidence=pcr][linkage-evidence=map]"
        };

        // same result every iteration, so just build it here
        vector<CLinkage_evidence::EType> vecExpectedLinkEvids;
        vecExpectedLinkEvids.push_back(CLinkage_evidence::eType_pcr);
        vecExpectedLinkEvids.push_back(CLinkage_evidence::eType_strobe);
        vecExpectedLinkEvids.push_back(CLinkage_evidence::eType_map);
        sort( vecExpectedLinkEvids.begin(), vecExpectedLinkEvids.end() );

        ITERATE_0_IDX(linkEvidIdx, ArraySize(arrLinkageEvidences) ) {
            const char * pchLinkageEvidences = 
                arrLinkageEvidences[linkEvidIdx];

            cerr << "Trying: " << pchLinkageEvidences << endl;

            const string sDataToRead = kLinesBeforeGap +
                ">?unk" + NStr::NumericToString(kArbGapLen) +
                " [gap-type=between scaffolds] " + pchLinkageEvidences + "\n" + 
                kLinesAfterGap;

            CRef<CBioseq> pBioseq =
                s_ParseFasta(sDataToRead, kDefaultFastaFlags);

            BOOST_REQUIRE( pBioseq );

            s_CheckOnlyBioseqGap(
                pBioseq,
                s_RefStd(kNumDeltasExpected),
                s_RefStd(kArbGapLen),
                s_RefStd(CInt_fuzz::eLim_unk),
                s_RefStd(CSeq_gap::eType_contig),
                s_RefStd(vecExpectedLinkEvids) );
        }
    }

    // test that canonicalization does work
    // (that is, case, etc. is ignored)
    {
        const string sDataToRead = kLinesBeforeGap +
            ">?unk" + NStr::NumericToString(kArbGapLen) +
            " [  GAP tYpe  =   Between_Scaffolds  ] [ linkage_evidence  = Align xgenus   ]\n" + 
            kLinesAfterGap;

        CRef<CBioseq> pBioseq =
            s_ParseFasta(
            sDataToRead,
            kDefaultFastaFlags);

        BOOST_REQUIRE( pBioseq );

        vector<CLinkage_evidence::EType> vecExpectedLinkEvids(
            1, CLinkage_evidence::eType_align_xgenus);
        
        s_CheckOnlyBioseqGap(
            pBioseq,
            s_RefStd(kNumDeltasExpected),
            s_RefStd(kArbGapLen),
            s_RefStd(CInt_fuzz::eLim_unk),
            s_RefStd(CSeq_gap::eType_contig),
            s_RefStd(s_VecOfOne(CLinkage_evidence::eType_align_xgenus)) );
    }
}

BOOST_AUTO_TEST_CASE(TestNonDeltaGaps)
{
    const string kDefline = ">Seq1";
    const string kNucsBeforeGap = 
        "GATTACAACGTGATTACAACGTGATTACAAC";
    // arbitrary kArbGapSize, but used prime to make accidentally correct 
    // results less likely 
    const TSeqPos kArbGapSize = 17;
    const string kNucsAfterGap = "GTGATTACAACGTGATTACAACGTGATTACA";

    const string kExpectedBases = kNucsBeforeGap + 
        string(kArbGapSize, 'N') +
        kNucsAfterGap;
    // test if the fParseGaps flag is NOT set, which would result in 
    // one big sequence (no deltas).

    // all these different representations should result in a gap
    // of the same size
    const string arrGapStrings[] = {
        string(kArbGapSize, 'N'),
        string(kArbGapSize, '-'),
        "\n>?" + NStr::NumericToString(kArbGapSize) + "\n",
        "\n>?unk" + NStr::NumericToString(kArbGapSize) + "\n",
        "\n>?unk" + NStr::NumericToString(kArbGapSize) + 
            " [gap-type=unknown]  [linkage-evidence=unspecified]\n",
        "\n>?unk" + NStr::NumericToString(kArbGapSize) + 
            " [gap-type=repeat within scaffold]  [linkage-evidence=pcr]\n"
    };
    ITERATE_0_IDX( gap_str_idx, ArraySize(arrGapStrings) ) {
        const string sDataToRead =
            kDefline + "\n" +
            kNucsBeforeGap + arrGapStrings[gap_str_idx] + kNucsAfterGap + "\n";


        // if there are substantive mods on the gaps, a warning
        // is expected
        TWarnVec expectedWarnings;
        if( sDataToRead.find('[') != string::npos && 
            sDataToRead.find("unknown") == string::npos ) 
        {
            expectedWarnings.push_back(
                CFastaReader::CWarning::eType_GapModsFoundButNoneExpected);
        }

        CRef<CBioseq> pBioseq =
            s_ParseFasta(sDataToRead, 0, 
                kEmptyStr, expectedWarnings);

        BOOST_REQUIRE( pBioseq );

        // should NOT contain a gap per se
        NCBITEST_CHECK( ! pBioseq->GetInst().GetSeq_data().IsGap() );

        CSeqVector seq_vec(*pBioseq, NULL, CBioseq_Handle::eCoding_Iupac);
        BOOST_CHECK_EQUAL_COLLECTIONS(
            kExpectedBases.begin(), kExpectedBases.end(),
            seq_vec.begin(), seq_vec.end() );
    }
}
