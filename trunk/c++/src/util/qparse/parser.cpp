/*  $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors: Anatoliy Kuznetsov
 *
 * File Description:
 *      Query parser entry point. 
 *    Glues together code generated by BISON, lexical tokenizer, 
 *    error processing, etc.
 *
 */

#include <ncbi_pch.hpp>
#include <corelib/ncbimtx.hpp>
#include <corelib/ncbiapp.hpp>
#include <util/qparse/query_parse.hpp>
#include <util/resource_pool.hpp>


USING_NCBI_SCOPE;

/* extern "C" */ static int yyerror (const char *s);
/* extern "C" */ static int yylex (CQueryParseTree::TNode** lvalp, void* param);

BEGIN_NCBI_SCOPE



/// Query tree garbage collection functor.
///
/// Finds nodes in the query tree and removes them from the 
/// memory pool. All lost nodes are deleted by the pool object.
///
/// @internal
/// @ingroup QParser
///
class CQueryTreeCleanPoolFunc
{
public:
    typedef CResourcePool<CQueryParseTree::TNode, CFastMutex> TNodePool;
    
public: 
    CQueryTreeCleanPoolFunc(TNodePool& mem_pool)
    : m_Pool(mem_pool)
    {}
  
    ETreeTraverseCode 
    operator()(CQueryParseTree::TNode& tr, int delta)
    {
        if (delta == 0 || delta == 1) {
            m_Pool.Forget(&tr);
        }
        return eTreeTraverse;
    }
private:
    TNodePool&  m_Pool;
};

/// Class passed to Lex/Bison (yylex/yyparse) functions.
/// Works as a glue to pass all the information 
/// (both parsed stream and output syntactic tree)
///
/// @internal
/// @ingroup QParser
///
class CQueryParserEnv
{
public:
    typedef CResourcePool<CQueryParseTree::TNode, CFastMutex> TNodePool;

public:
    CQueryParserEnv(const char* query_str)
    : m_Query(query_str),
      m_Ptr(query_str),
      m_QueryTree(0),
      m_Verbose(false),
      m_Case(CQueryParseTree::eCaseInsensitive)
    {
        m_QueryLen = ::strlen(m_Query);
    }

    ~CQueryParserEnv()
    {
        try {
            Free();
        } 
        catch (exception & ex) {
            ERR_POST("Exception in ~CQueryParserEnv()" << ex.what());
        }
        catch (...) {
            ERR_POST("Unknown exception in ~CQueryParserEnv()");
        }
        
    }
    
    void Free()
    {
        if (m_QueryTree) {
            // Sync the memory pool not to delete the in-tree nodes
            CQueryTreeCleanPoolFunc func(m_NodePool);
            TreeDepthFirstTraverse(*m_QueryTree, func);

            delete m_QueryTree; m_QueryTree = 0;
        }
    }

    const char*  GetQueryBuffer() const { return m_Query; }
    const char*  GetBufPtr() const { return m_Ptr; }
    const char*  GetBufEnd() const { return m_Query + m_QueryLen; }
    void SetBufPtr(const char* ptr) { m_Ptr = ptr; }

    int GetChar()
    {
        int r = *m_Ptr++;
        return r;
    }

    /// Skip number of characters
    void Skip(int num)
    {
        m_Ptr += num;
    }

    void UnGetChar() { --m_Ptr; }

    void AttachQueryTree(CQueryParseTree::TNode* qc)
    {
        m_QueryTree = qc;
    }

    CQueryParseTree::TNode* GetQueryTree() { return m_QueryTree; }

    /// Return query clause.
    ///
    /// Caller is responsible for deleteion
    ///
    CQueryParseTree::TNode* DetachQueryTree() 
    { 
        if (m_QueryTree) {
            // Sync the memory pool
            CQueryTreeCleanPoolFunc func(m_NodePool);
            TreeDepthFirstTraverse(*m_QueryTree, func);

            CQueryParseTree::TNode* qc = m_QueryTree;
            m_QueryTree = 0;

            return qc; 
        }
        return 0;
    }

    void AddNodeToPool(CQueryParseTree::TNode* qnode)
    {
        m_NodePool.Put(qnode);
    }

    TNodePool& GetPool()
    {
        return m_NodePool;
    }
    
    bool IsVerbose() const { return m_Verbose; }
    void SetVerbose(bool verbose=true) { m_Verbose = verbose; }

    CQueryParseTree::ECase GetCase() const { return m_Case; }
    void SetCase(CQueryParseTree::ECase case_sense) { m_Case = case_sense; }

private:
    const char*    m_Query;   ///< Request buffer. (Source for the scanner)
    unsigned       m_QueryLen;///< Query length
    const char*    m_Ptr;     ///< Current position in the request buffer

    /// Query clause tree. This is the result of the statement parsing.
    CQueryParseTree::TNode*                 m_QueryTree;
    
    /// Memory pool of query clause tree nodes. 
    /// Used to avoid memory leaks when BISON shifts stack and calls
    /// yyerror (or othewise throws a C++ exception)
    TNodePool m_NodePool;
    /// Debug trace when parsing
    bool      m_Verbose;
    /// Case sensitivity switch
    CQueryParseTree::ECase  m_Case;
};




END_NCBI_SCOPE

#include "query_parser_bison.tab.c"
#include "lexer.inc"

/// Called by yyparse on error 
static
int yyerror (const char *s) 
{
    _TRACE("Parsing error!!!");
    NCBI_THROW(CQueryParseException, eParserError, "Syntax error!");
//    BDB_THROW(eQuerySyntaxError, s);
    return 1;
}


BEGIN_NCBI_SCOPE


void CQueryParseTree::Parse(const char* query_str, 
                            ECase       case_sense,
                            bool        verbose)
{
    CQueryParserEnv env(query_str);

#ifdef _DEBUG
    CNcbiApplication* app = CNcbiApplication::Instance();
    if (app  &&  app->GetEnvironment().Get("DIAG_TRACE") == "1") {
        yydebug = 1;
    }
#endif
    env.SetCase(case_sense);
    env.SetVerbose(verbose);

    /*int res = */ yyparse((void*) &env);
    CQueryParseTree::TNode* qt = env.GetQueryTree();

    if (qt) {
        qt = env.DetachQueryTree();
        this->SetQueryTree(qt);
    } else {

        // Check if we have only one token node created by the tokenizer
        // means it's just a single word request (perfectly legal)

        CQueryParserEnv::TNodePool& pool = env.GetPool();
        CQueryParserEnv::TNodePool::TPoolList& vec = pool.GetFreeList();

        // the only node in pool
        if (vec.size() == 1) {
            CQueryParseTree::TNode* qcl = vec[0];
            this->SetQueryTree(qcl);
            pool.ForgetAll();
        }
    }
    env.Free();
}


END_NCBI_SCOPE

/*
 * ===========================================================================
 * $Log$
 * Revision 1.2  2007/01/11 14:49:51  kuznets
 * Many cosmetic fixes and functional development
 *
 * Revision 1.1  2007/01/10 16:14:01  kuznets
 * initial revision
 *
 *
 * ==========================================================================
 */



