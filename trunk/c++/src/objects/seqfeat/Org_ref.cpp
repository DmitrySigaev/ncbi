/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqfeat.asn'.
 *
 * ---------------------------------------------------------------------------
 * $Log$
 * Revision 6.5  2005/05/20 13:36:54  shomrat
 * Added BasicCleanup()
 *
 * Revision 6.4  2004/05/19 17:26:04  gorelenk
 * Added include of PCH - ncbi_pch.hpp
 *
 * Revision 6.3  2002/01/28 22:20:14  grichenk
 * Fixed & assignments
 *
 * Revision 6.2  2002/01/28 19:49:49  domrach
 * Get/Set tax id methods added
 *
 * Revision 6.1  2002/01/10 19:58:39  clausen
 * Added GetLabel
 *
 *
 * ===========================================================================
 */

// standard includes

// generated includes
#include <ncbi_pch.hpp>
#include <objects/seqfeat/Org_ref.hpp>
#include <objects/general/Object_id.hpp>
#include <objects/general/Dbtag.hpp>
#include <objects/general/cleanup_utils.hpp>

// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
COrg_ref::~COrg_ref(void)
{
}

// Appends a label to "label" based on content
void COrg_ref::GetLabel(string* label) const
{
    if (IsSetTaxname()) {
        *label += GetTaxname();
    } else if (IsSetCommon()) {
        *label += GetCommon();
    } else if (IsSetDb()) {
        GetDb().front()->GetLabel(label);
    }
}
    
static const string s_taxonName( "taxon" );

int
COrg_ref::GetTaxId() const
{
    const TDb& lDbTags = GetDb();
 
    for(TDb::const_iterator i = lDbTags.begin();
	i != lDbTags.end();
	++i) {
	if( i->GetPointer()
	    && i->GetObject().GetDb().compare(s_taxonName) == 0 ) {
	    const CObject_id& id = i->GetObject().GetTag();
	    if( id.IsId() )
		return id.GetId();
	}
    }
    return 0;
}

int
COrg_ref::SetTaxId( int tax_id )
{
    int old_id(0);

    TDb& lDbTags = SetDb();
    // Try to update existing tax id first
    for(TDb::iterator i = lDbTags.begin();
	i != lDbTags.end();
	++i) {
	if( i->GetPointer()
	    && i->GetObject().GetDb().compare(s_taxonName) == 0 ) {
	    CObject_id& id = i->GetObject().SetTag();
	    if( id.IsId() )
		old_id = id.GetId();
	    id.SetId() = tax_id;
	    return old_id;
	}
    }
    // Add new tag
    CRef< CDbtag > ref( new CDbtag() );
    ref->SetDb( s_taxonName );
    ref->SetTag().SetId( tax_id );
    SetDb().push_back( ref );

    return old_id;
}


void COrg_ref::BasicCleanup(void)
{
    CLEAN_STRING_MEMBER(Taxname);
	CLEAN_STRING_MEMBER(Common);
	CLEAN_STRING_LIST(Mod);
	CLEAN_STRING_LIST(Syn);
	if (IsSetOrgname()) {
        if (IsSetMod()) {
            x_ModToOrgMod();
        }
		SetOrgname().BasicCleanup();
	}

	// !! To do: cleanup dbxref (sort, unique)

}


static COrgMod* s_StringToOrgMod(const string& str)
{
    try {
        size_t pos = str.find('=');
        if (pos == NPOS) {
            pos = str.find(' ');
        }
        if (pos == NPOS) {
            return NULL;
        }

        string subtype = str.substr(0, pos);
        string subname = str.substr(pos + 1);
        NStr::TruncateSpacesInPlace(subname);


        size_t num_spaces = 0;
        bool has_comma = false;
        ITERATE (string, it, subname) {
            if (isspace(*it)) {
                ++num_spaces;
            } else if (*it == ',') {
                has_comma = true;
                break;
            }
        }
        if (num_spaces > 4  ||  has_comma) {
            return NULL;
        }

        return new COrgMod(subtype, subname);
    } catch (CSerialException&) {}
    return NULL;
}


void COrg_ref::x_ModToOrgMod(void)
{
    _ASSERT(IsSetMod()  &&  IsSetOrgname());

    TMod& mod_list = SetMod();
    TOrgname& orgname = SetOrgname();

    COrg_ref::TMod::iterator it = mod_list.begin();
    while (it != mod_list.end()) {
        CRef<COrgMod> orgmod(s_StringToOrgMod(*it));
        if (orgmod) {
            orgname.SetMod().push_back(orgmod);
            it = mod_list.erase(it);
        } else {
            ++it;
        }
    }   
}

END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/* Original file checksum: lines: 61, chars: 1882, CRC32: c3300cc2 */
