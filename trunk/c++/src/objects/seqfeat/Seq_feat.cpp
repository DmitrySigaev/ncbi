/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqfeat.asn'.
 */

// generated includes
#include <ncbi_pch.hpp>
#include <objects/seqfeat/Seq_feat.hpp>
#include <objects/seqfeat/RNA_ref.hpp>
#include <objects/seqloc/Seq_loc.hpp>
#include <objects/seqloc/Seq_loc.hpp>
#include <objects/general/User_object.hpp>
#include <objects/general/User_field.hpp>
#include <objects/general/cleanup_utils.hpp>
#include <objects/seq/seqport_util.hpp>
#include <vector>


BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::


// destructor
CSeq_feat::~CSeq_feat(void)
{
}


static int s_TypeOrder[] = {
    3, // e_not_set = 0,
    0, // e_Gene,
    3, // e_Org,
    2, // e_Cdregion,
    3, // e_Prot,
    1, // e_Rna,
    3  // e_Pub, and the rest
};

int CSeq_feat::GetTypeSortingOrder(CSeqFeatData::E_Choice type)
{
    return s_TypeOrder[min(size_t(type),
                           sizeof(s_TypeOrder)/sizeof(s_TypeOrder[0])-1)];
}


// Corresponds to SortFeatItemListByPos from the C toolkit
int CSeq_feat::CompareNonLocation(const CSeq_feat& f2,
                                  const CSeq_loc& loc1,
                                  const CSeq_loc& loc2) const
{
    const CSeqFeatData& data1 = GetData();
    const CSeqFeatData& data2 = f2.GetData();
    CSeqFeatData::E_Choice type1 = data1.Which();
    CSeqFeatData::E_Choice type2 = data2.Which();

    if ( type1 != type2 ) { // order by feature type
        int order1 = GetTypeSortingOrder(type1);
        int order2 = GetTypeSortingOrder(type2);
        int diff = order1 - order2;
        if ( diff != 0 )
            return diff;
    }

    // compare internal intervals
    if ( loc1.IsMix()  &&  loc2.IsMix() ) {
        const CSeq_loc_mix::Tdata& l1 = loc1.GetMix().Get();
        const CSeq_loc_mix::Tdata& l2 = loc2.GetMix().Get();
        for ( CSeq_loc_mix::Tdata::const_iterator
                  it1 = l1.begin(), it2 = l2.begin(); ;  it1++, it2++) {
            if ( it1 == l1.end() ) {
                if ( it2 == l2.end() ) {
                    break;
                }
                else {
                    // f1 loc is shorter
                    return -1;
                }
            }
            if ( it2 == l2.end() ) {
                // f2 loc is shorter
                return 1;
            }
            int diff = (*it1)->Compare(**it2);
            if ( diff != 0 )
                return diff;
        }
    }

    {{ // compare subtypes
        CSeqFeatData::ESubtype subtype1 = data1.GetSubtype();
        CSeqFeatData::ESubtype subtype2 = data2.GetSubtype();
        int diff = subtype1 - subtype2;
        if ( diff != 0 )
            return diff;
    }}

    // compare frames of identical CDS ranges
    if ( type1 == CSeqFeatData::e_Cdregion &&
         type2 == CSeqFeatData::e_Cdregion ) {
        CCdregion::EFrame frame1 = data1.GetCdregion().GetFrame();
        CCdregion::EFrame frame2 = data2.GetCdregion().GetFrame();
        if (frame1 > CCdregion::eFrame_one
            ||  frame2 > CCdregion::eFrame_one) {
            int diff = frame1 - frame2;
            if ( diff != 0 )
                return diff;
        }
    }

    // compare labels
    // if imp features
    if ( type1 == CSeqFeatData::e_Imp && type2 == CSeqFeatData::e_Imp ) {
        int diff = NStr::CompareNocase(data1.GetImp().GetKey(),
                                       data2.GetImp().GetKey());
        if ( diff != 0 )
            return diff;
    }

    // XXX - should compare parent seq-annots
    // XXX 1. parent Seq-annot idx.itemID
    // XXX 2. features itemID

    return 0; // unknown
}

const CGene_ref* CSeq_feat::GetGeneXref(void) const

{
    ITERATE(CSeq_feat::TXref, it, GetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsGene ()) {
            return &((*it)->GetData ().GetGene ());
        }
    }
    return 0;
}

void CSeq_feat::SetGeneXref(CGene_ref& value)

{
    NON_CONST_ITERATE(CSeq_feat::TXref, it, SetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsGene ()) {
            (*it)->SetData ().SetGene ().Assign(value);
            return;
        }
    }
    TXref& xref = SetXref ();
    CRef<CSeqFeatXref> gref (new CSeqFeatXref);
    xref.push_back (gref);
    gref->SetData ().SetGene ().Assign (value);
}

CGene_ref& CSeq_feat::SetGeneXref(void)
{
    NON_CONST_ITERATE(CSeq_feat::TXref, it, SetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsGene ()) {
            return ((*it)->SetData ().SetGene ());
        }
    }
    TXref& xref = SetXref ();
    CRef<CSeqFeatXref> gref (new CSeqFeatXref);
    xref.push_back (gref);
    return gref->SetData ().SetGene ();
}

const CProt_ref* CSeq_feat::GetProtXref(void) const

{
    ITERATE(CSeq_feat::TXref, it, GetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsProt ()) {
            return &((*it)->GetData ().GetProt ());
        }
    }
    return 0;
}

void CSeq_feat::SetProtXref(CProt_ref& value)

{
    NON_CONST_ITERATE(CSeq_feat::TXref, it, SetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsProt ()) {
            (*it)->SetData ().SetProt ().Assign(value);
            return;
        }
    }
    TXref& xref = SetXref ();
    CRef<CSeqFeatXref> pref (new CSeqFeatXref);
    xref.push_back (pref);
    pref->SetData ().SetProt ().Assign (value);
}

CProt_ref& CSeq_feat::SetProtXref(void)

{
    NON_CONST_ITERATE(CSeq_feat::TXref, it, SetXref ()) {
        if ((*it)->IsSetData () && (*it)->GetData ().IsProt ()) {
            return ((*it)->SetData ().SetProt ());
        }
    }
    TXref& xref = SetXref ();
    CRef<CSeqFeatXref> pref (new CSeqFeatXref);
    xref.push_back (pref);
    return pref->SetData ().SetProt ();
}


void CSeq_feat::AddQualifier(const string& qual_name, const string& qual_val)
{
    CRef<CGb_qual> qual(new CGb_qual());
    qual->SetQual(qual_name);
    qual->SetVal(qual_val);
    SetQual().push_back(qual);
}


void CSeq_feat::AddDbxref(const string& db, const string& tag)
{
    CRef<CDbtag> dbtag(new CDbtag());
    dbtag->SetDb(db);
    dbtag->SetTag().SetStr(tag);
    SetDbxref().push_back(dbtag);
}


void CSeq_feat::AddDbxref(const string& db, int tag)
{
    CRef<CDbtag> dbtag(new CDbtag());
    dbtag->SetDb(db);
    dbtag->SetTag().SetId(tag);
    SetDbxref().push_back(dbtag);
}


CConstRef<CDbtag> CSeq_feat::GetNamedDbxref(const string& db) const
{
    if (IsSetDbxref()) {
        ITERATE (TDbxref, iter, GetDbxref()) {
            if ( (*iter)->GetDb() == db) {
                return *iter;
            }
        }
    }

    return CConstRef<CDbtag>();
}


const string& CSeq_feat::GetNamedQual(const string& qual_name) const
{
    if (IsSetQual()) {
        ITERATE (TQual, iter, GetQual()) {
            if ( (*iter)->GetQual() == qual_name  &&  (*iter)->IsSetVal()) {
                return (*iter)->GetVal();
            }
        }
    }

    return kEmptyStr;
}


// ==========================================================================
//                              Cleanup section
// ==========================================================================

static void s_CleanupExcept_text(string& except_text)
{
    if (NStr::Find(except_text, "ribosome slippage") == NPOS     &&
        NStr::Find(except_text, "trans splicing") == NPOS        &&
        NStr::Find(except_text, "alternate processing") == NPOS  &&
        NStr::Find(except_text, "non-consensus splice site") == NPOS) {
        return;
    }

    vector<string> exceptions;
    NStr::Tokenize(except_text, ",", exceptions);

    NON_CONST_ITERATE(vector<string>, it, exceptions) {
        string& text = *it;
        NStr::TruncateSpacesInPlace(text);
        if (!text.empty()) {
            if (text == "ribosome slippage") {
                text = "ribosomal slippage";
            } else if (text == "trans splicing") {
                text = "trans-splicing";
            } else if (text == "alternate processing") {
                text = "alternative processing";
            } else if (text == "non-consensus splice site") {
                text = "nonconsensus splice site";
            }
        }
    }
    except_text = NStr::Join(exceptions, ", ");
}


// === Gene

static bool s_IsEmptyGeneRef(const CGene_ref& gref)
{
    return (!gref.IsSetLocus()  &&  !gref.IsSetAllele()  &&
        !gref.IsSetDesc()  &&  !gref.IsSetMaploc()  &&  !gref.IsSetDb()  &&
        !gref.IsSetSyn()  &&  !gref.IsSetLocus_tag());
}


static void s_MoveDbxrefToFeat(CSeq_feat& feat)
{
    CSeq_feat::TData::TGene& g = feat.SetData().SetGene();

    // move db_xref from Gene-ref to feature
    if (g.IsSetDb()) {
        copy(g.GetDb().begin(), g.GetDb().end(), back_inserter(feat.SetDbxref()));
        g.ResetDb();
    }

    // move db_xref from gene xrefs to feature
    if (feat.IsSetXref()) {
        CSeq_feat::TXref& xrefs = feat.SetXref();
        CSeq_feat::TXref::iterator it = xrefs.begin();
        while (it != xrefs.end()) {
            CSeqFeatXref& xref = **it;
            if (xref.IsSetData()  &&  xref.GetData().IsGene()) {
                CGene_ref& gref = xref.SetData().SetGene();
                if (gref.IsSetDb()) {
                    copy(gref.GetDb().begin(), gref.GetDb().end(), 
                        back_inserter(feat.SetDbxref()));
                    gref.ResetDb();
                }
                // remove gene xref if it has no values set
                if (s_IsEmptyGeneRef(gref)) {
                    it = xrefs.erase(it);
                } else {
                    ++it;
                }
            }
        }
    }
}


static void s_CleanupGene(CSeq_feat& feat)
{
    _ASSERT(feat.IsSetData()  &&  feat.GetData().IsGene());

    CSeqFeatData::TGene& gene = feat.SetData().SetGene();

    gene.BasicCleanup();

    // remove feat.comment if equal to gene.locus
    if (gene.IsSetLocus()  &&  feat.IsSetComment()) {
        if (feat.GetComment() == gene.GetLocus()) {
            feat.ResetComment();
        }
    }

    // move db_xrefs from the Gene-ref or gene Xrefs to the feature
    s_MoveDbxrefToFeat(feat);
}


// === Site

typedef pair<const string, CSeqFeatData::TSite>  TSiteElem;
static const TSiteElem sc_site_map[] = {
    TSiteElem("acetylation", CSeqFeatData::eSite_acetylation),
    TSiteElem("active", CSeqFeatData::eSite_active),
    TSiteElem("amidation", CSeqFeatData::eSite_amidation),
    TSiteElem("binding", CSeqFeatData::eSite_binding),
    TSiteElem("blocked", CSeqFeatData::eSite_blocked),
    TSiteElem("cleavage", CSeqFeatData::eSite_cleavage),
    TSiteElem("dna binding", CSeqFeatData::eSite_dna_binding),
    TSiteElem("dna-binding", CSeqFeatData::eSite_dna_binding),
    TSiteElem("gamma carboxyglutamic acid", CSeqFeatData::eSite_gamma_carboxyglutamic_acid),
    TSiteElem("gamma-carboxyglutamic-acid", CSeqFeatData::eSite_gamma_carboxyglutamic_acid),
    TSiteElem("glycosylation", CSeqFeatData::eSite_glycosylation),
    TSiteElem("hydroxylation", CSeqFeatData::eSite_hydroxylation),
    TSiteElem("inhibit", CSeqFeatData::eSite_inhibit),
    TSiteElem("lipid binding", CSeqFeatData::eSite_lipid_binding),
    TSiteElem("lipid-binding", CSeqFeatData::eSite_lipid_binding),
    TSiteElem("metal binding", CSeqFeatData::eSite_metal_binding),
    TSiteElem("metal-binding", CSeqFeatData::eSite_metal_binding),
    TSiteElem("methylation", CSeqFeatData::eSite_methylation),
    TSiteElem("modified", CSeqFeatData::eSite_modified),
    TSiteElem("mutagenized", CSeqFeatData::eSite_mutagenized),
    TSiteElem("myristoylation", CSeqFeatData::eSite_myristoylation),
    TSiteElem("np binding", CSeqFeatData::eSite_np_binding),
    TSiteElem("np-binding", CSeqFeatData::eSite_np_binding),
    TSiteElem("oxidative deamination", CSeqFeatData::eSite_oxidative_deamination),
    TSiteElem("oxidative-deamination", CSeqFeatData::eSite_oxidative_deamination),
    TSiteElem("phosphorylation", CSeqFeatData::eSite_phosphorylation),
    TSiteElem("pyrrolidone carboxylic acid", CSeqFeatData::eSite_pyrrolidone_carboxylic_acid),
    TSiteElem("pyrrolidone-carboxylic-acid", CSeqFeatData::eSite_pyrrolidone_carboxylic_acid),
    TSiteElem("signal peptide", CSeqFeatData::eSite_signal_peptide),
    TSiteElem("signal-peptide", CSeqFeatData::eSite_signal_peptide),
    TSiteElem("sulfatation", CSeqFeatData::eSite_sulfatation),
    TSiteElem("transit peptide", CSeqFeatData::eSite_transit_peptide),
    TSiteElem("transit-peptide", CSeqFeatData::eSite_transit_peptide),
    TSiteElem("transmembrane region", CSeqFeatData::eSite_transmembrane_region),
    TSiteElem("transmembrane-region", CSeqFeatData::eSite_transmembrane_region)
};
typedef CStaticArrayMap<const string, CSeqFeatData::TSite>   TSiteMap;
static const TSiteMap sc_SiteMap(sc_site_map, sizeof(sc_site_map));


static void s_CleanupSite(CSeq_feat& feat)
{
    _ASSERT(feat.IsSetData()  &&  feat.SetData().IsSite());

    CSeqFeatData::TSite site = feat.GetData().GetSite();
    if (feat.IsSetComment()  &&
        (site == CSeqFeatData::TSite(0)  ||  site == CSeqFeatData::eSite_other)) {
        const string& comment = feat.GetComment();
        ITERATE (TSiteMap, it, sc_SiteMap) {
            if (NStr::StartsWith(comment, it->first, NStr::eNocase)) {
                feat.SetData().SetSite(it->second);
                if (NStr::IsBlank(comment, it->first.length())  ||
                    NStr::EqualNocase(comment, it->first.length(), NPOS, " site")) {
                    feat.ResetComment();
                }
            }
        }
    }
}


// === Prot

static const string uninf_names[] = {
    "peptide", "putative", "signal", "signal peptide", "signal-peptide",
    "signal_peptide", "transit", "transit peptide", "transit-peptide",
    "transit_peptide", "unknown", "unnamed"
};
typedef CStaticArraySet<string, PNocase> TUninformative;
static const TUninformative sc_UninfNames(uninf_names, sizeof(uninf_names));

static bool s_IsInformativeName(const string& name)
{
    return sc_UninfNames.find(name) == sc_UninfNames.end();
}


static void s_CleanupProt(CSeq_feat& feat)
{
    _ASSERT(feat.IsSetData()  &&  feat.GetData().IsProt());

    CSeq_feat::TData::TProt& prot = feat.SetData().SetProt();

    prot.BasicCleanup();

    if (prot.IsSetProcessed()  &&  prot.IsSetName()) {
        CProt_ref::TProcessed processed = prot.GetProcessed();
        CProt_ref::TName& name = prot.SetName();
        if (processed == CProt_ref::eProcessed_signal_peptide  ||
            processed == CProt_ref::eProcessed_transit_peptide) {
            CProt_ref::TName::iterator it = name.begin();
            while (it != name.end()) {
                if (!feat.IsSetComment()) {
                    if (NStr::Find(*it, "putative") != NPOS  ||
                        NStr::Find(*it, "put. ") != NPOS) {
                        feat.SetComment("putative");
                    }
                }
                // remove uninformative names
                if (!s_IsInformativeName(*it)) {
                    it = name.erase(it);
                } else {
                    ++it;
                }
            }
        }
    }

    // move Prot-ref.db to Seq-feat.dbxref
    if (prot.IsSetDb()) {
        copy(prot.GetDb().begin(), prot.GetDb().end(),
            back_inserter(feat.SetDbxref()));
        prot.ResetDb();
    }
}


// === RNA

static void s_CleanupRna(CSeq_feat& feat)
{
    _ASSERT(feat.IsSetData()  &&  feat.GetData().IsRna());

    CSeq_feat::TData& data = feat.SetData();
    CSeq_feat::TData::TRna& rna = data.SetRna();
    
    rna.BasicCleanup();

    /*if (rna.IsSetExt()  &&  rna.GetExt().IsName()) {
        string &name = rna.SetExt().SetName();
    }*/

    // !!! more?
}


// === Imp

static void s_AddReplaceQual(CSeq_feat& feat, const string& str)
{
    if (!NStr::EndsWith(str, ')')) {
        return;
    }

    SIZE_TYPE start = str.find_first_of('\"');
    if (start != NPOS) {
        SIZE_TYPE end = str.find_first_of('\"', start + 1);
        if (end != NPOS) {
            feat.AddQualifier("replace", str.substr(start + 1, end));
        }
    }
}

typedef pair<const string, CRNA_ref::TType> TRnaTypePair;
static const TRnaTypePair sc_rna_type_map[] = {
    TRnaTypePair("mRNA", CRNA_ref::eType_premsg),
    TRnaTypePair("misc_RNA", CRNA_ref::eType_other),
    TRnaTypePair("precursor_RNA", CRNA_ref::eType_premsg),
    TRnaTypePair("rRNA", CRNA_ref::eType_tRNA),
    TRnaTypePair("scRNA", CRNA_ref::eType_scRNA),
    TRnaTypePair("snRNA", CRNA_ref::eType_snRNA),
    TRnaTypePair("snoRNA", CRNA_ref::eType_snoRNA),
    TRnaTypePair("tRNA", CRNA_ref::eType_mRNA)
};
typedef CStaticArrayMap<const string, CRNA_ref::TType> TRnaTypeMap;
static const TRnaTypeMap sc_RnaTypeMap(sc_rna_type_map, sizeof(sc_rna_type_map));

static void s_CleanupImp(CSeq_feat& feat, bool is_embl_or_ddbj)
{
    _ASSERT(feat.IsSetData()  &&  feat.GetData().IsImp());

    CSeqFeatData& data = feat.SetData();
    CSeqFeatData::TImp& imp = data.SetImp();

    imp.BasicCleanup();

    if (imp.IsSetLoc()  &&  (NStr::Find(imp.GetLoc(), "replace") != NPOS)) {
        s_AddReplaceQual(feat, imp.GetLoc());
        imp.ResetLoc();
    }

    if (imp.IsSetKey()) {
        const CImp_feat::TKey& key = imp.GetKey();

        if (key == "CDS") {
            if (!is_embl_or_ddbj) {
                data.SetCdregion();
                //s_CleanupCdregion(feat);
            }
        } else if (!imp.IsSetLoc()  ||  NStr::IsBlank(imp.GetLoc())) {
            TRnaTypeMap::const_iterator rna_type_it = sc_RnaTypeMap.find(key);
            if (rna_type_it != sc_RnaTypeMap.end()) {
                CSeqFeatData::TRna& rna = data.SetRna();
                rna.SetType(rna_type_it->second);
                s_CleanupRna(feat);
            } else {
                // !!! need to find protein bioseq without object manager
            }
        }
    }
}


// === Region

static void s_CleanupRegion(CSeq_feat& feat)
{
    _ASSERT(feat.IsSetData()  &&  feat.GetData().IsRegion());

    string &region = feat.SetData().SetRegion();
    CleanString(region);
    ConvertDoubleQuotes(region);
    if (region.empty()) {
        feat.SetData().SetComment();
    }
}


// === User

static void s_CleanupUserString(string& str)
{
    if (!NStr::IsBlank(str)) {
        NStr::TruncateSpacesInPlace(str);
    }
}

static void s_CleanupObject_id(CObject_id& oid)
{
    if (oid.IsStr()) {
        s_CleanupUserString(oid.SetStr());
    }
}


static void s_CleanupUserObject(CUser_object& uo); // forward decleration

static void s_CleanupUserField(CUser_field& field)
{
    if (field.IsSetLabel()) {
        s_CleanupObject_id(field.SetLabel());
    }

    if (field.IsSetData()) {
        CUser_field::TData& data = field.SetData();
        switch (data.Which()) {
        case CUser_field::TData::e_Str:
            s_CleanupUserString(data.SetStr());
            break;
        case CUser_field::TData::e_Strs:
            NON_CONST_ITERATE (CUser_field::TData::TStrs, it, data.SetStrs()) {
                s_CleanupUserString(*it);
            }
            break;
        case CUser_field::TData::e_Object:
            s_CleanupUserObject(data.SetObject());
            break;
        case CUser_field::TData::e_Objects:
            NON_CONST_ITERATE (CUser_field::TData::TObjects, it, data.SetObjects()) {
                s_CleanupUserObject(**it);
            }
            break;
        case CUser_field::TData::e_Fields:
            NON_CONST_ITERATE (CUser_field::TData::TFields, it, data.SetFields()) {
                s_CleanupUserField(**it);
            }
            break;
        default:
            break;
        };
    }
}


static void s_CleanupUserObject(CUser_object& uo)
{
    if (uo.IsSetType()) {
        s_CleanupObject_id(uo.SetType());
    }

    NON_CONST_ITERATE (CUser_object::TData, it, uo.SetData()) {
        s_CleanupUserField(**it);
    }
}


static void s_CleanupUser(CSeq_feat& feat)
{
    _ASSERT(feat.IsSetData()  &&  feat.GetData().IsUser());

    s_CleanupUserObject(feat.SetData().SetUser());
}


// === Seq-feat.data

static void s_CleanupData(CSeq_feat& feat, bool is_embl_or_ddbj) {
    _ASSERT(feat.IsSetData());

    CSeq_feat::TData& data = feat.SetData();

    switch (data.Which()) {
    case CSeqFeatData::e_Gene:
        s_CleanupGene(feat);
        break;
    case CSeqFeatData::e_Org:
        break;
    case CSeqFeatData::e_Cdregion:
        break;
    case CSeqFeatData::e_Prot:
        s_CleanupProt(feat);
        break;
    case CSeqFeatData::e_Rna:
        s_CleanupRna(feat);
        break;
    case CSeqFeatData::e_Pub:
        break;
    case CSeqFeatData::e_Seq:
        break;
    case CSeqFeatData::e_Imp:
        s_CleanupImp(feat, is_embl_or_ddbj);
        break;
    case CSeqFeatData::e_Region:
        s_CleanupRegion(feat);
        break;
    case CSeqFeatData::e_Comment:
        break;
    case CSeqFeatData::e_Bond:
        break;
    case CSeqFeatData::e_Site:
        s_CleanupSite(feat);
        break;
    case CSeqFeatData::e_Rsite:
        break;
    case CSeqFeatData::e_User:
        s_CleanupUser(feat);
        break;
    case CSeqFeatData::e_Txinit:
        break;
    case CSeqFeatData::e_Num:
        break;
    case CSeqFeatData::e_Psec_str:
        break;
    case CSeqFeatData::e_Non_std_residue:
        break;
    case CSeqFeatData::e_Het:
        break;
    case CSeqFeatData::e_Biosrc:
        break;
    default:
        break;
    }
}


// seq-feat.qual

static void s_TrimParenthesesAndCommas(string& str)
{
    string::iterator it;
    for (it = str.begin(); it != str.end(); ++it) {
        char ch = *it;
        if (ch == '\0'  ||  (ch >= ' ' &&  ch != '('  &&  ch != ',')) {
            break;
        }
    }

    if (it != str.end()) {
        str.erase(str.begin(), it);
    }

    for (it = str.end(); it != str.begin(); --it) {
        char ch = *it;
        if (ch == '\0'  ||  (ch >= ' ' &&  ch != '('  &&  ch != ',')) {
            break;
        }
    }

    if (it != str.begin()) {
        str.erase(it);
    }
}


static void s_CombineSplitQual(string& val, string& new_val)
{
    if (NStr::Find(val, new_val) != NPOS) {
        return;
    }

    s_TrimParenthesesAndCommas(val);
    s_TrimParenthesesAndCommas(new_val);

    val.insert(0, "(");
    ((val += ',') += new_val) += ')';
}


static bool s_HandleGbQualOnGene(CSeq_feat& feat, const string& qual, const string& val)
{
    _ASSERT(feat.GetData().IsGene());

    CGene_ref& gene = feat.SetData().SetGene();

    bool retval = true;
    if (NStr::EqualNocase(qual, "pseudo")) {
        gene.SetPseudo(true);
    } else if (NStr::EqualNocase(qual, "map")) {
        if (gene.IsSetMaploc()  ||  NStr::IsBlank(val)) {
            retval = false;
        } else {
            gene.SetMaploc(val);
        }
    } else if (NStr::EqualNocase(qual, "allele")) {
        if (gene.IsSetAllele()  ||  NStr::IsBlank(val)) {
            retval = false;
        } else {
            gene.SetAllele(val);
        }
    } else if (NStr::EqualNocase(qual, "locus_tag")) {
        if (gene.IsSetLocus_tag()  ||  NStr::IsBlank(val)) {
            retval = false;
        } else {
            gene.SetLocus_tag(val);
        }
    }

    return retval;
}


static bool s_HandleGbQualOnCDS(CSeq_feat& feat, const string& qual, const string& val)
{
    _ASSERT(feat.GetData().IsCdregion());

    CSeq_feat::TData::TCdregion& cds = feat.SetData().SetCdregion();

    // transl_except qual -> Cdregion.code_break
    if (NStr::EqualNocase(qual, "transl_except")) {
        return false ; // s_ParseCodeBreak(feat, val);
    }

    // codon_start qual -> Cdregion.frame
    if (NStr::EqualNocase(qual, "codon_start")) {
        CCdregion::TFrame frame = cds.GetFrame();
        CCdregion::TFrame new_frame = CCdregion::TFrame(NStr::StringToNumeric(val));
        if (new_frame == CCdregion::eFrame_one  ||
            new_frame == CCdregion::eFrame_two  ||
            new_frame == CCdregion::eFrame_three) {
            if (frame == CCdregion::eFrame_not_set  ||
                (feat.IsSetPseudo()  &&  feat.GetPseudo()  &&  !feat.IsSetProduct())) {
                cds.SetFrame(new_frame);
            }
            return true;
        }
    }

    // transl_table qual -> Cdregion.code
    if (NStr::EqualNocase(qual, "transl_table")) {
        if (cds.IsSetCode()) {
            const CCdregion::TCode& code = cds.GetCode();
            int transl_table = 1;
            ITERATE (CCdregion::TCode::Tdata, it, code.Get()) {
                if ((*it)->IsId()  &&  (*it)->GetId() != 0) {
                    transl_table = (*it)->GetId();
                    break;
                }
            }
            
            if (NStr::EqualNocase(NStr::UIntToString(transl_table), val)) {
                return true;
            }
        } else {
            int new_val = NStr::StringToNumeric(val);
            if (new_val > 0) {
                CRef<CGenetic_code::C_E> gc(new CGenetic_code::C_E);
                gc->SetId(new_val);
                cds.SetCode().Set().push_back(gc);
                return true;
            }
        }
    }

    /*if (NStr::EqualNocase(qual, "translation")) {
        return TRUE;
    }*/
    return false;
}


static bool s_HandleGbQualOnRna(CSeq_feat& feat, const string& qual, const string& val, bool is_embl_or_ddbj)
{
    _ASSERT(feat.GetData().IsRna());

    CSeq_feat::TData::TRna& rna = feat.SetData().SetRna();

    bool is_std_name = NStr::EqualNocase(qual, "standard_name");
    if (NStr::EqualNocase(qual, "product")  ||  (is_std_name  &&  !is_embl_or_ddbj)) {
        if (rna.IsSetType()) {
            if (rna.GetType() == CRNA_ref::eType_unknown) {
                rna.SetType(CRNA_ref::eType_other);
            }
        } else {
            rna.SetType(CRNA_ref::eType_other);
        }
        _ASSERT(rna.IsSetType());

        CRNA_ref::TType type = rna.GetType();
        
        if (type == CRNA_ref::eType_other  &&  is_std_name) {
            return false;
        }

        if (type == CRNA_ref::eType_tRNA  &&  rna.IsSetExt()  &&  rna.GetExt().IsName()) {
            //!!! const string& name = rna.GetExt().GetName();
        }
    }
    return false;
}


static bool s_HandleGbQualOnProt(CSeq_feat& feat, const string& qual, const string& val)
{
    _ASSERT(feat.GetData().IsProt());
    
    CSeq_feat::TData::TProt& prot = feat.SetData().SetProt();

    if (NStr::EqualNocase(qual, "product")  ||  NStr::EqualNocase(qual, "standard_name")) {
        if (!prot.IsSetName()  ||  NStr::IsBlank(prot.GetName().front())) {
            prot.SetName().push_back(val);
            if (prot.IsSetDesc()) {
                const CProt_ref::TDesc& desc = prot.GetDesc();
                ITERATE (CProt_ref::TName, it, prot.GetName()) {
                    if (NStr::EqualNocase(desc, *it)) {
                        prot.ResetDesc();
                        break;
                    }
                }
            }
            return true;
        }
    } else if (NStr::EqualNocase(qual, "function")) {
        prot.SetActivity().push_back(val);
        return true;
    } else if (NStr::EqualNocase(qual, "EC_number")) {
        prot.SetEc().push_back(val);
        return true;
    }

    return false;
}


static void s_CleanupQual(CSeq_feat& feat, bool is_embl_or_ddbj)
{
    _ASSERT(feat.IsSetQual()  &&  feat.IsSetData());

    CSeq_feat::TQual& qual = feat.SetQual();
    CSeq_feat::TData& data = feat.SetData();

    vector<CSeq_feat::TQual::iterator> remove;

    CRef<CGb_qual> rpt_type, rpt_unit, usedin, old_locus_tag, compare;

    NON_CONST_ITERATE (CSeq_feat::TQual, it, qual) {
        CGb_qual& gb_qual = **it;

        gb_qual.BasicCleanup();
        _ASSERT(gb_qual.IsSetQual()  &&  gb_qual.IsSetVal());

        string& qual = gb_qual.SetQual();
        string& val  = gb_qual.SetVal();

        // 'replace' qualifier
        if (NStr::EqualNocase(qual, "replace")) {
            if (data.IsImp()  &&  data.GetImp().IsSetKey()) {
                CSeq_feat::TData::TImp& imp = feat.SetData().SetImp();
                if (NStr::EqualNocase(imp.GetKey(), "variation")) {
                    NStr::ToLower(val);
                }
            }
        }

        if (NStr::EqualNocase(qual, "partial")) {
            feat.SetPartial();
            remove.push_back(it);  // mark qual for deletion
        } else if (NStr::EqualNocase(qual, "evidance")) {
            if (NStr::EqualNocase(val, "experimental")) {
                if (!feat.IsSetExp_ev()  ||  feat.GetExp_ev() != CSeq_feat::eExp_ev_not_experimental) {
                    feat.SetExp_ev(CSeq_feat::eExp_ev_experimental);
                }
            } else if (NStr::EqualNocase(val, "not_experimental")) {
                feat.SetExp_ev(CSeq_feat::eExp_ev_not_experimental);
            }
            remove.push_back(it);  // mark qual for deletion
        } else if (NStr::EqualNocase(qual, "exception")) {
            feat.SetExcept(true);
            if (!NStr::IsBlank(val)  &&  !NStr::EqualNocase(val, "true")) {
                if (!feat.IsSetExcept_text()) {
                    feat.SetExcept_text(val);
                }
            }
            remove.push_back(it);  // mark qual for deletion
        } else if (NStr::EqualNocase(qual, "note")) {
            if (!feat.IsSetComment()) {
                feat.SetComment(val);
            } else {
                (feat.SetComment() += "; ") += val;
            }
            remove.push_back(it);  // mark qual for deletion
        } else if (NStr::EqualNocase(qual, "db_xref")) {
            string tag, db;
            if (NStr::SplitInTwo(val, ":", db, tag)) {
                CRef<CDbtag> dbp(new CDbtag);
                dbp->SetDb(db);
                dbp->SetTag().SetStr(tag);
                feat.SetDbxref().push_back(dbp);
                remove.push_back(it);  // mark qual for deletion
            }
        } else if (NStr::EqualNocase(qual, "gdb_xref")) {
            CRef<CDbtag> dbp(new CDbtag);
            dbp->SetDb("GDB");
            dbp->SetTag().SetStr(val);
            feat.SetDbxref().push_back(dbp);
            remove.push_back(it);  // mark qual for deletion
        } else if (NStr::EqualNocase(qual, "rpt_type")) {
            if (rpt_type.Empty()) {
                rpt_type.Reset(&gb_qual);
            } else {
                
                remove.push_back(it);  // mark qual for deletion
            }
        } else if (NStr::EqualNocase(qual, "rpt_unit")) {
            if (rpt_unit.Empty()) {
                rpt_unit.Reset(&gb_qual);
            } else {
                s_CombineSplitQual(rpt_unit->SetVal(), val);
                remove.push_back(it);  // mark qual for deletion
            }
        } else if (NStr::EqualNocase(qual, "usedin")) {
            if (usedin.Empty()) {
                usedin.Reset(&gb_qual);
            } else {
                s_CombineSplitQual(usedin->SetVal(), val);
                remove.push_back(it);  // mark qual for deletion
            }
        } else if (NStr::EqualNocase(qual, "old_locus_tag")) {
            if (old_locus_tag.Empty()) {
                old_locus_tag.Reset(&gb_qual);
            } else {
                s_CombineSplitQual(old_locus_tag->SetVal(), val);
                remove.push_back(it);  // mark qual for deletion
            }
        } else if (NStr::EqualNocase(qual, "compare")) {
            if (compare.Empty()) {
                compare.Reset(&gb_qual);
            } else {
                s_CombineSplitQual(compare->SetVal(), val);
                remove.push_back(it);  // mark qual for deletion
            }
        } else if (NStr::EqualNocase(qual, "pseudo")) {
            feat.SetPseudo(true);
            remove.push_back(it);  // mark qual for deletion
        } else if (NStr::EqualNocase(qual, "gene")) {
            if (!NStr::IsBlank(val)) {
                CRef<CSeqFeatXref> xref(new CSeqFeatXref);
                xref->SetData().SetGene().SetLocus(val);
                feat.SetXref().push_back(xref);
                remove.push_back(it);  // mark qual for deletion
            }
        } else if (NStr::EqualNocase(qual, "codon_start")) {
            if (!data.IsCdregion()) {
                // not legal on anything but CDS, so remove it
                remove.push_back(it);  // mark qual for deletion
            }
        } else if (data.IsGene()  &&  s_HandleGbQualOnGene(feat, qual, val)) {
            remove.push_back(it);  // mark qual for deletion
        } else if (data.IsCdregion()  &&  s_HandleGbQualOnCDS(feat, qual, val)) {
            remove.push_back(it);  // mark qual for deletion
        } else if (data.IsRna()  &&  s_HandleGbQualOnRna(feat, qual, val, is_embl_or_ddbj)) {
            remove.push_back(it);  // mark qual for deletion
        } else if (data.IsProt()  &&  s_HandleGbQualOnProt(feat, qual, val)) {
            remove.push_back(it);  // mark qual for deletion
        }
    }

    if (rpt_unit.NotEmpty()) {
        // re-trigger cleanup for newly constructed rpt_unit qualifier
        rpt_unit->BasicCleanup();
    }

    // delete all marked quals
    ITERATE (vector<CSeq_feat::TQual::iterator>, it, remove) {
        feat.SetQual().erase(*it);
    }
}


// === Seq-feat.dbxref


struct SDbtagCompare
{
    // is dbt1 < dbt2
    bool operator()(const CRef<CDbtag>& dbt1, const CRef<CDbtag>& dbt2) {
        return dbt1->Compare(*dbt2) < 0;
    }
};


struct SDbtagEqual
{
    // is dbt1 < dbt2
    bool operator()(const CRef<CDbtag>& dbt1, const CRef<CDbtag>& dbt2) {
        return dbt1->Compare(*dbt2) == 0;
    }
};


static void s_CleanupDbxref(CSeq_feat& feat)
{
    _ASSERT(feat.IsSetDbxref());

    CSeq_feat::TDbxref& dbxref = feat.SetDbxref();

    // dbxrefs cleanup
    CSeq_feat::TDbxref::iterator it = dbxref.begin();
    while (it != dbxref.end()) {
        if (it->Empty()) {
            it = dbxref.erase(it);
            continue;
        }
        (*it)->BasicCleanup();

        ++it;
    }

    // sort/unique db_xrefs
    stable_sort(dbxref.begin(), dbxref.end(), SDbtagCompare());
    it = unique(dbxref.begin(), dbxref.end(), SDbtagEqual());
    dbxref.erase(it, dbxref.end());
}   


// BasicCleanup
void CSeq_feat::BasicCleanup(ECleanupMode mode)
{
    if (!IsSetData()) {
        return;
    }

    CLEAN_STRING_MEMBER(Comment);
    if (IsSetComment()  &&  GetComment() == ".") {
        ResetComment();
    }
    CLEAN_STRING_MEMBER(Title);
    CLEAN_STRING_MEMBER(Except_text);
    if (IsSetExcept_text()) {
        s_CleanupExcept_text(SetExcept_text());
    }

    bool is_embl_or_ddbj = (mode == eCleanup_EMBL  ||  mode == eCleanup_DDBJ);

    s_CleanupData(*this, is_embl_or_ddbj);

    if (IsSetDbxref()) {
       s_CleanupDbxref(*this);
    }
    if (IsSetQual()) {
        s_CleanupQual(*this, is_embl_or_ddbj);
    }
}

// ==========================================================================
//                             end of cleanup section
// ==========================================================================

END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/*
 * ===========================================================================
 *
 * $Log$
 * Revision 6.23  2005/05/20 13:36:54  shomrat
 * Added BasicCleanup()
 *
 * Revision 6.22  2004/10/13 13:57:15  shomrat
 * GetNamedQual return const string& instead of string
 *
 * Revision 6.21  2004/10/12 13:28:18  dicuccio
 * GetNamedDbxref() / GetNamedQual(): made const
 *
 * Revision 6.20  2004/10/04 17:20:45  dicuccio
 * Doxygen-ated comments.  Added GetNamedDbxref() / GetNamedQual()
 *
 * Revision 6.19  2004/05/19 17:26:04  gorelenk
 * Added include of PCH - ncbi_pch.hpp
 *
 * Revision 6.18  2004/02/09 14:45:07  vasilche
 * Do not check type order if types are equal.
 *
 * Revision 6.17  2004/01/05 19:16:57  dicuccio
 * Added APIs to ease adding qualifiers and dbxrefs
 *
 * Revision 6.16  2003/12/31 15:36:08  grichenk
 * Moved CompareLocations() from CSeq_feat to CSeq_loc,
 * renamed it to Compare().
 *
 * Revision 6.15  2003/08/07 21:42:31  kans
 * added SetGeneXref and SetProtXref
 *
 * Revision 6.14  2003/04/24 16:15:32  vasilche
 * Fixed CSeq_feat::Compare().
 *
 * Revision 6.13  2003/04/18 19:40:39  kans
 * changed iterate to ITERATE
 *
 * Revision 6.12  2003/02/26 17:53:06  vasilche
 * Added public version of feature comparison assuming that
 * total range check is done already.
 *
 * Revision 6.11  2003/02/24 18:52:57  vasilche
 * Added optional mapped locations arguments to feature comparison.
 *
 * Revision 6.10  2003/02/10 15:52:08  grichenk
 * CSeq_feat::Compare() takes optional seq-locs for remapped features
 *
 * Revision 6.9  2003/02/06 22:24:23  vasilche
 * Added int CSeq_feat::Compare().
 * Fixed slow comparison of CSeq_feat with mix seq locs.
 *
 * Revision 6.8  2003/01/29 17:43:23  vasilche
 * Added Compare(CSeq_feat, CSeq_feat) returning int for easier comparison.
 * operator<(CSeq_feat, CSeq_feat) uses Compare().
 *
 * Revision 6.7  2002/12/19 21:31:29  kans
 * added GetGeneXref and GetProtXref
 *
 * Revision 6.6  2002/09/18 18:31:11  ucko
 * operator <: Remove bogus comparison of feature type labels.
 * operator <: Mention content labels in to-do comment.
 * general: Move CVS log to end per current practice.
 *
 * Revision 6.5  2002/06/06 20:55:48  clausen
 * Moved GetLabel to objects/util/feature.cpp
 *
 * Revision 6.4  2002/05/06 03:39:11  vakatov
 * OM/OM1 renaming
 *
 * Revision 6.3  2002/01/10 19:53:48  clausen
 * Added GetLabel
 *
 * Revision 6.2  2002/01/09 15:59:28  grichenk
 * Fixed includes
 *
 * Revision 6.1  2001/10/30 20:25:58  ucko
 * Implement feature labels/keys, subtypes, and sorting
 *
 *
 * ===========================================================================
 */

/* Original file checksum: lines: 61, chars: 1885, CRC32: 417ca6e0 */
