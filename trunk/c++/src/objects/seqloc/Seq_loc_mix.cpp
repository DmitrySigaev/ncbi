/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  Eugene Vasilchenko
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seqloc.asn'.
 */

#include <ncbi_pch.hpp>
#include <objects/seqloc/Seq_loc_mix.hpp>
#include <objects/seqloc/Seq_interval.hpp>
#include <objects/seqloc/Seq_point.hpp>


BEGIN_NCBI_SCOPE
BEGIN_objects_SCOPE // namespace ncbi::objects::

CSeq_loc_mix::CSeq_loc_mix(void)
{
    return;
}


CSeq_loc_mix::~CSeq_loc_mix(void)
{
}

bool CSeq_loc_mix::IsPartialStart(ESeqLocExtremes ext) const
{
    if (!Get().empty()) {
        return (IsReverseStrand()  &&  ext == eExtreme_Positional) ?
            Get().back()->IsPartialStart(ext) : Get().front()->IsPartialStart(ext);
    }
    return false;
}

bool CSeq_loc_mix::IsPartialStop(ESeqLocExtremes ext) const
{
    if (!Get().empty()) {
        return (IsReverseStrand()  &&  ext == eExtreme_Positional) ?
            Get().front()->IsPartialStop(ext) : Get().back()->IsPartialStop(ext);
    }
    return false;
}


void CSeq_loc_mix::SetPartialStart(bool val, ESeqLocExtremes ext)
{
    if (IsPartialStart(ext) == val  ||  Set().empty()) {
        return;
    }
    if ((IsReverseStrand()  &&  ext == eExtreme_Positional)) {
        Set().back()->SetPartialStart(val, ext);
    }else {
        Set().front()->SetPartialStart(val, ext);
    }
}


void CSeq_loc_mix::SetPartialStop(bool val, ESeqLocExtremes ext)
{
    if (IsPartialStop(ext) == val  ||  Set().empty()) {
        return;
    }
    if (IsReverseStrand()  &&  ext == eExtreme_Positional) {
        Set().front()->SetPartialStop(val, ext);
    } else {
        Set().back()->SetPartialStop(val, ext);
    }
}


bool CSeq_loc_mix::IsTruncatedStart(ESeqLocExtremes ext) const
{
    if (!Get().empty()) {
        return (IsReverseStrand()  &&  ext == eExtreme_Positional) ?
            Get().back()->IsTruncatedStart(ext) :
            Get().front()->IsTruncatedStart(ext);
    }
    return false;
}

bool CSeq_loc_mix::IsTruncatedStop(ESeqLocExtremes ext) const
{
    if (!Get().empty()) {
        return (IsReverseStrand()  &&  ext == eExtreme_Positional) ?
            Get().front()->IsTruncatedStop(ext) :
            Get().back()->IsTruncatedStop(ext);
    }
    return false;
}


void CSeq_loc_mix::SetTruncatedStart(bool val, ESeqLocExtremes ext)
{
    if (IsTruncatedStart(ext) == val  ||  Set().empty()) {
        return;
    }
    if ((IsReverseStrand()  &&  ext == eExtreme_Positional)) {
        Set().back()->SetTruncatedStart(val, ext);
    }else {
        Set().front()->SetTruncatedStart(val, ext);
    }
}


void CSeq_loc_mix::SetTruncatedStop(bool val, ESeqLocExtremes ext)
{
    if (IsTruncatedStop(ext) == val  ||  Set().empty()) {
        return;
    }
    if (IsReverseStrand()  &&  ext == eExtreme_Positional) {
        Set().front()->SetTruncatedStop(val, ext);
    } else {
        Set().back()->SetTruncatedStop(val, ext);
    }
}


ENa_strand CSeq_loc_mix::GetStrand(void) const
{
    ENa_strand strand = eNa_strand_unknown;
    bool strand_set = false;
    const CSeq_id* id = NULL;
    ITERATE(Tdata, it, Get()) {
        if ((*it)->IsNull()  ||  (*it)->IsEmpty()) {
            continue;
        }

        // check fro multiple IDs
        const CSeq_id* iid = (*it)->GetId();
        if (iid == NULL) {
            return eNa_strand_other;
        }
        if (id == NULL) {
            id = iid;
        } else {
            if (id->Compare(*iid) != CSeq_id::e_YES) {
                return eNa_strand_other;
            }
        }

        ENa_strand istrand = (*it)->GetStrand();
        if (strand == eNa_strand_unknown  &&  istrand == eNa_strand_plus) {
            strand = istrand;
            strand_set = true;
        } else if (strand == eNa_strand_plus  &&  istrand == eNa_strand_unknown) {
        } else if (!strand_set) {
            strand = istrand;
            strand_set = true;
        } else if (istrand != strand) {
            return eNa_strand_other;
        }
    }
    return strand;
}


TSeqPos CSeq_loc_mix::GetStart(ESeqLocExtremes ext) const
{
    if (!Get().empty()) {
        return (IsReverseStrand()  &&  ext == eExtreme_Positional) ?
            Get().back()->GetStart(ext) : Get().front()->GetStart(ext);
    }
    return kInvalidSeqPos;
}


TSeqPos CSeq_loc_mix::GetStop(ESeqLocExtremes ext) const
{
    if (!Get().empty()) {
        return (IsReverseStrand()  &&  ext == eExtreme_Positional) ?
            Get().front()->GetStop(ext) : Get().back()->GetStop(ext);
    }
    return kInvalidSeqPos;
}


void CSeq_loc_mix::AddSeqLoc(const CSeq_loc& other)
{
    if ( !other.IsMix() ) {
        CRef<CSeq_loc> loc(new CSeq_loc);
        loc->Assign(other);
        Set().push_back(loc);
    } else {
        // "flatten" the other seq-loc
        ITERATE(CSeq_loc_mix::Tdata, li, other.GetMix().Get()) {
            AddSeqLoc(**li);
        }
    }
}


void CSeq_loc_mix::AddSeqLoc(CSeq_loc& other)
{
    if ( !other.IsMix() ) {
        CRef<CSeq_loc> loc(&other);
        Set().push_back(loc);
    } else {
        // "flatten" the other seq-loc
        NON_CONST_ITERATE(CSeq_loc_mix::Tdata, li, other.SetMix().Set()) {
            AddSeqLoc(**li);
        }
    }
}


void CSeq_loc_mix::AddInterval(const CSeq_id& id, TSeqPos from, TSeqPos to,
                               ENa_strand strand)
{
    CRef<CSeq_loc> loc(new CSeq_loc);
    if (from == to) {
        CSeq_point& pnt = loc->SetPnt();
        pnt.SetPoint(from);
        pnt.SetId().Assign(id);
        if (strand != eNa_strand_unknown) {
            pnt.SetStrand(strand);
        }
    } else {
        CSeq_interval& ival = loc->SetInt();
        ival.SetFrom(from);
        ival.SetTo(to);
        ival.SetId().Assign(id);
        if (strand != eNa_strand_unknown) {
            ival.SetStrand(strand);
        }
    }
    Set().push_back(loc);
}


void CSeq_loc_mix::SetStrand(ENa_strand strand)
{
    NON_CONST_ITERATE (Tdata, it, Set()) {
        (*it)->SetStrand(strand);
    }
}


void CSeq_loc_mix::ResetStrand()
{
    NON_CONST_ITERATE (Tdata, it, Set()) {
        (*it)->ResetStrand();
    }
}


void CSeq_loc_mix::FlipStrand(void)
{
    NON_CONST_ITERATE (Tdata, it, Set()) {
        (*it)->FlipStrand();
    }
}

END_objects_SCOPE // namespace ncbi::objects::
END_NCBI_SCOPE

/*
 * ===========================================================================
 *
 * $Log$
 * Revision 6.22  2007/01/09 12:40:18  dicuccio
 * Added ResetStrand() to all relevant top-level Seq-loc objects
 *
 * Revision 6.21  2006/03/16 18:58:30  grichenk
 * Indicate intervals truncated while mapping by fuzz lim tl/tr.
 *
 * Revision 6.20  2005/02/18 15:01:53  shomrat
 * Use ESeqLocExtremes to solve Left/Right ambiguity
 *
 * Revision 6.19  2005/01/05 18:29:59  shomrat
 * Fixed IsReverseStrand
 *
 * Revision 6.18  2004/12/15 16:26:56  grichenk
 * Ignore NULLs in IsReverseStrand()
 *
 * Revision 6.17  2004/11/19 15:42:33  shomrat
 * + SetStrand
 *
 * Revision 6.16  2004/10/25 18:01:33  shomrat
 * + FlipStrand
 *
 * Revision 6.15  2004/10/22 16:01:20  kans
 * protect IsPartialXXX with Get empty test
 *
 * Revision 6.14  2004/10/21 21:45:07  kans
 * CSeq_loc_mix::SetPartialRight was incorrectly using front instead of back
 *
 * Revision 6.13  2004/09/01 15:33:44  grichenk
 * Check strand in GetStart and GetEnd. Circular length argument
 * made optional.
 *
 * Revision 6.12  2004/05/19 17:26:25  gorelenk
 * Added include of PCH - ncbi_pch.hpp
 *
 * Revision 6.11  2004/05/06 16:55:00  shomrat
 * Added methods to set partial left and right
 *
 * Revision 6.10  2004/01/28 17:18:19  shomrat
 * Added methods to ease the construction of objects
 *
 * Revision 6.9  2003/05/23 20:24:56  ucko
 * +AddInterval (also handles points automatically); CVS log -> end;
 * drop workaround for old WorkShop bug
 *
 * Revision 6.8  2002/09/12 21:19:02  kans
 * added IsPartialLeft and IsPartialRight
 *
 * Revision 6.7  2002/06/06 20:51:51  clausen
 * Moved GetLength to objects/util/sequence.cpp
 *
 * Revision 6.6  2002/05/03 21:28:19  ucko
 * Introduce T(Signed)SeqPos.
 *
 * Revision 6.5  2002/04/22 20:09:08  grichenk
 * -GetTotalRange(), GetRangeMap(), ResetRangeMap()
 *
 * Revision 6.4  2002/01/24 23:29:48  vakatov
 * Note for ourselves that the bug workaround "BW_010" is not needed
 * anymore, and we should get rid of it in about half a year
 *
 * Revision 6.3  2002/01/07 05:20:03  vakatov
 * Workaround for the SUN Forte 6 Update 1,2 compiler's internal bug.
 *
 * Revision 6.2  2001/01/03 16:39:05  vasilche
 * Added CAbstractObjectManager - stub for object manager.
 * CRange extracted to separate file.
 *
 * Revision 6.1  2000/11/17 21:35:10  vasilche
 * Added GetLength() method to CSeq_loc class.
 *
 * ===========================================================================
 */
