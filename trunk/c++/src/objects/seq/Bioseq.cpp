/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  .......
 *
 * File Description:
 *   .......
 *
 * Remark:
 *   This code was originally generated by application DATATOOL
 *   using specifications from the ASN data definition file
 *   'seq.asn'.
 *
 * ---------------------------------------------------------------------------
 * $Log$
 * Revision 6.9  2002/03/28 21:21:49  grichenk
 * Fixed range exclusion
 *
 * Revision 6.8  2002/03/18 21:46:13  grichenk
 * +ConstructExcludedSequence()
 *
 * Revision 6.7  2002/01/16 18:56:31  grichenk
 * Removed CRef<> argument from choice variant setter, updated sources to
 * use references instead of CRef<>s
 *
 * Revision 6.6  2001/12/20 20:00:31  grichenk
 * CObjectManager::ConstructBioseq(CSeq_loc) -> CBioseq::CBioseq(CSeq_loc ...)
 *
 * Revision 6.5  2001/10/12 19:32:57  ucko
 * move BREAK to a central location; move CBioseq::GetTitle to object manager
 *
 * Revision 6.4  2001/10/04 19:11:54  ucko
 * Centralize (rudimentary) code to get a sequence's title.
 *
 * Revision 6.3  2001/07/16 16:20:19  grichenk
 * Initial revision
 *
 *
 * ===========================================================================
 */

// standard includes
#include <objects/seqloc/Seq_loc.hpp>
#include <objects/seqloc/Seq_id.hpp>
#include <objects/seq/Delta_seq.hpp>
#include <objects/seq/Delta_ext.hpp>
#include <objects/general/Object_id.hpp>
#include <objects/seq/Seq_inst.hpp>
#include <objects/seq/Seq_ext.hpp>
#include <objects/seqloc/Seq_interval.hpp>
#include <objects/seqloc/Seq_point.hpp>

// generated includes
#include <objects/seq/Bioseq.hpp>

#include <serial/typeinfo.hpp>
// generated classes

BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::

// destructor
CBioseq::~CBioseq(void)
{
}

void CBioseq::Assign(const CSerialUserOp& source)
{
    const CBioseq& src = dynamic_cast<const CBioseq&>(source);
    m_ParentEntry = src.m_ParentEntry;
}

bool CBioseq::Equals(const CSerialUserOp& object) const
{
    const CBioseq& obj = dynamic_cast<const CBioseq&>(object);
    return m_ParentEntry == obj.m_ParentEntry;
}


int CBioseq::sm_ConstructedId = 0;

void CBioseq::x_SeqLoc_To_DeltaExt(const CSeq_loc& loc, CDelta_ext& ext)
{
    switch ( loc.Which() ) {
    case CSeq_loc::e_Packed_int:
        {
            // extract each range, create and add simple location
            iterate ( CPacked_seqint::Tdata, ii, loc.GetPacked_int().Get() ) {
                CSeq_loc* int_loc = new CSeq_loc;
                SerialAssign<CSeq_id>
                    (int_loc->SetInt().SetId(), (*ii)->GetId());
                int_loc->SetInt().SetFrom((*ii)->GetFrom());
                int_loc->SetInt().SetTo((*ii)->GetTo());
                if ( (*ii)->IsSetStrand() )
                    int_loc->SetInt().SetStrand((*ii)->GetStrand());
                CDelta_seq* dseq = new CDelta_seq;
                dseq->SetLoc(*int_loc);
                ext.Set().push_back(dseq);
            }
            break;
        }
    case CSeq_loc::e_Packed_pnt:
        {
            // extract each point
            iterate ( CPacked_seqpnt::TPoints, pi,
                      loc.GetPacked_pnt().GetPoints() ) {
                CSeq_loc* pnt_loc = new CSeq_loc;
                SerialAssign<CSeq_id>
                    (pnt_loc->SetPnt().SetId(), loc.GetPacked_pnt().GetId());
                pnt_loc->SetPnt().SetPoint(*pi);
                if ( loc.GetPacked_pnt().IsSetStrand() ) {
                    pnt_loc->SetPnt().SetStrand(
                        loc.GetPacked_pnt().GetStrand());
                }
                CDelta_seq* dseq = new CDelta_seq;
                dseq->SetLoc(*pnt_loc);
                ext.Set().push_back(dseq);
            }
        }
    case CSeq_loc::e_Mix:
        {
            // extract sub-locations
            iterate ( CSeq_loc_mix::Tdata, li, loc.GetMix().Get() ) {
                x_SeqLoc_To_DeltaExt(**li, ext);
            }
            return;
        }
    default:
        {
            // Just add the location
            CDelta_seq* dseq = new CDelta_seq;
            CSeq_loc* cp_loc = new CSeq_loc;
            SerialAssign<CSeq_loc>(*cp_loc, loc);
            dseq->SetLoc(*cp_loc);
            ext.Set().push_back(dseq);
        }
    }
}


CBioseq::CBioseq(const CSeq_loc& loc, string str_id)
    : m_ParentEntry(0)
{
    CBioseq::TId& id_list = SetId();

    // Id
    CSeq_id* id = new CSeq_id;
    if ( str_id.empty() ) {
        id->SetLocal().SetStr("constructed" + NStr::IntToString(sm_ConstructedId++));
    }
    else {
        id->SetLocal().SetStr(str_id);
    }
    id_list.push_back(id);

    // Inst
    CSeq_inst& inst = SetInst();
    inst.SetRepr(CSeq_inst::eRepr_const);
    inst.SetMol(CSeq_inst::eMol_other);

    CDelta_ext& ext = inst.SetExt().SetDelta();
    x_SeqLoc_To_DeltaExt(loc, ext);
}


void CBioseq::x_ExcludeRange(TRanges& ranges, int start, int stop)
{
    if (ranges.size() == 0)
        return;
    TRanges::iterator lo = ranges.lower_bound(start);
    TRanges::iterator hi = ranges.upper_bound(stop+1);
    if (lo != ranges.end()) {
        if (lo->second == eStop) {
            // eStop will be removed, add the correct one
            ranges[start] = eStop;
        }
    }
    if (hi != ranges.end()  &&  hi->second == eStop) {
        // eStart will be removed, add the correct one
        ranges[stop+1] = eStart;
        if (hi->first <= lo->first) {
            return;
        }
        --hi;
    }
    if (lo->first == start  &&  lo->second == eStop) {
        ++lo;
    }
    ranges.erase(lo, hi);
}


void CBioseq::x_ExcludeSeqLoc(const CSeq_loc& loc,
                              TRanges& ranges,
                              CSeq_id& id)
{
    // Compare all seq-ids to the first one
    switch ( loc.Which() ) {
    case CSeq_loc::e_Whole:
        {
            if (id.Which() == CSeq_id::e_not_set) {
                SerialAssign<CSeq_id>(id, loc.GetWhole());
            }
            else {
                _ASSERT(SerialEquals<CSeq_id>(id, loc.GetWhole()));
            }
            ranges.clear(); // no ranges left
            break;
        }
    case CSeq_loc::e_Int:
        {
            if (id.Which() == CSeq_id::e_not_set) {
                SerialAssign<CSeq_id>(id, loc.GetInt().GetId());
            }
            else {
                _ASSERT(SerialEquals<CSeq_id>(id, loc.GetInt().GetId()));
            }
            x_ExcludeRange(ranges,
                loc.GetInt().GetFrom(), loc.GetInt().GetTo());
            break;
        }
    case CSeq_loc::e_Packed_int:
        {
            iterate (CPacked_seqint::Tdata, ii, loc.GetPacked_int().Get() ) {
                if (id.Which() == CSeq_id::e_not_set) {
                    SerialAssign<CSeq_id>(id, (*ii)->GetId());
                }
                else {
                    _ASSERT(SerialEquals<CSeq_id>(id, (*ii)->GetId()));
                }
                x_ExcludeRange(ranges, (*ii)->GetFrom(), (*ii)->GetTo());
            }
            break;
        }
    case CSeq_loc::e_Pnt:
        {
            if (id.Which() == CSeq_id::e_not_set) {
                SerialAssign<CSeq_id>(id, loc.GetPnt().GetId());
            }
            else {
                _ASSERT(SerialEquals<CSeq_id>(id, loc.GetPnt().GetId()));
            }
            x_ExcludeRange(ranges,
                loc.GetPnt().GetPoint(), loc.GetPnt().GetPoint());
            break;
        }
    case CSeq_loc::e_Packed_pnt:
        {
            if (id.Which() == CSeq_id::e_not_set) {
                SerialAssign<CSeq_id>(id, loc.GetPacked_pnt().GetId());
            }
            else {
                _ASSERT(SerialEquals<CSeq_id>(id, loc.GetPacked_pnt().GetId()));
            }
            iterate (CPacked_seqpnt::TPoints, pi, loc.GetPacked_pnt().GetPoints()) {
                x_ExcludeRange(ranges, *pi, *pi);
            }
            break;
        }
    case CSeq_loc::e_Mix:
        {
            iterate (CSeq_loc_mix::Tdata, li, loc.GetMix().Get()) {
                x_ExcludeSeqLoc(**li, ranges, id);
            }
            break;
        }
    case CSeq_loc::e_Equiv:
    case CSeq_loc::e_Bond:
    case CSeq_loc::e_Feat:
        {
            throw runtime_error(
                "CBioseq::x_ExcludeSeqLoc() -- seq-loc type not allowed");
        }
    }
}


void CBioseq::x_RangeToSeqLoc(CSeq_loc& loc,
                              CSeq_id& id,
                              int start,
                              int stop)
{
    _ASSERT(start <= stop);
    if (start < stop) {
        // interval
        loc.SetInt().SetId(id);
        loc.SetInt().SetFrom(start);
        loc.SetInt().SetTo(stop);
    }
    else {
        // point
        loc.SetPnt().SetId(id);
        loc.SetPnt().SetPoint(start);
    }
}


CBioseq& CBioseq::ConstructExcludedSequence(const CSeq_loc& loc,
                                            int len,
                                            string str_id)
{
    TRanges rg;
    rg[0] = eStart;
    rg[len] = eStop;
    CSeq_id* id = new CSeq_id;
    x_ExcludeSeqLoc(loc, rg, *id);

    // Create seq-loc from the remaining intervals
    CSeq_loc loc_ex;
    if (rg.size() == 0) {
        // No unused ranges left
        loc_ex.SetEmpty();
    }
    else if (rg.size() == 2) {
        // Simple seq-loc
        TRanges::iterator it_stop = rg.begin();
        TRanges::iterator it_start = it_stop;
        ++it_stop;
        x_RangeToSeqLoc(loc_ex, *id, it_start->first, it_stop->first-1);
    }
    else {
        // Complex seq-loc
        CSeq_loc_mix::Tdata& mix = loc_ex.SetMix();
        for (TRanges::iterator rit = rg.begin(); rit != rg.end(); ++rit) {
            CRef<CSeq_loc> next = new CSeq_loc;
            _ASSERT(rit->second == eStart);
            TRanges::iterator rit2 = rit;
            ++rit;
            x_RangeToSeqLoc(*next, *id, rit2->first, rit->first-1);
            mix.push_back(next);
        }
    }

    CBioseq* seq = new CBioseq(loc_ex, str_id);
    return *seq;
}


END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

/* Original file checksum: lines: 61, chars: 1871, CRC32: 1d5d7d05 */
