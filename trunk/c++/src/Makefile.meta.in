#################################
# $Id$
# Author:  Denis Vakatov (vakatov@ncbi.nlm.nih.gov)
#################################
# Meta-makefile(to be configured into "Makefile")
# This can be used to build/install/clean [*_PROJ] makefiles
# in current directory and in the below [SUB_PROJ] directories.
#
# LIB_PROJ = pl1 pl2 ...  // Makefile.pl1.lib Makefile.pl1.lib ...
# APP_PROJ = pa1 pl2 ...  // Makefile.pa1.app Makefile.pa1.app ...
# USR_PROJ = pu1 pu2 ...  // Makefile.pu1 Makefile.pu1 ...
# SUB_PROJ = app sub_proj1 sub_proj2
#
# srcdir = @srcdir@
# include @builddir@/Makefile.meta
#################################

builddir = @builddir@
top_srcdir = @top_srcdir@

### Make sure we are using a right command shell

@make_shell@

### Protect against two MAKE processes running in the same dir

RWL = $(top_srcdir)/scripts/run_with_lock.sh

### Tests config variables

check_run = $(top_srcdir)/scripts/check/check_run.sh
check_add = $(top_srcdir)/scripts/check/check_add.sh

### One-level build -- [USR_PROJ] makefiles

NOTK_BRA = test "$$expendable" = true || case "$(MFLAGS)" in *k*) ;; *)
NOTK_KET = ;; esac

USRP_BRA = \
if test ! -z "$(USR_PROJ)"  ||  test ! -z "@UNIX_USR_PROJ@" \
	|| test ! -z "$(EXPENDABLE_USR_PROJ)" ; then \
   x_project="$(USR_PROJ) @UNIX_USR_PROJ@ - $(EXPENDABLE_USR_PROJ)" ; \
   expendable=false ; \
   for i in $$x_project ; do \
      if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
      if test -f "Makefile.$$i" ; then \
         x_mfile="Makefile.$$i" ; \
      else \
         x_mfile="$(srcdir)/Makefile.$$i" ; \
      fi ; \
      $(RWL) -base "make_$$i" $(MAKE) -f "$$x_mfile" builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS)
USRP_KET = || $(NOTK_BRA) exit 1 $(NOTK_KET) ; \
   done ; \
fi

MAKE_ASN = $(builddir)/new_module.sh "$$i"
ASNP_BRA = \
if test ! -z "$(ASN_PROJ)" ; then \
   x_project="$(ASN_PROJ)" ; \
   for i in $$x_project ; do \
      (cd $(srcdir)  &&  $(RWL) $(MAKE_ASN)
ASNP_KET = ) || $(NOTK_BRA) exit 6 $(NOTK_KET) ; \
   done ; \
fi

MAKE_LIB = $(MAKE) -f "$(builddir)/Makefile.lib.tmpl" srcdir="$(srcdir)" TMPL="$$i" $(MFLAGS)
LIBP_BRA = \
if test ! -z "$(LIB_PROJ)"  -o  ! -z "$(EXPENDABLE_LIB_PROJ)"  -o  ! -z "$(ASN_PROJ)"; then \
   x_project="$(ASN_PROJ) $(LIB_PROJ) - $(EXPENDABLE_LIB_PROJ)" ; \
   expendable=false ; \
   for i in $$x_project ; do \
     if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
     if $(MAKE_LIB) -q requirements ; then \
        $(RWL) -base "make_$$i" $(MAKE_LIB)
LIBP_KET = || $(NOTK_BRA) exit 2 $(NOTK_KET) ; \
     else \
       echo "NOTE:  skipping project \"$$i\" due to unmet requirements"; \
     fi; \
   done ; \
fi

MAKE_APP = $(MAKE) -f "$(builddir)/Makefile.app.tmpl" srcdir="$(srcdir)" TMPL="$$i" @APP_NOCOPY@ $(MFLAGS)
APPP_BRA = \
if test ! -z "$(APP_PROJ)"  -o  ! -z "$(EXPENDABLE_APP_PROJ)" ; then \
   x_project="$(APP_PROJ) - $(EXPENDABLE_APP_PROJ)" ; \
   expendable=false ; \
   for i in $$x_project ; do \
     if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
     if $(MAKE_APP) -q requirements ; then \
        $(RWL) -base "make_$$i" $(MAKE_APP)
APPP_KET = || $(NOTK_BRA) exit 3 $(NOTK_KET) ; \
     else \
       echo "NOTE:  skipping project \"$$i\" due to unmet requirements"; \
     fi; \
   done ; \
fi

CHECK_BRA = \
if test -f "$(check_run)"; then \
  $(check_run) $(MAKE) $(MFLAGS)
CHECK_KET = ||  exit 7 ; \
fi

CHECK_ADD_BRA = \
if test ! -z "$(APP_PROJ)"  -o  ! -z "$(EXPENDABLE_APP_PROJ)" ; then \
   x_project="$(APP_PROJ) - $(EXPENDABLE_APP_PROJ)" ; \
   expendable=false ; \
   for i in $$x_project ; do \
      if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
      $(check_add) $(srcdir) $$i @signature@ @exe_ext@
CHECK_ADD_KET = ||  exit 5 ; \
   done ; \
fi


PRE_LIB_PROJ = $(USR_PROJ) $(UNIX_USR_PROJ) $(EXPENDABLE_USR_PROJ)
PRE_APP_PROJ = $(LIB_PROJ) $(EXPENDABLE_LIB_PROJ) $(ASN_PROJ) $(PRE_LIB_PROJ)
ALL_PROJ = $(APP_PROJ) $(EXPENDABLE_APP_PROJ) $(PRE_APP_PROJ)

all:	$(ALL_PROJ)

# we must rebuild all projects unconditionally
$(ALL_PROJ) ALL_PROJ: FORCE

$(APP_PROJ) APP_PROJ: $(PRE_APP_PROJ)
	@$(MAKE) -f "$(builddir)/Makefile.app.tmpl" srcdir="$(srcdir)" TMPL="$@"  $(MFLAGS) all

$(EXPENDABLE_APP_PROJ) EXPENDABLE_APP_PROJ: $(PRE_APP_PROJ)
	@-$(MAKE) -f "$(builddir)/Makefile.app.tmpl" srcdir="$(srcdir)" TMPL="$@"  $(MFLAGS) all

$(LIB_PROJ) LIB_PROJ: $(PRE_LIB_PROJ)
	@$(MAKE) -f "$(builddir)/Makefile.lib.tmpl" srcdir="$(srcdir)" TMPL="$@" $(MFLAGS) all

$(EXPENDABLE_LIB_PROJ) EXPENDABLE_LIB_PROJ: $(PRE_LIB_PROJ)
	@-$(MAKE) -f "$(builddir)/Makefile.lib.tmpl" srcdir="$(srcdir)" TMPL="$@" $(MFLAGS) all

$(USR_PROJ) $(UNIX_USR_PROJ) USR_PROJ:
	@$(MAKE) -f "$(srcdir)/Makefile.$@" builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS) all

$(EXPENDABLE_USR_PROJ) EXPENDABLE_USR_PROJ:
	@-$(MAKE) -f "$(srcdir)/Makefile.$@" builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS) all

$(ASN_PROJ) ASN_PROJ: $(PRE_LIB_PROJ)
	+cd $(srcdir) && $(builddir)/new_module.sh "$@" all
	@$(MAKE) -f "$(builddir)/Makefile.lib.tmpl" srcdir="$(srcdir)" TMPL="$@" $(MFLAGS) all

clean:
	@$(USRP_BRA) clean $(USRP_KET)
#	@$(ASNP_BRA) clean_sources $(ASNP_KET)
	@$(LIBP_BRA) clean $(LIBP_KET)
	@$(APPP_BRA) clean $(APPP_KET)
purge:
	@$(USRP_BRA) purge $(USRP_KET)
#	@$(ASNP_BRA) purge_sources $(ASNP_KET)
	@$(LIBP_BRA) purge $(LIBP_KET)
	@$(APPP_BRA) purge $(APPP_KET)
sources:
	@$(ASNP_BRA) all   $(ASNP_KET)
libs:
	@$(LIBP_BRA) all   $(LIBP_KET)
check:
	@$(CHECK_BRA) check_add $(CHECK_KET)
check_add:
	@$(CHECK_ADD_BRA)  $(CHECK_ADD_KET)


### Recursive build -- in the [SUB_PROJ] directories

SUB_BRA = \
if test ! -z "$(SUB_PROJ)"  -o  ! -z "$(EXPENDABLE_SUB_PROJ)" ; then \
    x_subproj="$(SUB_PROJ) - $(EXPENDABLE_SUB_PROJ)" ; \
    expendable=false ; \
    for i in $$x_subproj ; do \
        if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
        ( if test -d $$i ; then \
          cd $$i  &&  $(MAKE) $(MFLAGS)

SUB_KET = || $(NOTK_BRA) exit 4 $(NOTK_KET) ; \
        else \
          echo "Warning:  non-existent sub-project \"$$i\"" ; \
        fi ) || $(NOTK_BRA)  exit 5 $(NOTK_KET) ; \
    done ; \
fi

all_r: all $(SUB_PROJ) $(EXPENDABLE_SUB_PROJ)

# we must rebuild all subprojects unconditionally
$(SUB_PROJ) $(EXPENDABLE_SUB_PROJ) SUB_PROJ: FORCE

$(SUB_PROJ) SUB_PROJ: $(ALL_PROJ)
	@cd $@ && $(MAKE) $(MFLAGS) all_r
$(EXPENDABLE_SUB_PROJ) EXPENDABLE_SUB_PROJ: $(ALL_PROJ)
	@-cd $@ && $(MAKE) $(MFLAGS) all_r

clean_r: clean
	@$(SUB_BRA) clean_r $(SUB_KET)
purge_r: purge 
	@$(SUB_BRA) purge_r $(SUB_KET)
check_r:
	@$(CHECK_BRA) check_add_r $(CHECK_KET)
check_add_r: check_add
	@$(SUB_BRA) check_add_r $(SUB_KET)


PROJECTS = @PROJECTS@ # File listing relevant project directories.

# This file contains the actual patterns to grep for, formed by
# prepending "build/" to each original pattern as an anchor.
RELEVANT_FILE = $(builddir)/relevant.patterns
$(RELEVANT_FILE): $(PROJECTS)
	@if test -n "$(PROJECTS)" ; then \
	    sed -e '/ update-only$$/d; /^$$/d; s@^@build/@' $(PROJECTS); \
	else \
	    echo '.*'; \
	fi > $(RELEVANT_FILE)

IRRELEVANT_FILE = $(builddir)/irrelevant.patterns
$(IRRELEVANT_FILE): $(PROJECTS)
	@if test -n "$(PROJECTS)" ; then \
	    echo '# Dummy line to avoid empty file'; \
	    sed -ne 's@^-@build/@p' $(PROJECTS); \
	else \
	    echo '^$$'; \
	fi > $(IRRELEVANT_FILE)

# Commands to see whether project directories are relevant.
RELEVANT = @EGREP@ -f $(RELEVANT_FILE) | @EGREP@ -v -f $(IRRELEVANT_FILE) > /dev/null
RELEVANT_DIR = pwd | $(RELEVANT)
RELEVANT_SUBS = find "`pwd`"/* -type d | $(RELEVANT)

SUB_BRA_P = \
if test ! -z "$(SUB_PROJ)" \
	|| test ! -z "$(POTENTIAL_SUB_PROJ)" \
	|| test ! -z "$(EXPENDABLE_SUB_PROJ)" ; then \
    x_subproj="$(SUB_PROJ) $(POTENTIAL_SUB_PROJ) - $(EXPENDABLE_SUB_PROJ)" ; \
    expendable=false ; \
    for i in $$x_subproj ; do \
        if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
        ( if test -d $$i ; then \
          cd $$i  &&  $(RWL) $(MAKE) $(MFLAGS)

SUB_KET_P = $(SUB_KET)

all_p: $(RELEVANT_FILE) $(IRRELEVANT_FILE)
	@if $(RELEVANT_DIR); then $(MAKE) $(MFLAGS) all; else true; fi
	@if $(RELEVANT_SUBS); then $(SUB_BRA_P) all_p $(SUB_KET_P); else true; fi

clean_p: $(RELEVANT_FILE) $(IRRELEVANT_FILE)
	@if $(RELEVANT_DIR); then $(MAKE) $(MFLAGS) clean; else true; fi
	@if $(RELEVANT_SUBS); then $(SUB_BRA_P) clean_p $(SUB_KET_P); else true; fi

purge_p: $(RELEVANT_FILE) $(IRRELEVANT_FILE)
	@if $(RELEVANT_DIR); then $(MAKE) $(MFLAGS) purge; else true; fi
	@if $(RELEVANT_SUBS); then $(SUB_BRA_P) purge_p $(SUB_KET_P); else true; fi

check_p: $(RELEVANT_FILE) $(IRRELEVANT_FILE)
	@$(CHECK_BRA) check_add_p $(CHECK_KET)

check_add_p: $(RELEVANT_FILE) $(IRRELEVANT_FILE)
	@if $(RELEVANT_DIR); then $(CHECK_ADD_BRA) $(CHECK_ADD_KET); else true; fi
	@if $(RELEVANT_SUBS); then $(SUB_BRA_P) check_add_p $(SUB_KET_P); else true; fi

# special FORCE target to force rebuild of all dependant targets
FORCE:
