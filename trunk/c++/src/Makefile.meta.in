#################################
# $Id$
# Author:  Denis Vakatov (vakatov@ncbi.nlm.nih.gov)
#################################
# Meta-makefile(to be configured into "Makefile")
# This can be used to build/install/clean [*_PROJ] makefiles
# in current directory and in the below [SUB_PROJ] directories.
#
# LIB_PROJ = pl1 pl2 ...  // Makefile.pl1.lib Makefile.pl1.lib ...
# APP_PROJ = pa1 pl2 ...  // Makefile.pa1.app Makefile.pa1.app ...
# USR_PROJ = pu1 pu2 ...  // Makefile.pu1 Makefile.pu1 ...
# SUB_PROJ = app sub_proj1 sub_proj2
#
# srcdir = @srcdir@
# include @builddir@/Makefile.meta
#################################

builddir = @builddir@
top_srcdir = @top_srcdir@

### Make sure we are using a right command shell

@make_shell@

### Protect against two MAKE processes running in the same dir

RWL = $(top_srcdir)/scripts/run_with_lock.sh

### Tests config variables

check_run = $(top_srcdir)/scripts/check/check_run.sh
check_add = $(top_srcdir)/scripts/check/check_add.sh

### One-level build -- [USR_PROJ] makefiles

NOTK_BRA = test "$$expendable" = true || case "$(MFLAGS)" in *k*) ;; *)
NOTK_KET = ;; esac

# Factored out merely to avoid duplication
MAKE_USR = $(MAKE) -f "$$x_mfile" builddir="$(builddir)" srcdir="$(srcdir)" $(MFLAGS)
USRP_BRA = \
+if test ! -z "$(USR_PROJ)"  ||  test ! -z "@UNIX_USR_PROJ@" \
	|| test ! -z "$(EXPENDABLE_USR_PROJ)" ; then \
   x_project="$(USR_PROJ) @UNIX_USR_PROJ@ - $(EXPENDABLE_USR_PROJ)" ; \
   expendable=false ; \
   test -f requirements  ||  touch -t 197001010000 requirements ; \
   for i in $$x_project ; do \
      if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
      if test -f "Makefile.$$i" ; then \
         x_mfile="Makefile.$$i" ; \
      else \
         x_mfile="$(srcdir)/Makefile.$$i" ; \
      fi ; \
      if $(MAKE_USR) -q requirements ; then \
         $(RWL) -base "make_$$i" $(MAKE_USR)
USRP_KET = || $(NOTK_BRA) exit 1 $(NOTK_KET) ; \
      else \
         echo "NOTE:  skipping project \"$$i\" due to unmet requirements"; \
      fi; \
   done ; \
   test -s requirements  ||  rm -f requirements ; \
fi

MAKE_ASN = $(builddir)/new_module.sh "$$i"
ASNP_BRA = \
+if test ! -z "$(ASN_PROJ)" ; then \
   x_project="$(ASN_PROJ)" ; \
   for i in $$x_project ; do \
      (cd $(srcdir)  &&  MAKE="$(MAKE) $(MFLAGS)" $(RWL) -base make_asn $(MAKE_ASN)
ASNP_KET = ) || $(NOTK_BRA) exit 6 $(NOTK_KET) ; \
   done ; \
fi

# If you change this rule, please continue to honor external
# definitions of $(MAKE_LIB).
MAKE_LIB = $(MAKE) -f "$(builddir)/Makefile.lib.tmpl" srcdir="$(srcdir)" TMPL="$$i" $(MFLAGS)
LIBP_BRA = \
+if test ! -z "$(LIB_PROJ)"  -o  ! -z "$(EXPENDABLE_LIB_PROJ)"  -o  ! -z "$(ASN_PROJ)"; then \
   x_project="$(ASN_PROJ) $(LIB_PROJ) - $(EXPENDABLE_LIB_PROJ)" ; \
   expendable=false ; \
   for i in $$x_project ; do \
     if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
     if $(MAKE_LIB) -q requirements ; then \
        $(RWL) -base "make_$$i" $(MAKE_LIB)
LIBP_KET = || $(NOTK_BRA) exit 2 $(NOTK_KET) ; \
     else \
       echo "NOTE:  skipping project \"$$i\" due to unmet requirements"; \
     fi; \
   done ; \
fi

# If you change this rule, please continue to honor external
# definitions of $(MAKE_APP).
MAKE_APP = $(MAKE) -f "$(builddir)/Makefile.app.tmpl" srcdir="$(srcdir)" TMPL="$$i" @APP_NOCOPY@ $(MFLAGS)
APPP_BRA = \
+if test ! -z "$(APP_PROJ)"  -o  ! -z "$(EXPENDABLE_APP_PROJ)" ; then \
   x_project="$(APP_PROJ) - $(EXPENDABLE_APP_PROJ)" ; \
   expendable=false ; \
   for i in $$x_project ; do \
     if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
     if $(MAKE_APP) -q requirements ; then \
        $(RWL) -base "make_$$i" $(MAKE_APP)
APPP_KET = || $(NOTK_BRA) exit 3 $(NOTK_KET) ; \
     else \
       echo "NOTE:  skipping project \"$$i\" due to unmet requirements"; \
     fi; \
   done ; \
fi

CHECK_BRA = \
+if test -f "$(check_run)"; then \
  $(check_run) $(MAKE) $(MFLAGS) IS_CHECK=Y
CHECK_KET = ||  exit 7 ; \
fi

CHECK_ADD_BRA = \
if test ! -z "$(APP_PROJ)"  -o  ! -z "$(EXPENDABLE_APP_PROJ)" ; then \
   x_project="$(APP_PROJ) - $(EXPENDABLE_APP_PROJ)" ; \
   expendable=false ; \
   for i in $$x_project ; do \
      if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
      $(check_add) $(srcdir) $$i @signature@ @exe_ext@
CHECK_ADD_KET = ||  exit 5 ; \
   done ; \
fi


all:
	@$(USRP_BRA) all   $(USRP_KET)
	@$(ASNP_BRA) all   $(ASNP_KET)
	@$(LIBP_BRA) all   $(LIBP_KET)
	@$(APPP_BRA) all   $(APPP_KET)
clean:
	@$(USRP_BRA) clean $(USRP_KET)
#	@$(ASNP_BRA) clean_sources $(ASNP_KET)
	@$(LIBP_BRA) clean $(LIBP_KET)
	@$(APPP_BRA) clean $(APPP_KET)
purge:
	@$(USRP_BRA) purge $(USRP_KET)
#	@$(ASNP_BRA) purge_sources $(ASNP_KET)
	@$(LIBP_BRA) purge $(LIBP_KET)
	@$(APPP_BRA) purge $(APPP_KET)
sources:
	@$(ASNP_BRA) all   $(ASNP_KET)
libs:
	@$(LIBP_BRA) all   $(LIBP_KET)
check:
	@$(CHECK_BRA) check_add $(CHECK_KET)
check_add:
	@$(CHECK_ADD_BRA)  $(CHECK_ADD_KET)

status_dir = @status_dir@
requirements: $(REQUIRES:%=$(status_dir)/%.enabled)

### Recursive build -- in the [SUB_PROJ] directories

SUB_BRA = \
+if test ! -z "$(SUB_PROJ)"  -o  ! -z "$(EXPENDABLE_SUB_PROJ)" ; then \
    x_subproj="$(SUB_PROJ) - $(EXPENDABLE_SUB_PROJ)" ; \
    expendable=false ; \
    for i in $$x_subproj ; do \
        if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
        if test "x$(IS_CHECK)" = "xY"  -a  "x$$i" = "xcheck" ; then \
            continue ; \
        fi ; \
        ( if test -d $$i ; then \
          cd $$i  &&  if $(MAKE) $(MFLAGS) -q requirements ; then \
            $(RWL) $(MAKE) $(MFLAGS)

SUB_KET = || $(NOTK_BRA) exit 4 $(NOTK_KET) ; \
          else \
            echo "NOTE:  skipping project \"$$i\" due to unmet requirements"; \
          fi \
        else \
          echo "Warning:  non-existent sub-project \"$$i\"" ; \
        fi ) || $(NOTK_BRA)  exit 5 $(NOTK_KET) ; \
    done ; \
fi

all_r: all
	@$(SUB_BRA) all_r   $(SUB_KET)
clean_r: clean
	@$(SUB_BRA) clean_r $(SUB_KET)
purge_r: purge 
	@$(SUB_BRA) purge_r $(SUB_KET)
check_r:
	@$(CHECK_BRA) check_add_r $(CHECK_KET)
check_add_r: check_add
	@$(SUB_BRA) check_add_r $(SUB_KET)


PROJECTS = @PROJECTS@ # File listing relevant project directories.

# This file contains the actual patterns to grep for, formed by
# prepending "build/" to each original pattern as an anchor.
RELEVANT_FILE = $(builddir)/relevant.patterns
$(RELEVANT_FILE): $(PROJECTS)
	@if test -n "$(PROJECTS)" ; then \
	    sed -e '/ update-only$$/d; /^$$/d; s@^@build/@' $(PROJECTS); \
	else \
	    echo '.*'; \
	fi > $(RELEVANT_FILE)

IRRELEVANT_FILE = $(builddir)/irrelevant.patterns
$(IRRELEVANT_FILE): $(PROJECTS)
	@if test -n "$(PROJECTS)" ; then \
	    echo '# Dummy line to avoid empty file'; \
	    sed -ne 's@^-@build/@p' $(PROJECTS); \
	else \
	    echo '^$$'; \
	fi > $(IRRELEVANT_FILE)

# Commands to see whether project directories are relevant.
RELEVANT = @EGREP@ -f $(RELEVANT_FILE) | @EGREP@ -v -f $(IRRELEVANT_FILE) > /dev/null
RELEVANT_DIR = pwd | $(RELEVANT)
RELEVANT_SUBS = find "`pwd`"/* -type d | $(RELEVANT)

SUB_BRA_P = \
if test -n "$(SUB_PROJ)"             -o  -n "$(POTENTIAL_SUB_PROJ)"  -o \
        -n "$(EXPENDABLE_SUB_PROJ)"  -o  -n "$(CHECK_SUB_PROJ)" ;  then \
    x_subproj="$(SUB_PROJ) $(POTENTIAL_SUB_PROJ) - $(EXPENDABLE_SUB_PROJ) $(CHECK_SUB_PROJ)"; \
    expendable=false ; \
    for i in $$x_subproj ; do \
        if test "x$$i" = "x-" ; then expendable=true ; continue ; fi ; \
        ( if test -d $$i ; then \
          cd $$i  &&  if $(MAKE) $(MFLAGS) -q requirements ; then \
            $(RWL) $(MAKE) $(MFLAGS)

SUB_KET_P = $(SUB_KET)

all_p: $(RELEVANT_FILE) $(IRRELEVANT_FILE)
	@+if $(RELEVANT_DIR); then $(MAKE) $(MFLAGS) all; else true; fi
	@+if $(RELEVANT_SUBS); then $(SUB_BRA_P) all_p $(SUB_KET_P); else true; fi

clean_p: $(RELEVANT_FILE) $(IRRELEVANT_FILE)
	@if $(RELEVANT_DIR); then $(MAKE) $(MFLAGS) clean; else true; fi
	@+if $(RELEVANT_SUBS); then $(SUB_BRA_P) clean_p $(SUB_KET_P); else true; fi

purge_p: $(RELEVANT_FILE) $(IRRELEVANT_FILE)
	@if $(RELEVANT_DIR); then $(MAKE) $(MFLAGS) purge; else true; fi
	@+if $(RELEVANT_SUBS); then $(SUB_BRA_P) purge_p $(SUB_KET_P); else true; fi

check_p: $(RELEVANT_FILE) $(IRRELEVANT_FILE)
	@$(CHECK_BRA) check_add_p $(CHECK_KET)

check_add_p: $(RELEVANT_FILE) $(IRRELEVANT_FILE)
	@if $(RELEVANT_DIR); then $(CHECK_ADD_BRA) $(CHECK_ADD_KET); else true; fi
	@+if $(RELEVANT_SUBS); then $(SUB_BRA_P) check_add_p $(SUB_KET_P); else true; fi
