diff -urN fltk-1.1.6.orig/FL/Fl.H fltk-1.1.6/FL/Fl.H
--- fltk-1.1.6.orig/FL/Fl.H	2004-11-23 14:47:50.000000000 -0500
+++ fltk-1.1.6/FL/Fl.H	2006-01-26 11:25:13.390549300 -0500
@@ -261,8 +261,29 @@
   // Widget deletion:
   static void delete_widget(Fl_Widget *w);
   static void do_widget_deletion();
+
+  // patch for focus handling
+public:
+    typedef void (FFocusCallback)(Fl_Widget* new_focus, void* data);
+
+    /// deprecated
+    static void       set_focus_callback(FFocusCallback* callback, void* data);
+    FFocusCallback*   get_focus_callback() const;
+    typedef FFocusCallback TFocusCallback_F;
+
+    static void       focus_callback(FFocusCallback* callback, void* data);
+    FFocusCallback*   focus_callback() const;
+
+private:
+    static TFocusCallback_F*   focus_callback_;
+    static void*    focus_callback_data_;
+  // end of patch for focus handling
 };
 
+// patch for focus handling
+#define NCBI_SET_FOCUS_PATCH
+// end of patch for focus handling
+
 #endif // !Fl_H
 
 //
diff -urN fltk-1.1.6.orig/FL/Fl_Browser_.H fltk-1.1.6/FL/Fl_Browser_.H
--- fltk-1.1.6.orig/FL/Fl_Browser_.H	2004-04-11 00:38:54.000000000 -0400
+++ fltk-1.1.6/FL/Fl_Browser_.H	2006-01-26 11:25:13.406174900 -0500
@@ -92,6 +92,7 @@
   void redraw_lines() {damage(FL_DAMAGE_SCROLL);} // redraw all of them
   void bbox(int&,int&,int&,int&) const;
   int leftedge() const;	// x position after scrollbar & border
+  int top_offset() const { return offset_; } // y position after scrollbar and border
   void *find_item(int my); // item under mouse
   void draw(int,int,int,int);
   int handle(int,int,int,int,int);
@@ -144,6 +145,9 @@
 
 };
 
+// guard for NCBI-specific binary changes
+#define NCBI_FLTK_FL_BROWSER
+
 #endif
 
 //
diff -urN fltk-1.1.6.orig/FL/Fl_Group.H fltk-1.1.6/FL/Fl_Group.H
--- fltk-1.1.6.orig/FL/Fl_Group.H	2004-04-11 00:38:54.000000000 -0400
+++ fltk-1.1.6/FL/Fl_Group.H	2006-01-26 11:25:13.406174900 -0500
@@ -41,6 +41,10 @@
   int navigation(int);
   static Fl_Group *current_;
 
+  // unimplemented copy ctor and assignment operator
+  Fl_Group(const Fl_Group&);
+  Fl_Group& operator=(const Fl_Group&);
+
 protected:
 
   void draw();
diff -urN fltk-1.1.6.orig/FL/Fl_Widget.H fltk-1.1.6/FL/Fl_Widget.H
--- fltk-1.1.6.orig/FL/Fl_Widget.H	2004-11-23 14:47:50.000000000 -0500
+++ fltk-1.1.6/FL/Fl_Widget.H	2006-01-26 11:25:13.421800500 -0500
@@ -69,13 +69,9 @@
 
   const char *tooltip_;
 
-#  if !defined(WIN32) || !defined(FL_DLL)
-  // "de-implement" the copy constructors, EXCEPT for when we are using the
-  // WIN32 DLL interface, in which case we can't hide them because Microsoft
-  // requires the copy constructors to implement subclassing...
-  Fl_Widget & operator=(const Fl_Widget &) { return *this; }
-  Fl_Widget(const Fl_Widget &) {}
-#  endif // !WIN32 || !FL_DLL
+  // unimplemented copy ctor and assignment operator
+  Fl_Widget(const Fl_Widget &);
+  Fl_Widget& operator=(const Fl_Widget &);
 
 protected:
 
diff -urN fltk-1.1.6.orig/FL/Fl_Window.H fltk-1.1.6/FL/Fl_Window.H
--- fltk-1.1.6.orig/FL/Fl_Window.H	2004-11-19 22:19:57.000000000 -0500
+++ fltk-1.1.6/FL/Fl_Window.H	2006-01-26 11:25:13.437426100 -0500
@@ -58,6 +58,10 @@
   };
   void _Fl_Window(); // constructor innards
 
+  // unimplemented copy ctor and assignment operator
+  Fl_Window(const Fl_Window&);
+  Fl_Window& operator=(const Fl_Window&);
+
 protected:
 
   static Fl_Window *current_;
@@ -88,7 +92,7 @@
   void hotspot(const Fl_Widget& p, int offscreen = 0) {hotspot(&p,offscreen);}
   void free_position()	{clear_flag(FL_FORCE_POSITION);}
   void size_range(int a, int b, int c=0, int d=0, int e=0, int f=0, int g=0) {
-    minw=(short)a; minh=(short)b; maxw=(short)c; maxh=(short)d; dw=(short)e; dh=(short)f; aspect=(short)g; size_range_();}
+    minw=(short)a; minh=(short)b; maxw=(short)c; maxh=(short)d; dw=(uchar)e; dh=(uchar)f; aspect=(uchar)g; size_range_();}
 
   const char* label() const	{return Fl_Widget::label();}
   const char* iconlabel() const	{return iconlabel_;}
diff -urN fltk-1.1.6.orig/configure fltk-1.1.6/configure
--- fltk-1.1.6.orig/configure	2004-11-23 15:35:43.000000000 -0500
+++ fltk-1.1.6/configure	2006-01-26 11:25:13.453051700 -0500
@@ -1464,7 +1464,7 @@
 	    ;;
     esac
 
-    LINKSHARED="-L../src -lfltk_images$SHAREDSUFFIX -lfltk_forms$SHAREDSUFFIX -lfltk$SHAREDSUFFIX"
+    LINKSHARED="-L../src -L../lib -lfltk_images$SHAREDSUFFIX -lfltk_forms$SHAREDSUFFIX -lfltk$SHAREDSUFFIX"
 else
     DSOCOMMAND="echo"
     DSOLINK=""
diff -urN fltk-1.1.6.orig/configure.in fltk-1.1.6/configure.in
--- fltk-1.1.6.orig/configure.in	2004-11-19 22:44:17.000000000 -0500
+++ fltk-1.1.6/configure.in	2006-01-26 11:25:13.468677300 -0500
@@ -195,7 +195,7 @@
 	    ;;
     esac
 
-    LINKSHARED="-L../src -lfltk_images$SHAREDSUFFIX -lfltk_forms$SHAREDSUFFIX -lfltk$SHAREDSUFFIX"
+    LINKSHARED="-L../src -L../lib -lfltk_images$SHAREDSUFFIX -lfltk_forms$SHAREDSUFFIX -lfltk$SHAREDSUFFIX"
 else
     DSOCOMMAND="echo"
     DSOLINK=""
diff -urN fltk-1.1.6.orig/makeinclude.in fltk-1.1.6/makeinclude.in
--- fltk-1.1.6.orig/makeinclude.in	2004-10-18 16:22:21.000000000 -0400
+++ fltk-1.1.6/makeinclude.in	2006-01-26 11:25:13.484302900 -0500
@@ -76,7 +76,8 @@
 LINKFLTKGL	= -L../lib @LINKFLTKGL@
 LINKFLTKFORMS	= -L../lib -lfltk_forms @LINKFLTK@
 LINKFLTKIMG	= -L../lib -lfltk_images @LINKFLTK@ $(IMAGELIBS)
-LINKSHARED	= @DSOLINK@ @LINKSHARED@ $(IMAGELIBS)
+DSOLINK         = @DSOLINK@
+LINKSHARED	= $(DSOLINK) @LINKSHARED@ $(IMAGELIBS)
 IMAGELIBS	= @IMAGELIBS@
 
 # image libraries to build...
diff -urN fltk-1.1.6.orig/src/Fl.cxx fltk-1.1.6/src/Fl.cxx
--- fltk-1.1.6.orig/src/Fl.cxx	2004-11-23 14:50:58.000000000 -0500
+++ fltk-1.1.6/src/Fl.cxx	2006-01-26 11:25:13.499928500 -0500
@@ -33,6 +33,7 @@
 #include <FL/x.H>
 #include <FL/Fl_Tooltip.H>
 #include <ctype.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include "flstring.h"
 
@@ -94,6 +95,124 @@
   return (mx >= 0 && mx < o->w() && my >= 0 && my < o->h());
 }
 
+//
+//
+// timer support
+//
+
+#ifdef WIN32
+
+/// implementation in Fl_win32.cxx
+
+#elif defined(__APPLE__)
+
+//
+// MacOS X timers
+//
+
+struct MacTimeout {
+    Fl_Timeout_Handler callback;
+    void* data;
+    EventLoopTimerRef timer;
+};
+static MacTimeout* mac_timers;
+static int mac_timer_alloc;
+static int mac_timer_used;
+
+
+static void realloc_timers()
+{
+    if (mac_timer_alloc == 0) {
+        mac_timer_alloc = 8;
+    }
+    MacTimeout* new_timers = new MacTimeout[mac_timer_alloc * 2];
+    memmove(new_timers, mac_timers, sizeof(MacTimeout) * mac_timer_used);
+    MacTimeout* delete_me = mac_timers;
+    mac_timers = new_timers;
+    delete [] delete_me;
+    mac_timer_alloc *= 2;
+}
+
+static void delete_timer(MacTimeout& t)
+{
+    RemoveEventLoopTimer(t.timer);
+    memset(&t, 0, sizeof(MacTimeout));
+}
+
+
+static pascal void do_timer(EventLoopTimerRef timer, void* data)
+{
+   for (int i = 0;  i < mac_timer_used;  ++i) {
+        MacTimeout& t = mac_timers[i];
+        if (t.timer == timer  &&  t.data == data) {
+            return (*t.callback)(data);
+        }
+    }
+}
+
+
+void Fl::add_timeout(double time, Fl_Timeout_Handler cb, void* data)
+{
+    int timer_id = -1;
+    for (int i = 0;  i < mac_timer_used;  ++i) {
+        if ( !mac_timers[i].timer ) {
+            timer_id = i;
+            break;
+        }
+    }
+    if (timer_id == -1) {
+        if (mac_timer_used == mac_timer_alloc) {
+            realloc_timers();
+        }
+        timer_id = mac_timer_used++;
+    }
+    
+    EventTimerInterval fireDelay = (EventTimerInterval) time;
+    EventLoopTimerUPP  timerUPP = NewEventLoopTimerUPP(do_timer);
+    EventLoopTimerRef  timerRef;
+    OSStatus err = InstallEventLoopTimer(GetMainEventLoop(), fireDelay, 0, timerUPP, data, &timerRef);
+    if (err == noErr) {
+        mac_timers[timer_id].callback = cb;
+        mac_timers[timer_id].data     = data;
+        mac_timers[timer_id].timer    = timerRef;
+    }
+}
+
+void Fl::repeat_timeout(double time, Fl_Timeout_Handler cb, void* data)
+{
+    remove_timeout(cb, data);
+    add_timeout(time, cb, data);
+}
+
+int Fl::has_timeout(Fl_Timeout_Handler cb, void* data)
+{
+   for (int i = 0;  i < mac_timer_used;  ++i) {
+        MacTimeout& t = mac_timers[i];
+        if (t.callback == cb  &&  t.data == data) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+void Fl::remove_timeout(Fl_Timeout_Handler cb, void* data)
+{
+   for (int i = 0;  i < mac_timer_used;  ++i) {
+        MacTimeout& t = mac_timers[i];
+        if (t.callback == cb  && ( t.data == data || data == NULL)) {
+            delete_timer(t);
+        }
+    }
+}
+
+
+#else
+
+//
+// X11 timers
+//
+
+
 ////////////////////////////////////////////////////////////////
 // Timeouts are stored in a sorted list, so only the first one needs
 // to be checked to see if any should be called.
@@ -105,10 +224,9 @@
   Timeout* next;
 };
 static Timeout* first_timeout, *free_timeout;
+static int first_timeout_count, free_timeout_count;
 
-#ifndef WIN32
-#  include <sys/time.h>
-#endif
+#include <sys/time.h>
 
 // I avoid the overhead of getting the current time when we have no
 // timeouts by setting this flag instead of getting the time.
@@ -117,12 +235,6 @@
 static char reset_clock = 1;
 
 static void elapse_timeouts() {
-#ifdef WIN32
-  unsigned long newclock = GetTickCount();
-  static unsigned long prevclock;
-  double elapsed = (newclock-prevclock)/1000.0;
-  prevclock = newclock;
-#else
   static struct timeval prevclock;
   struct timeval newclock;
   gettimeofday(&newclock, NULL);
@@ -130,7 +242,6 @@
     (newclock.tv_usec - prevclock.tv_usec)/1000000.0;
   prevclock.tv_sec = newclock.tv_sec;
   prevclock.tv_usec = newclock.tv_usec;
-#endif
   if (reset_clock) {
     reset_clock = 0;
   } else if (elapsed > 0) {
@@ -152,8 +263,12 @@
 void Fl::repeat_timeout(double time, Fl_Timeout_Handler cb, void *argp) {
   time += missed_timeout_by; if (time < -.05) time = 0;
   Timeout* t = free_timeout;
-  if (t) free_timeout = t->next;
-  else t = new Timeout;
+  if (t) {
+      free_timeout = t->next;
+      --free_timeout_count;
+  } else {
+      t = new Timeout;
+  }
   t->time = time;
   t->cb = cb;
   t->arg = argp;
@@ -185,6 +300,8 @@
   }
 }
 
+#endif
+
 ////////////////////////////////////////////////////////////////
 // Checks are just stored in a list. They are called in the reverse
 // order that they were added (this may change in the future).
@@ -198,7 +315,7 @@
   void* arg;
   Check* next;
 };
-static Check* first_check, *next_check, *free_check;
+static Check *first_check, *next_check, *free_check;
 
 void Fl::add_check(Fl_Timeout_Handler cb, void *argp) {
   Check* t = free_check;
@@ -225,6 +342,20 @@
   }
 }
 
+static void run_checks()
+{
+  // checks are a bit messy so that add/remove and wait may be called
+  // from inside them without causing an infinite loop:
+  if (next_check == first_check) {
+    while (next_check) {
+      Check* checkp = next_check;
+      next_check = checkp->next;
+      (checkp->cb)(checkp->arg);
+    }
+    next_check = first_check;
+  }
+}
+
 ////////////////////////////////////////////////////////////////
 // wait/run/check/ready:
 
@@ -233,11 +364,17 @@
 extern int fl_ready(); // in Fl_<platform>.cxx
 extern int fl_wait(double time); // in Fl_<platform>.cxx
 
-static char in_idle;
-
 double Fl::wait(double time_to_wait) {
   do_widget_deletion();
 
+#ifdef WIN32
+
+  return fl_wait(time_to_wait);
+
+#elif defined(__APPLE__)
+  flush();
+  return fl_wait(time_to_wait);
+#else
   if (first_timeout) {
     elapse_timeouts();
     Timeout *t;
@@ -251,32 +388,17 @@
       first_timeout = t->next;
       t->next = free_timeout;
       free_timeout = t;
+      ++free_timeout_count;
+      --first_timeout_count;
       // Now it is safe for the callback to do add_timeout:
       cb(argp);
     }
   } else {
     reset_clock = 1; // we are not going to check the clock
   }
-  // checks are a bit messy so that add/remove and wait may be called
-  // from inside them without causing an infinite loop:
-  if (next_check == first_check) {
-    while (next_check) {
-      Check* checkp = next_check;
-      next_check = checkp->next;
-      (checkp->cb)(checkp->arg);
-    }
-    next_check = first_check;
-  }
-//  if (idle && !fl_ready()) {
-  if (idle) {
-    if (!in_idle) {
-      in_idle = 1;
-      idle();
-      in_idle = 0;
-    }
-    // the idle function may turn off idle, we can then wait:
-    if (idle) time_to_wait = 0.0;
-  }
+
+  run_checks();
+
   if (first_timeout && first_timeout->time < time_to_wait)
     time_to_wait = first_timeout->time;
   if (time_to_wait <= 0.0) {
@@ -289,9 +411,10 @@
     flush();
     return fl_wait(time_to_wait);
   }
+#endif
 }
 
-#define FOREVER 1e20
+#define FOREVER 0.01 //1e20
 
 int Fl::run() {
   while (Fl_X::first) wait(FOREVER);
@@ -311,12 +434,14 @@
 extern int fl_ready();
 
 int Fl::ready() {
+#if ! defined( WIN32 )  &&  ! defined(__APPLE__)
   if (first_timeout) {
     elapse_timeouts();
     if (first_timeout->time <= 0) return 1;
   } else {
     reset_clock = 1;
   }
+#endif
   return fl_ready();
 }
 
@@ -437,12 +562,46 @@
 
 ////////////////////////////////////////////////////////////////
 
+// patch for focus handling
+Fl::FFocusCallback*   Fl::focus_callback_ = NULL;
+void*   Fl::focus_callback_data_ = NULL;
+
+/// deprecated
+void  Fl::set_focus_callback(FFocusCallback* callback, void* data)
+{
+    focus_callback(callback, data);
+}
+
+void Fl::focus_callback(FFocusCallback* callback, void* data)
+{
+    focus_callback_ = callback;
+    focus_callback_data_ = data; 
+}
+
+Fl::FFocusCallback* Fl::get_focus_callback() const
+{
+    return focus_callback();
+}
+
+Fl::FFocusCallback* Fl::focus_callback() const
+{
+    return focus_callback_;
+}
+// end of patch
+
 Fl_Widget* fl_oldfocus; // kludge for Fl_Group...
 
 void Fl::focus(Fl_Widget *o) {
   if (o && !o->visible_focus()) return;
   if (grab()) return; // don't do anything while grab is on
   Fl_Widget *p = focus_;
+
+  // patch for focus handling
+  if(focus_callback_)  {
+    (*focus_callback_)(o, focus_callback_data_);
+  }
+  // end of patch
+
   if (o != p) {
     Fl::compose_reset();
     focus_ = o;
@@ -1053,6 +1212,11 @@
   draw();
 }
 
+#ifdef WIN32
+#  include "Fl_win32.cxx"
+#elif defined(__APPLE__)
+#  include "Fl_mac.cxx"
+#endif
 
 //
 // The following methods allow callbacks to schedule the deletion of
diff -urN fltk-1.1.6.orig/src/Fl_Browser.cxx fltk-1.1.6/src/Fl_Browser.cxx
--- fltk-1.1.6.orig/src/Fl_Browser.cxx	2004-11-19 22:19:58.000000000 -0500
+++ fltk-1.1.6/src/Fl_Browser.cxx	2006-01-26 11:25:13.515554100 -0500
@@ -374,9 +374,13 @@
     }
   BREAK:
     fl_font(font, tsize);
-    if (((FL_BLINE*)v)->flags & SELECTED)
-      lcol = fl_contrast(lcol, selection_color());
-    if (!active_r()) lcol = fl_inactive(lcol);
+    if (((FL_BLINE*)v)->flags & SELECTED) {
+      if (active_r() && Fl::focus() == static_cast<const Fl_Widget *>(this)) {
+        lcol = fl_contrast(lcol, selection_color());
+      }
+    } else if (!active_r()) {
+      lcol = fl_inactive(lcol);
+    }
     fl_color(lcol);
     fl_draw(str, X+3, Y, w1-6, H, e ? Fl_Align(talign|FL_ALIGN_CLIP) : talign, 0, 0);
     if (!e) break; // no more fields...
diff -urN fltk-1.1.6.orig/src/Fl_Browser_.cxx fltk-1.1.6/src/Fl_Browser_.cxx
--- fltk-1.1.6.orig/src/Fl_Browser_.cxx	2004-07-27 12:02:19.000000000 -0400
+++ fltk-1.1.6/src/Fl_Browser_.cxx	2006-01-26 11:25:13.531179700 -0500
@@ -353,7 +353,11 @@
     if (hh <= 0) continue;
     if ((damage()&(FL_DAMAGE_SCROLL|FL_DAMAGE_ALL)) || l == redraw1 || l == redraw2) {
       if (item_selected(l)) {
-	fl_color(active_r() ? selection_color() : fl_inactive(selection_color()));
+        Fl_Color sel_c = selection_color();
+        if ( !active_r()  ||  Fl::focus() != this ) {
+          sel_c = FL_BACKGROUND_COLOR;
+        }
+	fl_color(sel_c);
 	fl_rectf(X, yy+Y, W, hh);
       } else if (!(damage()&FL_DAMAGE_ALL)) {
 	fl_push_clip(X, yy+Y, W, hh);
diff -urN fltk-1.1.6.orig/src/Fl_Gl_Choice.H fltk-1.1.6/src/Fl_Gl_Choice.H
--- fltk-1.1.6.orig/src/Fl_Gl_Choice.H	2004-09-09 17:34:46.000000000 -0400
+++ fltk-1.1.6/src/Fl_Gl_Choice.H	2006-01-26 11:25:13.546805300 -0500
@@ -124,6 +124,7 @@
 void fl_set_gl_context(Fl_Window*, GLContext);
 void fl_no_gl_context();
 void fl_delete_gl_context(GLContext);
+void fl_hide_gl_context(GLContext context);
 
 #endif
 
diff -urN fltk-1.1.6.orig/src/Fl_Gl_Choice.cxx fltk-1.1.6/src/Fl_Gl_Choice.cxx
--- fltk-1.1.6.orig/src/Fl_Gl_Choice.cxx	2004-09-24 12:00:10.000000000 -0400
+++ fltk-1.1.6/src/Fl_Gl_Choice.cxx	2006-01-26 11:25:13.562430900 -0500
@@ -435,6 +435,21 @@
   del_context(context);
 }
 
+
+void fl_hide_gl_context(GLContext context) {
+  cached_context = 0;
+  cached_window = 0;
+# if defined(__APPLE_QD__)
+  aglSetCurrentContext(0);
+  aglSetDrawable( context, NULL );
+#  elif defined(__APPLE_QUARTZ__)
+  // warning: the Quartz version should probably use Core GL (CGL) instead of AGL
+  aglSetCurrentContext(0);
+  aglSetDrawable( context, NULL );
+#  endif
+}
+
+
 #endif // HAVE_GL
 
 
diff -urN fltk-1.1.6.orig/src/Fl_Gl_Window.cxx fltk-1.1.6/src/Fl_Gl_Window.cxx
--- fltk-1.1.6.orig/src/Fl_Gl_Window.cxx	2004-09-09 17:34:46.000000000 -0400
+++ fltk-1.1.6/src/Fl_Gl_Window.cxx	2006-01-26 11:25:13.578056500 -0500
@@ -285,14 +285,21 @@
     if (SWAP_TYPE == NODAMAGE) {
 
       // don't draw if only overlay damage or expose events:
-      if ((damage()&~(FL_DAMAGE_OVERLAY|FL_DAMAGE_EXPOSE)) || !save_valid)
-	draw();
+      if ((damage()&~(FL_DAMAGE_OVERLAY|FL_DAMAGE_EXPOSE)) || !save_valid) {
+        draw();
+      } else {
+        swap_buffers();
+      }
       swap_buffers();
 
     } else if (SWAP_TYPE == COPY) {
 
       // don't draw if only the overlay is damaged:
-      if (damage() != FL_DAMAGE_OVERLAY || !save_valid) draw();
+      if (damage() != FL_DAMAGE_OVERLAY || !save_valid) {
+        draw();
+      } else {
+        swap_buffers();
+      }
       swap_buffers();
 
     } else { // SWAP_TYPE == UNDEFINED
@@ -408,7 +415,12 @@
 }    
 
 void Fl_Gl_Window::hide() {
+#if defined(__APPLE_QD__)  ||  defined(__APPLE_QUARTZ__)
+  fl_hide_gl_context((GLContext) context());
+#else
   context(0);
+#endif
+
 #if HAVE_GL_OVERLAY && defined(WIN32)
   if (overlay && overlay != this) {
     fl_delete_gl_context((GLContext)overlay);
@@ -419,6 +431,7 @@
 }
 
 Fl_Gl_Window::~Fl_Gl_Window() {
+  context(0);
   hide();
 //  delete overlay; this is done by ~Fl_Group
 }
diff -urN fltk-1.1.6.orig/src/Fl_mac.cxx fltk-1.1.6/src/Fl_mac.cxx
--- fltk-1.1.6.orig/src/Fl_mac.cxx	2004-11-22 19:28:35.000000000 -0500
+++ fltk-1.1.6/src/Fl_mac.cxx	2006-01-26 11:25:13.593682100 -0500
@@ -578,6 +578,25 @@
 }
 
 
+pascal void idleTimerProcCB( EventLoopTimerRef timer, EventLoopIdleTimerMessage idleact, void* data)
+{
+  fl_lock_function();
+
+  // do Check call backs.
+  run_checks();  
+  
+  // Now idle callbacks.
+    static char in_idle;
+    if (Fl::idle && !in_idle) {
+        in_idle = 1;
+        Fl::idle();
+        in_idle = 0;
+    }
+  
+  fl_unlock_function();
+}
+
+
 /**
  * This function is the central event handler.
  * It reads events from the event queue using the given maximum time
@@ -600,6 +619,7 @@
   OSStatus ret;
   static EventTargetRef target = 0;
   static EventLoopTimerRef timer = 0;
+  static EventLoopTimerRef idle_timer = 0;
   if ( !target ) 
   {
     target = GetEventDispatcherTarget();
@@ -627,6 +647,7 @@
         { kEventClassCommand, kEventCommandProcess } };
     ret = InstallApplicationEventHandler( dispatchHandler, GetEventTypeCount(appEvents), appEvents, 0, 0L );
     ret = InstallEventLoopTimer( GetMainEventLoop(), 0, 0, NewEventLoopTimerUPP( timerProcCB ), 0, &timer );
+    ret = InstallEventLoopIdleTimer( GetMainEventLoop(), 0.01, 0.01, NewEventLoopIdleTimerUPP( idleTimerProcCB ), 0, &idle_timer );
   }
 
   got_events = 0;
@@ -668,8 +689,8 @@
  */
 int fl_wait( double time ) 
 {
-  do_queued_events( time );
-  return (got_events);
+   do_queued_events( time );
+   return (got_events);
 }
 
 
diff -urN fltk-1.1.6.orig/src/Fl_win32.cxx fltk-1.1.6/src/Fl_win32.cxx
--- fltk-1.1.6.orig/src/Fl_win32.cxx	2004-10-19 14:21:52.000000000 -0400
+++ fltk-1.1.6/src/Fl_win32.cxx	2006-01-26 11:28:48.758194100 -0500
@@ -219,7 +219,6 @@
 // it returns 1.
 int fl_wait(double time_to_wait) {
   int have_message = 0;
-  int timerid;
 
 #ifndef USE_ASYNC_SELECT
   if (nfds) {
@@ -257,47 +256,50 @@
 
   fl_unlock_function();
 
-  if (time_to_wait < 2147483.648) {
-    // Perform the requested timeout...
-    have_message = PeekMessage(&fl_msg, NULL, 0, 0, PM_REMOVE);
-    if (!have_message) {
-      int t = (int)(time_to_wait * 1000.0 + .5);
-      if (t <= 0) { // too short to measure
-        fl_lock_function();
-	return 0;
-      }
-      timerid = SetTimer(NULL, 0, t, NULL);
-      have_message = GetMessage(&fl_msg, NULL, 0, 0);
-      KillTimer(NULL, timerid);
-    }
-  } else {
-    have_message = GetMessage(&fl_msg, NULL, 0, 0);
-  }
+  time_to_wait = (time_to_wait > 10000 ? 10000 : time_to_wait);
+  int t_msec = (int) (time_to_wait * 1000.0 + 0.5);
+  int ret_val = MsgWaitForMultipleObjects(0, NULL, FALSE, t_msec, QS_ALLINPUT);
 
   fl_lock_function();
 
   // Execute the message we got, and all other pending messages:
-  while (have_message) {
+  have_message = PeekMessage(&fl_msg, NULL, 0, 0, PM_REMOVE);
+  if (have_message > 0) {
+      while (have_message != 0  &&  have_message != -1) {
 #ifdef USE_ASYNC_SELECT
-    if (fl_msg.message == WM_FLSELECT) {
-      // Got notification for socket
-      for (int i = 0; i < nfds; i ++)
-        if (fd[i].fd == (int)fl_msg.wParam) {
-	  (fd[i].cb)(fd[i].fd, fd[i].arg);
-	  break;
-	}
-      // looks like it is best to do the dispatch-message anyway:
-    }
+          if (fl_msg.message == WM_FLSELECT) {
+              // Got notification for socket
+              for (int i = 0; i < nfds; i ++)
+                  if (fd[i].fd == (int)fl_msg.wParam) {
+                      (fd[i].cb)(fd[i].fd, fd[i].arg);
+                      break;
+                  }
+                  // looks like it is best to do the dispatch-message anyway:
+          }
 #endif
 
-    if (fl_msg.message == fl_wake_msg)  // Used for awaking wait() from another thread
-      thread_message_ = (void*)fl_msg.wParam;
+          if (fl_msg.message == fl_wake_msg)  // Used for awaking wait() from another thread
+              thread_message_ = (void*)fl_msg.wParam;
 
-    TranslateMessage(&fl_msg);
-    DispatchMessage(&fl_msg);
-    have_message = PeekMessage(&fl_msg, NULL, 0, 0, PM_REMOVE);
+          TranslateMessage(&fl_msg);
+          DispatchMessage(&fl_msg);
+          have_message = PeekMessage(&fl_msg, NULL, 0, 0, PM_REMOVE);
+      }
+      Fl::flush();
+  } else {
+      Fl::flush();
+
+      // idle processing
+      static char in_idle;
+      if (Fl::idle && !in_idle) {
+          in_idle = 1;
+          Fl::idle();
+          in_idle = 0;
+      }
   }
 
+  run_checks();
+  
   // This should return 0 if only timer events were handled:
   return 1;
 }
@@ -549,6 +551,45 @@
 extern HPALETTE fl_select_palette(void); // in fl_color_win32.cxx
 #endif
 
+
+/////////////////////////////////////////////////////////////////////////////
+/// Win32 timers
+///
+
+struct Win32Timer
+{
+    UINT_PTR handle;
+    Fl_Timeout_Handler callback;
+    void *data;
+};
+static Win32Timer* win32_timers;
+static int win32_timer_alloc;
+static int win32_timer_used;
+static HWND s_TimerWnd;
+
+static void realloc_timers()
+{
+    if (win32_timer_alloc == 0) {
+        win32_timer_alloc = 8;
+    }
+    size_t size = sizeof(Win32Timer);
+    Win32Timer* new_timers = new Win32Timer[win32_timer_alloc * 2];
+    memmove(new_timers, win32_timers, sizeof(Win32Timer) * win32_timer_used);
+    Win32Timer* delete_me = win32_timers;
+    win32_timers = new_timers;
+    delete [] delete_me;
+    win32_timer_alloc *= 2;
+}
+
+static void delete_timer(Win32Timer& t)
+{
+    KillTimer(s_TimerWnd, t.handle);
+    memset(&t, 0, sizeof(Win32Timer));
+}
+
+/// END TIMERS
+/////////////////////////////////////////////////////////////////////////////
+
 static Fl_Window* resize_bug_fix;
 
 extern void fl_save_pen(void);
@@ -576,6 +617,7 @@
 
   case WM_CLOSE: // user clicked close box
     Fl::handle(FL_CLOSE, window);
+    PostQuitMessage(0);
     return 0;
 
   case WM_SYNCPAINT :
@@ -719,10 +761,12 @@
     }
     if (GetKeyState(VK_SCROLL)) state |= FL_SCROLL_LOCK;
     Fl::e_state = state;
-    if (lParam & (1<<31)) { // key up events.
+    
+    /* NCBI NUMLOC patch - this code moved down
+    if (lParam & (1<<31)) {     // key up events.
       if (Fl::handle(FL_KEYUP, window)) return 0;
       break;
-    }
+    }*/
     static char buffer[2];
     if (uMsg == WM_CHAR || uMsg == WM_SYSCHAR) {
       buffer[0] = char(wParam);
@@ -730,61 +774,71 @@
     } else if (Fl::e_keysym >= FL_KP && Fl::e_keysym <= FL_KP_Last) {
       if (state & FL_NUM_LOCK) {
         // Convert to regular keypress...
-	buffer[0] = Fl::e_keysym-FL_KP;
-	Fl::e_length = 1;
+	    buffer[0] = Fl::e_keysym - FL_KP;
+	    Fl::e_length = 1;
       } else {
         // Convert to special keypress...
-	buffer[0] = 0;
-	Fl::e_length = 0;
-	switch (Fl::e_keysym) {
-	  case FL_KP + '0' :
-	    Fl::e_keysym = FL_Insert;
-	    break;
-	  case FL_KP + '1' :
-	    Fl::e_keysym = FL_End;
-	    break;
-	  case FL_KP + '2' :
-	    Fl::e_keysym = FL_Down;
-	    break;
-	  case FL_KP + '3' :
-	    Fl::e_keysym = FL_Page_Down;
-	    break;
-	  case FL_KP + '4' :
-	    Fl::e_keysym = FL_Left;
-	    break;
-	  case FL_KP + '6' :
-	    Fl::e_keysym = FL_Right;
-	    break;
-	  case FL_KP + '7' :
-	    Fl::e_keysym = FL_Home;
-	    break;
-	  case FL_KP + '8' :
-	    Fl::e_keysym = FL_Up;
-	    break;
-	  case FL_KP + '9' :
-	    Fl::e_keysym = FL_Page_Up;
-	    break;
-	  case FL_KP + '.' :
-	    Fl::e_keysym = FL_Delete;
-	    break;
-	  case FL_KP + '/' :
-	  case FL_KP + '*' :
-	  case FL_KP + '-' :
-	  case FL_KP + '+' :
-	    buffer[0] = Fl::e_keysym-FL_KP;
-	    Fl::e_length = 1;
-	    break;
-	}
+	    buffer[0] = 0;
+	    Fl::e_length = 0;
+	    switch (Fl::e_keysym) {
+	    case FL_KP + '0' :
+	        Fl::e_keysym = FL_Insert;
+	        break;
+	    case FL_KP + '1' :
+	        Fl::e_keysym = FL_End;
+	        break;
+	    case FL_KP + '2' :
+	        Fl::e_keysym = FL_Down;
+	        break;
+	    case FL_KP + '3' :
+	        Fl::e_keysym = FL_Page_Down;
+	        break;
+	    case FL_KP + '4' :
+	        Fl::e_keysym = FL_Left;
+	        break;
+	    case FL_KP + '6' :
+	        Fl::e_keysym = FL_Right;
+	        break;
+	    case FL_KP + '7' :
+	        Fl::e_keysym = FL_Home;
+	        break;
+	    case FL_KP + '8' :
+	        Fl::e_keysym = FL_Up;
+	        break;
+	    case FL_KP + '9' :
+	        Fl::e_keysym = FL_Page_Up;
+	        break;
+	    case FL_KP + '.' :
+	        Fl::e_keysym = FL_Delete;
+	        break;
+	    case FL_KP + '/' :
+	    case FL_KP + '*' :
+	    case FL_KP + '-' :
+	    case FL_KP + '+' :
+	        buffer[0] = Fl::e_keysym - FL_KP;
+	        Fl::e_length = 1;
+	        break;
+	    }
       }
     } else {
       buffer[0] = 0;
       Fl::e_length = 0;
     }
+
     Fl::e_text = buffer;
+
+    /// NCBI NUMLOCK patch - moved here, so that NUMLOCK is handled properly
+    if (lParam & (1<<31)) {     // key up events.
+      if (Fl::handle(FL_KEYUP, window)) return 0;
+      break;
+    }
+    /// END of NCBI NUMLOCK patch
+
     // for (int i = lParam&0xff; i--;)
     while (window->parent()) window = window->window();
     if (Fl::handle(FL_KEYBOARD,window)) return 0;
-    break;}
+    break;
+  }
 
   case WM_MOUSEWHEEL: {
     static int delta = 0; // running total of all motion
@@ -986,13 +1040,14 @@
   const char* message_name = "FLTK::ThreadWakeup";
 
   WNDCLASSEX wc;
+  memset(&wc, 0, sizeof(WNDCLASSEX));
+  wc.cbSize = sizeof(WNDCLASSEX);
   // Documentation states a device context consumes about 800 bytes
   // of memory... so who cares? If 800 bytes per window is what it
   // takes to speed things up, I'm game.
   //wc.style = CS_HREDRAW | CS_VREDRAW | CS_CLASSDC | CS_DBLCLKS;
   wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_DBLCLKS;
   wc.lpfnWndProc = (WNDPROC)WndProc;
-  wc.cbClsExtra = wc.cbWndExtra = 0;
   wc.hInstance = fl_display;
   if (!w->icon())
     w->icon((void *)LoadIcon(NULL, IDI_APPLICATION));
@@ -1000,11 +1055,9 @@
   wc.hCursor = fl_default_cursor = LoadCursor(NULL, IDC_ARROW);
   //uchar r,g,b; Fl::get_color(FL_GRAY,r,g,b);
   //wc.hbrBackground = (HBRUSH)CreateSolidBrush(RGB(r,g,b));
-  wc.hbrBackground = NULL;
-  wc.lpszMenuName = NULL;
   wc.lpszClassName = class_name;
-  wc.cbSize = sizeof(WNDCLASSEX);
-  RegisterClassEx(&wc);
+  ATOM atom = RegisterClassEx(&wc);
+  int err_no = GetLastError();
   if (!fl_wake_msg) fl_wake_msg = RegisterWindowMessage(message_name);
 
   HWND parent;
@@ -1116,6 +1169,115 @@
   return x;
 }
 
+
+
+
+/////////////////////////////////////////////////////////////////////////////
+/// Win32 timers
+///
+
+
+static LRESULT CALLBACK s_TimerProc(HWND hwnd, UINT msg,
+                                    WPARAM wParam, LPARAM lParam)
+{
+    switch (msg) {
+    case WM_TIMER:
+        {
+            unsigned int id = wParam - 1;
+            if (id < win32_timer_used && win32_timers[id].handle) {
+                Fl_Timeout_Handler cb   = win32_timers[id].callback;
+                void*              data = win32_timers[id].data;
+                delete_timer(win32_timers[id]);
+                if (cb) {
+                    (*cb)(data);
+                }
+            }
+        }
+        return 0;
+
+    default:
+        break;
+    }
+
+    return DefWindowProc(hwnd, msg, wParam, lParam);
+}
+
+void Fl::add_timeout(double time, Fl_Timeout_Handler cb, void* data)
+{
+    repeat_timeout(time, cb, data);
+}
+
+void Fl::repeat_timeout(double time, Fl_Timeout_Handler cb, void* data)
+{
+    int timer_id = -1;
+    for (int i = 0;  i < win32_timer_used;  ++i) {
+        if ( !win32_timers[i].handle ) {
+            timer_id = i;
+            break;
+        }
+    }
+    if (timer_id == -1) {
+        if (win32_timer_used == win32_timer_alloc) {
+            realloc_timers();
+        }
+        timer_id = win32_timer_used++;
+    }
+    unsigned int elapsed = (unsigned int)(time * 1000);
+
+    if ( !s_TimerWnd ) {
+        const char* timer_class = "FLTimer";
+        WNDCLASSEX wc;
+        memset(&wc, 0, sizeof(wc));
+        wc.cbSize = sizeof (wc);
+        wc.style = CS_CLASSDC;
+        wc.lpfnWndProc = (WNDPROC)s_TimerProc;
+        wc.hInstance = fl_display;
+        wc.lpszClassName = timer_class;
+        ATOM atom = RegisterClassEx(&wc);
+
+        s_TimerWnd = CreateWindowEx(WS_EX_LEFT | WS_EX_TOOLWINDOW,
+                                    timer_class, "",
+                                    WS_POPUP,
+                                    CW_USEDEFAULT, CW_USEDEFAULT, 1, 1,
+                                    NULL, NULL, fl_display, NULL);
+        ShowWindow(s_TimerWnd, SW_SHOWNOACTIVATE);
+    }
+
+    win32_timers[timer_id].callback = cb;
+    win32_timers[timer_id].data     = data;
+
+    win32_timers[timer_id].handle =
+        SetTimer(s_TimerWnd, timer_id + 1, elapsed, NULL);
+}
+
+int Fl::has_timeout(Fl_Timeout_Handler cb, void* data)
+{
+    for (int i = 0;  i < win32_timer_used;  ++i) {
+        Win32Timer& t = win32_timers[i];
+        if (t.handle  &&  t.callback == cb  &&  t.data == data) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+void Fl::remove_timeout(Fl_Timeout_Handler cb, void* data)
+{
+    int i;
+    for (i = 0;  i < win32_timer_used;  ++i) {
+        Win32Timer& t = win32_timers[i];
+        if (t.handle  &&  t.callback == cb  &&
+            (t.data == data  ||  data == NULL)) {
+            delete_timer(t);
+        }
+    }
+}
+
+/// END TIMERS
+/////////////////////////////////////////////////////////////////////////////
+
+
+
 ////////////////////////////////////////////////////////////////
 
 HINSTANCE fl_display = GetModuleHandle(NULL);
diff -urN fltk-1.1.6.orig/src/Fl_x.cxx fltk-1.1.6/src/Fl_x.cxx
--- fltk-1.1.6.orig/src/Fl_x.cxx	2004-11-20 08:52:47.000000000 -0500
+++ fltk-1.1.6/src/Fl_x.cxx	2006-01-26 11:25:13.624933300 -0500
@@ -24,9 +24,9 @@
 //
 
 #ifdef WIN32
-#  include "Fl_win32.cxx"
+//#  include "Fl_win32.cxx"
 #elif defined(__APPLE__)
-#  include "Fl_mac.cxx"
+//#  include "Fl_mac.cxx"
 #else
 
 #  define CONSOLIDATE_MOTION 1
@@ -195,7 +195,17 @@
   // OpenGL and other broken libraries call XEventsQueued
   // unnecessarily and thus cause the file descriptor to not be ready,
   // so we must check for already-read events:
-  if (fl_display && XQLength(fl_display)) {do_queued_events(); return 1;}
+  if (fl_display && XQLength(fl_display)) {
+      do_queued_events();
+      return 1;
+  } else {
+      static char in_idle;
+      if (Fl::idle && !in_idle) {
+          in_idle = 1;
+          Fl::idle();
+          in_idle = 0;
+      }
+  }
 
 #  if !USE_POLL
   fd_set fdt[3];
diff -urN fltk-1.1.6.orig/src/Makefile fltk-1.1.6/src/Makefile
--- fltk-1.1.6.orig/src/Makefile	2004-11-19 22:19:58.000000000 -0500
+++ fltk-1.1.6/src/Makefile	2006-01-26 11:25:13.640558900 -0500
@@ -237,7 +237,7 @@
 
 libfltk_forms.so.1.1: $(FLOBJECTS) libfltk.so.1.1
 	echo $(DSOCOMMAND) $@ ...
-	$(DSOCOMMAND) $@ $(FLOBJECTS) -L. -lfltk
+	$(DSOCOMMAND) $@ $(FLOBJECTS) $(DSOLINK) -L. -lfltk
 	$(RM) libfltk_forms.so
 	$(LN) libfltk_forms.so.1.1 libfltk_forms.so
 
@@ -273,7 +273,7 @@
 
 libfltk_gl.so.1.1: $(GLOBJECTS) libfltk.so.1.1
 	echo $(DSOCOMMAND) $@ ...
-	$(DSOCOMMAND) $@ $(GLOBJECTS) -L. -lfltk
+	$(DSOCOMMAND) $@ $(GLOBJECTS) $(GLDLIBS) $(DSOLINK) -L. -lfltk
 	$(RM) libfltk_gl.so
 	$(LN) libfltk_gl.so.1.1 libfltk_gl.so
 
@@ -309,7 +309,7 @@
 
 libfltk_images.so.1.1: $(IMGOBJECTS) libfltk.so.1.1
 	echo $(DSOCOMMAND) $@ ...
-	$(DSOCOMMAND) $@ $(IMGOBJECTS) $(IMAGELIBS) -L. -lfltk
+	$(DSOCOMMAND) $@ $(IMGOBJECTS) -L../lib $(IMAGELIBS) $(DSOLINK) -L. -lfltk
 	$(RM) libfltk_images.so
 	$(LN) libfltk_images.so.1.1 libfltk_images.so
 
