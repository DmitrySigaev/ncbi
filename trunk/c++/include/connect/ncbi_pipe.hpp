#ifndef CONNECT___NCBI_PIPE__HPP
#define CONNECT___NCBI_PIPE__HPP

/*  $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  Anton Lavrentiev, Vladimir Ivanov
 *
 *
 */

/// @file ncbi_pipe.hpp
/// Portable class for work with process pipes.
///
/// Defines classes: 
///     CPipe          -  class for work with pipes
///     CPipeIOStream  -  class with realization iostream over pipes
///
/// Implemented for: UNIX, MS-Windows


#include <connect/ncbi_core.h>
#include <corelib/ncbistd.hpp>
#include <stdio.h>
#include <vector>

#if defined(NCBI_OS_MSWIN)
#elif defined(NCBI_OS_UNIX)
#else
#  error "Class CPipe is supported only on Windows and Unix"
#endif


/** @addtogroup Pipes
 *
 * @{
 */


BEGIN_NCBI_SCOPE


// Forward declaration.
class CPipeHandle;
class CPipeStreambuf;


/////////////////////////////////////////////////////////////////////////////
/// CPipeException --
///
/// Define exceptions generated by CPipe and CPipeIOStream.
///
/// CPipeException inherits its basic functionality from CCoreException
/// and defines additional error codes for CPipe.

class NCBI_XCONNECT_EXPORT CPipeException : public CCoreException
{
public:
    /// Error types for pipe exceptions.
    enum EErrCode {
        eInit,      ///< Pipe initialization error
        eOpen,      ///< Unable to open pipe (from constructor)
        eSetBuf     ///< setbuf() not permited error
    };

    /// Translate from the error code value to its string representation.
    virtual const char* GetErrCodeString(void) const
    {
        switch (GetErrCode()) {
        case eInit:   return "eInit";
        case eOpen:   return "eOpen";
        case eSetBuf: return "eSetBuf";
        default:      return CException::GetErrCodeString();
        }
    }
    // Standard exception bolier plate code.
    NCBI_EXCEPTION_DEFAULT(CPipeException,CCoreException);
};



/////////////////////////////////////////////////////////////////////////////
///
/// CPipe --
///
/// Create a pipe between program and some child process.
///
/// Program can read from stdin/stderr and write to stdin of the
/// executed child process using pipe object functions Read/Write.
///
/// @sa
///   CPipeIOStream, CNamedPipe, CExec

class NCBI_XCONNECT_EXPORT CPipe
{
public:
    /// Flags for creating a standart I/O handles of a child process.
    ///
    /// Default is 0 (fStdIn_Open | fStdOut_Open | fStdErr_Close).
    enum ECreateFlags {
        fStdIn_Open    =    0,  ///< do     open child stdin (default)
        fStdIn_Close   = 0x01,  ///< do not open child's stdin
        fStdOut_Open   =    0,  ///< do     open child stdout (default)
        fStdOut_Close  = 0x02,  ///< do not open child's stdout
        fStdErr_Open   = 0x04,  ///< do     open child stderr
        fStdErr_Close  =    0   ///, do not open child stderr (default)
    };
    typedef unsigned int TCreateFlags;  ///< bit-wise OR of "ECreateFlags"

    /// Which of the child I/O handles to used.
    enum EChildIOHandle {
        eStdIn,
        eStdOut,
        eStdErr
    };

    /// Constructor.
    CPipe();

    /// Constructor.
    ///
    /// Calls the Open() method to open a pipe. Throws CPipeException defined
    /// errors on failure to create a pipe.
    ///
    /// @param cmd
    ///   Command name to execute.
    /// @param args
    ///   Vector of string arguments for command.
    /// @param create_flags
    ///   Specifies the options to be applied when creating the pipe.
    /// @sa
    ///   Open()

    CPipe
        (const string&         cmd,
         const vector<string>& args,
         TCreateFlags          create_flags = 0
        );

    /// Destructor. 
    ///
    /// If pipe was created, destructor waits for new child process
    /// and closes stream on associated pipe by calling the Close() method.
    ~CPipe(void);

    /// Open a pipe.
    ///
    /// Create a pipe and execute a command with the vector of arguments
    /// "args". The other end of the pipe is associated with the spawned
    /// command's standard input or standard output according to the open mode
    /// setting. 
    ///
    /// @param cmd
    ///   Command name to execute.
    /// @param args
    ///   Vector of string arguments for command.
    /// @param create_flags
    ///   Specifies the options to be applied when creating the pipe.
    /// @return 
    ///   Status of the operation.
    /// @sa
    ///   Open()
    EIO_Status Open
        (const string&         cmd,
         const vector<string>& args,
         TCreateFlags          create_flags = 0
        );

    /// Close pipe.
    ///
    /// Waits for new spawned child process to terminate and then closes
    /// the associated pipe.
    ///
    /// @param exitcode
    ///   Return here the exit code of child process if it has terminate
    ///   succesfully, or -1 if an error has occurs.
    /// @return
    ///   Status of the operation.
    ///   The returned status eIO_Timeout means that child process is still 
    ///   running and pipe handle not closed yet. Otherwise, the pipe handle
    ///   goes invalid after this function call, regardless of whether the call
    ///   was successful or not.
    EIO_Status Close(int* exitcode = 0);

    /// Close a specified pipe handle.
    ///
    /// @param handle
    ///   Pipe handle to close
    /// @return
    ///   Status of the operation.
    /// @sa
    ///   Close()
    EIO_Status CloseHandle(EChildIOHandle handle);

    /// Read data from the pipe. 
    ///
    /// @param buf
    ///   Buffer into which data is read.
    /// @param count
    ///   Number of bytes to read.
    /// @param read
    ///   Number of bytes actually read, which may be less than "count" if an
    ///   error occurs or if the end of the pipe file stream is encountered. 
    /// @param from_handle
    ///   Handle to read data from.
    /// @return
    ///   Always return eIO_Success if some data were read (regardless of pipe
    ///   conditions that may include EOF/error).
    //    Return other (error) code only if no data at all could be obtained.
    /// @sa
    ///   Write(), SetTimeout()
    EIO_Status Read(void* buf, size_t count, size_t* read = 0,
        const EChildIOHandle from_handle = eStdOut);

    /// Write data to the pipe. 
    ///
    /// @param buf
    ///   Buffer from which data is written.
    /// @param count
    ///   Number of bytes to write.
    /// @param written
    ///   Number of bytes actually written, which may be less than "count" if
    ///   an error occurs. 
    /// @return
    ///   Return eIO_Success if some data were written.
    ///   Return other (error) code only if no data at all could be written.
    /// @sa
    ///   Read(), SetTimeout()
    EIO_Status Write(const void* buf, size_t count, size_t* written = 0);

    /// Return a status of the last I/O operation.
    /// 
    /// @param direction
    ///   Direction to get status from.
    /// @return
    ///   I/O status for the specified direction.
    ///   eIO_Closed     -- if the pipe is closed;
    ///   eIO_Unknown    -- if an error was detected during the last I/O;
    ///   eIO_InvalidArg -- if "direction" is not one of:  eIO_Read, eIO_Write;
    ///   eIO_Timeout    -- if the timeout was on last I/O;
    ///   eIO_Success    -- otherwise.
    /// @sa
    ///   Read(), Write()
    EIO_Status Status(EIO_Event direction);

    /// Specify timeout for the pipe I/O.
    ///
    /// @param event
    ///   I/O event for which timeout will be set.
    /// @param timeout
    ///   Timeout value to set from.
    ///   If "timeout" is NULL then set the timeout to be infinite.
    ///   - By default, initially all timeouts are infinite;
    ///   - kDefaultTimeout has no effect.
    /// @return
    ///   Status of the operation.
    /// @sa
    ///   Read(), Write(), Close(), GetTimeout()
    EIO_Status SetTimeout(EIO_Event event, const STimeout* timeout);

    /// Get the pipe I/O timeout.
    ///
    /// @param event
    ///   I/O event for which timeout will be get.
    /// @return
    //    Timeout for specified event (or NULL, if the timeout is infinite).
    ///   The returned timeout is guaranteed to be pointing to a valid
    ///   (and correct) structure in memory at least until the pipe is
    ///   closed or SetTimeout() is called for this pipe.
    /// @sa
    ///   SetTimeout()
    const STimeout* GetTimeout(EIO_Event event) const;

private:
    CPipeHandle*  m_PipeHandle;        ///< Internal pipe handle that handles
                                       ///< requests forwarded by CPipe.
    // Last IO status
    EIO_Status    m_ReadStatus;        ///< Last read status
    EIO_Status    m_WriteStatus;       ///< Last write status

    // Timeouts
    STimeout*     m_ReadTimeout;       ///< eIO_Read timeout
    STimeout*     m_WriteTimeout;      ///< eIO_Write timeout
    STimeout*     m_CloseTimeout;      ///< eIO_Close timeout
    STimeout      m_ReadTimeoutValue;  ///< Storage for m_ReadTimeout
    STimeout      m_WriteTimeoutValue; ///< Storage for m_WriteTimeout
    STimeout      m_CloseTimeoutValue; ///< Storage for m_CloseTimeout

    /// Disable copy constructor and assignment.
    CPipe(const CPipe&);
    CPipe& operator= (const CPipe&);
};



/////////////////////////////////////////////////////////////////////////////
///
/// CPipeIOStream --
///
/// Create an input and output stream for a pipe.
///
/// This class is  derived from "std::iostream" and performs both input and 
/// output, using the specified pipe. 

class NCBI_XCONNECT_EXPORT CPipeIOStream : public iostream
{
public:

    /// Default I/O buffer size.
    static const streamsize kDefaultBufferSize;

    /// Constructor.
    ///
    /// @param pipe
    ///   Pipe which will be used for stream input/output.
    /// @param buf_size
    ///   Buffer size to be used for pipe.
    CPipeIOStream(CPipe& pipe, streamsize buf_size = kDefaultBufferSize);

    /// Destructor.
    virtual ~CPipeIOStream(void);

    /// Set the read handle of the child process as specified by "handle"
    /// (eStdOut/eStdErr).
    void SetReadHandle(const CPipe::EChildIOHandle handle) const;

private:
    CPipeStreambuf* m_StreamBuf;    ///< Stream buffer for pipe I/O 
};


END_NCBI_SCOPE


/* @} */


/*
 * ===========================================================================
 * $Log$
 * Revision 1.14  2003/09/02 20:46:59  lavr
 * -<connect/connect_export.h> -- included from <connect/ncbi_core.h>
 *
 * Revision 1.13  2003/09/02 20:24:32  ivanov
 * Moved ncbipipe to CONNECT library from CORELIB.
 * Rewritten CPipe class using I/O timeouts.
 *
 * Revision 1.12  2003/08/26 14:06:51  siyan
 * Minor doc fixes.
 *
 * Revision 1.11  2003/08/24 22:53:03  siyan
 * Added documentation.
 *
 * Revision 1.10  2003/04/23 20:50:27  ivanov
 * Added CPipe::CloseHandle()
 *
 * Revision 1.9  2003/04/01 14:20:13  siyan
 * Added doxygen support
 *
 * Revision 1.8  2003/03/03 14:46:02  dicuccio
 * Reimplemented CPipe using separate private platform-specific implementations
 *
 * Revision 1.7  2002/12/18 22:53:21  dicuccio
 * Added export specifier for building DLLs in windows.  Added global list of
 * all such specifiers in mswin_exports.hpp, included through ncbistl.hpp
 *
 * Revision 1.6  2002/07/15 18:17:52  gouriano
 * renamed CNcbiException and its descendents
 *
 * Revision 1.5  2002/07/11 14:17:55  gouriano
 * exceptions replaced by CNcbiException-type ones
 *
 * Revision 1.4  2002/06/12 19:38:45  ucko
 * Remove a superfluous comma from the definition of EMode.
 *
 * Revision 1.3  2002/06/11 19:25:06  ivanov
 * Added class CPipeIOStream
 *
 * Revision 1.2  2002/06/10 18:35:13  ivanov
 * Changed argument's type of a running child program from char*[]
 * to vector<string>
 *
 * Revision 1.1  2002/06/10 16:57:04  ivanov
 * Initial revision
 *
 * ===========================================================================
 */

#endif  /* CONNECT__NCBI_PIPE__HPP */
