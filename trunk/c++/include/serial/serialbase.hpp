#ifndef SERIALBASE__HPP
#define SERIALBASE__HPP

/*  $Id$
* ===========================================================================
*
*                            PUBLIC DOMAIN NOTICE
*               National Center for Biotechnology Information
*
*  This software/database is a "United States Government Work" under the
*  terms of the United States Copyright Act.  It was written as part of
*  the author's official duties as a United States Government employee and
*  thus cannot be copyrighted.  This software/database is freely available
*  to the public for use. The National Library of Medicine and the U.S.
*  Government have not placed any restriction on its use or reproduction.
*
*  Although all reasonable efforts have been taken to ensure the accuracy
*  and reliability of the software and data, the NLM and the U.S.
*  Government do not and cannot warrant the performance or results that
*  may be obtained by using this software or data. The NLM and the U.S.
*  Government disclaim all warranties, express or implied, including
*  warranties of performance, merchantability or fitness for any particular
*  purpose.
*
*  Please cite the author in any work or product based on this material.
*
* ===========================================================================
*
* Author: Eugene Vasilchenko
*
* File Description:
*   File to be included in all headers generated by datatool
*
* ---------------------------------------------------------------------------
* $Log$
* Revision 1.5  2000/07/10 17:59:30  vasilche
* Moved macros needed in headers to serialbase.hpp.
* Use DECLARE_ENUM_INFO in generated code.
*
* Revision 1.4  2000/06/16 16:31:07  vasilche
* Changed implementation of choices and classes info to allow use of the same classes in generated and user written classes.
*
* Revision 1.3  2000/05/04 16:21:36  vasilche
* Fixed bug in choice reset.
*
* Revision 1.2  2000/04/28 16:58:03  vasilche
* Added classes CByteSource and CByteSourceReader for generic reading.
* Added delayed reading of choice variants.
*
* Revision 1.1  2000/04/03 18:47:09  vasilche
* Added main include file for generated headers.
* serialimpl.hpp is included in generated sources with GetTypeInfo methods
*
* ===========================================================================
*/

#include <corelib/ncbiobj.hpp>
#include <serial/serialdef.hpp>
#include <typeinfo>

BEGIN_NCBI_SCOPE

// forward declaration
class CClassTypeInfoBase;
class CClassTypeInfo;
class CChoiceTypeInfo;
class CDelayBufferData;

// these methods are external to avoid inclusion of big headers
class CClassInfoHelperBase
{
protected:
    typedef const type_info* (*TGetTypeIdFunction)(TConstObjectPtr object);
    typedef TObjectPtr (*TCreateFunction)(TTypeInfo info);
    typedef int (*TWhichFunction)(TConstObjectPtr object);
    typedef void (*TResetFunction)(TObjectPtr object);
    typedef void (*TSelectFunction)(TObjectPtr object, int index);
    typedef void (*TSelectDelayFunction)(TObjectPtr object, int index);
    typedef void (*TPostReadFunction)(TTypeInfo info, TObjectPtr object);
    typedef void (*TPreWriteFunction)(TTypeInfo info, TConstObjectPtr object);

    static CChoiceTypeInfo* CreateChoiceInfo(const char* name, size_t size,
                                             const type_info& ti,
                                             TCreateFunction createFunc,
                                             TWhichFunction whichFunc,
                                             TSelectFunction selectFunc,
                                             TResetFunction resetFunc = 0);

public:
#if HAVE_NCBI_C
    static CChoiceTypeInfo* CreateAsnChoiceInfo(const char* name);
    static CClassTypeInfo* CreateAsnStructInfo(const char* name, size_t size,
                                               const type_info& id);
#endif
    
protected:
    static void SetCreateFunction(CClassTypeInfo* info, TCreateFunction func);
    static void SetPostReadFunction(CClassTypeInfo* info, TPostReadFunction func);
    static void SetPreWriteFunction(CClassTypeInfo* info, TPreWriteFunction func);
    static void UpdateCObject(CClassTypeInfo* /*info*/, const void* /*object*/)
        {
            // do nothing
        }
    static void UpdateCObject(CClassTypeInfo* info, const CObject* object);

    static void SetPostReadFunction(CChoiceTypeInfo* info, TPostReadFunction func);
    static void SetPreWriteFunction(CChoiceTypeInfo* info, TPreWriteFunction func);
    static void UpdateCObject(CChoiceTypeInfo* /*info*/, const void* /*object*/)
        {
            // do nothing
        }
    static void UpdateCObject(CChoiceTypeInfo* info, const CObject* object);

    static CClassTypeInfo* CreateClassInfo(const char* name, size_t size,
                                           const type_info& id,
                                           TGetTypeIdFunction func);
private:
    static CClassTypeInfo* CreateClassInfo(const char* name, size_t size,
                                           const type_info& id);
};

// template collecting all helper methods for generated classes
template<class C>
class CClassInfoHelper : public CClassInfoHelperBase
{
    typedef CClassInfoHelperBase CParent;
public:
    typedef C CClassType;

    static CClassType& Get(void* object)
        {
            return *static_cast<CClassType*>(object);
        }
    static const CClassType& Get(const void* object)
        {
            return *static_cast<const CClassType*>(object);
        }

    static void* Create(TTypeInfo /*typeInfo*/)
        {
            return new CClassType();
        }

    static const type_info* GetTypeId(const void* object)
        {
            return &typeid(Get(object));
        }
    static void Reset(void* object)
        {
            Get(object).Reset();
        }

    static void PostRead(TTypeInfo /*info*/, void* object)
        {
            Get(object).PostRead();
        }
    static void PreWrite(TTypeInfo /*info*/, const void* object)
        {
            Get(object).PreWrite();
        }

    static int Which(const void* object)
        {
            return Get(object).Which() - 1;
        }
    static void ResetChoice(void* object)
        {
            if ( Which(object) != -1 )
                Reset(object);
        }
    static void Select(void* object, int index)
        {
            typedef typename CClassType::E_Choice E_Choice;
            Get(object).Select(E_Choice(index+1));
        }
    static void SelectDelayBuffer(void* object, int index)
        {
            typedef typename CClassType::E_Choice E_Choice;
            Get(object).SelectDelayBuffer(E_Choice(index+1));
        }

    static void SetPostRead(NCBI_NS_NCBI::CClassTypeInfo* info)
        {
            SetPostReadFunction(info, &PostRead);
        }
    static void SetPreWrite(NCBI_NS_NCBI::CClassTypeInfo* info)
        {
            SetPreWriteFunction(info, &PreWrite);
        }
    static void SetReadWriteMethods(NCBI_NS_NCBI::CClassTypeInfo* info)
        {
            const CClassType* object = 0;
            UpdateCObject(info, object);
            NCBISERSetPostRead(object, info);
            NCBISERSetPreWrite(object, info);
        }
    static void SetPostRead(NCBI_NS_NCBI::CChoiceTypeInfo* info)
        {
            SetPostReadFunction(info, &PostRead);
        }
    static void SetPreWrite(NCBI_NS_NCBI::CChoiceTypeInfo* info)
        {
            SetPreWriteFunction(info, &PreWrite);
        }
    static void SetReadWriteMethods(NCBI_NS_NCBI::CChoiceTypeInfo* info)
        {
            const CClassType* object = 0;
            UpdateCObject(info, object);
            NCBISERSetPostRead(object, info);
            NCBISERSetPreWrite(object, info);
        }

    static CClassTypeInfo* CreateAbstractClassInfo(const char* name)
        {
            CClassTypeInfo* info =
                CParent::CreateClassInfo(name, sizeof(CClassType),
                                         typeid(CClassType), &GetTypeId);
            SetReadWriteMethods(info);
            return info;
        }
    static CClassTypeInfo* CreateClassInfo(const char* name)
        {
            CClassTypeInfo* info = CreateAbstractClassInfo(name);
            SetCreateFunction(info, &Create);
            return info;
        }

    static CChoiceTypeInfo* CreateChoiceInfo(const char* name)
        {
            CChoiceTypeInfo* info =
                CParent::CreateChoiceInfo(name, sizeof(CClassType),
                                          typeid(CClassType), &Create,
                                          &Which, &Select, &ResetChoice);
            SetReadWriteMethods(info);
            return info;
        }

    static CClassTypeInfo* CreateAsnStructInfo(const char* name)
        {
            return CParent::CreateAsnStructInfo(name,
                                                sizeof(CClassType),
                                                typeid(CClassType));
        }
};

END_NCBI_SCOPE

// these methods must be defined in root namespace so they have prefix NCBISER

// default functions do nothing
template<class CInfo>
inline
void NCBISERSetPostRead(const void* /*object*/, CInfo* /*info*/)
{
}

template<class CInfo>
inline
void NCBISERSetPreWrite(const void* /*object*/, CInfo* /*info*/)
{
}

// define for declaring specific function
#define NCBISER_HAVE_POST_READ(Class) \
template<class CInfo> \
inline \
void NCBISERSetPostRead(const Class* /*object*/, CInfo* info) \
{ \
    NCBI_NS_NCBI::CClassInfoHelper<Class>::SetPostRead(info); \
}

#define NCBISER_HAVE_PRE_WRITE(Class) \
template<class CInfo> \
inline \
void NCBISERSetPreWrite(const Class* /*object*/, CInfo* info) \
{ \
    NCBI_NS_NCBI::CClassInfoHelper<Class>::SetPreWrite(info); \
}

#define ENUM_METHOD_NAME(EnumName) \
    NCBI_NAME2(GetTypeInfo_enum_,EnumName)
#define DECLARE_ENUM_INFO(EnumName) \
    const NCBI_NS_NCBI::CEnumeratedTypeValues* ENUM_METHOD_NAME(EnumName)(void)
#define DECLARE_INTERNAL_ENUM_INFO(EnumName) \
    static DECLARE_ENUM_INFO(EnumName)

#if HAVE_NCBI_C

#define ASN_STRUCT_NAME(AsnStructName) NCBI_NAME2(struct_, AsnStructName)
#define ASN_STRUCT_METHOD_NAME(AsnStructName) \
    NCBI_NAME2(GetTypeInfo_struct_,AsnStructName)

#define DECLARE_ASN_TYPE_INFO(AsnStructName) \
    const NCBI_NS_NCBI::CTypeInfo* ASN_STRUCT_METHOD_NAME(AsnStructName)(void)
#define DECLARE_ASN_STRUCT_INFO(AsnStructName) \
    struct ASN_STRUCT_NAME(AsnStructName); \
    DECLARE_ASN_TYPE_INFO(AsnStructName); \
    inline \
    const NCBI_NS_NCBI::CTypeInfo* \
    GetAsnStructTypeInfo(const ASN_STRUCT_NAME(AsnStructName)* ) \
    { \
        return ASN_STRUCT_METHOD_NAME(AsnStructName)(); \
    } \
    struct ASN_STRUCT_NAME(AsnStructName)

#define DECLARE_ASN_CHOICE_INFO(AsnChoiceName) \
    DECLARE_ASN_TYPE_INFO(AsnChoiceName)

#endif

#endif  /* SERIALBASE__HPP */
