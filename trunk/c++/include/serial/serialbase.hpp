#ifndef SERIALBASE__HPP
#define SERIALBASE__HPP

/*  $Id$
* ===========================================================================
*
*                            PUBLIC DOMAIN NOTICE
*               National Center for Biotechnology Information
*
*  This software/database is a "United States Government Work" under the
*  terms of the United States Copyright Act.  It was written as part of
*  the author's official duties as a United States Government employee and
*  thus cannot be copyrighted.  This software/database is freely available
*  to the public for use. The National Library of Medicine and the U.S.
*  Government have not placed any restriction on its use or reproduction.
*
*  Although all reasonable efforts have been taken to ensure the accuracy
*  and reliability of the software and data, the NLM and the U.S.
*  Government do not and cannot warrant the performance or results that
*  may be obtained by using this software or data. The NLM and the U.S.
*  Government disclaim all warranties, express or implied, including
*  warranties of performance, merchantability or fitness for any particular
*  purpose.
*
*  Please cite the author in any work or product based on this material.
*
* ===========================================================================
*
* Author: Eugene Vasilchenko
*
* File Description:
*   File to be included in all headers generated by datatool
*
* ---------------------------------------------------------------------------
* $Log$
* Revision 1.3  2000/05/04 16:21:36  vasilche
* Fixed bug in choice reset.
*
* Revision 1.2  2000/04/28 16:58:03  vasilche
* Added classes CByteSource and CByteSourceReader for generic reading.
* Added delayed reading of choice variants.
*
* Revision 1.1  2000/04/03 18:47:09  vasilche
* Added main include file for generated headers.
* serialimpl.hpp is included in generated sources with GetTypeInfo methods
*
* ===========================================================================
*/

#include <corelib/ncbiobj.hpp>
#include <serial/serialdef.hpp>
#include <typeinfo>

BEGIN_NCBI_SCOPE

// forward declaration
class CGeneratedClassInfo;
class CGeneratedChoiceInfo;
class CDelayBufferData;

// these methods are external to avoid inclusion of big headers
void DoSetPostRead(CGeneratedClassInfo* info,
                   void (*func)(void* object));
void DoSetPreWrite(CGeneratedClassInfo* info,
                   void (*func)(const void* object));
void DoSetPostRead(CGeneratedChoiceInfo* info,
                   void (*func)(void* object));
void DoSetPreWrite(CGeneratedChoiceInfo* info,
                   void (*func)(const void* object));

// template collecting all helper methods for generated classes
template<class C>
class CClassInfoHelper
{
public:
    typedef C CClassType;

    static CClassType& Get(void* object)
        {
            return *static_cast<CClassType*>(object);
        }
    static const CClassType& Get(const void* object)
        {
            return *static_cast<const CClassType*>(object);
        }

    static void* Create(void)
        {
            return CClassType::New();
        }
    static const type_info* GetTypeId(const void* object)
        {
            return &typeid(Get(object));
        }
    static void Reset(void* object)
        {
            Get(object).Reset();
        }

    static void PostRead(void* object)
        {
            Get(object).PostRead();
        }
    static void PreWrite(const void* object)
        {
            Get(object).PreWrite();
        }

    static int Which(const void* object)
        {
            return Get(object).Which()-1;
        }
    static void ResetChoice(void* object)
        {
            if ( Which(object) != -1 )
                Reset(object);
        }
    static void Select(void* object, int index)
        {
            typedef typename CClassType::E_Choice E_Choice;
            Get(object).Select(E_Choice(index+1));
        }
    static void SelectDelayBuffer(void* object, int index)
        {
            typedef typename CClassType::E_Choice E_Choice;
            Get(object).SelectDelayBuffer(E_Choice(index+1));
        }

    static void SetPostRead(NCBI_NS_NCBI::CGeneratedClassInfo* info)
        {
            DoSetPostRead(info, &PostRead);
        }
    static void SetPreWrite(NCBI_NS_NCBI::CGeneratedClassInfo* info)
        {
            DoSetPreWrite(info, &PreWrite);
        }
    static void SetPostRead(NCBI_NS_NCBI::CGeneratedChoiceInfo* info)
        {
            DoSetPostRead(info, &PostRead);
        }
    static void SetPreWrite(NCBI_NS_NCBI::CGeneratedChoiceInfo* info)
        {
            DoSetPreWrite(info, &PreWrite);
        }

    static void SetMethods(NCBI_NS_NCBI::CGeneratedClassInfo* info)
        {
            const CClassType* const object = 0;
            NCBISERSetPostRead(info, object);
            NCBISERSetPreWrite(info, object);
        }
    static void SetMethods(NCBI_NS_NCBI::CGeneratedChoiceInfo* info)
        {
            const CClassType* const object = 0;
            NCBISERSetPostRead(info, object);
            NCBISERSetPreWrite(info, object);
        }

    static CGeneratedClassInfo* CreateClassInfo(const char* name)
        {
            CGeneratedClassInfo* info =
                new CGeneratedClassInfo(name,
                                        typeid(CClassType),
                                        sizeof(CClassType),
                                        &Create, &GetTypeId);
            SetMethods(info);
            return info;
        }
    static CGeneratedChoiceInfo* CreateChoiceInfo(const char* name)
        {
            CGeneratedChoiceInfo* info =
                new CGeneratedChoiceInfo(name,
                                         sizeof(CClassType),
                                         &Create, &Which,
                                         &ResetChoice, &Select);
            SetMethods(info);
            return info;
        }
};

template<class CInfo, class C>
inline
void SetPostReadSet(CInfo* info, const C* /*object*/)
{
    NCBI_NS_NCBI::CClassInfoHelper<C>::SetPostRead(info);
}

template<class CInfo, class C>
inline
void SetPreWriteSet(CInfo* info, const C* /*object*/)
{
    NCBI_NS_NCBI::CClassInfoHelper<C>::SetPreWrite(info);
}

END_NCBI_SCOPE

// these methods must be defined in root namespace so they have prefix NCBISER

// default functions do nothing
static inline
void NCBISERSetPostRead(void* /*info*/, const void* /*object*/)
{
}

static inline
void NCBISERSetPreWrite(void* /*info*/, const void* /*object*/)
{
}

// define for declaring specific function
#define NCBISER_HAVE_POST_READ(Class) \
template<class CInfo> \
inline void NCBISERSetPostRead(CInfo* info, const Class* object) \
{ \
    NCBI_NS_NCBI::SetPostReadSet(info, object); \
}

#define NCBISER_HAVE_PRE_WRITE(Class) \
template<class CInfo> \
inline void NCBISERSetPreWrite(CInfo* info, const Class* object) \
{ \
    NCBI_NS_NCBI::SetPreWriteSet(info, object); \
}

#endif  /* SERIALBASE__HPP */
