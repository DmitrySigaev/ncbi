#ifndef CORELIB___PLUGIN_MANAGER__HPP
#define CORELIB___PLUGIN_MANAGER__HPP

/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  Denis Vakatov, Anatoliy Kuznetsov
 *
 * File Description:  Plugin manager (using class factory paradigm)
 *
 */

/// @file plugin_manager.hpp
/// Plugin manager (using class factory paradigm).
///
/// Describe generic interface and provide basic functionality to advertise
/// and export a class factory. 
/// The class and class factory implementation code can be linked to
/// either statically (then, the class factory will need to be registered
/// explicitly by the user code) or dynamically (then, the DLL will be
/// searched for using plugin name, and the well-known DLL entry point
/// will be used to register the class factory, automagically).
/// 
/// - "class factory" -- An entity used to generate objects of the given class.
///                      One class factory can generate more than one version
///                      of the class.
/// 
/// - "interface"  -- Defines the implementation-independent API and expected
///                   behaviour of a class.
///                   Interface's name is provided by its class's factory,
///                   see IClassFactory::GetInterfaceName().
///                   Interfaces are versioned to track the compatibility.
/// 
/// - "driver"  -- A concrete implementation of the interface and its factory.
///                Each driver has its own name (do not confuse it with the
///                interface name!) and version.
/// 
/// - "host"    -- An entity (DLL or the EXEcutable itself) that contains
///                one or more drivers (or versions of the same driver),
///                which can implement one or more interfaces.
/// 
/// - "version" -- MAJOR (backward- and forward-incompatible changes in the
///                       interface and/or its expected behaviour);
///                MINOR (backward compatible changes in the driver code);
///                PATCH_LEVEL (100% compatible plugin or driver code changes).
/// 

#include <corelib/ncbimtx.hpp>
#include <corelib/version.hpp>
#include <corelib/ncbidll.hpp>

#include <set>

/** @addtogroup PluginMgr
 *
 * @{
 */


BEGIN_NCBI_SCOPE


/////////////////////////////////////////////////////////////////////////////
///
/// CPluginManagerException --
///
/// Exception generated by CPluginManager.

class NCBI_XNCBI_EXPORT CPluginManagerException : public CCoreException
{
public:
    /// Error types that CTime can generate.
    enum EErrCode {
        eResolveFailure       ///< Cannot resolve interface driver
    };

    /// Translate from the error code value to its string representation.
    virtual const char* GetErrCodeString(void) const
    {
        switch (GetErrCode()) {
        case eResolveFailure:   return "eResolveFailure";
        default:    return CException::GetErrCodeString();
        }
    }

    // Standard exception boilerplate code.
    NCBI_EXCEPTION_DEFAULT(CPluginManagerException, CCoreException);
};


/// CInterfaceVersion<> --
///
/// Current interface version.
///
/// It is just a boilerplate, to be hard-coded in the concrete interface header
/// @sa NCBI_PLUGIN_VERSION, CVersionInfo

template <class TClass>
class CInterfaceVersion
{
};


/// Macro to auto-setup the current interface name and version.
///
/// This macro must be "called" once per interface, usually in the
/// very header that describes that interface.
///
/// Example:
///    NCBI_INTERFACE_VERSION(IFooBar, "IFooBar", 1, 3, 8);
/// @sa CInterfaceVersion

#define NCBI_DECLARE_INTERFACE_VERSION(iface, iface_name, major, minor, patch_level) \
EMPTY_TEMPLATE \
class CInterfaceVersion<iface> \
{ \
public: \
    enum { \
        eMajor      = major, \
        eMinor      = minor, \
        ePatchLevel = patch_level \
    }; \
    static const char* GetName() { return iface_name; } \
}

/// Macro to contruct CVersionInfo class using interface name
/// (relies on CInterfaceVersion class)
/// @sa CVersionInfo
#define NCBI_INTERFACE_VERSION(iface) CVersionInfo( \
        ncbi::CInterfaceVersion<iface>::eMajor, \
        ncbi::CInterfaceVersion<iface>::eMinor, \
        ncbi::CInterfaceVersion<iface>::ePatchLevel)



/// IClassFactory<> --
///
/// Class factory for the given interface.
///
/// IClassFactory should be implemented for collection of drivers
/// and exported by hosts

template <class TClass>
class IClassFactory
{
public:
    typedef TClass TInterface;

    struct SDriverInfo
    {
        string         name;        ///< Driver name
        CVersionInfo   version;     ///< Driver version

        SDriverInfo(const string&       driver_name,
                    const CVersionInfo& driver_version)
            : name(driver_name),
              version(driver_version)
        {}
    };

    typedef list<SDriverInfo>  TDriverList;


    /// Create driver's instance
    ///
    /// Function creates driver by its name and version.
    /// The requirements is the drivers version should match the interface
    /// up to the patch level.
    ///
    /// @param driver
    ///  Requested driver's name (not the name of the supported interface)
    /// @param version
    ///  Requested interface version (as understood by the caller).
    ///  By default it will be passed the version which is current from
    ///  the calling code's point of view.
    /// @return
    ///  NULL on any error (not found entry point, version mismatch, etc.)
    virtual
    TClass* CreateInstance(const string&  driver  = kEmptyStr,
                           CVersionInfo   version = 
                                          NCBI_INTERFACE_VERSION(TClass))
        const = 0;

    // Versions of the interface exported by the factory
    virtual void GetDriverVersions(TDriverList& driver_list) const = 0;

    virtual ~IClassFactory(void) {}
};



//
class CPluginManager_DllResolver;



/// CPluginManager<> --
///
/// To register (either directly, or via an "entry point") class factories
/// for the given interface.
///
/// Then, to facilitate the process of instantiating the class given
/// the registered pool of drivers, and also taking into accont the driver name
/// and/or version as requested by the calling code.
///
/// Template class is protected by mutex and safe for use from diffrent threads

template <class TClass>
class CPluginManager
{
public:
    typedef IClassFactory<TClass> TClassFactory;

    /// Create class instance
    /// @return
    ///  Never returns NULL -- always throw exception on error.
    /// @sa GetFactory()
    TClass* CreateInstance(const string&       driver  = kEmptyStr,
                           const CVersionInfo& version = 
                                   NCBI_INTERFACE_VERSION(TClass))
    {
        TClassFactory* factory = GetFactory(driver, version);
        return factory->CreateInstance(driver, version);
    }


    /// Get class factory
    ///
    /// If more than one (of registered) class factory contain eligible
    /// driver candidates, then pick the class factory containing driver of
    /// the latest version.
    /// @param driver
    ///  Name of the driver. If passed empty, then -- any.
    /// @param version
    ///  Requested version. The returned driver can have a different (newer)
    ///  version (provided that the new implementation is backward-compatible
    ///  with the requested version.
    /// @return
    ///  Never return NULL -- always throw exception on error.
    TClassFactory* GetFactory(const string&       driver  = kEmptyStr,
                              const CVersionInfo& version = 
                                              NCBI_INTERFACE_VERSION(TClass));

    /// Information about a driver, with maybe a pointer to an instantiated
    /// class factory that contains the driver.
    /// @sa FNCBI_EntryPoint
    struct SDriverInfo {
        string         name;        //!< Driver name
        CVersionInfo   version;     //!< Driver version
        // It's the plugin manager's (and not SDriverInfo) responsibility to
        // keep and then destroy class factories.
        TClassFactory* factory;     //!< Class factory (can be NULL)

        SDriverInfo(const string&       driver_name,
                    const CVersionInfo& driver_version)
            : name(driver_name),
              version(driver_version),
              factory(0)
        {}
    };

    /// List of driver information.
    ///
    /// It is used to communicate using the entry points mechanism.
    /// @sa FNCBI_EntryPoint
    typedef list<SDriverInfo> TDriverInfoList;

    /// Register factory in the manager.
    ///  
    /// The registered factory will be owned by the manager.
    /// @sa UnregisterFactory()
    void RegisterFactory(TClassFactory& factory);

    /// Unregister and release (un-own)
    /// @sa RegisterFactory()
    bool UnregisterFactory(TClassFactory& factory);

    /// Actions performed by the entry point
    /// @sa FNCBI_EntryPoint
    enum EEntryPointRequest {
        /// Add info about all drivers exported through the entry point
        /// to the end of list.
        ///
        /// "SFactoryInfo::factory" in the added info should be assigned NULL.
        eGetFactoryInfo,

        /// Scan the driver info list passed to the entry point for the
        /// [name,version] pairs exported by the given entry point.
        ///
        /// For each pair found, if its "SDriverInfo::factory" is NULL,
        /// instantiate its class factory and assign it to the
        /// "SDriverInfo::factory".
        eInstantiateFactory
    };

    /// Entry point to get drivers' info, and (if requested) their class
    /// factori(es).
    ///
    /// This function is usually (but not necessarily) called by
    /// RegisterWithEntryPoint().
    ///
    /// Usually, it's called twice -- the first time to get the info
    /// about the drivers exported by the entry point, and then
    /// to instantiate selected factories.
    ///
    /// Caller is responsible for the proper destruction (deallocation)
    /// of the instantiated factories.
    typedef void (*FNCBI_EntryPoint)(TDriverInfoList&   info_list,
                                     EEntryPointRequest method);

    /// Register all factories exported by the plugin entry point.
    /// @sa RegisterFactory()
    void RegisterWithEntryPoint(FNCBI_EntryPoint plugin_entry_point);

    /// Attach DLL resolver to plugin manager 
    /// 
    /// Plugin mananger uses all attached resolvers to search for DLLs
    /// exporting drivers of this interface.
    ///
    /// @param resolver
    ///   DLL resolver. Plugin manager takes ownership of the resolver.
    void AddResolver(CPluginManager_DllResolver* resolver);

    /// 
    void AddDllSearchPath(const string& path);

    /// Scan DLLs for specified driver using attached resolvers
    void Resolve(const string&       driver,
                 const CVersionInfo& version);

    // ctors
    CPluginManager(void) {}
    virtual ~CPluginManager();

protected:
    /// Protective mutex to syncronize the access to the plugin manager
    /// from different threads
    CFastMutex m_Mutex;

    typedef vector<CDllResolver::SResolvedEntry> TResolvedEntries;

private:
    /// List of factories presently registered with (and owned by)
    /// the plugin manager.
    set<TClassFactory*>                  m_Factories;
    /// DLL resolvers
    vector<CPluginManager_DllResolver*>  m_Resolvers;
    /// Paths used for DLL search
    vector<string>                       m_DllSearchPaths;
    /// DLL entries resolved and registered with dll resolver(s)
    TResolvedEntries                     m_RegisteredEntries;
};


template <class TClass>
CPluginManager<TClass>::TClassFactory* 
CPluginManager<TClass>::GetFactory(const string&       driver,
                                   const CVersionInfo& version)
{
    CFastMutexGuard guard(m_Mutex);

    typename 
        set<TClassFactory*>::const_iterator it = FindVersion(m_Factories, version);
    if (it != m_Factories.end()) {
        return *it1;
    }

    // Trying to resolve the driver
    Resolve(driver, version);

    // Re-scanning factories...
    it = FindVersion(m_Factories, version);
    if (it != m_Factories.end()) {
        return *it1;
    }


    NCBI_THROW(CPluginManagerException, eResolveFailure, 
               "Cannot resolve class factory");

    return 0;
}



template <class TClass>
void CPluginManager<TClass>::RegisterFactory(TClassFactory& factory)
{
    CFastMutexGuard guard(m_Mutex);

    m_Factories->insert(&factory);
}

template <class TClass>
bool CPluginManager<TClass>::UnregisterFactory(TClassFactory& factory)
{
    CFastMutexGuard guard(m_Mutex);

    typename set<TClassFactory*>::iterator it = m_Factories.find(&factory);
    if (it != m_Factories.end()) {
        TClassFactory* f = *it;
        m_Factories.erase(it);
        delete f;
    }
}


template <class TClass>
void CPluginManager<TClass>::RegisterWithEntryPoint(FNCBI_EntryPoint plugin_entry_point)
{
    TDriverInfoList drv_list;
    plugin_entry_point(&drv_list, eGetFactoryInfo);

    if (!drv_list.empty()) {
        plugin_entry_point(&drv_list, eInstantiateFactory);

        typename TDriverInfoList::iterator it = drv_list.begin();
        typename TDriverInfoList::iterator it_end = drv_list.end();
        for (; it != it_end; ++it) {
            if (it->factory) {
                RegisterFactory(*(it->factory));
            }
        }
    }
}


template <class TClass>
void CPluginManager<TClass>::AddResolver(CPluginManager_DllResolver* resolver)
{
    _ASSERT(resolver);
    m_Resolvers.push_back(resolver);
}


template <class TClass>
void CPluginManager<TClass>::AddDllSearchPath(const string& path)
{
    m_DllSearchPaths.push_back(path);
}


template <class TClass>
void CPluginManager<TClass>::Resolve(const string&       driver,
                                     const CVersionInfo& version)
{
    vector<CDllResolver*> resolvers;
    // run all resolvers to search for driver
    ITERATE(vector<CPluginManager_DllResolver*>, it, m_Resolvers) {
        CDllResolver& dll_resolver = it->Resolve(m_DllSearchPaths);
        resolvers.push_back(&dll_resover);
    }
    // Now choose the DLL entry point to register the class factory

    NON_CONST_ITERATE(CDllResolver*>, it, resolvers) {
        CDllResolver::TEntries& entry_points = it->GetResolvedEntries();

        NON_CONST_ITERATE(CDllResolver::TEntries, ite, entry_points) {
            CDllResolver::SResolvedEntry& entry = *ite;
            // TODO:
            // check if entry point provides the required interface-driver-version
            // and do not register otherwise...
            if (entry.entry_point) {
                FNCBI_EntryPoint ep = (FNCBI_EntryPoint) entry.entry_point;
                RegisterWithEntryPoint(ep);
                m_RegisteredEntries.push_back(entry);
            }
        }
        entry_points.resize(0);
    }
}


template <class TClass>
CPluginManager<TClass>::~CPluginManager()
{
    {{
        typename set<TClassFactory*>::iterator it = m_Factories.begin();
        typename set<TClassFactory*>::iterator it_end = m_Factories.end();
        for (; it != it_end; ++it) {
            TClassFactory* f = *it;
            delete f;
        }

    }}

    {{
        typename vector<CPluginManager_DllResolver*>::iterator it =
            m_Resolvers.begin();
        typename vector<CPluginManager_DllResolver*>::iterator it_end = 
            m_Resolvers.end();
        for (; it != it_end; ++it) {
            CPluginManager_DllResolver* r = *it;
            delete r;
        }

    }}

    NON_CONST_ITERATE(TResolvedEntries, it, m_RegisteredEntries) {
        delete it->dll;
    }
}


/// Template implements entry point
///
/// The actual entry point is a C callable exported function 
///   delegates the functionality to 
///               CHostEntryPointImpl<>::NCBI_EntryPointImpl()

template<class TClassFactory> struct CHostEntryPointImpl
{
    typedef typename TClassFactory::TInterface                TInterface;
    typedef CPluginManager<TInterface>                        TPluginManager;
    typedef typename CPluginManager<TInterface>::SDriverInfo  TDriverInfo;
    
    typedef typename 
    CPluginManager<TInterface>::TDriverInfoList             TDriverInfoList;
    typedef typename 
    CPluginManager<TInterface>::EEntryPointRequest        EEntryPointRequest;
    typedef typename TClassFactory::SDriverInfo             TCFDriverInfo;
    

    /// Entry point implementation. 
    ///
    /// @sa CPluginManager::FNCBI_EntryPoint
    static void NCBI_EntryPointImpl(TDriverInfoList& info_list,
                                    EEntryPointRequest method)
    {
        TClassFactory cf;
        list<TCFDriverInfo> cf_info_list;
        cf.GetDriverVersions(cf_info_list);

        switch (method)
            { 
            case TPluginManager::eGetFactoryInfo:
                {
                    typename list<TCFDriverInfo>::const_iterator it =
                        cf_info_list.begin();
                    typename list<TCFDriverInfo>::const_iterator it_end =
                        cf_info_list.end();
                    for (; it != it_end; ++it) {
                        info_list.push_back(TDriverInfo(it->name, it->version));
                    }

                }
            break;
            case TPluginManager::eInstantiateFactory:
                {
                    typename TDriverInfoList::iterator it1 = info_list.begin();
                    typename TDriverInfoList::iterator it1_end = info_list.end();
                    for(; it1 != it1_end; ++it1) {
                        if (it1->factory) {    // already instantiated
                            continue;
                        }
                        typename list<TCFDriverInfo>::iterator it2 = 
                            cf_info_list.begin();
                        typename list<TCFDriverInfo>::iterator it2_end = 
                            cf_info_list.end();
                        for (; it2 != it2_end; ++it2) {
                            if (it1->name == it2->name) {
                                if (it1->version.Match(it2->version) != 
                                    CVersionInfo::eNonCompatible)
                                    {
                                        TClassFactory* cg = new TClassFactory();
                                        IClassFactory<TInterface>* icf = cg;
                                        it1->factory = icf;
                                    }
                            }
                        } // for

                    } // for

                }
            break;
            default:
                _ASSERT(0);
            } // switch
    }

};


/// Template class helps to implement one driver class factory.
///
/// Class supports one driver, one version class factory 
/// (the very basic one)
/// Template parameters are:
///   TIClass - interface class 
///   TDriver - driver class

template <class TIClass, class TDriver>
class CSimpleClassFactoryImpl : public IClassFactory<TIClass>
{
public:

    typedef IClassFactory<TIClass>         TParent;
    typedef typename TParent::SDriverInfo  TDriverInfo;
    typedef typename TParent::TDriverList  TDriverList;

    /// Construction
    ///
    /// @param driver_name
    ///   Driver name string
    /// @param patch_level
    ///   Patch level implemented by the driver. 
    ///   By default corresponds to interface patch level.
    CSimpleClassFactoryImpl(const string& driver_name, int patch_level = -1) 
        : m_DriverVersionInfo()
        (ncbi::CInterfaceVersion<TIClass>::eMajor, 
         ncbi::CInterfaceVersion<TIClass>::eMinor, 
         patch_level >= 0 ?
         patch_level : ncbi::CInterfaceVersion<TIClass>::ePatchLevel),
      m_DriverName(driver_name)
    {
        _ASSERT(!m_DriverName.empty());
    }

    TIClass* CreateInstance
    (const string&  driver  = kEmptyStr,
     CVersionInfo version = 
     CVersionInfo(ncbi::CInterfaceVersion<TIClass>::eMajor,
                  ncbi::CInterfaceVersion<TIClass>::eMinor,
                  ncbi::CInterfaceVersion<TIClass>::ePatchLevel))
        const

    {
        if (driver.empty() || driver == m_DriverName) {
            CVersionInfo v(ncbi::CInterfaceVersion<TIClass>::eMajor,
                           ncbi::CInterfaceVersion<TIClass>::eMinor,
                           ncbi::CInterfaceVersion<TIClass>::ePatchLevel);

            if (version.Match(v) == CVersionInfo::eNonCompatible) {
                return 0;
            }
            return new TDriver();
        }
        return 0;
    }

    void GetDriverVersions(TDriverList& info_list) const
    {
        info_list.push_back(TDriverInfo(m_DriverName, m_DriverVersionInfo));
    }

protected:
    CVersionInfo  m_DriverVersionInfo;
    string        m_DriverName;
};



/// Service class for DLLs resolution.
/// 
/// Class is used by CPluginManager to scan directories for DLLs, 
/// load and resolve entry points.
///
class NCBI_XNCBI_EXPORT CPluginManager_DllResolver
{
public:
    //
    CPluginManager_DllResolver(void);

    /// Construction
    ///
    /// @param interface_name
    ///   Target interface name
    /// @param plugin_name
    ///   Plugin family name (dbapi, xloader, etc)
    /// @param driver_name
    ///   Name of the driver (dblib, id1, etc)
    /// @param version
    ///   Interface version
    CPluginManager_DllResolver
    (const string&       interface_name,
     const string&       driver_name,
     const CVersionInfo& version = CVersionInfo::kAny);

    //
    virtual ~CPluginManager_DllResolver(void);

    /// Search for plugin DLLs, resolve entry points.
    ///
    /// @param paths
    ///    List of directories to scan for DLLs
    /// @return
    ///   Reference on DLL resolver holding all entry points
    CDllResolver& Resolve(const vector<string>& paths);

    /// Search for plugin DLLs, resolve entry points.
    ///
    /// @param paths
    ///    Path to scan for DLLs
    /// @return Reference on DLL resolver holding all entry points
    CDllResolver& Resolve(const string& path);


    /// Return dll file name. Name does not include path.
    ///
    /// Example:
    ///    "ncbi_plugin_dbapi_ftds_3_1_7".
    ///    "ncbi_pulgin_dbapi_ftds.so.3.1.7"
    /// In this case, the DLL will be searched for in the standard
    /// DLL search paths, with automatic addition of any platform-specific
    /// prefixes and suffixes.
    ///
    /// @param driver_name
    ///    driver name ( "id1", "lds", etc)
    /// @param version
    ///    version of the driver
    virtual
    string GetDllName(const string&       interface_name,
                      const string&       driver_name  = kEmptyStr,
                      const CVersionInfo& version      = CVersionInfo::kAny)
        const;

    /// Return DLL name mask 
    ///
    /// DLL name mask is used for DLL file search.
    ///
    /// Example:
    ///    "ncbi_plugin_objmgr_*.dll"
    ///    "ncbi_plugin_dbapi_ftds.so.*"
    /// 
    virtual
    string GetDllNameMask(const string&       interface_name,
                          const string&       driver_name = kEmptyStr,
                          const CVersionInfo& version     = CVersionInfo::kAny)
        const;

    /// Return DLL entry point name:
    ///
    /// Default name pattern is:
    ///  - "NCBI_EntryPoint_interface_driver"
    /// Alternative variants:
    ///  - "NCBI_EntryPoint"
    ///  - "NCBI_EntryPoint_interface"
    ///  - "NCBI_EntryPoint_driver"
    ///
    /// @sa GetEntryPointPrefix
    virtual
    string GetEntryPointName(const string& interface_name = kEmptyStr,
                             const string& driver_name    = kEmptyStr) const;


    /// Return DLL entry point prefix ("NCBI_EntryPoint")
    virtual string GetEntryPointPrefix() const;

    /// Return DLL file name prefix ("ncbi_plugin")
    virtual string GetDllNamePrefix() const;

    /// Set DLL file name prefix
    virtual void SetDllNamePrefix(const string& prefix);

    /// Return name of the driver
    const string& GetDriverName() const 
    {
        return m_DriverName;
    }


protected:

    CDllResolver* GetCreateDllResolver();
    CDllResolver* CreateDllResolver() const;


protected:
    string          m_DllNamePrefix;
    string          m_EntryPointPrefix;
    string          m_InterfaceName;
    string          m_DriverName;
    CVersionInfo    m_Version;
    CDllResolver*   m_DllResolver;
};



END_NCBI_SCOPE


/* @} */


/*
 * ===========================================================================
 * $Log$
 * Revision 1.12  2003/11/17 17:04:11  kuznets
 * Cosmetic fixes
 *
 * Revision 1.11  2003/11/12 18:56:53  kuznets
 * Implemented dll resolution.
 *
 * Revision 1.10  2003/11/07 17:02:48  kuznets
 * Drafted CPluginManager_DllResolver.
 *
 * Revision 1.9  2003/11/03 20:08:01  kuznets
 * Fixing various compiler warnings
 *
 * Revision 1.8  2003/11/03 17:52:00  kuznets
 * Added CSimpleClassFactoryImpl template.
 * Helps quickly implement basic PM compatible class factory.
 *
 * Revision 1.7  2003/11/03 16:32:58  kuznets
 * Cleaning the code to be compatible with GCC, WorkShop 53 and MSVC at the
 * same time...
 *
 * Revision 1.6  2003/10/31 19:53:52  kuznets
 * +CHostEntryPointImpl
 *
 * Revision 1.5  2003/10/30 20:03:49  kuznets
 * Work in progress. Added implementations of CPluginManager<> methods.
 *
 * Revision 1.4  2003/10/29 23:35:46  vakatov
 * Just starting with CDllResolver...
 *
 * Revision 1.3  2003/10/29 19:34:43  vakatov
 * Comment out unfinished defined APIs (using "#if 0")
 *
 * Revision 1.2  2003/10/28 22:29:04  vakatov
 * Draft-done with:
 *   general terminology
 *   CInterfaceVersion<>
 *   NCBI_PLUGIN_VERSION()
 *   IClassFactory<>
 *   CPluginManager<>
 * TODO:
 *   Host-related API
 *   DLL resolution
 *
 * Revision 1.1  2003/10/28 00:12:23  vakatov
 * Initial revision
 *
 * Work-in-progress, totally unfinished.
 * Note: DLL resolution shall be split and partially moved to the NCBIDLL.
 *
 * ===========================================================================
 */

#endif  /* CORELIB___PLUGIN_MANAGER__HPP */
