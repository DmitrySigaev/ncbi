#ifndef CORELIB__NCBIFILE__HPP
#define CORELIB__NCBIFILE__HPP

/*  $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author: Vladimir Ivanov, Denis Vakatov
 *
 * File Description:  Files and directories accessory functions
 *
 */

#include <corelib/ncbistd.hpp>
#include <corelib/ncbitime.hpp>
#include <vector>


#ifdef NCBI_OS_MAC
struct FSSpec;
#endif


/** @addtogroup Files
 *
 * @{
 */


BEGIN_NCBI_SCOPE



/////////////////////////////////////////////////////////////////////////////
// CFileException - exceptions generated by files


class NCBI_XNCBI_EXPORT CFileException : public CCoreException
{
public:
    enum EErrCode {
        eMemoryMap
    };
    virtual const char* GetErrCodeString(void) const
    {
        switch (GetErrCode()) {
        case eMemoryMap:  return "eMemoryMap";
        default:    return CException::GetErrCodeString();
        }
    }
    NCBI_EXCEPTION_DEFAULT(CFileException,CCoreException);
};


//////////////////////////////////////////////////////////////////////////////
//
// Base class to work with files and directories
//
// We assume that the path argument has the following form, where any or all
// components may be missing.
//
// <dir><title><ext>
//
// dir   - file path             ("/usr/local/bin/"  or  "c:\windows\")
// title - file name without ext ("autoexec")
// ext   - file extension        (".bat" -- whatever goes after the last dot)
//
// Supported filename formats:  DOS, UNIX and MAC.
//

class NCBI_XNCBI_EXPORT CDirEntry
{
public:
    CDirEntry();
#ifdef NCBI_OS_MAC
    CDirEntry(const CDirEntry& other);
    CDirEntry& operator= (const CDirEntry& other);
    CDirEntry(const FSSpec& fss);
#endif
    CDirEntry(const string& path);
    void Reset(const string& path);
    virtual ~CDirEntry(void);

	bool operator== (const CDirEntry& other) const;
#ifdef NCBI_OS_MAC
	const FSSpec& FSS() const;
#endif
    // Get entry path
    string GetPath(void) const;


    //
    // Path processing
    //

    // Break a path into components.
    // "dir" will always have terminating path separator (e.g. "/usr/local/").
    // "ext" will always start from dot (e.g. ".bat").
    static void SplitPath(const string& path,
                          string* dir = 0, string* base = 0, string* ext = 0);
    string GetDir (void) const;  // directory this entry belongs to
    string GetName(void) const;  // base entry name (with extension)
    string GetBase(void) const;  // base entry name without extension
    string GetExt (void) const;  // entry name extension

    // Create a path from components
    static string MakePath(const string& dir  = kEmptyStr,
                           const string& base = kEmptyStr,
                           const string& ext  = kEmptyStr);

    // Get path separator symbol specific for the platform
    static char GetPathSeparator(void);

    // Check character "c" at path separator symbol specific for the platform
    static bool IsPathSeparator(const char c);

    // Add a trailing path separator (if needed)
    static string AddTrailingPathSeparator(const string& path);

    // Convert relative "path" (any OS) to current OS dependent relative path 
    static string ConvertToOSPath(const string& path);

    // Detect if the "path" is absolute.
    //  1) "path" must be for current OS 
    static bool IsAbsolutePath(const string& path);
    //  2) "path" can be for any OS (MSWIN, UNIX, MAC )
    static bool IsAbsolutePathEx(const string& path);

    // Concatenate 2 parts of the path. "first" path can be either absolute or
    // relative;  "second" must always be relative.
    //  1) "first" and "second" must be paths for the current OS
    static string ConcatPath(const string& first, const string& second);
    //  2) "first" and "second" can be paths for any OS (MSWIN, UNIX, MAC)
    static string ConcatPathEx(const string& first, const string& second);


    //
    // Checks & manipulations
    //

    // Match "name" against the filename "mask"
    static bool MatchesMask(const char *name, const char *mask);

    // Check existence of entry "path"
    virtual bool Exists(void) const;

    // Rename entry
    bool Rename(const string& new_path);

    // Directory remove mode
    enum EDirRemoveMode {
        eOnlyEmpty,     // Remove only empty directory
        eNonRecursive,  // Remove all files in directory, but not remove
                        // subdirectories and files in it.
        eRecursive      // Remove all files and subdirectories
    };

    // Remove entry
    // NOTE: "mode" appoint removing method only for directories
    virtual bool Remove(EDirRemoveMode mode = eRecursive) const;
    
    // See also GetType() below for other entry types
    bool IsFile(void) const;
    bool IsDir(void) const;

    // Get type of entry
    enum EType {
        eFile = 0,     // Regular file
        eDir,          // Directory
        ePipe,         // Pipe
        eLink,         // Symbolic link     (UNIX only)
        eSocket,       // Socket            (UNIX only)
        eDoor,         // Door              (UNIX only)
        eBlockSpecial, // Block special     (UNIX only)
        eCharSpecial,  // Character special
        //
        eUnknown       // Unknown type
    };
    // NOTE: On error (e.g. if the entry does not exist), return "eUnknown".
    EType GetType(void) const;

    // Get time of entry. Returns TRUE if time was acquired or FALSE otherwise.
    // NOTE: "creation" time under MS windows is actual creation time of the
    //       entry. Under UNIX "creation" time is a time of last entry status
    //       change.
    bool GetTime(CTime *modification, CTime *creation = 0, 
                 CTime *last_access = 0) const;

    //
    // Access permissions
    //

    // Entry's access permissions
    enum EMode {
        fExecute = 1,
        fWrite   = 2,
        fRead    = 4,
        // initial defaults for dirs
        fDefaultDirUser  = fRead | fExecute | fWrite,
        fDefaultDirGroup = fRead | fExecute,
        fDefaultDirOther = fRead | fExecute,
        // initial defaults for non-dir entries (files, etc.)
        fDefaultUser     = fRead | fWrite,
        fDefaultGroup    = fRead,
        fDefaultOther    = fRead,
        // special flag:  ignore all other flags, use current default mode
        fDefault = 8
    };
    typedef unsigned int TMode;

    // Get this (existing) entry's mode (permissions).
    // NOTE: On WINDOWS, there is only "user_mode". "group_" and "other_"
    // modes will be ignored.
    bool GetMode(TMode* user_mode,
                 TMode* group_mode = 0,
                 TMode* other_mode = 0) const;

    // Set mode for this (existing) entry.
    // "fDefault" will set the mode as specified in the SetDefaultMode(),
    // or (if SetDefaultMode() was not called for this object or was
    // called with "fDefault") as specified in the SetDefaultModeGlobal(), or
    // else as specific for this class of entry (e.g. "fDefaultDir*" for dirs).
    bool SetMode(TMode user_mode,  // e.g. fDefault
                 TMode group_mode = fDefault,
                 TMode other_mode = fDefault) const;

    // Set default mode for all CDirEntry objects (except for those having
    // their own mode set with SetDefaultMode()).
    static void SetDefaultModeGlobal(EType entry_type,
                                     TMode user_mode,  // e.g. fDefault
                                     TMode group_mode = fDefault,
                                     TMode other_mode = fDefault);

    // Set mode for this one object only.
    // By default ("fDefault), mode will be set to the current global mode
    // (specified by SetDefaultModeGlobal()).
    virtual void SetDefaultMode(EType entry_type,
                                TMode user_mode,  // e.g. fDefault
                                TMode group_mode = fDefault,
                                TMode other_mode = fDefault);

protected:
    static void GetDefaultModeGlobal(EType  entry_type,
                                     TMode* user_mode,
                                     TMode* group_mode,
                                     TMode* other_mode);
    void GetDefaultMode(TMode* user_mode,
                        TMode* group_mode,
                        TMode* other_mode) const;

private:
#ifdef NCBI_OS_MAC
    FSSpec* m_FSS;
#else
    // Full entry path
    string m_Path;
#endif

    // Global and local current default mode (NOTE: no "fDefault" here!)
    enum EWho {
        eUser = 0,
        eGroup,
        eOther
    };
    static TMode m_DefaultModeGlobal[eUnknown][3/*EWho*/];
    TMode        m_DefaultMode[3/*EWho*/];
};



//////////////////////////////////////////////////////////////////////////////
//
// Class for support work with files
//
// NOTE: Next functions are unsafe in multithreaded applications:
//       - GetTmpName() (use GetTmpNameExt() -- it is safe);
//       - CreateTmpFile() with empty first parameter
//         (use CreateTmpFileExt() -- it is safe);
//

class NCBI_XNCBI_EXPORT CFile : public CDirEntry
{
    typedef CDirEntry CParent;
public:
    CFile(const string& file);
    virtual ~CFile(void);

    // Check existence for file "filename"
    virtual bool Exists(void) const;

    // Get size of file. Return "-1" if was error obtaining size.
    Int8 GetLength(void) const;

    // Get temporary file name
    // NOTE:
    //   - return "kEmptyStr" if was error get temporary file name
    //   - the "prefix" may be don't specified or it must be up to five
    //     characters length
    static string GetTmpName(void);
    static string GetTmpNameExt(const string& dir,
                                const string& prefix = kEmptyStr);


    // Create a temporary file, return pointer to corresponding stream.
    // On error, NULL will be returned.
    // NOTE: The temporary file will be automatically deleted after
    //       delete streem object.
    //       If file exists before call function, then after call it will
    //       be removed also.
    enum ETextBinary {
        eText,
        eBinary
    };
    enum EAllowRead {
        eAllowRead,
        eWriteOnly
    };
    static fstream* CreateTmpFile(const string& filename = kEmptyStr,
                                  ETextBinary text_binary = eBinary,
                                  EAllowRead  allow_read  = eAllowRead);
    static fstream* CreateTmpFileEx(const string& dir = ".",
                                    const string& prefix = kEmptyStr,
                                    ETextBinary text_binary = eBinary,
                                    EAllowRead  allow_read  = eAllowRead);
};



//////////////////////////////////////////////////////////////////////////////
//
// Class for support work with directories
//
//
// NOTE: Next functions are unsafe in multithreaded applications:
//       - static bool Exists() (for Mac only);
//       - bool Exists() (for Mac only);
//       - iterators (also is unsafe in single threaded applications if
//         one iterator use inside another);

class NCBI_XNCBI_EXPORT CDir : public CDirEntry
{
    typedef CDirEntry CParent;
public:
    CDir();
#ifdef NCBI_OS_MAC
    CDir(const FSSpec& fss);
#endif
    CDir(const string& dirname);
    virtual ~CDir(void);

    // Check if directory "dirname" exists
    virtual bool Exists(void) const;

    // Get user "home" dir
    static string GetHome(void);

    // Get the current working directory
    static string GetCwd();

    // Return an array containing all directory entries.
    // Use file name mask "mask" (if passed non-empty).
    typedef vector< AutoPtr<CDirEntry> > TEntries;
    TEntries GetEntries(const string& mask = kEmptyStr) const;

    // Create the directory using "dirname" passed in the constructor
    bool Create(void) const;
    // Create the directory recursively (possibly more than one at a time)
    bool CreatePath(void) const;

    // Delete existing directory
    virtual bool Remove(EDirRemoveMode mode = eRecursive) const;
};






//////////////////////////////////////////////////////////////////////////////
//
// Class for support file memory mapping
//
//

// fwd-decl of struct containing OS-specific mem.-file handle
struct SMemoryFileHandle;


class NCBI_XNCBI_EXPORT CMemoryFile
{
public:
    // Protect attributes
    typedef enum {
        eMMP_Read,	      // Data can be read
        eMMP_Write,	      // Data can be written
        eMMP_ReadWrite    // Data can be read and written
    } EMemMapProtect;

    // Share attributes
    typedef enum {
        eMMS_Shared,	  // Changes are shared
        eMMS_Private	  // Changes are private
    } EMemMapShare;

    // Initialize the memory mapping on file "file_name".
    // Throws an exception on error.
    CMemoryFile(const string& file_name,
                EMemMapProtect protect_attr = eMMP_Read,
                EMemMapShare   share_attr   = eMMS_Private);

    // Call Unmap();  do other cleanup...
    ~CMemoryFile(void);

    // Is memory-mapping supported (by the C++ Toolkit) on this platform
    static bool IsSupported(void);

    // Get pointer to beginning of data.
    // Return NULL if mapped to a file of zero length, or if unmapped already.
    void* GetPtr(void) const;

    // Get size (in bytes) of the mapped area.
    // Return "-1" if unmapped already.
    Int8 GetSize(void) const;

    // Write all modified copies of memory pages to the underlying file.
    // By default data will be flushed in Unmap() or destructor.
    bool Flush(void) const;

    // Unmap file (if mapped).
    // Return FALSE on error.
    bool Unmap(void);

    // Advises the VM system that the a certain region of user mapped memory 
    // will be accessed following a type of pattern. The VM system uses this 
    // information to optimize work wih mapped memory.
    // NOTE: Now work on UNIX platform only.
    typedef enum {
        eMMA_Normal,	  // No further special threatment
        eMMA_Random,	  // Expect random page references
        eMMA_Sequential,  // Expect sequential page references
        eMMA_WillNeed,	  // Will need these pages
        eMMA_DontNeed	  // Don't need these pages
    } EMemMapAdvise;

    bool MemMapAdvise(EMemMapAdvise advise);
    static bool MemMapAdviseAddr(void* addr, size_t len, EMemMapAdvise advise);

private:
    // Map file to memory
    void x_Map(const string& file_name,
               EMemMapProtect protect_attr,
               EMemMapShare   share_attr);

private:
    SMemoryFileHandle*  m_Handle;   // Memory file handle
    Int8                m_Size;     // Size (in bytes) of the mapped area
    void*               m_DataPtr;  // Pointer to the begining of mapped data
};


/* @} */


//////////////////////////////////////////////////////////////////////////////
//
// Inline
//


// CDirEntry

#ifndef NCBI_OS_MAC
inline
void CDirEntry::Reset(const string& path)
{
    m_Path = path;
}

inline
string CDirEntry::GetPath(void) const
{
    return m_Path;
}
#endif

inline
string CDirEntry::GetDir(void) const
{
    string dir;
    SplitPath(GetPath(), &dir);
    return dir;
}

inline
string CDirEntry::GetName(void) const
{
    string title, ext;
    SplitPath(GetPath(), 0, &title, &ext);
    return title + ext;
}

inline
string CDirEntry::GetBase(void) const
{
    string base;
    SplitPath(GetPath(), 0, &base);
    return base;
}

inline
string CDirEntry::GetExt(void) const
{
    string ext;
    SplitPath(GetPath(), 0, 0, &ext);
    return ext;
}

inline
bool CDirEntry::IsFile(void) const
{
    return GetType() == eFile;
}

inline
bool CDirEntry::IsDir(void) const
{
    return GetType() == eDir;
}

inline
bool CDirEntry::Exists(void) const
{
    return GetType() != eUnknown;
}


// CFile

inline
bool CFile::Exists(void) const
{
    return GetType() == eFile;
}


// CDir

inline
bool CDir::Exists(void) const
{
    return GetType() == eDir;
}


// CMemoryFile

inline
void* CMemoryFile::GetPtr(void) const
{
    return m_DataPtr;
}

inline
Int8 CMemoryFile::GetSize(void) const
{
    return m_Size;
}


END_NCBI_SCOPE


/*
 * ===========================================================================
 * $Log$
 * Revision 1.21  2003/05/29 17:21:31  gouriano
 * added CreatePath() which creates directories recursively
 *
 * Revision 1.20  2003/03/31 16:54:25  siyan
 * Added doxygen support
 *
 * Revision 1.19  2003/02/05 22:07:32  ivanov
 * Added protect and sharing parameters to the CMemoryFile constructor.
 * Added CMemoryFile::Flush() method.
 *
 * Revision 1.18  2003/01/16 13:03:47  dicuccio
 * Added CDir::GetCwd()
 *
 * Revision 1.17  2002/12/18 22:53:21  dicuccio
 * Added export specifier for building DLLs in windows.  Added global list of
 * all such specifiers in mswin_exports.hpp, included through ncbistl.hpp
 *
 * Revision 1.16  2002/07/15 18:17:51  gouriano
 * renamed CNcbiException and its descendents
 *
 * Revision 1.15  2002/07/11 19:21:58  ivanov
 * Added CMemoryFile::MemMapAdvise[Addr]()
 *
 * Revision 1.14  2002/07/11 14:17:54  gouriano
 * exceptions replaced by CNcbiException-type ones
 *
 * Revision 1.13  2002/06/07 16:11:09  ivanov
 * Chenget GetTime() -- using CTime instead time_t, modification time by default
 *
 * Revision 1.12  2002/06/07 15:20:41  ivanov
 * Added CDirEntry::GetTime()
 *
 * Revision 1.11  2002/04/11 20:39:18  ivanov
 * CVS log moved to end of the file
 *
 * Revision 1.10  2002/04/01 18:49:07  ivanov
 * Added class CMemoryFile
 *
 * Revision 1.9  2002/01/24 22:17:40  ivanov
 * Changed CDirEntry::Remove() and CDir::Remove()
 *
 * Revision 1.8  2002/01/10 16:46:09  ivanov
 * Added CDir::GetHome() and some CDirEntry:: path processing functions
 *
 * Revision 1.7  2001/12/26 20:58:23  juran
 * Use an FSSpec* member instead of an FSSpec, so a forward declaration can 
 * be used.
 * Add copy constructor and assignment operator for CDirEntry on Mac OS,
 * thus avoiding memberwise copy which would blow up upon deleting the 
 * pointer twice.
 *
 * Revision 1.6  2001/12/13 20:14:34  juran
 * Add forward declaration of struct FSSpec for Mac OS.
 *
 * Revision 1.5  2001/11/19 18:07:38  juran
 * Change Contents() to GetEntries().
 * Implement MatchesMask().
 *
 * Revision 1.4  2001/11/15 16:30:46  ivanov
 * Moved from util to corelib
 *
 * Revision 1.3  2001/11/01 21:02:18  ucko
 * Fix to work on non-MacOS platforms again.
 *
 * Revision 1.2  2001/11/01 20:06:49  juran
 * Replace directory streams with Contents() method.
 * Implement and test Mac OS platform.
 *
 * Revision 1.1  2001/09/19 13:04:18  ivanov
 * Initial revision
 * ===========================================================================
 */

#endif  /* CORELIB__NCBIFILE__HPP */
