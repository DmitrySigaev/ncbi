#ifndef CORELIB__NCBIPIPE__HPP
#define CORELIB__NCBIPIPE__HPP

/*  $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Author:  Vladimir Ivanov
 *
 *
 */

/// @file ncbipipe.hpp
/// Portable class for work with process pipes.


#include <corelib/ncbistd.hpp>
#include <corelib/ncbiobj.hpp>
#include <stdio.h>
#include <vector>


/** @addtogroup Pipes
 *
 * @{
 */


BEGIN_NCBI_SCOPE


/////////////////////////////////////////////////////////////////////////////
///
/// CPipeException --
///
/// Define exceptions generated by CPipe.
///
/// CPipeException inherits its basic functionality from CCoreException
/// and defines additional error codes for CPipe.

class NCBI_XNCBI_EXPORT CPipeException : public CCoreException
{
public:
    /// Error types that an application can generate.
    enum EErrCode {
        eRun,           ///< Run error
        eBind,          ///< Unable to bind pipe to childs IO channels
        eUnbind,        ///< Unable to restore IO channels 
        eNoInit,        ///< Pipe initialization error
        eSetBuf         ///< setbuf() not permitted error
    };

    /// Translate from the error code value to its string representation.
    virtual const char* GetErrCodeString(void) const
    {
        switch (GetErrCode()) {
        case eRun:    return "eRun";
        case eBind:   return "eBind";
        case eUnbind: return "eUnbind";
        case eNoInit: return "eNoInit";
        case eSetBuf: return "eSetBuf";
        default:      return CException::GetErrCodeString();
        }
    }

    // Standard exception boilerplate code.
    NCBI_EXCEPTION_DEFAULT(CPipeException,CCoreException);
};


// Forward declaration.
class CPipeHandle;



/////////////////////////////////////////////////////////////////////////////
///
/// CPipe --
///
/// Create a pipe between program and some child process.
///
/// Program can read from stdin/stderr and write to stdin of the executed
/// child process using pipe object functions Read/Write.

class NCBI_XNCBI_EXPORT CPipe
{
public:
    /// Which mode to use for standard I/O handles of a child process.
    enum EMode {
        eText,                      ///< Text mode
        eBinary,                    ///< Binary mode
        eDoNotUse,                  ///< "Do not use" mode
        // Default modes
        eDefaultStdIn  = eBinary,   ///< Default mode for stdin
        eDefaultStdOut = eBinary,   ///< Default mode for stdout
        eDefaultStdErr = eDoNotUse  ///< Default mode for stderr
    };

    /// Which of the child I/O handles to used.
    enum EChildIOHandle {
        eStdIn,                     ///< stdin IO handle
        eStdOut,                    ///< stdout IO handle
        eStdErr                     ///< stderr IO handle
    };

    /// Constructor.
    CPipe();

    /// Constructor.
    ///
    /// Calls the Open() method to open a pipe. Throws CPipeException defined
    /// errors on failure to create a pipe.
    ///
    /// @param cmdname
    ///   Command name to execute.
    /// @param args
    ///   Vector of string arguments for command.
    /// @param mode_stdin
    ///   Mode to use for stdin.
    /// @param mode_stdout
    ///   Mode to use for stdout.
    /// @param mode_stderr
    ///   Mode to use for stderr.
    /// @sa
    ///   Open()
    CPipe(const char *cmdname, const vector<string>& args,
          const EMode mode_stdin  = eDefaultStdIn,
          const EMode mode_stdout = eDefaultStdOut,
          const EMode mode_stderr = eDefaultStdErr);


    /// Destructor.
    ///
    /// If pipe was created, destructor waits for new child process
    /// and closes stream on associated pipe by calling the Close() method.
    ~CPipe(void);

    /// Open a pipe.
    ///
    /// Create a pipe and execute a command with the vector of arguments
    /// "args". The other end of the pipe is associated with the spawned
    /// command's standard input or standard output according to the open mode
    /// setting. If some pipe was already open when this method is called,
    /// it will be closed.
    ///
    /// Throws CPipeException defined errors on failure to open a pipe.
    ///
    /// @param cmdname
    ///   Command name to execute.
    /// @param args
    ///   Vector of string arguments for command.
    /// @param mode_stdin
    ///   Mode to use for stdin.
    /// @param mode_stdout
    ///   Mode to use for stdout.
    /// @param mode_stderr
    ///   Mode to use for stderr.
    void Open(const char *cmdname, const vector<string>& args,
              const EMode mode_stdin  = eDefaultStdIn,
              const EMode mode_stdout = eDefaultStdOut,
              const EMode mode_stderr = eDefaultStdErr);

    /// Close pipe.
    ///
    /// Waits for new spawned child process to terminate and then closes
    /// the associated pipe.
    /// @return
    ///   - Exit code of child process if it has terminate succesfully, 
    ///   - -1 if an error has occurs.
    int Close();

    /// Close the specified pipe handle.
    void CloseHandle(EChildIOHandle handle);

    /// Read data from the pipe. 
    ///
    /// @param buffer
    ///   Buffer into which data is read.
    /// @param count
    ///   Number of bytes to read.
    /// @param from_handle
    ///   Handle to read data from.
    /// @return
    ///   Number of bytes actually read, which may be less than "count" if an
    ///   error occurs or if the end of the pipe file stream is encountered. 
    size_t Read(void *buffer, const size_t count, 
                const EChildIOHandle from_handle = eStdOut) const;

    /// Write data to the pipe. 
    ///
    /// @param buffer
    ///   Buffer from which data is written.
    /// @param count
    ///   Number of bytes to write.
    /// @return
    ///   Number of bytes actually written, which may be less than "count" if
    ///   an error occurs. 
    size_t Write(const void *buffer, const size_t count) const;

private:
    CRef<CPipeHandle> m_PipeHandle;     ///< Internal pipe handle that handles
                                        ///< requests forwarded by CPipe.
};


// Forward declaration.
class CPipeStreambuf;

/// Default buffer size for pipe iostream.
const streamsize kPipeDefaultBufSize = 4096;



/////////////////////////////////////////////////////////////////////////////
///
/// CPipeIOStream --
///
/// Create an input and output stream for a pipe.
///
/// This class is  derived from "std::iostream" and performs both input and 
/// output, using the specified pipe. 

class NCBI_XNCBI_EXPORT CPipeIOStream : public iostream
{
public:

    /// Constructor.
    ///
    /// @param pipe
    ///   Pipe which has input and output stream.
    /// @param buf_size
    ///   Buffer size to be used for pipe.
    CPipeIOStream(const CPipe& pipe, 
                  streamsize buf_size = kPipeDefaultBufSize);

    /// Destructor.
    virtual ~CPipeIOStream(void);

    /// Set the read handle of the child process as specified by "handle".
    void SetReadHandle(const CPipe::EChildIOHandle handle) const;

private:
    CPipeStreambuf* m_StreamBuf;    ///< Stream buffer for pipe I/O 
};
 

END_NCBI_SCOPE


/* @} */


/*
 * ===========================================================================
 * $Log$
 * Revision 1.12  2003/08/26 14:06:51  siyan
 * Minor doc fixes.
 *
 * Revision 1.11  2003/08/24 22:53:03  siyan
 * Added documentation.
 *
 * Revision 1.10  2003/04/23 20:50:27  ivanov
 * Added CPipe::CloseHandle()
 *
 * Revision 1.9  2003/04/01 14:20:13  siyan
 * Added doxygen support
 *
 * Revision 1.8  2003/03/03 14:46:02  dicuccio
 * Reimplemented CPipe using separate private platform-specific implementations
 *
 * Revision 1.7  2002/12/18 22:53:21  dicuccio
 * Added export specifier for building DLLs in windows.  Added global list of
 * all such specifiers in mswin_exports.hpp, included through ncbistl.hpp
 *
 * Revision 1.6  2002/07/15 18:17:52  gouriano
 * renamed CNcbiException and its descendents
 *
 * Revision 1.5  2002/07/11 14:17:55  gouriano
 * exceptions replaced by CNcbiException-type ones
 *
 * Revision 1.4  2002/06/12 19:38:45  ucko
 * Remove a superfluous comma from the definition of EMode.
 *
 * Revision 1.3  2002/06/11 19:25:06  ivanov
 * Added class CPipeIOStream
 *
 * Revision 1.2  2002/06/10 18:35:13  ivanov
 * Changed argument's type of a running child program from char*[]
 * to vector<string>
 *
 * Revision 1.1  2002/06/10 16:57:04  ivanov
 * Initial revision
 *
 * ===========================================================================
 */

#endif  /* CORELIB__NCBIPIPE__HPP */
