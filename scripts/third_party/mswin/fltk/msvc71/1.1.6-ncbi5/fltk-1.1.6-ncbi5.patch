diff -urN fltk-1.1.6.orig/FL/Fl.H fltk-1.1.6/FL/Fl.H
--- fltk-1.1.6.orig/FL/Fl.H	2004-11-23 14:47:50.000000000 -0500
+++ fltk-1.1.6/FL/Fl.H	2005-07-14 14:49:50.000000000 -0400
@@ -261,8 +261,29 @@
   // Widget deletion:
   static void delete_widget(Fl_Widget *w);
   static void do_widget_deletion();
+
+  // patch for focus handling
+public:
+    typedef void (FFocusCallback)(Fl_Widget* new_focus, void* data);
+
+    /// deprecated
+    static void       set_focus_callback(FFocusCallback* callback, void* data);
+    FFocusCallback*   get_focus_callback() const;
+    typedef FFocusCallback TFocusCallback_F;
+
+    static void       focus_callback(FFocusCallback* callback, void* data);
+    FFocusCallback*   focus_callback() const;
+
+private:
+    static TFocusCallback_F*   focus_callback_;
+    static void*    focus_callback_data_;
+  // end of patch for focus handling
 };
 
+// patch for focus handling
+#define NCBI_SET_FOCUS_PATCH
+// end of patch for focus handling
+
 #endif // !Fl_H
 
 //
diff -urN fltk-1.1.6.orig/FL/Fl_Browser_.H fltk-1.1.6/FL/Fl_Browser_.H
--- fltk-1.1.6.orig/FL/Fl_Browser_.H	2004-04-11 00:38:54.000000000 -0400
+++ fltk-1.1.6/FL/Fl_Browser_.H	2005-07-14 14:49:50.000000000 -0400
@@ -92,6 +92,7 @@
   void redraw_lines() {damage(FL_DAMAGE_SCROLL);} // redraw all of them
   void bbox(int&,int&,int&,int&) const;
   int leftedge() const;	// x position after scrollbar & border
+  int top_offset() const { return offset_; } // y position after scrollbar and border
   void *find_item(int my); // item under mouse
   void draw(int,int,int,int);
   int handle(int,int,int,int,int);
@@ -144,6 +145,9 @@
 
 };
 
+// guard for NCBI-specific binary changes
+#define NCBI_FLTK_FL_BROWSER
+
 #endif
 
 //
diff -urN fltk-1.1.6.orig/FL/Fl_Group.H fltk-1.1.6/FL/Fl_Group.H
--- fltk-1.1.6.orig/FL/Fl_Group.H	2004-04-11 00:38:54.000000000 -0400
+++ fltk-1.1.6/FL/Fl_Group.H	2005-07-14 14:49:50.000000000 -0400
@@ -41,6 +41,10 @@
   int navigation(int);
   static Fl_Group *current_;
 
+  // unimplemented copy ctor and assignment operator
+  Fl_Group(const Fl_Group&);
+  Fl_Group& operator=(const Fl_Group&);
+
 protected:
 
   void draw();
diff -urN fltk-1.1.6.orig/FL/Fl_Widget.H fltk-1.1.6/FL/Fl_Widget.H
--- fltk-1.1.6.orig/FL/Fl_Widget.H	2004-11-23 14:47:50.000000000 -0500
+++ fltk-1.1.6/FL/Fl_Widget.H	2005-07-14 14:49:50.000000000 -0400
@@ -69,13 +69,9 @@
 
   const char *tooltip_;
 
-#  if !defined(WIN32) || !defined(FL_DLL)
-  // "de-implement" the copy constructors, EXCEPT for when we are using the
-  // WIN32 DLL interface, in which case we can't hide them because Microsoft
-  // requires the copy constructors to implement subclassing...
-  Fl_Widget & operator=(const Fl_Widget &) { return *this; }
-  Fl_Widget(const Fl_Widget &) {}
-#  endif // !WIN32 || !FL_DLL
+  // unimplemented copy ctor and assignment operator
+  Fl_Widget(const Fl_Widget &);
+  Fl_Widget& operator=(const Fl_Widget &);
 
 protected:
 
diff -urN fltk-1.1.6.orig/FL/Fl_Window.H fltk-1.1.6/FL/Fl_Window.H
--- fltk-1.1.6.orig/FL/Fl_Window.H	2004-11-19 22:19:57.000000000 -0500
+++ fltk-1.1.6/FL/Fl_Window.H	2005-07-14 14:49:50.000000000 -0400
@@ -58,6 +58,10 @@
   };
   void _Fl_Window(); // constructor innards
 
+  // unimplemented copy ctor and assignment operator
+  Fl_Window(const Fl_Window&);
+  Fl_Window& operator=(const Fl_Window&);
+
 protected:
 
   static Fl_Window *current_;
@@ -88,7 +92,7 @@
   void hotspot(const Fl_Widget& p, int offscreen = 0) {hotspot(&p,offscreen);}
   void free_position()	{clear_flag(FL_FORCE_POSITION);}
   void size_range(int a, int b, int c=0, int d=0, int e=0, int f=0, int g=0) {
-    minw=(short)a; minh=(short)b; maxw=(short)c; maxh=(short)d; dw=(short)e; dh=(short)f; aspect=(short)g; size_range_();}
+    minw=(short)a; minh=(short)b; maxw=(short)c; maxh=(short)d; dw=(uchar)e; dh=(uchar)f; aspect=(uchar)g; size_range_();}
 
   const char* label() const	{return Fl_Widget::label();}
   const char* iconlabel() const	{return iconlabel_;}
diff -urN fltk-1.1.6.orig/configure fltk-1.1.6/configure
--- fltk-1.1.6.orig/configure	2004-11-23 15:35:43.000000000 -0500
+++ fltk-1.1.6/configure	2005-07-14 14:49:50.000000000 -0400
@@ -1464,7 +1464,7 @@
 	    ;;
     esac
 
-    LINKSHARED="-L../src -lfltk_images$SHAREDSUFFIX -lfltk_forms$SHAREDSUFFIX -lfltk$SHAREDSUFFIX"
+    LINKSHARED="-L../src -L../lib -lfltk_images$SHAREDSUFFIX -lfltk_forms$SHAREDSUFFIX -lfltk$SHAREDSUFFIX"
 else
     DSOCOMMAND="echo"
     DSOLINK=""
diff -urN fltk-1.1.6.orig/configure.in fltk-1.1.6/configure.in
--- fltk-1.1.6.orig/configure.in	2004-11-19 22:44:17.000000000 -0500
+++ fltk-1.1.6/configure.in	2005-07-14 14:49:50.000000000 -0400
@@ -195,7 +195,7 @@
 	    ;;
     esac
 
-    LINKSHARED="-L../src -lfltk_images$SHAREDSUFFIX -lfltk_forms$SHAREDSUFFIX -lfltk$SHAREDSUFFIX"
+    LINKSHARED="-L../src -L../lib -lfltk_images$SHAREDSUFFIX -lfltk_forms$SHAREDSUFFIX -lfltk$SHAREDSUFFIX"
 else
     DSOCOMMAND="echo"
     DSOLINK=""
diff -urN fltk-1.1.6.orig/makeinclude.in fltk-1.1.6/makeinclude.in
--- fltk-1.1.6.orig/makeinclude.in	2004-10-18 16:22:21.000000000 -0400
+++ fltk-1.1.6/makeinclude.in	2005-07-14 14:49:50.000000000 -0400
@@ -76,7 +76,8 @@
 LINKFLTKGL	= -L../lib @LINKFLTKGL@
 LINKFLTKFORMS	= -L../lib -lfltk_forms @LINKFLTK@
 LINKFLTKIMG	= -L../lib -lfltk_images @LINKFLTK@ $(IMAGELIBS)
-LINKSHARED	= @DSOLINK@ @LINKSHARED@ $(IMAGELIBS)
+DSOLINK         = @DSOLINK@
+LINKSHARED	= $(DSOLINK) @LINKSHARED@ $(IMAGELIBS)
 IMAGELIBS	= @IMAGELIBS@
 
 # image libraries to build...
diff -urN fltk-1.1.6.orig/src/Fl.cxx fltk-1.1.6/src/Fl.cxx
--- fltk-1.1.6.orig/src/Fl.cxx	2004-11-23 14:50:58.000000000 -0500
+++ fltk-1.1.6/src/Fl.cxx	2005-07-14 14:49:50.000000000 -0400
@@ -33,6 +33,7 @@
 #include <FL/x.H>
 #include <FL/Fl_Tooltip.H>
 #include <ctype.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include "flstring.h"
 
@@ -94,6 +95,124 @@
   return (mx >= 0 && mx < o->w() && my >= 0 && my < o->h());
 }
 
+//
+//
+// timer support
+//
+
+#ifdef WIN32
+
+/// implementation in Fl_win32.cxx
+
+#elif defined(__APPLE__)
+
+//
+// MacOS X timers
+//
+
+struct MacTimeout {
+    Fl_Timeout_Handler callback;
+    void* data;
+    EventLoopTimerRef timer;
+};
+static MacTimeout* mac_timers;
+static int mac_timer_alloc;
+static int mac_timer_used;
+
+
+static void realloc_timers()
+{
+    if (mac_timer_alloc == 0) {
+        mac_timer_alloc = 8;
+    }
+    MacTimeout* new_timers = new MacTimeout[mac_timer_alloc * 2];
+    memmove(new_timers, mac_timers, sizeof(MacTimeout) * mac_timer_used);
+    MacTimeout* delete_me = mac_timers;
+    mac_timers = new_timers;
+    delete [] delete_me;
+    mac_timer_alloc *= 2;
+}
+
+static void delete_timer(MacTimeout& t)
+{
+    RemoveEventLoopTimer(t.timer);
+    memset(&t, 0, sizeof(MacTimeout));
+}
+
+
+static pascal void do_timer(EventLoopTimerRef timer, void* data)
+{
+   for (int i = 0;  i < mac_timer_used;  ++i) {
+        MacTimeout& t = mac_timers[i];
+        if (t.timer == timer  &&  t.data == data) {
+            return (*t.callback)(data);
+        }
+    }
+}
+
+
+void Fl::add_timeout(double time, Fl_Timeout_Handler cb, void* data)
+{
+    int timer_id = -1;
+    for (int i = 0;  i < mac_timer_used;  ++i) {
+        if ( !mac_timers[i].timer ) {
+            timer_id = i;
+            break;
+        }
+    }
+    if (timer_id == -1) {
+        if (mac_timer_used == mac_timer_alloc) {
+            realloc_timers();
+        }
+        timer_id = mac_timer_used++;
+    }
+    
+    EventTimerInterval fireDelay = (EventTimerInterval) time;
+    EventLoopTimerUPP  timerUPP = NewEventLoopTimerUPP(do_timer);
+    EventLoopTimerRef  timerRef;
+    OSStatus err = InstallEventLoopTimer(GetMainEventLoop(), fireDelay, 0, timerUPP, data, &timerRef);
+    if (err == noErr) {
+        mac_timers[timer_id].callback = cb;
+        mac_timers[timer_id].data     = data;
+        mac_timers[timer_id].timer    = timerRef;
+    }
+}
+
+void Fl::repeat_timeout(double time, Fl_Timeout_Handler cb, void* data)
+{
+    remove_timeout(cb, data);
+    add_timeout(time, cb, data);
+}
+
+int Fl::has_timeout(Fl_Timeout_Handler cb, void* data)
+{
+   for (int i = 0;  i < mac_timer_used;  ++i) {
+        MacTimeout& t = mac_timers[i];
+        if (t.callback == cb  &&  t.data == data) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+void Fl::remove_timeout(Fl_Timeout_Handler cb, void* data)
+{
+   for (int i = 0;  i < mac_timer_used;  ++i) {
+        MacTimeout& t = mac_timers[i];
+        if (t.callback == cb  && ( t.data == data || data == NULL)) {
+            delete_timer(t);
+        }
+    }
+}
+
+
+#else
+
+//
+// X11 timers
+//
+
+
 ////////////////////////////////////////////////////////////////
 // Timeouts are stored in a sorted list, so only the first one needs
 // to be checked to see if any should be called.
@@ -105,10 +224,9 @@
   Timeout* next;
 };
 static Timeout* first_timeout, *free_timeout;
+static int first_timeout_count, free_timeout_count;
 
-#ifndef WIN32
-#  include <sys/time.h>
-#endif
+#include <sys/time.h>
 
 // I avoid the overhead of getting the current time when we have no
 // timeouts by setting this flag instead of getting the time.
@@ -117,12 +235,6 @@
 static char reset_clock = 1;
 
 static void elapse_timeouts() {
-#ifdef WIN32
-  unsigned long newclock = GetTickCount();
-  static unsigned long prevclock;
-  double elapsed = (newclock-prevclock)/1000.0;
-  prevclock = newclock;
-#else
   static struct timeval prevclock;
   struct timeval newclock;
   gettimeofday(&newclock, NULL);
@@ -130,7 +242,6 @@
     (newclock.tv_usec - prevclock.tv_usec)/1000000.0;
   prevclock.tv_sec = newclock.tv_sec;
   prevclock.tv_usec = newclock.tv_usec;
-#endif
   if (reset_clock) {
     reset_clock = 0;
   } else if (elapsed > 0) {
@@ -152,8 +263,12 @@
 void Fl::repeat_timeout(double time, Fl_Timeout_Handler cb, void *argp) {
   time += missed_timeout_by; if (time < -.05) time = 0;
   Timeout* t = free_timeout;
-  if (t) free_timeout = t->next;
-  else t = new Timeout;
+  if (t) {
+      free_timeout = t->next;
+      --free_timeout_count;
+  } else {
+      t = new Timeout;
+  }
   t->time = time;
   t->cb = cb;
   t->arg = argp;
@@ -185,6 +300,8 @@
   }
 }
 
+#endif
+
 ////////////////////////////////////////////////////////////////
 // Checks are just stored in a list. They are called in the reverse
 // order that they were added (this may change in the future).
@@ -198,7 +315,7 @@
   void* arg;
   Check* next;
 };
-static Check* first_check, *next_check, *free_check;
+static Check *first_check, *next_check, *free_check;
 
 void Fl::add_check(Fl_Timeout_Handler cb, void *argp) {
   Check* t = free_check;
@@ -225,6 +342,20 @@
   }
 }
 
+static void run_checks()
+{
+  // checks are a bit messy so that add/remove and wait may be called
+  // from inside them without causing an infinite loop:
+  if (next_check == first_check) {
+    while (next_check) {
+      Check* checkp = next_check;
+      next_check = checkp->next;
+      (checkp->cb)(checkp->arg);
+    }
+    next_check = first_check;
+  }
+}
+
 ////////////////////////////////////////////////////////////////
 // wait/run/check/ready:
 
@@ -233,11 +364,17 @@
 extern int fl_ready(); // in Fl_<platform>.cxx
 extern int fl_wait(double time); // in Fl_<platform>.cxx
 
-static char in_idle;
-
 double Fl::wait(double time_to_wait) {
   do_widget_deletion();
 
+#ifdef WIN32
+
+  return fl_wait(time_to_wait);
+
+#elif defined(__APPLE__)
+  flush();
+  return fl_wait(time_to_wait);
+#else
   if (first_timeout) {
     elapse_timeouts();
     Timeout *t;
@@ -251,32 +388,17 @@
       first_timeout = t->next;
       t->next = free_timeout;
       free_timeout = t;
+      ++free_timeout_count;
+      --first_timeout_count;
       // Now it is safe for the callback to do add_timeout:
       cb(argp);
     }
   } else {
     reset_clock = 1; // we are not going to check the clock
   }
-  // checks are a bit messy so that add/remove and wait may be called
-  // from inside them without causing an infinite loop:
-  if (next_check == first_check) {
-    while (next_check) {
-      Check* checkp = next_check;
-      next_check = checkp->next;
-      (checkp->cb)(checkp->arg);
-    }
-    next_check = first_check;
-  }
-//  if (idle && !fl_ready()) {
-  if (idle) {
-    if (!in_idle) {
-      in_idle = 1;
-      idle();
-      in_idle = 0;
-    }
-    // the idle function may turn off idle, we can then wait:
-    if (idle) time_to_wait = 0.0;
-  }
+
+  run_checks();
+
   if (first_timeout && first_timeout->time < time_to_wait)
     time_to_wait = first_timeout->time;
   if (time_to_wait <= 0.0) {
@@ -289,9 +411,10 @@
     flush();
     return fl_wait(time_to_wait);
   }
+#endif
 }
 
-#define FOREVER 1e20
+#define FOREVER 0.01 //1e20
 
 int Fl::run() {
   while (Fl_X::first) wait(FOREVER);
@@ -311,12 +434,14 @@
 extern int fl_ready();
 
 int Fl::ready() {
+#if ! defined( WIN32 )  &&  ! defined(__APPLE__)
   if (first_timeout) {
     elapse_timeouts();
     if (first_timeout->time <= 0) return 1;
   } else {
     reset_clock = 1;
   }
+#endif
   return fl_ready();
 }
 
@@ -437,12 +562,46 @@
 
 ////////////////////////////////////////////////////////////////
 
+// patch for focus handling
+Fl::FFocusCallback*   Fl::focus_callback_ = NULL;
+void*   Fl::focus_callback_data_ = NULL;
+
+/// deprecated
+void  Fl::set_focus_callback(FFocusCallback* callback, void* data)
+{
+    focus_callback(callback, data);
+}
+
+void Fl::focus_callback(FFocusCallback* callback, void* data)
+{
+    focus_callback_ = callback;
+    focus_callback_data_ = data; 
+}
+
+Fl::FFocusCallback* Fl::get_focus_callback() const
+{
+    return focus_callback();
+}
+
+Fl::FFocusCallback* Fl::focus_callback() const
+{
+    return focus_callback_;
+}
+// end of patch
+
 Fl_Widget* fl_oldfocus; // kludge for Fl_Group...
 
 void Fl::focus(Fl_Widget *o) {
   if (o && !o->visible_focus()) return;
   if (grab()) return; // don't do anything while grab is on
   Fl_Widget *p = focus_;
+
+  // patch for focus handling
+  if(focus_callback_)  {
+    (*focus_callback_)(o, focus_callback_data_);
+  }
+  // end of patch
+
   if (o != p) {
     Fl::compose_reset();
     focus_ = o;
@@ -1053,6 +1212,11 @@
   draw();
 }
 
+#ifdef WIN32
+#  include "Fl_win32.cxx"
+#elif defined(__APPLE__)
+#  include "Fl_mac.cxx"
+#endif
 
 //
 // The following methods allow callbacks to schedule the deletion of
diff -urN fltk-1.1.6.orig/src/Fl.cxx~ fltk-1.1.6/src/Fl.cxx~
--- fltk-1.1.6.orig/src/Fl.cxx~	1969-12-31 19:00:00.000000000 -0500
+++ fltk-1.1.6/src/Fl.cxx~	2005-07-14 14:49:50.000000000 -0400
@@ -0,0 +1,1134 @@
+//
+// "$Id$"
+//
+// Main event handling code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2004 by Bill Spitzak and others.
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems to "fltk-bugs@fltk.org".
+//
+
+// warning: the Apple Quartz version still uses some Quickdraw calls,
+//          mostly to get around the single active context in QD and 
+//          to implement clipping. This should be changed into pure
+//          Quartz calls in the near future.
+
+#include <FL/Fl.H>
+#include <FL/Fl_Window.H>
+#include <FL/x.H>
+#include <FL/Fl_Tooltip.H>
+#include <ctype.h>
+#include <stdlib.h>
+#include "flstring.h"
+
+#ifdef DEBUG
+#  include <stdio.h>
+#endif // DEBUG
+
+
+//
+// Globals...
+//
+
+Fl_Widget	*Fl::belowmouse_,
+		*Fl::pushed_,
+		*Fl::focus_,
+		*Fl::selection_owner_;
+int		Fl::damage_,
+		Fl::e_number,
+		Fl::e_x,
+		Fl::e_y,
+		Fl::e_x_root,
+		Fl::e_y_root,
+		Fl::e_dx,
+		Fl::e_dy,
+		Fl::e_state,
+		Fl::e_clicks,
+		Fl::e_is_click,
+		Fl::e_keysym;
+char		*Fl::e_text = (char *)"";
+int		Fl::e_length;
+int		Fl::visible_focus_ = 1,
+		Fl::dnd_text_ops_ = 1;
+
+
+//
+// 'Fl::version()' - Return the API version number...
+//
+
+double
+Fl::version() {
+  return FL_VERSION;
+}
+
+
+//
+// 'Fl:event_inside()' - Return whether or not the mouse event is inside
+//                       the given rectangle.
+//
+
+int Fl::event_inside(int xx,int yy,int ww,int hh) /*const*/ {
+  int mx = e_x - xx;
+  int my = e_y - yy;
+  return (mx >= 0 && mx < ww && my >= 0 && my < hh);
+}
+
+int Fl::event_inside(const Fl_Widget *o) /*const*/ {
+  int mx = e_x - o->x();
+  int my = e_y - o->y();
+  return (mx >= 0 && mx < o->w() && my >= 0 && my < o->h());
+}
+
+////////////////////////////////////////////////////////////////
+// Timeouts are stored in a sorted list, so only the first one needs
+// to be checked to see if any should be called.
+  
+struct Timeout {
+  double time;
+  void (*cb)(void*);
+  void* arg;
+  Timeout* next;
+};
+static Timeout* first_timeout, *free_timeout;
+
+#ifndef WIN32
+#  include <sys/time.h>
+#endif
+
+// I avoid the overhead of getting the current time when we have no
+// timeouts by setting this flag instead of getting the time.
+// In this case calling elapse_timeouts() does nothing, but records
+// the current time, and the next call will actualy elapse time.
+static char reset_clock = 1;
+
+static void elapse_timeouts() {
+#ifdef WIN32
+  unsigned long newclock = GetTickCount();
+  static unsigned long prevclock;
+  double elapsed = (newclock-prevclock)/1000.0;
+  prevclock = newclock;
+#else
+  static struct timeval prevclock;
+  struct timeval newclock;
+  gettimeofday(&newclock, NULL);
+  double elapsed = newclock.tv_sec - prevclock.tv_sec +
+    (newclock.tv_usec - prevclock.tv_usec)/1000000.0;
+  prevclock.tv_sec = newclock.tv_sec;
+  prevclock.tv_usec = newclock.tv_usec;
+#endif
+  if (reset_clock) {
+    reset_clock = 0;
+  } else if (elapsed > 0) {
+    for (Timeout* t = first_timeout; t; t = t->next) t->time -= elapsed;
+  }
+}
+
+// Continuously-adjusted error value, this is a number <= 0 for how late
+// we were at calling the last timeout. This appears to make repeat_timeout
+// very accurate even when processing takes a significant portion of the
+// time interval:
+static double missed_timeout_by;
+
+void Fl::add_timeout(double time, Fl_Timeout_Handler cb, void *argp) {
+  elapse_timeouts();
+  repeat_timeout(time, cb, argp);
+}
+
+void Fl::repeat_timeout(double time, Fl_Timeout_Handler cb, void *argp) {
+  time += missed_timeout_by; if (time < -.05) time = 0;
+  Timeout* t = free_timeout;
+  if (t) free_timeout = t->next;
+  else t = new Timeout;
+  t->time = time;
+  t->cb = cb;
+  t->arg = argp;
+  // insert-sort the new timeout:
+  Timeout** p = &first_timeout; 
+  while (*p && (*p)->time <= time) p = &((*p)->next);
+  t->next = *p;
+  *p = t;
+}
+
+int Fl::has_timeout(Fl_Timeout_Handler cb, void *argp) {
+  for (Timeout* t = first_timeout; t; t = t->next)
+    if (t->cb == cb && t->arg == argp) return 1;
+  return 0;
+}
+
+void Fl::remove_timeout(Fl_Timeout_Handler cb, void *argp) {
+  // This version removes all matching timeouts, not just the first one.
+  // This may change in the future.
+  for (Timeout** p = &first_timeout; *p;) {
+    Timeout* t = *p;
+    if (t->cb == cb && (t->arg == argp || !argp)) {
+      *p = t->next;
+      t->next = free_timeout;
+      free_timeout = t;
+    } else {
+      p = &(t->next);
+    }
+  }
+}
+
+////////////////////////////////////////////////////////////////
+// Checks are just stored in a list. They are called in the reverse
+// order that they were added (this may change in the future).
+// This is a bit messy because I want to allow checks to be added,
+// removed, and have wait() called from inside them, to do this
+// next_check points at the next unprocessed one for the outermost
+// call to Fl::wait().
+
+struct Check {
+  void (*cb)(void*);
+  void* arg;
+  Check* next;
+};
+static Check* first_check, *next_check, *free_check;
+
+void Fl::add_check(Fl_Timeout_Handler cb, void *argp) {
+  Check* t = free_check;
+  if (t) free_check = t->next;
+  else t = new Check;
+  t->cb = cb;
+  t->arg = argp;
+  t->next = first_check;
+  if (next_check == first_check) next_check = t;
+  first_check = t;
+}
+
+void Fl::remove_check(Fl_Timeout_Handler cb, void *argp) {
+  for (Check** p = &first_check; *p;) {
+    Check* t = *p;
+    if (t->cb == cb && t->arg == argp) {
+      if (next_check == t) next_check = t->next;
+      *p = t->next;
+      t->next = free_check;
+      free_check = t;
+    } else {
+      p = &(t->next);
+    }
+  }
+}
+
+////////////////////////////////////////////////////////////////
+// wait/run/check/ready:
+
+void (*Fl::idle)(); // see Fl_add_idle.cxx for the add/remove functions
+
+extern int fl_ready(); // in Fl_<platform>.cxx
+extern int fl_wait(double time); // in Fl_<platform>.cxx
+
+static char in_idle;
+
+double Fl::wait(double time_to_wait) {
+  do_widget_deletion();
+
+  if (first_timeout) {
+    elapse_timeouts();
+    Timeout *t;
+    while ((t = first_timeout)) {
+      if (t->time > 0) break;
+      // The first timeout in the array has expired.
+      missed_timeout_by = t->time;
+      // We must remove timeout from array before doing the callback:
+      void (*cb)(void*) = t->cb;
+      void *argp = t->arg;
+      first_timeout = t->next;
+      t->next = free_timeout;
+      free_timeout = t;
+      // Now it is safe for the callback to do add_timeout:
+      cb(argp);
+    }
+  } else {
+    reset_clock = 1; // we are not going to check the clock
+  }
+  // checks are a bit messy so that add/remove and wait may be called
+  // from inside them without causing an infinite loop:
+  if (next_check == first_check) {
+    while (next_check) {
+      Check* checkp = next_check;
+      next_check = checkp->next;
+      (checkp->cb)(checkp->arg);
+    }
+    next_check = first_check;
+  }
+//  if (idle && !fl_ready()) {
+  if (idle) {
+    if (!in_idle) {
+      in_idle = 1;
+      idle();
+      in_idle = 0;
+    }
+    // the idle function may turn off idle, we can then wait:
+    if (idle) time_to_wait = 0.0;
+  }
+  if (first_timeout && first_timeout->time < time_to_wait)
+    time_to_wait = first_timeout->time;
+  if (time_to_wait <= 0.0) {
+    // do flush second so that the results of events are visible:
+    int ret = fl_wait(0.0);
+    flush();
+    return ret;
+  } else {
+    // do flush first so that user sees the display:
+    flush();
+    return fl_wait(time_to_wait);
+  }
+}
+
+#define FOREVER 1e20
+
+int Fl::run() {
+  while (Fl_X::first) wait(FOREVER);
+  return 0;
+}
+
+int Fl::wait() {
+  wait(FOREVER);
+  return Fl_X::first != 0; // return true if there is a window
+}
+
+int Fl::check() {
+  wait(0.0);
+  return Fl_X::first != 0; // return true if there is a window
+}
+
+extern int fl_ready();
+
+int Fl::ready() {
+  if (first_timeout) {
+    elapse_timeouts();
+    if (first_timeout->time <= 0) return 1;
+  } else {
+    reset_clock = 1;
+  }
+  return fl_ready();
+}
+
+////////////////////////////////////////////////////////////////
+// Window list management:
+
+Fl_X* Fl_X::first;
+
+Fl_Window* fl_find(Window xid) {
+  Fl_X *window;
+  for (Fl_X **pp = &Fl_X::first; (window = *pp); pp = &window->next)
+#ifdef __APPLE_QD__
+    if (window->xid == xid && !window->w->window()) {
+#elif defined(__APPLE_QUARTZ__)
+    if (window->xid == xid && !window->w->window()) {
+#else
+    if (window->xid == xid) {
+#endif // __APPLE__
+      if (window != Fl_X::first && !Fl::modal()) {
+	// make this window be first to speed up searches
+	// this is not done if modal is true to avoid messing up modal stack
+	*pp = window->next;
+	window->next = Fl_X::first;
+	Fl_X::first = window;
+      }
+      return window->w;
+    }
+  return 0;
+}
+
+Fl_Window* Fl::first_window() {
+  Fl_X* i = Fl_X::first;
+  return i ? i->w : 0;
+}
+
+Fl_Window* Fl::next_window(const Fl_Window* window) {
+  Fl_X* i = Fl_X::i(window)->next;
+  return i ? i->w : 0;
+}
+
+void Fl::first_window(Fl_Window* window) {
+  if (!window || !window->shown()) return;
+  fl_find(fl_xid(window));
+}
+
+void Fl::redraw() {
+  for (Fl_X* i = Fl_X::first; i; i = i->next) i->w->redraw();
+}
+
+void Fl::flush() {
+  if (damage()) {
+    damage_ = 0;
+    for (Fl_X* i = Fl_X::first; i; i = i->next) {
+      if (i->wait_for_expose) {damage_ = 1; continue;}
+      Fl_Window* wi = i->w;
+      if (!wi->visible_r()) continue;
+      if (wi->damage()) {i->flush(); wi->clear_damage();}
+      // destroy damage regions for windows that don't use them:
+      if (i->region) {XDestroyRegion(i->region); i->region = 0;}
+    }
+  }
+
+#ifdef WIN32
+  GdiFlush();
+#elif defined(__APPLE_QD__)
+  GrafPtr port;
+  GetPort( &port );
+  if ( port )
+    QDFlushPortBuffer( port, 0 );
+#elif defined (__APPLE_QUARTZ__)
+  if (fl_gc)
+    CGContextFlush(fl_gc);
+#else
+  if (fl_display) XFlush(fl_display);
+#endif
+}
+
+////////////////////////////////////////////////////////////////
+// Event handlers:
+
+struct handler_link {
+  int (*handle)(int);
+  handler_link *next;
+};
+
+static handler_link *handlers = 0;
+
+void Fl::add_handler(int (*ha)(int)) {
+  handler_link *l = new handler_link;
+  l->handle = ha;
+  l->next = handlers;
+  handlers = l;
+}
+
+void Fl::remove_handler(int (*ha)(int)) {
+  handler_link *l, *p;
+
+  // Search for the handler in the list...
+  for (l = handlers, p = 0; l && l->handle != ha; p = l, l = l->next);
+
+  if (l) {
+    // Found it, so remove it from the list...
+    if (p) p->next = l->next;
+    else handlers = l->next;
+
+    // And free the record...
+    delete l;
+  }
+}
+
+int (*fl_local_grab)(int); // used by fl_dnd.cxx
+
+static int send_handlers(int e) {
+  for (const handler_link *hl = handlers; hl; hl = hl->next)
+    if (hl->handle(e)) return 1;
+  return 0;
+}
+
+////////////////////////////////////////////////////////////////
+
+// patch for focus handling
+Fl::FFocusCallback*   Fl::focus_callback_ = NULL;
+void*   Fl::focus_callback_data_ = NULL;
+
+/// deprecated
+void  Fl::set_focus_callback(FFocusCallback* callback, void* data)
+{
+    focus_callback(callback, data);
+}
+
+void Fl::focus_callback(FFocusCallback* callback, void* data)
+{
+    focus_callback_ = callback;
+    focus_callback_data_ = data; 
+}
+
+Fl::FFocusCallback* Fl::get_focus_callback() const
+{
+    return focus_callback();
+}
+
+Fl::FFocusCallback* Fl::focus_callback() const
+{
+    return focus_callback_;
+}
+// end of patch
+
+Fl_Widget* fl_oldfocus; // kludge for Fl_Group...
+
+void Fl::focus(Fl_Widget *o) {
+  if (o && !o->visible_focus()) return;
+  if (grab()) return; // don't do anything while grab is on
+  Fl_Widget *p = focus_;
+
+  // patch for focus handling
+  if(focus_callback_)  {
+    (*focus_callback_)(o, focus_callback_data_);
+  }
+  // end of patch
+
+  if (o != p) {
+    Fl::compose_reset();
+    focus_ = o;
+    fl_oldfocus = 0;
+    for (; p; p = p->parent()) {
+      p->handle(FL_UNFOCUS);
+      fl_oldfocus = p;
+    }
+  }
+}
+
+static char dnd_flag = 0; // make 'belowmouse' send DND_LEAVE instead of LEAVE
+
+void Fl::belowmouse(Fl_Widget *o) {
+  if (grab()) return; // don't do anything while grab is on
+  Fl_Widget *p = belowmouse_;
+  if (o != p) {
+    belowmouse_ = o;
+    for (; p && !p->contains(o); p = p->parent()) {
+      p->handle(dnd_flag ? FL_DND_LEAVE : FL_LEAVE);
+    }
+  }
+}
+
+void Fl::pushed(Fl_Widget *o) {
+  pushed_ = o;
+}
+
+Fl_Window *fl_xfocus;	// which window X thinks has focus
+Fl_Window *fl_xmousewin;// which window X thinks has FL_ENTER
+Fl_Window *Fl::grab_;	// most recent Fl::grab()
+Fl_Window *Fl::modal_;	// topmost modal() window
+
+static void nothing(Fl_Widget *) {}
+void (*Fl_Tooltip::enter)(Fl_Widget *) = nothing;
+void (*Fl_Tooltip::exit)(Fl_Widget *) = nothing;
+
+// Update modal(), focus() and other state according to system state,
+// and send FL_ENTER, FL_LEAVE, FL_FOCUS, and/or FL_UNFOCUS events.
+// This is the only function that produces these events in response
+// to system activity.
+// This is called whenever a window is added or hidden, and whenever
+// X says the focus or mouse window have changed.
+
+void fl_fix_focus() {
+#ifdef DEBUG
+  puts("fl_fix_focus();");
+#endif // DEBUG
+
+  if (Fl::grab()) return; // don't do anything while grab is on.
+
+  // set focus based on Fl::modal() and fl_xfocus
+  Fl_Widget* w = fl_xfocus;
+  if (w) {
+    if (Fl::e_keysym < (FL_Button + FL_LEFT_MOUSE) ||
+        Fl::e_keysym > (FL_Button + FL_RIGHT_MOUSE))
+      Fl::e_keysym = 0; // make sure widgets don't think a keystroke moved focus
+    while (w->parent()) w = w->parent();
+    if (Fl::modal()) w = Fl::modal();
+    if (!w->contains(Fl::focus()))
+      if (!w->take_focus()) Fl::focus(w);
+  } else
+    Fl::focus(0);
+
+// MRS: Originally we checked the button state, but a user reported that it
+//      broke click-to-focus in FLWM?!?
+//  if (!(Fl::event_state() & 0x7f00000 /*FL_BUTTONS*/)) {
+  if (!Fl::pushed()) {
+    // set belowmouse based on Fl::modal() and fl_xmousewin:
+    w = fl_xmousewin;
+    if (w) {
+      if (Fl::modal()) w = Fl::modal();
+      if (!w->contains(Fl::belowmouse())) {
+	w->handle(FL_ENTER);
+	if (!w->contains(Fl::belowmouse())) Fl::belowmouse(w);
+      } else {
+	// send a FL_MOVE event so the enter/leave state is up to date
+	Fl::e_x = Fl::e_x_root-fl_xmousewin->x();
+	Fl::e_y = Fl::e_y_root-fl_xmousewin->y();
+	w->handle(FL_MOVE);
+      }
+    } else {
+      Fl::belowmouse(0);
+      Fl_Tooltip::enter(0);
+    }
+  }
+}
+
+#ifndef WIN32
+extern Fl_Widget *fl_selection_requestor; // from Fl_x.cxx
+#endif
+
+// This function is called by ~Fl_Widget() and by Fl_Widget::deactivate
+// and by Fl_Widget::hide().  It indicates that the widget does not want
+// to receive any more events, and also removes all global variables that
+// point at the widget.
+// I changed this from the 1.0.1 behavior, the older version could send
+// FL_LEAVE or FL_UNFOCUS events to the widget.  This appears to not be
+// desirable behavior and caused flwm to crash.
+
+void fl_throw_focus(Fl_Widget *o) {
+#ifdef DEBUG
+  printf("fl_throw_focus(o=%p)\n", o);
+#endif // DEBUG
+
+  if (o->contains(Fl::pushed())) Fl::pushed_ = 0;
+#ifndef WIN32
+  if (o->contains(fl_selection_requestor)) fl_selection_requestor = 0;
+#endif
+  if (o->contains(Fl::belowmouse())) Fl::belowmouse_ = 0;
+  if (o->contains(Fl::focus())) Fl::focus_ = 0;
+  if (o == fl_xfocus) fl_xfocus = 0;
+  if (o == Fl_Tooltip::current()) Fl_Tooltip::current(0);
+  if (o == fl_xmousewin) fl_xmousewin = 0;
+  Fl_Tooltip::exit(o);
+  fl_fix_focus();
+}
+
+////////////////////////////////////////////////////////////////
+
+// Call to->handle but first replace the mouse x/y with the correct
+// values to account for nested X windows. 'window' is the outermost
+// window the event was posted to by X:
+static int send(int event, Fl_Widget* to, Fl_Window* window) {
+  int dx, dy;
+  if (window) {
+    dx = window->x();
+    dy = window->y();
+  } else {
+    dx = dy = 0;
+  }
+  for (const Fl_Widget* w = to; w; w = w->parent())
+    if (w->type()>=FL_WINDOW) {dx -= w->x(); dy -= w->y();}
+  int save_x = Fl::e_x; Fl::e_x += dx;
+  int save_y = Fl::e_y; Fl::e_y += dy;
+  int ret = to->handle(event);
+  Fl::e_y = save_y;
+  Fl::e_x = save_x;
+  return ret;
+}
+
+int Fl::handle(int e, Fl_Window* window)
+{
+  e_number = e;
+  if (fl_local_grab) return fl_local_grab(e);
+
+  Fl_Widget* wi = window;
+
+  switch (e) {
+
+  case FL_CLOSE:
+    if (grab() || modal() && window != modal()) return 0;
+    wi->do_callback();
+    return 1;
+
+  case FL_SHOW:
+    wi->show(); // this calls Fl_Widget::show(), not Fl_Window::show()
+    return 1;
+
+  case FL_HIDE:
+    wi->hide(); // this calls Fl_Widget::hide(), not Fl_Window::hide()
+    return 1;
+
+  case FL_PUSH:
+#ifdef DEBUG
+    printf("Fl::handle(e=%d, window=%p);\n", e, window);
+#endif // DEBUG
+
+    if (grab()) wi = grab();
+    else if (modal() && wi != modal()) return 0;
+    pushed_ = wi;
+    Fl_Tooltip::current(wi);
+    if (send(e, wi, window)) return 1;
+    // raise windows that are clicked on:
+    window->show();
+    return 1;
+
+  case FL_DND_ENTER:
+  case FL_DND_DRAG:
+    dnd_flag = 1;
+    break;
+
+  case FL_DND_LEAVE:
+    dnd_flag = 1;
+    belowmouse(0);
+    dnd_flag = 0;
+    return 1;
+
+  case FL_DND_RELEASE:
+    wi = belowmouse();
+    break;
+
+  case FL_MOVE:
+  case FL_DRAG:
+    fl_xmousewin = window; // this should already be set, but just in case.
+    if (pushed()) {
+      wi = pushed();
+      if (grab()) wi = grab();
+      e_number = e = FL_DRAG;
+      break;
+    }
+    if (modal() && wi != modal()) wi = 0;
+    if (grab()) wi = grab();
+    {Fl_Widget* pbm = belowmouse();
+    int ret = (wi && send(e, wi, window));
+    if (pbm != belowmouse()) {
+#ifdef DEBUG
+      printf("Fl::handle(e=%d, window=%p);\n", e, window);
+#endif // DEBUG
+      Fl_Tooltip::enter(belowmouse());
+    }
+    return ret;}
+
+  case FL_RELEASE: {
+//    printf("FL_RELEASE: window=%p, pushed() = %p, grab() = %p, modal() = %p\n",
+//           window, pushed(), grab(), modal());
+
+    if (grab()) {
+      wi = grab();
+      pushed_ = 0; // must be zero before callback is done!
+    } else if (pushed()) {
+      wi = pushed();
+      pushed_ = 0; // must be zero before callback is done!
+    } else if (modal() && wi != modal()) return 0;
+    int r = send(e, wi, window);
+    fl_fix_focus();
+    return r;}
+
+  case FL_UNFOCUS:
+    window = 0;
+  case FL_FOCUS:
+    fl_xfocus = window;
+    fl_fix_focus();
+    return 1;
+
+  case FL_KEYBOARD:
+#ifdef DEBUG
+    printf("Fl::handle(e=%d, window=%p);\n", e, window);
+#endif // DEBUG
+
+    Fl_Tooltip::enter((Fl_Widget*)0);
+
+    fl_xfocus = window; // this should not happen!  But maybe it does:
+
+    // Try it as keystroke, sending it to focus and all parents:
+    for (wi = grab() ? grab() : focus(); wi; wi = wi->parent())
+      if (send(FL_KEYBOARD, wi, window)) return 1;
+
+    // recursive call to try shortcut:
+    if (handle(FL_SHORTCUT, window)) return 1;
+
+    // and then try a shortcut with the case of the text swapped, by
+    // changing the text and falling through to FL_SHORTCUT case:
+    {char* c = (char*)event_text(); // cast away const
+    if (!isalpha(*c)) return 0;
+    *c = isupper(*c) ? tolower(*c) : toupper(*c);}
+    e_number = e = FL_SHORTCUT;
+
+  case FL_SHORTCUT:
+    if (grab()) {wi = grab(); break;} // send it to grab window
+
+    // Try it as shortcut, sending to mouse widget and all parents:
+    wi = belowmouse(); if (!wi) {wi = modal(); if (!wi) wi = window;}
+    for (; wi; wi = wi->parent()) if (send(FL_SHORTCUT, wi, window)) return 1;
+
+    // try using add_handle() functions:
+    if (send_handlers(FL_SHORTCUT)) return 1;
+
+    // make Escape key close windows:
+    if (event_key()==FL_Escape) {
+      wi = modal(); if (!wi) wi = window;
+      wi->do_callback();
+      return 1;
+    }
+
+    return 0;
+
+  case FL_ENTER:
+#ifdef DEBUG
+    printf("Fl::handle(e=%d, window=%p);\n", e, window);
+#endif // DEBUG
+
+    fl_xmousewin = window;
+    fl_fix_focus();
+    Fl_Tooltip::enter(belowmouse());
+    return 1;
+
+  case FL_LEAVE:
+#ifdef DEBUG
+    printf("Fl::handle(e=%d, window=%p);\n", e, window);
+#endif // DEBUG
+
+    if (!pushed_) {
+      belowmouse(0);
+      Fl_Tooltip::enter(0);
+    }
+    if (window == fl_xmousewin) {fl_xmousewin = 0; fl_fix_focus();}
+    return 1;
+
+  case FL_MOUSEWHEEL:
+    fl_xfocus = window; // this should not happen!  But maybe it does:
+
+    // Try it as keystroke, sending it to focus and all parents:
+    for (wi = grab() ? grab() : focus(); wi; wi = wi->parent())
+      if (send(FL_MOUSEWHEEL, wi, window)) return 1;
+  default:
+    break;
+  }
+  if (wi && send(e, wi, window)) {
+    dnd_flag = 0;
+    return 1;
+  }
+  dnd_flag = 0;
+  return send_handlers(e);
+}
+
+////////////////////////////////////////////////////////////////
+// hide() destroys the X window, it does not do unmap!
+
+#if !defined(WIN32) && USE_XFT
+extern void fl_destroy_xft_draw(Window);
+#endif
+
+void Fl_Window::hide() {
+  clear_visible();
+
+  if (!shown()) return;
+
+  // remove from the list of windows:
+  Fl_X* ip = i;
+  Fl_X** pp = &Fl_X::first;
+  for (; *pp != ip; pp = &(*pp)->next) if (!*pp) return;
+  *pp = ip->next;
+
+#ifdef __APPLE_QD__
+  // remove all childwindow links
+  for ( Fl_X *pc = Fl_X::first; pc; pc = pc->next )
+  { 
+    if ( pc->xidNext == ip ) pc->xidNext = ip->xidNext;
+    if ( pc->xidChildren == ip ) pc->xidChildren = ip->xidNext;   
+  }
+#elif defined(__APPLE_QUARTZ__)
+  // remove all childwindow links
+  for ( Fl_X *pc = Fl_X::first; pc; pc = pc->next )
+  {
+    if ( pc->xidNext == ip ) pc->xidNext = ip->xidNext;
+    if ( pc->xidChildren == ip ) pc->xidChildren = ip->xidNext;
+  }
+#endif // __APPLE__
+
+  i = 0;
+
+  // recursively remove any subwindows:
+  for (Fl_X *wi = Fl_X::first; wi;) {
+    Fl_Window* W = wi->w;
+    if (W->window() == this) {
+      W->hide();
+      W->set_visible();
+      wi = Fl_X::first;
+    } else wi = wi->next;
+  }
+
+  if (this == Fl::modal_) { // we are closing the modal window, find next one:
+    Fl_Window* W;
+    for (W = Fl::first_window(); W; W = Fl::next_window(W))
+      if (W->modal()) break;
+    Fl::modal_ = W;
+  }
+
+  // Make sure no events are sent to this window:
+  fl_throw_focus(this);
+  handle(FL_HIDE);
+
+#ifdef WIN32
+  if (ip->private_dc) ReleaseDC(ip->xid,ip->private_dc);
+  if (ip->xid == fl_window && fl_gc) {
+    ReleaseDC(fl_window, fl_gc);
+    fl_window = (HWND)-1;
+    fl_gc = 0;
+  }
+#elif defined(__APPLE_QD__)
+  if ( ip->xid == fl_window )
+    fl_window = 0;
+#elif defined(__APPLE_QUARTZ__)
+  Fl_X::q_release_context(ip);
+  if ( ip->xid == fl_window )
+    fl_window = 0;
+#else
+  if (ip->region) XDestroyRegion(ip->region);
+#endif
+
+#ifdef __APPLE_QD__
+  if ( !parent() ) // don't destroy shared windows!
+  {
+    //+ RemoveTrackingHandler( dndTrackingHandler, ip->xid );
+    //+ RemoveReceiveHandler( dndReceiveHandler, ip->xid );
+    XDestroyWindow(fl_display, ip->xid);
+  }
+#elif defined(__APPLE_QUARTZ__)
+  if ( !parent() ) // don't destroy shared windows!
+  {
+    //+ RemoveTrackingHandler( dndTrackingHandler, ip->xid );
+    //+ RemoveReceiveHandler( dndReceiveHandler, ip->xid );
+    XDestroyWindow(fl_display, ip->xid);
+  }
+#else
+# if USE_XFT
+  fl_destroy_xft_draw(ip->xid);
+# endif
+  XDestroyWindow(fl_display, ip->xid);
+#endif
+  
+#ifdef WIN32
+  // Try to stop the annoying "raise another program" behavior
+  if (non_modal() && Fl::first_window() && Fl::first_window()->shown())
+    Fl::first_window()->show();
+#endif
+  delete ip;
+}
+
+Fl_Window::~Fl_Window() {
+  hide();
+}
+
+// FL_SHOW and FL_HIDE are called whenever the visibility of this widget
+// or any parent changes.  We must correctly map/unmap the system's window.
+
+// For top-level windows it is assummed the window has already been
+// mapped or unmapped!!!  This is because this should only happen when
+// Fl_Window::show() or Fl_Window::hide() is called, or in response to
+// iconize/deiconize events from the system.
+
+int Fl_Window::handle(int ev)
+{
+  if (parent()) {
+    switch (ev) {
+    case FL_SHOW:
+      if (!shown()) show();
+      else XMapWindow(fl_display, fl_xid(this)); // extra map calls are harmless
+      break;
+    case FL_HIDE:
+      if (shown()) {
+	// Find what really turned invisible, if is was a parent window
+	// we do nothing.  We need to avoid unnecessary unmap calls
+	// because they cause the display to blink when the parent is
+	// remapped.  However if this or any intermediate non-window
+	// widget has really had hide() called directly on it, we must
+	// unmap because when the parent window is remapped we don't
+	// want to reappear.
+	if (visible()) {
+	 Fl_Widget* p = parent(); for (;p->visible();p = p->parent()) {}
+	 if (p->type() >= FL_WINDOW) break; // don't do the unmap
+	}
+#ifdef __APPLE_QD__
+        hide();
+	set_visible();
+#elif defined(__APPLE_QUARTZ__)
+        hide();
+        set_visible();
+#else
+	XUnmapWindow(fl_display, fl_xid(this));
+#endif // __APPLE__
+      }
+      break;
+    }
+//  } else if (ev == FL_FOCUS || ev == FL_UNFOCUS) {
+//    Fl_Tooltip::exit(Fl_Tooltip::current());
+  }
+
+  return Fl_Group::handle(ev);
+}
+
+////////////////////////////////////////////////////////////////
+// Back compatability cut & paste functions for fltk 1.1 only:
+
+void Fl::selection_owner(Fl_Widget *owner) {selection_owner_ = owner;}
+
+void Fl::selection(Fl_Widget &owner, const char* text, int len) {
+  selection_owner_ = &owner;
+  Fl::copy(text, len, 0);
+}
+
+void Fl::paste(Fl_Widget &receiver) {
+  Fl::paste(receiver, 0);
+}
+
+////////////////////////////////////////////////////////////////
+
+#include <FL/fl_draw.H>
+
+void Fl_Widget::redraw() {
+  damage(FL_DAMAGE_ALL);
+}
+
+void Fl_Widget::redraw_label() {
+  if (window()) {
+    if (box() == FL_NO_BOX) {
+      // Widgets with the FL_NO_BOX boxtype need a parent to
+      // redraw, since it is responsible for redrawing the
+      // background...
+      int X = x() > 0 ? x() - 1 : 0;
+      int Y = y() > 0 ? y() - 1 : 0;
+      window()->damage(FL_DAMAGE_ALL, X, Y, w() + 2, h() + 2);
+    }
+
+    if (align() && !(align() & FL_ALIGN_INSIDE) && window()->shown()) {
+      // If the label is not inside the widget, compute the location of
+      // the label and redraw the window within that bounding box...
+      int W = 0, H = 0;
+      label_.measure(W, H);
+      W += 5; // Add a little to the size of the label to cover overflow
+      H += 5;
+
+      if (align() & FL_ALIGN_BOTTOM) {
+	window()->damage(FL_DAMAGE_EXPOSE, x(), y() + h(), w(), H);
+      } else if (align() & FL_ALIGN_TOP) {
+	window()->damage(FL_DAMAGE_EXPOSE, x(), y() - H, w(), H);
+      } else if (align() & FL_ALIGN_LEFT) {
+	window()->damage(FL_DAMAGE_EXPOSE, x() - W, y(), W, h());
+      } else if (align() & FL_ALIGN_RIGHT) {
+	window()->damage(FL_DAMAGE_EXPOSE, x() + w(), y(), W, h());
+      } else {
+        window()->damage(FL_DAMAGE_ALL);
+      }
+    } else {
+      // The label is inside the widget, so just redraw the widget itself...
+      damage(FL_DAMAGE_ALL);
+    }
+  }
+}
+
+void Fl_Widget::damage(uchar fl) {
+  if (type() < FL_WINDOW) {
+    // damage only the rectangle covered by a child widget:
+    damage(fl, x(), y(), w(), h());
+  } else {
+    // damage entire window by deleting the region:
+    Fl_X* i = Fl_X::i((Fl_Window*)this);
+    if (!i) return; // window not mapped, so ignore it
+    if (i->region) {XDestroyRegion(i->region); i->region = 0;}
+    damage_ |= fl;
+    Fl::damage(FL_DAMAGE_CHILD);
+  }
+}
+
+void Fl_Widget::damage(uchar fl, int X, int Y, int W, int H) {
+  Fl_Widget* wi = this;
+  // mark all parent widgets between this and window with FL_DAMAGE_CHILD:
+  while (wi->type() < FL_WINDOW) {
+    wi->damage_ |= fl;
+    wi = wi->parent();
+    if (!wi) return;
+    fl = FL_DAMAGE_CHILD;
+  }
+  Fl_X* i = Fl_X::i((Fl_Window*)wi);
+  if (!i) return; // window not mapped, so ignore it
+
+  // clip the damage to the window and quit if none:
+  if (X < 0) {W += X; X = 0;}
+  if (Y < 0) {H += Y; Y = 0;}
+  if (W > wi->w()-X) W = wi->w()-X;
+  if (H > wi->h()-Y) H = wi->h()-Y;
+  if (W <= 0 || H <= 0) return;
+
+  if (!X && !Y && W==wi->w() && H==wi->h()) {
+    // if damage covers entire window delete region:
+    wi->damage(fl);
+    return;
+  }
+
+  if (wi->damage()) {
+    // if we already have damage we must merge with existing region:
+    if (i->region) {
+#ifdef WIN32
+      Fl_Region R = XRectangleRegion(X, Y, W, H);
+      CombineRgn(i->region, i->region, R, RGN_OR);
+      XDestroyRegion(R);
+#elif defined(__APPLE_QD__)
+      Fl_Region R = NewRgn(); 
+      SetRectRgn(R, X, Y, X+W, Y+H);
+      UnionRgn(R, i->region, i->region);
+      DisposeRgn(R);
+#elif defined(__APPLE_QUARTZ__)
+      Fl_Region R = NewRgn();
+      SetRectRgn(R, X, Y, X+W, Y+H);
+      UnionRgn(R, i->region, i->region);
+      DisposeRgn(R);
+#else
+      XRectangle R;
+      R.x = X; R.y = Y; R.width = W; R.height = H;
+      XUnionRectWithRegion(&R, i->region, i->region);
+#endif
+    }
+    wi->damage_ |= fl;
+  } else {
+    // create a new region:
+    if (i->region) XDestroyRegion(i->region);
+    i->region = XRectangleRegion(X,Y,W,H);
+    wi->damage_ = fl;
+  }
+  Fl::damage(FL_DAMAGE_CHILD);
+}
+
+void Fl_Window::flush() {
+  make_current();
+//if (damage() == FL_DAMAGE_EXPOSE && can_boxcheat(box())) fl_boxcheat = this;
+  fl_clip_region(i->region); i->region = 0;
+  draw();
+}
+
+
+//
+// The following methods allow callbacks to schedule the deletion of
+// widgets at "safe" times.
+//
+
+static int		num_dwidgets = 0, alloc_dwidgets = 0;
+static Fl_Widget	**dwidgets = 0;
+
+void
+Fl::delete_widget(Fl_Widget *w) {
+  if (!w) return;
+
+  if (num_dwidgets >= alloc_dwidgets) {
+    Fl_Widget	**temp;
+
+    temp = new Fl_Widget *[alloc_dwidgets + 10];
+    if (alloc_dwidgets) {
+      memcpy(temp, dwidgets, alloc_dwidgets * sizeof(Fl_Widget *));
+      delete[] dwidgets;
+    }
+
+    dwidgets = temp;
+    alloc_dwidgets += 10;
+  }
+
+  dwidgets[num_dwidgets] = w;
+  num_dwidgets ++;
+}
+
+
+void
+Fl::do_widget_deletion() {
+  if (!num_dwidgets) return;
+
+  for (int i = 0; i < num_dwidgets; i ++)
+    delete dwidgets[i];
+
+  num_dwidgets = 0;
+}
+
+
+//
+// End of "$Id$".
+//
diff -urN fltk-1.1.6.orig/src/Fl_Browser.cxx fltk-1.1.6/src/Fl_Browser.cxx
--- fltk-1.1.6.orig/src/Fl_Browser.cxx	2004-11-19 22:19:58.000000000 -0500
+++ fltk-1.1.6/src/Fl_Browser.cxx	2005-07-14 14:49:50.000000000 -0400
@@ -374,9 +374,13 @@
     }
   BREAK:
     fl_font(font, tsize);
-    if (((FL_BLINE*)v)->flags & SELECTED)
-      lcol = fl_contrast(lcol, selection_color());
-    if (!active_r()) lcol = fl_inactive(lcol);
+    if (((FL_BLINE*)v)->flags & SELECTED) {
+      if (active_r() && Fl::focus() == static_cast<const Fl_Widget *>(this)) {
+        lcol = fl_contrast(lcol, selection_color());
+      }
+    } else if (!active_r()) {
+      lcol = fl_inactive(lcol);
+    }
     fl_color(lcol);
     fl_draw(str, X+3, Y, w1-6, H, e ? Fl_Align(talign|FL_ALIGN_CLIP) : talign, 0, 0);
     if (!e) break; // no more fields...
diff -urN fltk-1.1.6.orig/src/Fl_Browser_.cxx fltk-1.1.6/src/Fl_Browser_.cxx
--- fltk-1.1.6.orig/src/Fl_Browser_.cxx	2004-07-27 12:02:19.000000000 -0400
+++ fltk-1.1.6/src/Fl_Browser_.cxx	2005-07-14 14:49:50.000000000 -0400
@@ -353,7 +353,11 @@
     if (hh <= 0) continue;
     if ((damage()&(FL_DAMAGE_SCROLL|FL_DAMAGE_ALL)) || l == redraw1 || l == redraw2) {
       if (item_selected(l)) {
-	fl_color(active_r() ? selection_color() : fl_inactive(selection_color()));
+        Fl_Color sel_c = selection_color();
+        if ( !active_r()  ||  Fl::focus() != this ) {
+          sel_c = FL_BACKGROUND_COLOR;
+        }
+	fl_color(sel_c);
 	fl_rectf(X, yy+Y, W, hh);
       } else if (!(damage()&FL_DAMAGE_ALL)) {
 	fl_push_clip(X, yy+Y, W, hh);
diff -urN fltk-1.1.6.orig/src/Fl_Gl_Choice.H fltk-1.1.6/src/Fl_Gl_Choice.H
--- fltk-1.1.6.orig/src/Fl_Gl_Choice.H	2004-09-09 17:34:46.000000000 -0400
+++ fltk-1.1.6/src/Fl_Gl_Choice.H	2005-07-14 14:49:50.000000000 -0400
@@ -124,6 +124,7 @@
 void fl_set_gl_context(Fl_Window*, GLContext);
 void fl_no_gl_context();
 void fl_delete_gl_context(GLContext);
+void fl_hide_gl_context(GLContext context);
 
 #endif
 
diff -urN fltk-1.1.6.orig/src/Fl_Gl_Choice.cxx fltk-1.1.6/src/Fl_Gl_Choice.cxx
--- fltk-1.1.6.orig/src/Fl_Gl_Choice.cxx	2004-09-24 12:00:10.000000000 -0400
+++ fltk-1.1.6/src/Fl_Gl_Choice.cxx	2005-07-14 14:49:50.000000000 -0400
@@ -435,6 +435,21 @@
   del_context(context);
 }
 
+
+void fl_hide_gl_context(GLContext context) {
+  cached_context = 0;
+  cached_window = 0;
+# if defined(__APPLE_QD__)
+  aglSetCurrentContext(0);
+  aglSetDrawable( context, NULL );
+#  elif defined(__APPLE_QUARTZ__)
+  // warning: the Quartz version should probably use Core GL (CGL) instead of AGL
+  aglSetCurrentContext(0);
+  aglSetDrawable( context, NULL );
+#  endif
+}
+
+
 #endif // HAVE_GL
 
 
diff -urN fltk-1.1.6.orig/src/Fl_Gl_Window.cxx fltk-1.1.6/src/Fl_Gl_Window.cxx
--- fltk-1.1.6.orig/src/Fl_Gl_Window.cxx	2004-09-09 17:34:46.000000000 -0400
+++ fltk-1.1.6/src/Fl_Gl_Window.cxx	2005-07-14 14:49:50.000000000 -0400
@@ -285,14 +285,21 @@
     if (SWAP_TYPE == NODAMAGE) {
 
       // don't draw if only overlay damage or expose events:
-      if ((damage()&~(FL_DAMAGE_OVERLAY|FL_DAMAGE_EXPOSE)) || !save_valid)
-	draw();
+      if ((damage()&~(FL_DAMAGE_OVERLAY|FL_DAMAGE_EXPOSE)) || !save_valid) {
+        draw();
+      } else {
+        swap_buffers();
+      }
       swap_buffers();
 
     } else if (SWAP_TYPE == COPY) {
 
       // don't draw if only the overlay is damaged:
-      if (damage() != FL_DAMAGE_OVERLAY || !save_valid) draw();
+      if (damage() != FL_DAMAGE_OVERLAY || !save_valid) {
+        draw();
+      } else {
+        swap_buffers();
+      }
       swap_buffers();
 
     } else { // SWAP_TYPE == UNDEFINED
@@ -408,7 +415,12 @@
 }    
 
 void Fl_Gl_Window::hide() {
+#if defined(__APPLE_QD__)  ||  defined(__APPLE_QUARTZ__)
+  fl_hide_gl_context((GLContext) context());
+#else
   context(0);
+#endif
+
 #if HAVE_GL_OVERLAY && defined(WIN32)
   if (overlay && overlay != this) {
     fl_delete_gl_context((GLContext)overlay);
@@ -419,6 +431,7 @@
 }
 
 Fl_Gl_Window::~Fl_Gl_Window() {
+  context(0);
   hide();
 //  delete overlay; this is done by ~Fl_Group
 }
diff -urN fltk-1.1.6.orig/src/Fl_Gl_Window.cxx~ fltk-1.1.6/src/Fl_Gl_Window.cxx~
--- fltk-1.1.6.orig/src/Fl_Gl_Window.cxx~	1969-12-31 19:00:00.000000000 -0500
+++ fltk-1.1.6/src/Fl_Gl_Window.cxx~	2005-07-14 14:49:50.000000000 -0400
@@ -0,0 +1,456 @@
+//
+// "$Id$"
+//
+// OpenGL window code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2004 by Bill Spitzak and others.
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems to "fltk-bugs@fltk.org".
+//
+
+#include "flstring.h"
+#if HAVE_GL
+
+#include <FL/Fl.H>
+#include <FL/x.H>
+#include "Fl_Gl_Choice.H"
+#include <FL/Fl_Gl_Window.H>
+#include <stdlib.h>
+
+////////////////////////////////////////////////////////////////
+
+// The symbol SWAP_TYPE defines what is in the back buffer after doing
+// a glXSwapBuffers().
+
+// The OpenGl documentation says that the contents of the backbuffer
+// are "undefined" after glXSwapBuffers().  However, if we know what
+// is in the backbuffers then we can save a good deal of time.  For
+// this reason you can define some symbols to describe what is left in
+// the back buffer.
+
+// Having not found any way to determine this from glx (or wgl) I have
+// resorted to letting the user specify it with an environment variable,
+// GL_SWAP_TYPE, it should be equal to one of these symbols:
+
+// contents of back buffer after glXSwapBuffers():
+#define UNDEFINED 1 	// anything
+#define SWAP 2		// former front buffer (same as unknown)
+#define COPY 3		// unchanged
+#define NODAMAGE 4	// unchanged even by X expose() events
+
+static char SWAP_TYPE = 0 ; // 0 = determine it from environment variable
+
+////////////////////////////////////////////////////////////////
+
+int Fl_Gl_Window::can_do(int a, const int *b) {
+  return Fl_Gl_Choice::find(a,b) != 0;
+}
+
+void Fl_Gl_Window::show() {
+  if (!shown()) {
+    if (!g) {
+      g = Fl_Gl_Choice::find(mode_,alist);
+
+      if (!g && (mode_ & FL_DOUBLE) == FL_SINGLE) {
+        g = Fl_Gl_Choice::find(mode_ | FL_DOUBLE,alist);
+	if (g) mode_ |= FL_FAKE_SINGLE;
+      }
+
+      if (!g) {
+        Fl::error("Insufficient GL support");
+	return;
+      }
+    }
+#if !defined(WIN32) && !defined(__APPLE__)
+    Fl_X::make_xid(this, g->vis, g->colormap);
+    if (overlay && overlay != this) ((Fl_Gl_Window*)overlay)->show();
+#endif
+  }
+  Fl_Window::show();
+}
+
+void Fl_Gl_Window::invalidate() {
+  valid(0);
+#ifndef WIN32
+  if (overlay) ((Fl_Gl_Window*)overlay)->valid(0);
+#endif
+}
+
+int Fl_Gl_Window::mode(int m, const int *a) {
+  if (m == mode_ && a == alist) return 0;
+#ifndef __APPLE__
+  int oldmode = mode_;
+  Fl_Gl_Choice* oldg = g;
+#endif
+  context(0);
+  mode_ = m; alist = a;
+  if (shown()) {
+    g = Fl_Gl_Choice::find(m, a);
+#if defined(WIN32)
+    if (!g || (oldmode^m)&FL_DOUBLE) {
+      hide();
+      show();
+    }
+#elif defined(__APPLE_QD__)
+    redraw();
+#elif defined(__APPLE_QUARTZ__)
+    // warning: the Quartz version should probably use Core GL (CGL) instead of AGL
+    redraw();
+#else
+    // under X, if the visual changes we must make a new X window (yuck!):
+    if (!g || g->vis->visualid!=oldg->vis->visualid || (oldmode^m)&FL_DOUBLE) {
+      hide();
+      show();
+    }
+#endif
+  } else {
+    g = 0;
+  }
+  return 1;
+}
+
+#define NON_LOCAL_CONTEXT 0x80000000
+
+void Fl_Gl_Window::make_current() {
+//  puts("Fl_Gl_Window::make_current()");
+//  printf("make_current: context_=%p\n", context_);
+  if (!context_) {
+    mode_ &= ~NON_LOCAL_CONTEXT;
+    context_ = fl_create_gl_context(this, g);
+    valid(0);
+
+//#ifdef __APPLE__
+//    GLint xywh[4];
+//
+//    if (parent() && parent()->window()) {
+//      xywh[0] = x();
+//      xywh[1] = parent()->window()->h() - y() - h();
+//    } else {
+//      xywh[0] = 0;
+//      xywh[1] = 0;
+//    }
+//
+//    xywh[2] = w();
+//    xywh[3] = h();
+//    aglSetInteger(context_, AGL_BUFFER_RECT, xywh);
+//    printf("make_current: xywh=[%d %d %d %d]\n", xywh[0], xywh[1], xywh[2], xywh[3]);
+//
+//    aglUpdateContext(context_);
+//#endif // __APPLE__
+  }
+  fl_set_gl_context(this, context_);
+#if defined(WIN32) && USE_COLORMAP
+  if (fl_palette) {
+    fl_GetDC(fl_xid(this));
+    SelectPalette(fl_gc, fl_palette, FALSE);
+    RealizePalette(fl_gc);
+  }
+#endif // USE_COLORMAP
+  if (mode_ & FL_FAKE_SINGLE) {
+    glDrawBuffer(GL_FRONT);
+    glReadBuffer(GL_FRONT);
+  }
+  current_ = this;
+}
+
+void Fl_Gl_Window::ortho() {
+// Alpha NT seems to have a broken OpenGL that does not like negative coords:
+#ifdef _M_ALPHA
+  glLoadIdentity();
+  glViewport(0, 0, w(), h());
+  glOrtho(0, w(), 0, h(), -1, 1);
+#else
+  GLint v[2];
+  glGetIntegerv(GL_MAX_VIEWPORT_DIMS, v);
+  glLoadIdentity();
+  glViewport(w()-v[0], h()-v[1], v[0], v[1]);
+  glOrtho(w()-v[0], w(), h()-v[1], h(), -1, 1);
+#endif
+}
+
+void Fl_Gl_Window::swap_buffers() {
+#ifdef WIN32
+#  if HAVE_GL_OVERLAY
+  // Do not swap the overlay, to match GLX:
+  BOOL ret = wglSwapLayerBuffers(Fl_X::i(this)->private_dc, WGL_SWAP_MAIN_PLANE);
+  DWORD err = GetLastError();;
+#  else
+  SwapBuffers(Fl_X::i(this)->private_dc);
+#  endif
+#elif defined(__APPLE_QD__)
+  aglSwapBuffers((AGLContext)context_);
+#elif defined(__APPLE_QUARTZ__)
+  // warning: the Quartz version should probably use Core GL (CGL) instead of AGL
+  aglSwapBuffers((AGLContext)context_);
+#else
+  glXSwapBuffers(fl_display, fl_xid(this));
+#endif
+}
+
+#if HAVE_GL_OVERLAY && defined(WIN32)
+uchar fl_overlay; // changes how fl_color() works
+int fl_overlay_depth = 0;
+#endif
+
+void Fl_Gl_Window::flush() {
+  uchar save_valid = valid_;
+
+#ifdef __APPLE_QD__
+  //: clear previous clipping in this shared port
+  GrafPtr port = GetWindowPort( fl_xid(this) );
+  Rect rect; SetRect( &rect, 0, 0, 0x7fff, 0x7fff );
+  GrafPtr old; GetPort( &old );
+  SetPort( port );
+  ClipRect( &rect );
+  SetPort( old );
+#elif defined(__APPLE_QUARTZ__)
+  // warning: the Quartz version should probably use Core GL (CGL) instead of AGL
+  //: clear previous clipping in this shared port
+  GrafPtr port = GetWindowPort( fl_xid(this) );
+  Rect rect; SetRect( &rect, 0, 0, 0x7fff, 0x7fff );
+  GrafPtr old; GetPort( &old );
+  SetPort( port );
+  ClipRect( &rect );
+  SetPort( old );
+#endif
+
+#if HAVE_GL_OVERLAY && defined(WIN32)
+
+  bool fixcursor = false; // for fixing the SGI 320 bug
+
+  // Draw into hardware overlay planes if they are damaged:
+  if (overlay && overlay != this
+      && (damage()&(FL_DAMAGE_OVERLAY|FL_DAMAGE_EXPOSE) || !save_valid)) {
+    // SGI 320 messes up overlay with user-defined cursors:
+    if (Fl_X::i(this)->cursor && Fl_X::i(this)->cursor != fl_default_cursor) {
+      fixcursor = true; // make it restore cursor later
+      SetCursor(0);
+    }
+    fl_set_gl_context(this, (GLContext)overlay);
+    if (fl_overlay_depth)
+      wglRealizeLayerPalette(Fl_X::i(this)->private_dc, 1, TRUE);
+    glDisable(GL_SCISSOR_TEST);
+    glClear(GL_COLOR_BUFFER_BIT);
+    fl_overlay = 1;
+    draw_overlay();
+    fl_overlay = 0;
+    valid(save_valid);
+    wglSwapLayerBuffers(Fl_X::i(this)->private_dc, WGL_SWAP_OVERLAY1);
+    // if only the overlay was damaged we are done, leave main layer alone:
+    if (damage() == FL_DAMAGE_OVERLAY) {
+      if (fixcursor) SetCursor(Fl_X::i(this)->cursor);
+      return;
+    }
+  }
+#endif
+
+  make_current();
+
+  if (mode_ & FL_DOUBLE) {
+
+    glDrawBuffer(GL_BACK);
+
+    if (!SWAP_TYPE) {
+#ifdef __APPLE_QD__
+      SWAP_TYPE = COPY;
+#elif defined __APPLE_QUARTZ__
+      // warning: the Quartz version should probably use Core GL (CGL) instead of AGL
+      SWAP_TYPE = COPY;
+#else
+      SWAP_TYPE = UNDEFINED;
+#endif
+      const char* c = getenv("GL_SWAP_TYPE");
+      if (c) {
+	if (!strcmp(c,"COPY")) SWAP_TYPE = COPY;
+	else if (!strcmp(c, "NODAMAGE")) SWAP_TYPE = NODAMAGE;
+	else if (!strcmp(c, "SWAP")) SWAP_TYPE = SWAP;
+      }
+    }
+
+    if (SWAP_TYPE == NODAMAGE) {
+
+      // don't draw if only overlay damage or expose events:
+      if ((damage()&~(FL_DAMAGE_OVERLAY|FL_DAMAGE_EXPOSE)) || !save_valid) {
+        draw();
+      } else {
+        swap_buffers();
+      }
+      swap_buffers();
+
+    } else if (SWAP_TYPE == COPY) {
+
+      // don't draw if only the overlay is damaged:
+      if (damage() != FL_DAMAGE_OVERLAY || !save_valid) {
+        draw();
+      } else {
+        swap_buffers();
+      }
+      swap_buffers();
+
+    } else { // SWAP_TYPE == UNDEFINED
+
+      // If we are faking the overlay, use CopyPixels to act like
+      // SWAP_TYPE == COPY.  Otherwise overlay redraw is way too slow.
+      if (overlay == this) {
+	// don't draw if only the overlay is damaged:
+	if (damage1_ || damage() != FL_DAMAGE_OVERLAY || !save_valid) draw();
+	// we use a seperate context for the copy because rasterpos must be 0
+	// and depth test needs to be off:
+	static GLContext ortho_context = 0;
+	static Fl_Gl_Window* ortho_window = 0;
+	int orthoinit = !ortho_context;
+	if (orthoinit) ortho_context = fl_create_gl_context(this, g);
+	fl_set_gl_context(this, ortho_context);
+	if (orthoinit || !save_valid || ortho_window != this) {
+	  glDisable(GL_DEPTH_TEST);
+	  glReadBuffer(GL_BACK);
+	  glDrawBuffer(GL_FRONT);
+	  glLoadIdentity();
+	  glViewport(0, 0, w(), h());
+	  glOrtho(0, w(), 0, h(), -1, 1);
+	  glRasterPos2i(0,0);
+	  ortho_window = this;
+	}
+	glCopyPixels(0,0,w(),h(),GL_COLOR);
+	make_current(); // set current context back to draw overlay
+	damage1_ = 0;
+
+      } else {
+	damage1_ = damage();
+	clear_damage(~0); draw();
+	swap_buffers();
+      }
+
+    }
+
+    if (overlay==this) { // fake overlay in front buffer
+      glDrawBuffer(GL_FRONT);
+      draw_overlay();
+      glDrawBuffer(GL_BACK);
+      glFlush();
+    }
+
+  } else {	// single-buffered context is simpler:
+
+    draw();
+    if (overlay == this) draw_overlay();
+    glFlush();
+
+  }
+
+#if HAVE_GL_OVERLAY && defined(WIN32)
+  if (fixcursor) SetCursor(Fl_X::i(this)->cursor);
+#endif
+  valid(1);
+}
+
+void Fl_Gl_Window::resize(int X,int Y,int W,int H) {
+//  printf("Fl_Gl_Window::resize(X=%d, Y=%d, W=%d, H=%d)\n", X, Y, W, H);
+  if (W != w() || H != h()) {
+    valid(0);
+#ifdef __APPLE_QD__
+    GLint xywh[4];
+
+    if (window()) {
+      // MRS: This isn't quite right, but the parent window won't have its W and H updated yet...
+      xywh[0] = x();
+      xywh[1] = window()->h() - y() - h();
+    } else {
+      xywh[0] = 0;
+      xywh[1] = 0;
+    }
+
+    xywh[2] = W;
+    xywh[3] = H;
+    aglSetInteger(context_, AGL_BUFFER_RECT, xywh);
+//    printf("resize: xywh=[%d %d %d %d]\n", xywh[0], xywh[1], xywh[2], xywh[3]);
+
+    aglUpdateContext(context_);
+#elif defined(__APPLE_QUARTZ__)
+    GLint xywh[4];
+
+    if (window()) {
+      // MRS: This isn't quite right, but the parent window won't have its W and H updated yet...
+      xywh[0] = x();
+      xywh[1] = window()->h() - y() - h();
+    } else {
+      xywh[0] = 0;
+      xywh[1] = 0;
+    }
+
+    xywh[2] = W;
+    xywh[3] = H;
+    aglSetInteger(context_, AGL_BUFFER_RECT, xywh);
+//    printf("resize: xywh=[%d %d %d %d]\n", xywh[0], xywh[1], xywh[2], xywh[3]);
+
+    aglUpdateContext(context_);
+#elif !defined(WIN32)
+    if (!resizable() && overlay && overlay != this)
+      ((Fl_Gl_Window*)overlay)->resize(0,0,W,H);
+#endif
+  }
+  Fl_Window::resize(X,Y,W,H);
+}
+
+void Fl_Gl_Window::context(void* v, int destroy_flag) {
+  if (context_ && !(mode_&NON_LOCAL_CONTEXT)) fl_delete_gl_context(context_);
+  context_ = (GLContext)v;
+  if (destroy_flag) mode_ &= ~NON_LOCAL_CONTEXT;
+  else mode_ |= NON_LOCAL_CONTEXT;
+}    
+
+void Fl_Gl_Window::hide() {
+  context(0);
+#if HAVE_GL_OVERLAY && defined(WIN32)
+  if (overlay && overlay != this) {
+    fl_delete_gl_context((GLContext)overlay);
+    overlay = 0;
+  }
+#endif
+  Fl_Window::hide();
+}
+
+Fl_Gl_Window::~Fl_Gl_Window() {
+  hide();
+//  delete overlay; this is done by ~Fl_Group
+}
+
+void Fl_Gl_Window::init() {
+  end(); // we probably don't want any children
+  box(FL_NO_BOX);
+
+  mode_    = FL_RGB | FL_DEPTH | FL_DOUBLE;
+  alist    = 0;
+  context_ = 0;
+  g        = 0;
+  overlay  = 0;
+  valid_   = 0;
+  damage1_ = 0;
+
+  int H = h();
+  h(1); // Make sure we actually do something in resize()...
+  resize(x(), y(), w(), H);
+}
+
+void Fl_Gl_Window::draw_overlay() {}
+
+#endif
+
+//
+// End of "$Id$".
+//
diff -urN fltk-1.1.6.orig/src/Fl_mac.cxx fltk-1.1.6/src/Fl_mac.cxx
--- fltk-1.1.6.orig/src/Fl_mac.cxx	2004-11-22 19:28:35.000000000 -0500
+++ fltk-1.1.6/src/Fl_mac.cxx	2005-07-14 14:49:50.000000000 -0400
@@ -578,6 +578,25 @@
 }
 
 
+pascal void idleTimerProcCB( EventLoopTimerRef timer, EventLoopIdleTimerMessage idleact, void* data)
+{
+  fl_lock_function();
+
+  // do Check call backs.
+  run_checks();  
+  
+  // Now idle callbacks.
+    static char in_idle;
+    if (Fl::idle && !in_idle) {
+        in_idle = 1;
+        Fl::idle();
+        in_idle = 0;
+    }
+  
+  fl_unlock_function();
+}
+
+
 /**
  * This function is the central event handler.
  * It reads events from the event queue using the given maximum time
@@ -600,6 +619,7 @@
   OSStatus ret;
   static EventTargetRef target = 0;
   static EventLoopTimerRef timer = 0;
+  static EventLoopTimerRef idle_timer = 0;
   if ( !target ) 
   {
     target = GetEventDispatcherTarget();
@@ -627,6 +647,7 @@
         { kEventClassCommand, kEventCommandProcess } };
     ret = InstallApplicationEventHandler( dispatchHandler, GetEventTypeCount(appEvents), appEvents, 0, 0L );
     ret = InstallEventLoopTimer( GetMainEventLoop(), 0, 0, NewEventLoopTimerUPP( timerProcCB ), 0, &timer );
+    ret = InstallEventLoopIdleTimer( GetMainEventLoop(), 0.01, 0.01, NewEventLoopIdleTimerUPP( idleTimerProcCB ), 0, &idle_timer );
   }
 
   got_events = 0;
@@ -668,8 +689,8 @@
  */
 int fl_wait( double time ) 
 {
-  do_queued_events( time );
-  return (got_events);
+   do_queued_events( time );
+   return (got_events);
 }
 
 
diff -urN fltk-1.1.6.orig/src/Fl_win32.cxx fltk-1.1.6/src/Fl_win32.cxx
--- fltk-1.1.6.orig/src/Fl_win32.cxx	2004-10-19 14:21:52.000000000 -0400
+++ fltk-1.1.6/src/Fl_win32.cxx	2005-07-14 14:49:50.000000000 -0400
@@ -219,7 +219,6 @@
 // it returns 1.
 int fl_wait(double time_to_wait) {
   int have_message = 0;
-  int timerid;
 
 #ifndef USE_ASYNC_SELECT
   if (nfds) {
@@ -257,47 +256,50 @@
 
   fl_unlock_function();
 
-  if (time_to_wait < 2147483.648) {
-    // Perform the requested timeout...
-    have_message = PeekMessage(&fl_msg, NULL, 0, 0, PM_REMOVE);
-    if (!have_message) {
-      int t = (int)(time_to_wait * 1000.0 + .5);
-      if (t <= 0) { // too short to measure
-        fl_lock_function();
-	return 0;
-      }
-      timerid = SetTimer(NULL, 0, t, NULL);
-      have_message = GetMessage(&fl_msg, NULL, 0, 0);
-      KillTimer(NULL, timerid);
-    }
-  } else {
-    have_message = GetMessage(&fl_msg, NULL, 0, 0);
-  }
+  time_to_wait = (time_to_wait > 10000 ? 10000 : time_to_wait);
+  int t_msec = (int) (time_to_wait * 1000.0 + 0.5);
+  int ret_val = MsgWaitForMultipleObjects(0, NULL, FALSE, t_msec, QS_ALLINPUT);
 
   fl_lock_function();
 
   // Execute the message we got, and all other pending messages:
-  while (have_message) {
+  have_message = PeekMessage(&fl_msg, NULL, 0, 0, PM_REMOVE);
+  if (have_message > 0) {
+      while (have_message != 0  &&  have_message != -1) {
 #ifdef USE_ASYNC_SELECT
-    if (fl_msg.message == WM_FLSELECT) {
-      // Got notification for socket
-      for (int i = 0; i < nfds; i ++)
-        if (fd[i].fd == (int)fl_msg.wParam) {
-	  (fd[i].cb)(fd[i].fd, fd[i].arg);
-	  break;
-	}
-      // looks like it is best to do the dispatch-message anyway:
-    }
+          if (fl_msg.message == WM_FLSELECT) {
+              // Got notification for socket
+              for (int i = 0; i < nfds; i ++)
+                  if (fd[i].fd == (int)fl_msg.wParam) {
+                      (fd[i].cb)(fd[i].fd, fd[i].arg);
+                      break;
+                  }
+                  // looks like it is best to do the dispatch-message anyway:
+          }
 #endif
 
-    if (fl_msg.message == fl_wake_msg)  // Used for awaking wait() from another thread
-      thread_message_ = (void*)fl_msg.wParam;
+          if (fl_msg.message == fl_wake_msg)  // Used for awaking wait() from another thread
+              thread_message_ = (void*)fl_msg.wParam;
 
-    TranslateMessage(&fl_msg);
-    DispatchMessage(&fl_msg);
-    have_message = PeekMessage(&fl_msg, NULL, 0, 0, PM_REMOVE);
+          TranslateMessage(&fl_msg);
+          DispatchMessage(&fl_msg);
+          have_message = PeekMessage(&fl_msg, NULL, 0, 0, PM_REMOVE);
+      }
+      Fl::flush();
+  } else {
+      Fl::flush();
+
+      // idle processing
+      static char in_idle;
+      if (Fl::idle && !in_idle) {
+          in_idle = 1;
+          Fl::idle();
+          in_idle = 0;
+      }
   }
 
+  run_checks();
+  
   // This should return 0 if only timer events were handled:
   return 1;
 }
@@ -549,6 +551,45 @@
 extern HPALETTE fl_select_palette(void); // in fl_color_win32.cxx
 #endif
 
+
+/////////////////////////////////////////////////////////////////////////////
+/// Win32 timers
+///
+
+struct Win32Timer
+{
+    UINT_PTR handle;
+    Fl_Timeout_Handler callback;
+    void *data;
+};
+static Win32Timer* win32_timers;
+static int win32_timer_alloc;
+static int win32_timer_used;
+static HWND s_TimerWnd;
+
+static void realloc_timers()
+{
+    if (win32_timer_alloc == 0) {
+        win32_timer_alloc = 8;
+    }
+    size_t size = sizeof(Win32Timer);
+    Win32Timer* new_timers = new Win32Timer[win32_timer_alloc * 2];
+    memmove(new_timers, win32_timers, sizeof(Win32Timer) * win32_timer_used);
+    Win32Timer* delete_me = win32_timers;
+    win32_timers = new_timers;
+    delete [] delete_me;
+    win32_timer_alloc *= 2;
+}
+
+static void delete_timer(Win32Timer& t)
+{
+    KillTimer(s_TimerWnd, t.handle);
+    memset(&t, 0, sizeof(Win32Timer));
+}
+
+/// END TIMERS
+/////////////////////////////////////////////////////////////////////////////
+
 static Fl_Window* resize_bug_fix;
 
 extern void fl_save_pen(void);
@@ -576,6 +617,7 @@
 
   case WM_CLOSE: // user clicked close box
     Fl::handle(FL_CLOSE, window);
+    PostQuitMessage(0);
     return 0;
 
   case WM_SYNCPAINT :
@@ -986,13 +1028,14 @@
   const char* message_name = "FLTK::ThreadWakeup";
 
   WNDCLASSEX wc;
+  memset(&wc, 0, sizeof(WNDCLASSEX));
+  wc.cbSize = sizeof(WNDCLASSEX);
   // Documentation states a device context consumes about 800 bytes
   // of memory... so who cares? If 800 bytes per window is what it
   // takes to speed things up, I'm game.
   //wc.style = CS_HREDRAW | CS_VREDRAW | CS_CLASSDC | CS_DBLCLKS;
   wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_DBLCLKS;
   wc.lpfnWndProc = (WNDPROC)WndProc;
-  wc.cbClsExtra = wc.cbWndExtra = 0;
   wc.hInstance = fl_display;
   if (!w->icon())
     w->icon((void *)LoadIcon(NULL, IDI_APPLICATION));
@@ -1000,11 +1043,9 @@
   wc.hCursor = fl_default_cursor = LoadCursor(NULL, IDC_ARROW);
   //uchar r,g,b; Fl::get_color(FL_GRAY,r,g,b);
   //wc.hbrBackground = (HBRUSH)CreateSolidBrush(RGB(r,g,b));
-  wc.hbrBackground = NULL;
-  wc.lpszMenuName = NULL;
   wc.lpszClassName = class_name;
-  wc.cbSize = sizeof(WNDCLASSEX);
-  RegisterClassEx(&wc);
+  ATOM atom = RegisterClassEx(&wc);
+  int err_no = GetLastError();
   if (!fl_wake_msg) fl_wake_msg = RegisterWindowMessage(message_name);
 
   HWND parent;
@@ -1116,6 +1157,115 @@
   return x;
 }
 
+
+
+
+/////////////////////////////////////////////////////////////////////////////
+/// Win32 timers
+///
+
+
+static LRESULT CALLBACK s_TimerProc(HWND hwnd, UINT msg,
+                                    WPARAM wParam, LPARAM lParam)
+{
+    switch (msg) {
+    case WM_TIMER:
+        {
+            unsigned int id = wParam - 1;
+            if (id < win32_timer_used && win32_timers[id].handle) {
+                Fl_Timeout_Handler cb   = win32_timers[id].callback;
+                void*              data = win32_timers[id].data;
+                delete_timer(win32_timers[id]);
+                if (cb) {
+                    (*cb)(data);
+                }
+            }
+        }
+        return 0;
+
+    default:
+        break;
+    }
+
+    return DefWindowProc(hwnd, msg, wParam, lParam);
+}
+
+void Fl::add_timeout(double time, Fl_Timeout_Handler cb, void* data)
+{
+    repeat_timeout(time, cb, data);
+}
+
+void Fl::repeat_timeout(double time, Fl_Timeout_Handler cb, void* data)
+{
+    int timer_id = -1;
+    for (int i = 0;  i < win32_timer_used;  ++i) {
+        if ( !win32_timers[i].handle ) {
+            timer_id = i;
+            break;
+        }
+    }
+    if (timer_id == -1) {
+        if (win32_timer_used == win32_timer_alloc) {
+            realloc_timers();
+        }
+        timer_id = win32_timer_used++;
+    }
+    unsigned int elapsed = (unsigned int)(time * 1000);
+
+    if ( !s_TimerWnd ) {
+        const char* timer_class = "FLTimer";
+        WNDCLASSEX wc;
+        memset(&wc, 0, sizeof(wc));
+        wc.cbSize = sizeof (wc);
+        wc.style = CS_CLASSDC;
+        wc.lpfnWndProc = (WNDPROC)s_TimerProc;
+        wc.hInstance = fl_display;
+        wc.lpszClassName = timer_class;
+        ATOM atom = RegisterClassEx(&wc);
+
+        s_TimerWnd = CreateWindowEx(WS_EX_LEFT | WS_EX_TOOLWINDOW,
+                                    timer_class, "",
+                                    WS_POPUP,
+                                    CW_USEDEFAULT, CW_USEDEFAULT, 1, 1,
+                                    NULL, NULL, fl_display, NULL);
+        ShowWindow(s_TimerWnd, SW_SHOWNOACTIVATE);
+    }
+
+    win32_timers[timer_id].callback = cb;
+    win32_timers[timer_id].data     = data;
+
+    win32_timers[timer_id].handle =
+        SetTimer(s_TimerWnd, timer_id + 1, elapsed, NULL);
+}
+
+int Fl::has_timeout(Fl_Timeout_Handler cb, void* data)
+{
+    for (int i = 0;  i < win32_timer_used;  ++i) {
+        Win32Timer& t = win32_timers[i];
+        if (t.handle  &&  t.callback == cb  &&  t.data == data) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+void Fl::remove_timeout(Fl_Timeout_Handler cb, void* data)
+{
+    int i;
+    for (i = 0;  i < win32_timer_used;  ++i) {
+        Win32Timer& t = win32_timers[i];
+        if (t.handle  &&  t.callback == cb  &&
+            (t.data == data  ||  data == NULL)) {
+            delete_timer(t);
+        }
+    }
+}
+
+/// END TIMERS
+/////////////////////////////////////////////////////////////////////////////
+
+
+
 ////////////////////////////////////////////////////////////////
 
 HINSTANCE fl_display = GetModuleHandle(NULL);
diff -urN fltk-1.1.6.orig/src/Fl_x.cxx fltk-1.1.6/src/Fl_x.cxx
--- fltk-1.1.6.orig/src/Fl_x.cxx	2004-11-20 08:52:47.000000000 -0500
+++ fltk-1.1.6/src/Fl_x.cxx	2005-07-14 14:49:50.000000000 -0400
@@ -24,9 +24,9 @@
 //
 
 #ifdef WIN32
-#  include "Fl_win32.cxx"
+//#  include "Fl_win32.cxx"
 #elif defined(__APPLE__)
-#  include "Fl_mac.cxx"
+//#  include "Fl_mac.cxx"
 #else
 
 #  define CONSOLIDATE_MOTION 1
@@ -195,7 +195,17 @@
   // OpenGL and other broken libraries call XEventsQueued
   // unnecessarily and thus cause the file descriptor to not be ready,
   // so we must check for already-read events:
-  if (fl_display && XQLength(fl_display)) {do_queued_events(); return 1;}
+  if (fl_display && XQLength(fl_display)) {
+      do_queued_events();
+      return 1;
+  } else {
+      static char in_idle;
+      if (Fl::idle && !in_idle) {
+          in_idle = 1;
+          Fl::idle();
+          in_idle = 0;
+      }
+  }
 
 #  if !USE_POLL
   fd_set fdt[3];
diff -urN fltk-1.1.6.orig/src/Makefile fltk-1.1.6/src/Makefile
--- fltk-1.1.6.orig/src/Makefile	2004-11-19 22:19:58.000000000 -0500
+++ fltk-1.1.6/src/Makefile	2005-07-14 14:49:50.000000000 -0400
@@ -237,7 +237,7 @@
 
 libfltk_forms.so.1.1: $(FLOBJECTS) libfltk.so.1.1
 	echo $(DSOCOMMAND) $@ ...
-	$(DSOCOMMAND) $@ $(FLOBJECTS) -L. -lfltk
+	$(DSOCOMMAND) $@ $(FLOBJECTS) $(DSOLINK) -L. -lfltk
 	$(RM) libfltk_forms.so
 	$(LN) libfltk_forms.so.1.1 libfltk_forms.so
 
@@ -273,7 +273,7 @@
 
 libfltk_gl.so.1.1: $(GLOBJECTS) libfltk.so.1.1
 	echo $(DSOCOMMAND) $@ ...
-	$(DSOCOMMAND) $@ $(GLOBJECTS) -L. -lfltk
+	$(DSOCOMMAND) $@ $(GLOBJECTS) $(GLDLIBS) $(DSOLINK) -L. -lfltk
 	$(RM) libfltk_gl.so
 	$(LN) libfltk_gl.so.1.1 libfltk_gl.so
 
@@ -309,7 +309,7 @@
 
 libfltk_images.so.1.1: $(IMGOBJECTS) libfltk.so.1.1
 	echo $(DSOCOMMAND) $@ ...
-	$(DSOCOMMAND) $@ $(IMGOBJECTS) $(IMAGELIBS) -L. -lfltk
+	$(DSOCOMMAND) $@ $(IMGOBJECTS) -L../lib $(IMAGELIBS) $(DSOLINK) -L. -lfltk
 	$(RM) libfltk_images.so
 	$(LN) libfltk_images.so.1.1 libfltk_images.so
 
